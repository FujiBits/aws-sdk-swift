// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct AcceptReservedNodeExchangeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AcceptReservedNodeExchangeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AcceptReservedNodeExchangeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AcceptReservedNodeExchangeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AcceptReservedNodeExchangeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AcceptReservedNodeExchangeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AcceptReservedNodeExchangeOutputError>
}

extension AcceptReservedNodeExchangeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AcceptReservedNodeExchangeInput(reservedNodeId: \(Swift.String(describing: reservedNodeId)), targetReservedNodeOfferingId: \(Swift.String(describing: targetReservedNodeOfferingId)))"}
}

extension AcceptReservedNodeExchangeInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let reservedNodeId = reservedNodeId {
            try container.encode(reservedNodeId, forKey: ClientRuntime.Key("ReservedNodeId"))
        }
        if let targetReservedNodeOfferingId = targetReservedNodeOfferingId {
            try container.encode(targetReservedNodeOfferingId, forKey: ClientRuntime.Key("TargetReservedNodeOfferingId"))
        }
        try container.encode("AcceptReservedNodeExchange", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct AcceptReservedNodeExchangeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AcceptReservedNodeExchangeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AcceptReservedNodeExchangeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AcceptReservedNodeExchangeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AcceptReservedNodeExchangeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AcceptReservedNodeExchangeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AcceptReservedNodeExchangeOutputError>
}

public struct AcceptReservedNodeExchangeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AcceptReservedNodeExchangeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AcceptReservedNodeExchangeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AcceptReservedNodeExchangeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AcceptReservedNodeExchangeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AcceptReservedNodeExchangeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AcceptReservedNodeExchangeOutputError>
}

public struct AcceptReservedNodeExchangeInput: Swift.Equatable {
    /// <p>A string representing the node identifier of the DC1 Reserved Node to be
    ///             exchanged.</p>
    public let reservedNodeId: Swift.String?
    /// <p>The unique identifier of the DC2 Reserved Node offering to be used for the exchange.
    ///             You can obtain the value for the parameter by calling <a>GetReservedNodeExchangeOfferings</a>
    ///          </p>
    public let targetReservedNodeOfferingId: Swift.String?

    public init (
        reservedNodeId: Swift.String? = nil,
        targetReservedNodeOfferingId: Swift.String? = nil
    )
    {
        self.reservedNodeId = reservedNodeId
        self.targetReservedNodeOfferingId = targetReservedNodeOfferingId
    }
}

extension AcceptReservedNodeExchangeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AcceptReservedNodeExchangeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependentServiceUnavailableFault" : self = .dependentServiceUnavailableFault(try DependentServiceUnavailableFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidReservedNodeStateFault" : self = .invalidReservedNodeStateFault(try InvalidReservedNodeStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReservedNodeAlreadyExistsFault" : self = .reservedNodeAlreadyExistsFault(try ReservedNodeAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReservedNodeAlreadyMigratedFault" : self = .reservedNodeAlreadyMigratedFault(try ReservedNodeAlreadyMigratedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReservedNodeNotFoundFault" : self = .reservedNodeNotFoundFault(try ReservedNodeNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReservedNodeOfferingNotFoundFault" : self = .reservedNodeOfferingNotFoundFault(try ReservedNodeOfferingNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationFault" : self = .unsupportedOperationFault(try UnsupportedOperationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AcceptReservedNodeExchangeOutputError: Swift.Error, Swift.Equatable {
    case dependentServiceUnavailableFault(DependentServiceUnavailableFault)
    case invalidReservedNodeStateFault(InvalidReservedNodeStateFault)
    case reservedNodeAlreadyExistsFault(ReservedNodeAlreadyExistsFault)
    case reservedNodeAlreadyMigratedFault(ReservedNodeAlreadyMigratedFault)
    case reservedNodeNotFoundFault(ReservedNodeNotFoundFault)
    case reservedNodeOfferingNotFoundFault(ReservedNodeOfferingNotFoundFault)
    case unsupportedOperationFault(UnsupportedOperationFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension AcceptReservedNodeExchangeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AcceptReservedNodeExchangeOutputResponse(exchangedReservedNode: \(Swift.String(describing: exchangedReservedNode)))"}
}

extension AcceptReservedNodeExchangeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AcceptReservedNodeExchangeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.exchangedReservedNode = output.exchangedReservedNode
        } else {
            self.exchangedReservedNode = nil
        }
    }
}

public struct AcceptReservedNodeExchangeOutputResponse: Swift.Equatable {
    /// <p></p>
    public let exchangedReservedNode: RedshiftClientTypes.ReservedNode?

    public init (
        exchangedReservedNode: RedshiftClientTypes.ReservedNode? = nil
    )
    {
        self.exchangedReservedNode = exchangedReservedNode
    }
}

struct AcceptReservedNodeExchangeOutputResponseBody: Swift.Equatable {
    public let exchangedReservedNode: RedshiftClientTypes.ReservedNode?
}

extension AcceptReservedNodeExchangeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exchangedReservedNode = "ExchangedReservedNode"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("AcceptReservedNodeExchangeResult"))
        let exchangedReservedNodeDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.ReservedNode.self, forKey: .exchangedReservedNode)
        exchangedReservedNode = exchangedReservedNodeDecoded
    }
}

extension AccessToClusterDeniedFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessToClusterDeniedFault(message: \(Swift.String(describing: message)))"}
}

extension AccessToClusterDeniedFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<AccessToClusterDeniedFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You are not authorized to access the cluster.</p>
public struct AccessToClusterDeniedFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessToClusterDeniedFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AccessToClusterDeniedFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AccessToSnapshotDeniedFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessToSnapshotDeniedFault(message: \(Swift.String(describing: message)))"}
}

extension AccessToSnapshotDeniedFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<AccessToSnapshotDeniedFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The owner of the specified snapshot has not authorized your account to access the
///             snapshot.</p>
public struct AccessToSnapshotDeniedFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessToSnapshotDeniedFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AccessToSnapshotDeniedFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RedshiftClientTypes.AccountAttribute: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "AttributeName"
        case attributeValues = "AttributeValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let attributeName = attributeName {
            try container.encode(attributeName, forKey: ClientRuntime.Key("AttributeName"))
        }
        if let attributeValues = attributeValues {
            var attributeValuesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AttributeValues"))
            for (index0, attributevaluetarget0) in attributeValues.enumerated() {
                try attributeValuesContainer.encode(attributevaluetarget0, forKey: ClientRuntime.Key("AttributeValueTarget.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        if containerValues.contains(.attributeValues) {
            struct KeyVal0{struct AttributeValueTarget{}}
            let attributeValuesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AttributeValueTarget>.CodingKeys.self, forKey: .attributeValues)
            if let attributeValuesWrappedContainer = attributeValuesWrappedContainer {
                let attributeValuesContainer = try attributeValuesWrappedContainer.decodeIfPresent([RedshiftClientTypes.AttributeValueTarget].self, forKey: .member)
                var attributeValuesBuffer:[RedshiftClientTypes.AttributeValueTarget]? = nil
                if let attributeValuesContainer = attributeValuesContainer {
                    attributeValuesBuffer = [RedshiftClientTypes.AttributeValueTarget]()
                    for structureContainer0 in attributeValuesContainer {
                        attributeValuesBuffer?.append(structureContainer0)
                    }
                }
                attributeValues = attributeValuesBuffer
            } else {
                attributeValues = []
            }
        } else {
            attributeValues = nil
        }
    }
}

extension RedshiftClientTypes.AccountAttribute: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccountAttribute(attributeName: \(Swift.String(describing: attributeName)), attributeValues: \(Swift.String(describing: attributeValues)))"}
}

extension RedshiftClientTypes {
    /// <p>A name value pair that describes an aspect of an account. </p>
    public struct AccountAttribute: Swift.Equatable {
        /// <p>The name of the attribute.</p>
        public let attributeName: Swift.String?
        /// <p>A list of attribute values.</p>
        public let attributeValues: [RedshiftClientTypes.AttributeValueTarget]?

        public init (
            attributeName: Swift.String? = nil,
            attributeValues: [RedshiftClientTypes.AttributeValueTarget]? = nil
        )
        {
            self.attributeName = attributeName
            self.attributeValues = attributeValues
        }
    }

}

extension RedshiftClientTypes.AccountWithRestoreAccess: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAlias = "AccountAlias"
        case accountId = "AccountId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let accountAlias = accountAlias {
            try container.encode(accountAlias, forKey: ClientRuntime.Key("AccountAlias"))
        }
        if let accountId = accountId {
            try container.encode(accountId, forKey: ClientRuntime.Key("AccountId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let accountAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountAlias)
        accountAlias = accountAliasDecoded
    }
}

extension RedshiftClientTypes.AccountWithRestoreAccess: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccountWithRestoreAccess(accountAlias: \(Swift.String(describing: accountAlias)), accountId: \(Swift.String(describing: accountId)))"}
}

extension RedshiftClientTypes {
    /// <p>Describes an AWS customer account authorized to restore a snapshot.</p>
    public struct AccountWithRestoreAccess: Swift.Equatable {
        /// <p>The identifier of an AWS support account authorized to restore a snapshot. For AWS
        ///             support, the identifier is <code>amazon-redshift-support</code>. </p>
        public let accountAlias: Swift.String?
        /// <p>The identifier of an AWS customer account authorized to restore a
        ///             snapshot.</p>
        public let accountId: Swift.String?

        public init (
            accountAlias: Swift.String? = nil,
            accountId: Swift.String? = nil
        )
        {
            self.accountAlias = accountAlias
            self.accountId = accountId
        }
    }

}

extension RedshiftClientTypes {
    public enum ActionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case recommendNodeConfig
        case resizeCluster
        case restoreCluster
        case sdkUnknown(Swift.String)

        public static var allCases: [ActionType] {
            return [
                .recommendNodeConfig,
                .resizeCluster,
                .restoreCluster,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .recommendNodeConfig: return "recommend-node-config"
            case .resizeCluster: return "resize-cluster"
            case .restoreCluster: return "restore-cluster"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ActionType(rawValue: rawValue) ?? ActionType.sdkUnknown(rawValue)
        }
    }
}

public struct AddPartnerInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddPartnerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddPartnerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddPartnerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddPartnerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddPartnerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddPartnerOutputError>
}

extension AddPartnerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddPartnerInput(accountId: \(Swift.String(describing: accountId)), clusterIdentifier: \(Swift.String(describing: clusterIdentifier)), databaseName: \(Swift.String(describing: databaseName)), partnerName: \(Swift.String(describing: partnerName)))"}
}

extension AddPartnerInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let accountId = accountId {
            try container.encode(accountId, forKey: ClientRuntime.Key("AccountId"))
        }
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: ClientRuntime.Key("ClusterIdentifier"))
        }
        if let databaseName = databaseName {
            try container.encode(databaseName, forKey: ClientRuntime.Key("DatabaseName"))
        }
        if let partnerName = partnerName {
            try container.encode(partnerName, forKey: ClientRuntime.Key("PartnerName"))
        }
        try container.encode("AddPartner", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct AddPartnerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddPartnerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddPartnerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddPartnerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddPartnerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddPartnerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddPartnerOutputError>
}

public struct AddPartnerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddPartnerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddPartnerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddPartnerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddPartnerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddPartnerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddPartnerOutputError>
}

public struct AddPartnerInput: Swift.Equatable {
    /// <p>The AWS account ID that owns the cluster.</p>
    public let accountId: Swift.String?
    /// <p>The cluster identifier of the cluster that receives data from the partner.</p>
    public let clusterIdentifier: Swift.String?
    /// <p>The name of the database that receives data from the partner.</p>
    public let databaseName: Swift.String?
    /// <p>The name of the partner that is authorized to send data.</p>
    public let partnerName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        clusterIdentifier: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        partnerName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.clusterIdentifier = clusterIdentifier
        self.databaseName = databaseName
        self.partnerName = partnerName
    }
}

extension AddPartnerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AddPartnerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PartnerNotFoundFault" : self = .partnerNotFoundFault(try PartnerNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedPartnerIntegrationFault" : self = .unauthorizedPartnerIntegrationFault(try UnauthorizedPartnerIntegrationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddPartnerOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case partnerNotFoundFault(PartnerNotFoundFault)
    case unauthorizedPartnerIntegrationFault(UnauthorizedPartnerIntegrationFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddPartnerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddPartnerOutputResponse(databaseName: \(Swift.String(describing: databaseName)), partnerName: \(Swift.String(describing: partnerName)))"}
}

extension AddPartnerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AddPartnerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.databaseName = output.databaseName
            self.partnerName = output.partnerName
        } else {
            self.databaseName = nil
            self.partnerName = nil
        }
    }
}

public struct AddPartnerOutputResponse: Swift.Equatable {
    /// <p>The name of the database that receives data from the partner.</p>
    public let databaseName: Swift.String?
    /// <p>The name of the partner that is authorized to send data.</p>
    public let partnerName: Swift.String?

    public init (
        databaseName: Swift.String? = nil,
        partnerName: Swift.String? = nil
    )
    {
        self.databaseName = databaseName
        self.partnerName = partnerName
    }
}

struct AddPartnerOutputResponseBody: Swift.Equatable {
    public let databaseName: Swift.String?
    public let partnerName: Swift.String?
}

extension AddPartnerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName = "DatabaseName"
        case partnerName = "PartnerName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("AddPartnerResult"))
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let partnerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .partnerName)
        partnerName = partnerNameDecoded
    }
}

extension RedshiftClientTypes.AquaConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aquaConfigurationStatus = "AquaConfigurationStatus"
        case aquaStatus = "AquaStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let aquaConfigurationStatus = aquaConfigurationStatus {
            try container.encode(aquaConfigurationStatus, forKey: ClientRuntime.Key("AquaConfigurationStatus"))
        }
        if let aquaStatus = aquaStatus {
            try container.encode(aquaStatus, forKey: ClientRuntime.Key("AquaStatus"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aquaStatusDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.AquaStatus.self, forKey: .aquaStatus)
        aquaStatus = aquaStatusDecoded
        let aquaConfigurationStatusDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.AquaConfigurationStatus.self, forKey: .aquaConfigurationStatus)
        aquaConfigurationStatus = aquaConfigurationStatusDecoded
    }
}

extension RedshiftClientTypes.AquaConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AquaConfiguration(aquaConfigurationStatus: \(Swift.String(describing: aquaConfigurationStatus)), aquaStatus: \(Swift.String(describing: aquaStatus)))"}
}

extension RedshiftClientTypes {
    /// <p>The AQUA (Advanced Query Accelerator) configuration of the cluster.</p>
    public struct AquaConfiguration: Swift.Equatable {
        /// <p>The value represents how the cluster is configured to use AQUA. Possible values include the following.</p>
        ///         <ul>
        ///             <li>
        ///                <p>enabled - Use AQUA if it is available for the current AWS Region and Amazon Redshift node type.</p>
        ///             </li>
        ///             <li>
        ///                <p>disabled - Don't use AQUA. </p>
        ///             </li>
        ///             <li>
        ///                <p>auto - Amazon Redshift determines whether to use AQUA.</p>
        ///             </li>
        ///          </ul>
        public let aquaConfigurationStatus: RedshiftClientTypes.AquaConfigurationStatus?
        /// <p>The value indicates the status of AQUA on the cluster. Possible values include the following.</p>
        ///         <ul>
        ///             <li>
        ///                <p>enabled - AQUA is enabled.</p>
        ///             </li>
        ///             <li>
        ///                <p>disabled - AQUA is not enabled. </p>
        ///             </li>
        ///             <li>
        ///                <p>applying - AQUA status is being applied. </p>
        ///             </li>
        ///          </ul>
        public let aquaStatus: RedshiftClientTypes.AquaStatus?

        public init (
            aquaConfigurationStatus: RedshiftClientTypes.AquaConfigurationStatus? = nil,
            aquaStatus: RedshiftClientTypes.AquaStatus? = nil
        )
        {
            self.aquaConfigurationStatus = aquaConfigurationStatus
            self.aquaStatus = aquaStatus
        }
    }

}

extension RedshiftClientTypes {
    public enum AquaConfigurationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case auto
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [AquaConfigurationStatus] {
            return [
                .auto,
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .auto: return "auto"
            case .disabled: return "disabled"
            case .enabled: return "enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AquaConfigurationStatus(rawValue: rawValue) ?? AquaConfigurationStatus.sdkUnknown(rawValue)
        }
    }
}

extension RedshiftClientTypes {
    public enum AquaStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case applying
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [AquaStatus] {
            return [
                .applying,
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .applying: return "applying"
            case .disabled: return "disabled"
            case .enabled: return "enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AquaStatus(rawValue: rawValue) ?? AquaStatus.sdkUnknown(rawValue)
        }
    }
}

extension RedshiftClientTypes.AttributeValueTarget: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeValue = "AttributeValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let attributeValue = attributeValue {
            try container.encode(attributeValue, forKey: ClientRuntime.Key("AttributeValue"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeValue)
        attributeValue = attributeValueDecoded
    }
}

extension RedshiftClientTypes.AttributeValueTarget: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AttributeValueTarget(attributeValue: \(Swift.String(describing: attributeValue)))"}
}

extension RedshiftClientTypes {
    /// <p>Describes an attribute value.</p>
    public struct AttributeValueTarget: Swift.Equatable {
        /// <p>The value of the attribute.</p>
        public let attributeValue: Swift.String?

        public init (
            attributeValue: Swift.String? = nil
        )
        {
            self.attributeValue = attributeValue
        }
    }

}

extension AuthorizationAlreadyExistsFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AuthorizationAlreadyExistsFault(message: \(Swift.String(describing: message)))"}
}

extension AuthorizationAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<AuthorizationAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified CIDR block or EC2 security group is already authorized for the
///             specified cluster security group.</p>
public struct AuthorizationAlreadyExistsFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AuthorizationAlreadyExistsFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AuthorizationAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AuthorizationNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AuthorizationNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension AuthorizationNotFoundFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<AuthorizationNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified CIDR IP range or EC2 security group is not authorized for the
///             specified cluster security group.</p>
public struct AuthorizationNotFoundFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AuthorizationNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AuthorizationNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AuthorizationQuotaExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AuthorizationQuotaExceededFault(message: \(Swift.String(describing: message)))"}
}

extension AuthorizationQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<AuthorizationQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The authorization quota for the cluster security group has been reached.</p>
public struct AuthorizationQuotaExceededFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AuthorizationQuotaExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AuthorizationQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RedshiftClientTypes {
    public enum AuthorizationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case authorized
        case revoking
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthorizationStatus] {
            return [
                .authorized,
                .revoking,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .authorized: return "Authorized"
            case .revoking: return "Revoking"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthorizationStatus(rawValue: rawValue) ?? AuthorizationStatus.sdkUnknown(rawValue)
        }
    }
}

public struct AuthorizeClusterSecurityGroupIngressInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AuthorizeClusterSecurityGroupIngressInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AuthorizeClusterSecurityGroupIngressInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AuthorizeClusterSecurityGroupIngressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AuthorizeClusterSecurityGroupIngressInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AuthorizeClusterSecurityGroupIngressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AuthorizeClusterSecurityGroupIngressOutputError>
}

extension AuthorizeClusterSecurityGroupIngressInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AuthorizeClusterSecurityGroupIngressInput(cIDRIP: \(Swift.String(describing: cIDRIP)), clusterSecurityGroupName: \(Swift.String(describing: clusterSecurityGroupName)), eC2SecurityGroupName: \(Swift.String(describing: eC2SecurityGroupName)), eC2SecurityGroupOwnerId: \(Swift.String(describing: eC2SecurityGroupOwnerId)))"}
}

extension AuthorizeClusterSecurityGroupIngressInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let cIDRIP = cIDRIP {
            try container.encode(cIDRIP, forKey: ClientRuntime.Key("CIDRIP"))
        }
        if let clusterSecurityGroupName = clusterSecurityGroupName {
            try container.encode(clusterSecurityGroupName, forKey: ClientRuntime.Key("ClusterSecurityGroupName"))
        }
        if let eC2SecurityGroupName = eC2SecurityGroupName {
            try container.encode(eC2SecurityGroupName, forKey: ClientRuntime.Key("EC2SecurityGroupName"))
        }
        if let eC2SecurityGroupOwnerId = eC2SecurityGroupOwnerId {
            try container.encode(eC2SecurityGroupOwnerId, forKey: ClientRuntime.Key("EC2SecurityGroupOwnerId"))
        }
        try container.encode("AuthorizeClusterSecurityGroupIngress", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct AuthorizeClusterSecurityGroupIngressInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AuthorizeClusterSecurityGroupIngressInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AuthorizeClusterSecurityGroupIngressInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AuthorizeClusterSecurityGroupIngressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AuthorizeClusterSecurityGroupIngressInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AuthorizeClusterSecurityGroupIngressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AuthorizeClusterSecurityGroupIngressOutputError>
}

public struct AuthorizeClusterSecurityGroupIngressInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AuthorizeClusterSecurityGroupIngressInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AuthorizeClusterSecurityGroupIngressInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AuthorizeClusterSecurityGroupIngressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AuthorizeClusterSecurityGroupIngressInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AuthorizeClusterSecurityGroupIngressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AuthorizeClusterSecurityGroupIngressOutputError>
}

/// <p></p>
public struct AuthorizeClusterSecurityGroupIngressInput: Swift.Equatable {
    /// <p>The IP range to be added the Amazon Redshift security group.</p>
    public let cIDRIP: Swift.String?
    /// <p>The name of the security group to which the ingress rule is added.</p>
    public let clusterSecurityGroupName: Swift.String?
    /// <p>The EC2 security group to be added the Amazon Redshift security group.</p>
    public let eC2SecurityGroupName: Swift.String?
    /// <p>The AWS account number of the owner of the security group specified by the
    ///                 <i>EC2SecurityGroupName</i> parameter. The AWS Access Key ID is not an
    ///             acceptable value. </p>
    ///         <p>Example: <code>111122223333</code>
    ///         </p>
    public let eC2SecurityGroupOwnerId: Swift.String?

    public init (
        cIDRIP: Swift.String? = nil,
        clusterSecurityGroupName: Swift.String? = nil,
        eC2SecurityGroupName: Swift.String? = nil,
        eC2SecurityGroupOwnerId: Swift.String? = nil
    )
    {
        self.cIDRIP = cIDRIP
        self.clusterSecurityGroupName = clusterSecurityGroupName
        self.eC2SecurityGroupName = eC2SecurityGroupName
        self.eC2SecurityGroupOwnerId = eC2SecurityGroupOwnerId
    }
}

extension AuthorizeClusterSecurityGroupIngressOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AuthorizeClusterSecurityGroupIngressOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationAlreadyExistsFault" : self = .authorizationAlreadyExistsFault(try AuthorizationAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationQuotaExceededFault" : self = .authorizationQuotaExceededFault(try AuthorizationQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterSecurityGroupNotFoundFault" : self = .clusterSecurityGroupNotFoundFault(try ClusterSecurityGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterSecurityGroupStateFault" : self = .invalidClusterSecurityGroupStateFault(try InvalidClusterSecurityGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AuthorizeClusterSecurityGroupIngressOutputError: Swift.Error, Swift.Equatable {
    case authorizationAlreadyExistsFault(AuthorizationAlreadyExistsFault)
    case authorizationQuotaExceededFault(AuthorizationQuotaExceededFault)
    case clusterSecurityGroupNotFoundFault(ClusterSecurityGroupNotFoundFault)
    case invalidClusterSecurityGroupStateFault(InvalidClusterSecurityGroupStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension AuthorizeClusterSecurityGroupIngressOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AuthorizeClusterSecurityGroupIngressOutputResponse(clusterSecurityGroup: \(Swift.String(describing: clusterSecurityGroup)))"}
}

extension AuthorizeClusterSecurityGroupIngressOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AuthorizeClusterSecurityGroupIngressOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clusterSecurityGroup = output.clusterSecurityGroup
        } else {
            self.clusterSecurityGroup = nil
        }
    }
}

public struct AuthorizeClusterSecurityGroupIngressOutputResponse: Swift.Equatable {
    /// <p>Describes a security group.</p>
    public let clusterSecurityGroup: RedshiftClientTypes.ClusterSecurityGroup?

    public init (
        clusterSecurityGroup: RedshiftClientTypes.ClusterSecurityGroup? = nil
    )
    {
        self.clusterSecurityGroup = clusterSecurityGroup
    }
}

struct AuthorizeClusterSecurityGroupIngressOutputResponseBody: Swift.Equatable {
    public let clusterSecurityGroup: RedshiftClientTypes.ClusterSecurityGroup?
}

extension AuthorizeClusterSecurityGroupIngressOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterSecurityGroup = "ClusterSecurityGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("AuthorizeClusterSecurityGroupIngressResult"))
        let clusterSecurityGroupDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.ClusterSecurityGroup.self, forKey: .clusterSecurityGroup)
        clusterSecurityGroup = clusterSecurityGroupDecoded
    }
}

public struct AuthorizeEndpointAccessInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AuthorizeEndpointAccessInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AuthorizeEndpointAccessInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AuthorizeEndpointAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AuthorizeEndpointAccessInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AuthorizeEndpointAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AuthorizeEndpointAccessOutputError>
}

extension AuthorizeEndpointAccessInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AuthorizeEndpointAccessInput(account: \(Swift.String(describing: account)), clusterIdentifier: \(Swift.String(describing: clusterIdentifier)), vpcIds: \(Swift.String(describing: vpcIds)))"}
}

extension AuthorizeEndpointAccessInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let account = account {
            try container.encode(account, forKey: ClientRuntime.Key("Account"))
        }
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: ClientRuntime.Key("ClusterIdentifier"))
        }
        if let vpcIds = vpcIds {
            var vpcIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcIds"))
            for (index0, string0) in vpcIds.enumerated() {
                try vpcIdsContainer.encode(string0, forKey: ClientRuntime.Key("VpcIdentifier.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("AuthorizeEndpointAccess", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct AuthorizeEndpointAccessInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AuthorizeEndpointAccessInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AuthorizeEndpointAccessInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AuthorizeEndpointAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AuthorizeEndpointAccessInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AuthorizeEndpointAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AuthorizeEndpointAccessOutputError>
}

public struct AuthorizeEndpointAccessInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AuthorizeEndpointAccessInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AuthorizeEndpointAccessInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AuthorizeEndpointAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AuthorizeEndpointAccessInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AuthorizeEndpointAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AuthorizeEndpointAccessOutputError>
}

public struct AuthorizeEndpointAccessInput: Swift.Equatable {
    /// <p>The AWS account ID to grant access to.</p>
    public let account: Swift.String?
    /// <p>The cluster identifier of the cluster to grant access to.</p>
    public let clusterIdentifier: Swift.String?
    /// <p>The virtual private cloud (VPC) identifiers to grant access to.</p>
    public let vpcIds: [Swift.String]?

    public init (
        account: Swift.String? = nil,
        clusterIdentifier: Swift.String? = nil,
        vpcIds: [Swift.String]? = nil
    )
    {
        self.account = account
        self.clusterIdentifier = clusterIdentifier
        self.vpcIds = vpcIds
    }
}

extension AuthorizeEndpointAccessOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AuthorizeEndpointAccessOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EndpointAuthorizationAlreadyExistsFault" : self = .endpointAuthorizationAlreadyExistsFault(try EndpointAuthorizationAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EndpointAuthorizationsPerClusterLimitExceededFault" : self = .endpointAuthorizationsPerClusterLimitExceededFault(try EndpointAuthorizationsPerClusterLimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAuthorizationStateFault" : self = .invalidAuthorizationStateFault(try InvalidAuthorizationStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationFault" : self = .unsupportedOperationFault(try UnsupportedOperationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AuthorizeEndpointAccessOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case endpointAuthorizationAlreadyExistsFault(EndpointAuthorizationAlreadyExistsFault)
    case endpointAuthorizationsPerClusterLimitExceededFault(EndpointAuthorizationsPerClusterLimitExceededFault)
    case invalidAuthorizationStateFault(InvalidAuthorizationStateFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case unsupportedOperationFault(UnsupportedOperationFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension AuthorizeEndpointAccessOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AuthorizeEndpointAccessOutputResponse(allowedAllVPCs: \(Swift.String(describing: allowedAllVPCs)), allowedVPCs: \(Swift.String(describing: allowedVPCs)), authorizeTime: \(Swift.String(describing: authorizeTime)), clusterIdentifier: \(Swift.String(describing: clusterIdentifier)), clusterStatus: \(Swift.String(describing: clusterStatus)), endpointCount: \(Swift.String(describing: endpointCount)), grantee: \(Swift.String(describing: grantee)), grantor: \(Swift.String(describing: grantor)), status: \(Swift.String(describing: status)))"}
}

extension AuthorizeEndpointAccessOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AuthorizeEndpointAccessOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.allowedAllVPCs = output.allowedAllVPCs
            self.allowedVPCs = output.allowedVPCs
            self.authorizeTime = output.authorizeTime
            self.clusterIdentifier = output.clusterIdentifier
            self.clusterStatus = output.clusterStatus
            self.endpointCount = output.endpointCount
            self.grantee = output.grantee
            self.grantor = output.grantor
            self.status = output.status
        } else {
            self.allowedAllVPCs = false
            self.allowedVPCs = nil
            self.authorizeTime = nil
            self.clusterIdentifier = nil
            self.clusterStatus = nil
            self.endpointCount = 0
            self.grantee = nil
            self.grantor = nil
            self.status = nil
        }
    }
}

/// <p>Describes an endpoint authorization for authorizing Redshift-managed VPC endpoint access to a cluster across AWS accounts.</p>
public struct AuthorizeEndpointAccessOutputResponse: Swift.Equatable {
    /// <p>Indicates whether all VPCs in the grantee account are allowed access to the cluster.</p>
    public let allowedAllVPCs: Swift.Bool
    /// <p>The VPCs allowed access to the cluster.</p>
    public let allowedVPCs: [Swift.String]?
    /// <p>The time (UTC) when the authorization was created.</p>
    public let authorizeTime: ClientRuntime.Date?
    /// <p>The cluster identifier.</p>
    public let clusterIdentifier: Swift.String?
    /// <p>The status of the cluster.</p>
    public let clusterStatus: Swift.String?
    /// <p>The number of Redshift-managed VPC endpoints created for the authorization.</p>
    public let endpointCount: Swift.Int
    /// <p>The AWS account ID of the grantee of the cluster.</p>
    public let grantee: Swift.String?
    /// <p>The AWS account ID of the cluster owner.</p>
    public let grantor: Swift.String?
    /// <p>The status of the authorization action.</p>
    public let status: RedshiftClientTypes.AuthorizationStatus?

    public init (
        allowedAllVPCs: Swift.Bool = false,
        allowedVPCs: [Swift.String]? = nil,
        authorizeTime: ClientRuntime.Date? = nil,
        clusterIdentifier: Swift.String? = nil,
        clusterStatus: Swift.String? = nil,
        endpointCount: Swift.Int = 0,
        grantee: Swift.String? = nil,
        grantor: Swift.String? = nil,
        status: RedshiftClientTypes.AuthorizationStatus? = nil
    )
    {
        self.allowedAllVPCs = allowedAllVPCs
        self.allowedVPCs = allowedVPCs
        self.authorizeTime = authorizeTime
        self.clusterIdentifier = clusterIdentifier
        self.clusterStatus = clusterStatus
        self.endpointCount = endpointCount
        self.grantee = grantee
        self.grantor = grantor
        self.status = status
    }
}

struct AuthorizeEndpointAccessOutputResponseBody: Swift.Equatable {
    public let grantor: Swift.String?
    public let grantee: Swift.String?
    public let clusterIdentifier: Swift.String?
    public let authorizeTime: ClientRuntime.Date?
    public let clusterStatus: Swift.String?
    public let status: RedshiftClientTypes.AuthorizationStatus?
    public let allowedAllVPCs: Swift.Bool
    public let allowedVPCs: [Swift.String]?
    public let endpointCount: Swift.Int
}

extension AuthorizeEndpointAccessOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedAllVPCs = "AllowedAllVPCs"
        case allowedVPCs = "AllowedVPCs"
        case authorizeTime = "AuthorizeTime"
        case clusterIdentifier = "ClusterIdentifier"
        case clusterStatus = "ClusterStatus"
        case endpointCount = "EndpointCount"
        case grantee = "Grantee"
        case grantor = "Grantor"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("AuthorizeEndpointAccessResult"))
        let grantorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .grantor)
        grantor = grantorDecoded
        let granteeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .grantee)
        grantee = granteeDecoded
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let authorizeTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizeTime)
        var authorizeTimeBuffer:ClientRuntime.Date? = nil
        if let authorizeTimeDecoded = authorizeTimeDecoded {
            authorizeTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(authorizeTimeDecoded, format: .dateTime)
        }
        authorizeTime = authorizeTimeBuffer
        let clusterStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterStatus)
        clusterStatus = clusterStatusDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.AuthorizationStatus.self, forKey: .status)
        status = statusDecoded
        let allowedAllVPCsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .allowedAllVPCs)
        allowedAllVPCs = allowedAllVPCsDecoded
        if containerValues.contains(.allowedVPCs) {
            struct KeyVal0{struct VpcIdentifier{}}
            let allowedVPCsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.VpcIdentifier>.CodingKeys.self, forKey: .allowedVPCs)
            if let allowedVPCsWrappedContainer = allowedVPCsWrappedContainer {
                let allowedVPCsContainer = try allowedVPCsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var allowedVPCsBuffer:[Swift.String]? = nil
                if let allowedVPCsContainer = allowedVPCsContainer {
                    allowedVPCsBuffer = [Swift.String]()
                    for stringContainer0 in allowedVPCsContainer {
                        allowedVPCsBuffer?.append(stringContainer0)
                    }
                }
                allowedVPCs = allowedVPCsBuffer
            } else {
                allowedVPCs = []
            }
        } else {
            allowedVPCs = nil
        }
        let endpointCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .endpointCount)
        endpointCount = endpointCountDecoded
    }
}

public struct AuthorizeSnapshotAccessInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AuthorizeSnapshotAccessInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AuthorizeSnapshotAccessInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AuthorizeSnapshotAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AuthorizeSnapshotAccessInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AuthorizeSnapshotAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AuthorizeSnapshotAccessOutputError>
}

extension AuthorizeSnapshotAccessInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AuthorizeSnapshotAccessInput(accountWithRestoreAccess: \(Swift.String(describing: accountWithRestoreAccess)), snapshotClusterIdentifier: \(Swift.String(describing: snapshotClusterIdentifier)), snapshotIdentifier: \(Swift.String(describing: snapshotIdentifier)))"}
}

extension AuthorizeSnapshotAccessInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let accountWithRestoreAccess = accountWithRestoreAccess {
            try container.encode(accountWithRestoreAccess, forKey: ClientRuntime.Key("AccountWithRestoreAccess"))
        }
        if let snapshotClusterIdentifier = snapshotClusterIdentifier {
            try container.encode(snapshotClusterIdentifier, forKey: ClientRuntime.Key("SnapshotClusterIdentifier"))
        }
        if let snapshotIdentifier = snapshotIdentifier {
            try container.encode(snapshotIdentifier, forKey: ClientRuntime.Key("SnapshotIdentifier"))
        }
        try container.encode("AuthorizeSnapshotAccess", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct AuthorizeSnapshotAccessInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AuthorizeSnapshotAccessInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AuthorizeSnapshotAccessInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AuthorizeSnapshotAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AuthorizeSnapshotAccessInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AuthorizeSnapshotAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AuthorizeSnapshotAccessOutputError>
}

public struct AuthorizeSnapshotAccessInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AuthorizeSnapshotAccessInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AuthorizeSnapshotAccessInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AuthorizeSnapshotAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AuthorizeSnapshotAccessInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AuthorizeSnapshotAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AuthorizeSnapshotAccessOutputError>
}

/// <p></p>
public struct AuthorizeSnapshotAccessInput: Swift.Equatable {
    /// <p>The identifier of the AWS customer account authorized to restore the specified
    ///             snapshot.</p>
    ///         <p>To share a snapshot with AWS support, specify amazon-redshift-support.</p>
    public let accountWithRestoreAccess: Swift.String?
    /// <p>The identifier of the cluster the snapshot was created from. This parameter is
    ///             required if your IAM user has a policy containing a snapshot resource element that
    ///             specifies anything other than * for the cluster name.</p>
    public let snapshotClusterIdentifier: Swift.String?
    /// <p>The identifier of the snapshot the account is authorized to restore.</p>
    public let snapshotIdentifier: Swift.String?

    public init (
        accountWithRestoreAccess: Swift.String? = nil,
        snapshotClusterIdentifier: Swift.String? = nil,
        snapshotIdentifier: Swift.String? = nil
    )
    {
        self.accountWithRestoreAccess = accountWithRestoreAccess
        self.snapshotClusterIdentifier = snapshotClusterIdentifier
        self.snapshotIdentifier = snapshotIdentifier
    }
}

extension AuthorizeSnapshotAccessOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AuthorizeSnapshotAccessOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationAlreadyExistsFault" : self = .authorizationAlreadyExistsFault(try AuthorizationAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationQuotaExceededFault" : self = .authorizationQuotaExceededFault(try AuthorizationQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterSnapshotNotFoundFault" : self = .clusterSnapshotNotFoundFault(try ClusterSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependentServiceRequestThrottlingFault" : self = .dependentServiceRequestThrottlingFault(try DependentServiceRequestThrottlingFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterSnapshotStateFault" : self = .invalidClusterSnapshotStateFault(try InvalidClusterSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededFault" : self = .limitExceededFault(try LimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AuthorizeSnapshotAccessOutputError: Swift.Error, Swift.Equatable {
    case authorizationAlreadyExistsFault(AuthorizationAlreadyExistsFault)
    case authorizationQuotaExceededFault(AuthorizationQuotaExceededFault)
    case clusterSnapshotNotFoundFault(ClusterSnapshotNotFoundFault)
    case dependentServiceRequestThrottlingFault(DependentServiceRequestThrottlingFault)
    case invalidClusterSnapshotStateFault(InvalidClusterSnapshotStateFault)
    case limitExceededFault(LimitExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension AuthorizeSnapshotAccessOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AuthorizeSnapshotAccessOutputResponse(snapshot: \(Swift.String(describing: snapshot)))"}
}

extension AuthorizeSnapshotAccessOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AuthorizeSnapshotAccessOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.snapshot = output.snapshot
        } else {
            self.snapshot = nil
        }
    }
}

public struct AuthorizeSnapshotAccessOutputResponse: Swift.Equatable {
    /// <p>Describes a snapshot.</p>
    public let snapshot: RedshiftClientTypes.Snapshot?

    public init (
        snapshot: RedshiftClientTypes.Snapshot? = nil
    )
    {
        self.snapshot = snapshot
    }
}

struct AuthorizeSnapshotAccessOutputResponseBody: Swift.Equatable {
    public let snapshot: RedshiftClientTypes.Snapshot?
}

extension AuthorizeSnapshotAccessOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshot = "Snapshot"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("AuthorizeSnapshotAccessResult"))
        let snapshotDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.Snapshot.self, forKey: .snapshot)
        snapshot = snapshotDecoded
    }
}

extension RedshiftClientTypes.AvailabilityZone: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case supportedPlatforms = "SupportedPlatforms"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let supportedPlatforms = supportedPlatforms {
            var supportedPlatformsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SupportedPlatforms"))
            for (index0, supportedplatform0) in supportedPlatforms.enumerated() {
                try supportedPlatformsContainer.encode(supportedplatform0, forKey: ClientRuntime.Key("SupportedPlatform.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        if containerValues.contains(.supportedPlatforms) {
            struct KeyVal0{struct SupportedPlatform{}}
            let supportedPlatformsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.SupportedPlatform>.CodingKeys.self, forKey: .supportedPlatforms)
            if let supportedPlatformsWrappedContainer = supportedPlatformsWrappedContainer {
                let supportedPlatformsContainer = try supportedPlatformsWrappedContainer.decodeIfPresent([RedshiftClientTypes.SupportedPlatform].self, forKey: .member)
                var supportedPlatformsBuffer:[RedshiftClientTypes.SupportedPlatform]? = nil
                if let supportedPlatformsContainer = supportedPlatformsContainer {
                    supportedPlatformsBuffer = [RedshiftClientTypes.SupportedPlatform]()
                    for structureContainer0 in supportedPlatformsContainer {
                        supportedPlatformsBuffer?.append(structureContainer0)
                    }
                }
                supportedPlatforms = supportedPlatformsBuffer
            } else {
                supportedPlatforms = []
            }
        } else {
            supportedPlatforms = nil
        }
    }
}

extension RedshiftClientTypes.AvailabilityZone: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AvailabilityZone(name: \(Swift.String(describing: name)), supportedPlatforms: \(Swift.String(describing: supportedPlatforms)))"}
}

extension RedshiftClientTypes {
    /// <p>Describes an availability zone.</p>
    public struct AvailabilityZone: Swift.Equatable {
        /// <p>The name of the availability zone.</p>
        public let name: Swift.String?
        /// <p></p>
        public let supportedPlatforms: [RedshiftClientTypes.SupportedPlatform]?

        public init (
            name: Swift.String? = nil,
            supportedPlatforms: [RedshiftClientTypes.SupportedPlatform]? = nil
        )
        {
            self.name = name
            self.supportedPlatforms = supportedPlatforms
        }
    }

}

public struct BatchDeleteClusterSnapshotsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDeleteClusterSnapshotsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchDeleteClusterSnapshotsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDeleteClusterSnapshotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchDeleteClusterSnapshotsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDeleteClusterSnapshotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDeleteClusterSnapshotsOutputError>
}

extension BatchDeleteClusterSnapshotsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchDeleteClusterSnapshotsInput(identifiers: \(Swift.String(describing: identifiers)))"}
}

extension BatchDeleteClusterSnapshotsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let identifiers = identifiers {
            var identifiersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Identifiers"))
            for (index0, deleteclustersnapshotmessage0) in identifiers.enumerated() {
                try identifiersContainer.encode(deleteclustersnapshotmessage0, forKey: ClientRuntime.Key("DeleteClusterSnapshotMessage.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("BatchDeleteClusterSnapshots", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct BatchDeleteClusterSnapshotsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDeleteClusterSnapshotsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchDeleteClusterSnapshotsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDeleteClusterSnapshotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchDeleteClusterSnapshotsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDeleteClusterSnapshotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDeleteClusterSnapshotsOutputError>
}

public struct BatchDeleteClusterSnapshotsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDeleteClusterSnapshotsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchDeleteClusterSnapshotsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDeleteClusterSnapshotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchDeleteClusterSnapshotsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDeleteClusterSnapshotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDeleteClusterSnapshotsOutputError>
}

public struct BatchDeleteClusterSnapshotsInput: Swift.Equatable {
    /// <p>A list of identifiers for the snapshots that you want to delete.</p>
    public let identifiers: [RedshiftClientTypes.DeleteClusterSnapshotMessage]?

    public init (
        identifiers: [RedshiftClientTypes.DeleteClusterSnapshotMessage]? = nil
    )
    {
        self.identifiers = identifiers
    }
}

extension BatchDeleteClusterSnapshotsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension BatchDeleteClusterSnapshotsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BatchDeleteRequestSizeExceededFault" : self = .batchDeleteRequestSizeExceededFault(try BatchDeleteRequestSizeExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchDeleteClusterSnapshotsOutputError: Swift.Error, Swift.Equatable {
    case batchDeleteRequestSizeExceededFault(BatchDeleteRequestSizeExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDeleteClusterSnapshotsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchDeleteClusterSnapshotsOutputResponse(errors: \(Swift.String(describing: errors)), resources: \(Swift.String(describing: resources)))"}
}

extension BatchDeleteClusterSnapshotsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchDeleteClusterSnapshotsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
            self.resources = output.resources
        } else {
            self.errors = nil
            self.resources = nil
        }
    }
}

public struct BatchDeleteClusterSnapshotsOutputResponse: Swift.Equatable {
    /// <p>A list of any errors returned.</p>
    public let errors: [RedshiftClientTypes.SnapshotErrorMessage]?
    /// <p>A list of the snapshot identifiers that were deleted. </p>
    public let resources: [Swift.String]?

    public init (
        errors: [RedshiftClientTypes.SnapshotErrorMessage]? = nil,
        resources: [Swift.String]? = nil
    )
    {
        self.errors = errors
        self.resources = resources
    }
}

struct BatchDeleteClusterSnapshotsOutputResponseBody: Swift.Equatable {
    public let resources: [Swift.String]?
    public let errors: [RedshiftClientTypes.SnapshotErrorMessage]?
}

extension BatchDeleteClusterSnapshotsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors = "Errors"
        case resources = "Resources"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("BatchDeleteClusterSnapshotsResult"))
        if containerValues.contains(.resources) {
            struct KeyVal0{struct String{}}
            let resourcesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.String>.CodingKeys.self, forKey: .resources)
            if let resourcesWrappedContainer = resourcesWrappedContainer {
                let resourcesContainer = try resourcesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var resourcesBuffer:[Swift.String]? = nil
                if let resourcesContainer = resourcesContainer {
                    resourcesBuffer = [Swift.String]()
                    for stringContainer0 in resourcesContainer {
                        resourcesBuffer?.append(stringContainer0)
                    }
                }
                resources = resourcesBuffer
            } else {
                resources = []
            }
        } else {
            resources = nil
        }
        if containerValues.contains(.errors) {
            struct KeyVal0{struct SnapshotErrorMessage{}}
            let errorsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.SnapshotErrorMessage>.CodingKeys.self, forKey: .errors)
            if let errorsWrappedContainer = errorsWrappedContainer {
                let errorsContainer = try errorsWrappedContainer.decodeIfPresent([RedshiftClientTypes.SnapshotErrorMessage].self, forKey: .member)
                var errorsBuffer:[RedshiftClientTypes.SnapshotErrorMessage]? = nil
                if let errorsContainer = errorsContainer {
                    errorsBuffer = [RedshiftClientTypes.SnapshotErrorMessage]()
                    for structureContainer0 in errorsContainer {
                        errorsBuffer?.append(structureContainer0)
                    }
                }
                errors = errorsBuffer
            } else {
                errors = []
            }
        } else {
            errors = nil
        }
    }
}

extension BatchDeleteRequestSizeExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchDeleteRequestSizeExceededFault(message: \(Swift.String(describing: message)))"}
}

extension BatchDeleteRequestSizeExceededFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<BatchDeleteRequestSizeExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The maximum number for a batch delete of snapshots has been reached. The limit is
///             100. </p>
public struct BatchDeleteRequestSizeExceededFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct BatchDeleteRequestSizeExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension BatchDeleteRequestSizeExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct BatchModifyClusterSnapshotsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchModifyClusterSnapshotsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchModifyClusterSnapshotsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchModifyClusterSnapshotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchModifyClusterSnapshotsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchModifyClusterSnapshotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchModifyClusterSnapshotsOutputError>
}

extension BatchModifyClusterSnapshotsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchModifyClusterSnapshotsInput(force: \(Swift.String(describing: force)), manualSnapshotRetentionPeriod: \(Swift.String(describing: manualSnapshotRetentionPeriod)), snapshotIdentifierList: \(Swift.String(describing: snapshotIdentifierList)))"}
}

extension BatchModifyClusterSnapshotsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if force != false {
            try container.encode(force, forKey: ClientRuntime.Key("Force"))
        }
        if let manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriod {
            try container.encode(manualSnapshotRetentionPeriod, forKey: ClientRuntime.Key("ManualSnapshotRetentionPeriod"))
        }
        if let snapshotIdentifierList = snapshotIdentifierList {
            var snapshotIdentifierListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SnapshotIdentifierList"))
            for (index0, string0) in snapshotIdentifierList.enumerated() {
                try snapshotIdentifierListContainer.encode(string0, forKey: ClientRuntime.Key("String.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("BatchModifyClusterSnapshots", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct BatchModifyClusterSnapshotsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchModifyClusterSnapshotsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchModifyClusterSnapshotsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchModifyClusterSnapshotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchModifyClusterSnapshotsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchModifyClusterSnapshotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchModifyClusterSnapshotsOutputError>
}

public struct BatchModifyClusterSnapshotsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchModifyClusterSnapshotsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchModifyClusterSnapshotsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchModifyClusterSnapshotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchModifyClusterSnapshotsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchModifyClusterSnapshotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchModifyClusterSnapshotsOutputError>
}

public struct BatchModifyClusterSnapshotsInput: Swift.Equatable {
    /// <p>A boolean value indicating whether to override an exception if the retention period
    ///             has passed. </p>
    public let force: Swift.Bool
    /// <p>The number of days that a manual snapshot is retained. If you specify the value -1,
    ///             the manual snapshot is retained indefinitely.</p>
    ///         <p>The number must be either -1 or an integer between 1 and 3,653.</p>
    ///         <p>If you decrease the manual snapshot retention period from its current value, existing
    ///             manual snapshots that fall outside of the new retention period will return an error. If
    ///             you want to suppress the errors and delete the snapshots, use the force option. </p>
    public let manualSnapshotRetentionPeriod: Swift.Int?
    /// <p>A list of snapshot identifiers you want to modify.</p>
    public let snapshotIdentifierList: [Swift.String]?

    public init (
        force: Swift.Bool = false,
        manualSnapshotRetentionPeriod: Swift.Int? = nil,
        snapshotIdentifierList: [Swift.String]? = nil
    )
    {
        self.force = force
        self.manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriod
        self.snapshotIdentifierList = snapshotIdentifierList
    }
}

extension BatchModifyClusterSnapshotsLimitExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchModifyClusterSnapshotsLimitExceededFault(message: \(Swift.String(describing: message)))"}
}

extension BatchModifyClusterSnapshotsLimitExceededFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<BatchModifyClusterSnapshotsLimitExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The maximum number for snapshot identifiers has been reached. The limit is 100.
///         </p>
public struct BatchModifyClusterSnapshotsLimitExceededFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct BatchModifyClusterSnapshotsLimitExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension BatchModifyClusterSnapshotsLimitExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BatchModifyClusterSnapshotsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension BatchModifyClusterSnapshotsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BatchModifyClusterSnapshotsLimitExceededFault" : self = .batchModifyClusterSnapshotsLimitExceededFault(try BatchModifyClusterSnapshotsLimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRetentionPeriodFault" : self = .invalidRetentionPeriodFault(try InvalidRetentionPeriodFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchModifyClusterSnapshotsOutputError: Swift.Error, Swift.Equatable {
    case batchModifyClusterSnapshotsLimitExceededFault(BatchModifyClusterSnapshotsLimitExceededFault)
    case invalidRetentionPeriodFault(InvalidRetentionPeriodFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchModifyClusterSnapshotsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchModifyClusterSnapshotsOutputResponse(errors: \(Swift.String(describing: errors)), resources: \(Swift.String(describing: resources)))"}
}

extension BatchModifyClusterSnapshotsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchModifyClusterSnapshotsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
            self.resources = output.resources
        } else {
            self.errors = nil
            self.resources = nil
        }
    }
}

public struct BatchModifyClusterSnapshotsOutputResponse: Swift.Equatable {
    /// <p>A list of any errors returned.</p>
    public let errors: [RedshiftClientTypes.SnapshotErrorMessage]?
    /// <p>A list of the snapshots that were modified.</p>
    public let resources: [Swift.String]?

    public init (
        errors: [RedshiftClientTypes.SnapshotErrorMessage]? = nil,
        resources: [Swift.String]? = nil
    )
    {
        self.errors = errors
        self.resources = resources
    }
}

struct BatchModifyClusterSnapshotsOutputResponseBody: Swift.Equatable {
    public let resources: [Swift.String]?
    public let errors: [RedshiftClientTypes.SnapshotErrorMessage]?
}

extension BatchModifyClusterSnapshotsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors = "Errors"
        case resources = "Resources"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("BatchModifyClusterSnapshotsResult"))
        if containerValues.contains(.resources) {
            struct KeyVal0{struct String{}}
            let resourcesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.String>.CodingKeys.self, forKey: .resources)
            if let resourcesWrappedContainer = resourcesWrappedContainer {
                let resourcesContainer = try resourcesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var resourcesBuffer:[Swift.String]? = nil
                if let resourcesContainer = resourcesContainer {
                    resourcesBuffer = [Swift.String]()
                    for stringContainer0 in resourcesContainer {
                        resourcesBuffer?.append(stringContainer0)
                    }
                }
                resources = resourcesBuffer
            } else {
                resources = []
            }
        } else {
            resources = nil
        }
        if containerValues.contains(.errors) {
            struct KeyVal0{struct SnapshotErrorMessage{}}
            let errorsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.SnapshotErrorMessage>.CodingKeys.self, forKey: .errors)
            if let errorsWrappedContainer = errorsWrappedContainer {
                let errorsContainer = try errorsWrappedContainer.decodeIfPresent([RedshiftClientTypes.SnapshotErrorMessage].self, forKey: .member)
                var errorsBuffer:[RedshiftClientTypes.SnapshotErrorMessage]? = nil
                if let errorsContainer = errorsContainer {
                    errorsBuffer = [RedshiftClientTypes.SnapshotErrorMessage]()
                    for structureContainer0 in errorsContainer {
                        errorsBuffer?.append(structureContainer0)
                    }
                }
                errors = errorsBuffer
            } else {
                errors = []
            }
        } else {
            errors = nil
        }
    }
}

extension BucketNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BucketNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension BucketNotFoundFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<BucketNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Could not find the specified S3 bucket.</p>
public struct BucketNotFoundFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct BucketNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension BucketNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CancelResizeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelResizeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelResizeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelResizeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelResizeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelResizeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelResizeOutputError>
}

extension CancelResizeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelResizeInput(clusterIdentifier: \(Swift.String(describing: clusterIdentifier)))"}
}

extension CancelResizeInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: ClientRuntime.Key("ClusterIdentifier"))
        }
        try container.encode("CancelResize", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CancelResizeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelResizeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelResizeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelResizeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelResizeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelResizeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelResizeOutputError>
}

public struct CancelResizeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelResizeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelResizeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelResizeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelResizeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelResizeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelResizeOutputError>
}

public struct CancelResizeInput: Swift.Equatable {
    /// <p>The unique identifier for the cluster that you want to cancel a resize operation
    ///             for.</p>
    public let clusterIdentifier: Swift.String?

    public init (
        clusterIdentifier: Swift.String? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
    }
}

extension CancelResizeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CancelResizeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResizeNotFoundFault" : self = .resizeNotFoundFault(try ResizeNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationFault" : self = .unsupportedOperationFault(try UnsupportedOperationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelResizeOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case resizeNotFoundFault(ResizeNotFoundFault)
    case unsupportedOperationFault(UnsupportedOperationFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelResizeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelResizeOutputResponse(avgResizeRateInMegaBytesPerSecond: \(Swift.String(describing: avgResizeRateInMegaBytesPerSecond)), dataTransferProgressPercent: \(Swift.String(describing: dataTransferProgressPercent)), elapsedTimeInSeconds: \(Swift.String(describing: elapsedTimeInSeconds)), estimatedTimeToCompletionInSeconds: \(Swift.String(describing: estimatedTimeToCompletionInSeconds)), importTablesCompleted: \(Swift.String(describing: importTablesCompleted)), importTablesInProgress: \(Swift.String(describing: importTablesInProgress)), importTablesNotStarted: \(Swift.String(describing: importTablesNotStarted)), message: \(Swift.String(describing: message)), progressInMegaBytes: \(Swift.String(describing: progressInMegaBytes)), resizeType: \(Swift.String(describing: resizeType)), status: \(Swift.String(describing: status)), targetClusterType: \(Swift.String(describing: targetClusterType)), targetEncryptionType: \(Swift.String(describing: targetEncryptionType)), targetNodeType: \(Swift.String(describing: targetNodeType)), targetNumberOfNodes: \(Swift.String(describing: targetNumberOfNodes)), totalResizeDataInMegaBytes: \(Swift.String(describing: totalResizeDataInMegaBytes)))"}
}

extension CancelResizeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CancelResizeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.avgResizeRateInMegaBytesPerSecond = output.avgResizeRateInMegaBytesPerSecond
            self.dataTransferProgressPercent = output.dataTransferProgressPercent
            self.elapsedTimeInSeconds = output.elapsedTimeInSeconds
            self.estimatedTimeToCompletionInSeconds = output.estimatedTimeToCompletionInSeconds
            self.importTablesCompleted = output.importTablesCompleted
            self.importTablesInProgress = output.importTablesInProgress
            self.importTablesNotStarted = output.importTablesNotStarted
            self.message = output.message
            self.progressInMegaBytes = output.progressInMegaBytes
            self.resizeType = output.resizeType
            self.status = output.status
            self.targetClusterType = output.targetClusterType
            self.targetEncryptionType = output.targetEncryptionType
            self.targetNodeType = output.targetNodeType
            self.targetNumberOfNodes = output.targetNumberOfNodes
            self.totalResizeDataInMegaBytes = output.totalResizeDataInMegaBytes
        } else {
            self.avgResizeRateInMegaBytesPerSecond = nil
            self.dataTransferProgressPercent = nil
            self.elapsedTimeInSeconds = nil
            self.estimatedTimeToCompletionInSeconds = nil
            self.importTablesCompleted = nil
            self.importTablesInProgress = nil
            self.importTablesNotStarted = nil
            self.message = nil
            self.progressInMegaBytes = nil
            self.resizeType = nil
            self.status = nil
            self.targetClusterType = nil
            self.targetEncryptionType = nil
            self.targetNodeType = nil
            self.targetNumberOfNodes = nil
            self.totalResizeDataInMegaBytes = nil
        }
    }
}

/// <p>Describes the result of a cluster resize operation.</p>
public struct CancelResizeOutputResponse: Swift.Equatable {
    /// <p>The average rate of the resize operation over the last few minutes, measured in
    ///             megabytes per second. After the resize operation completes, this value shows the average
    ///             rate of the entire resize operation.</p>
    public let avgResizeRateInMegaBytesPerSecond: Swift.Double?
    /// <p>The percent of data transferred from source cluster to target cluster.</p>
    public let dataTransferProgressPercent: Swift.Double?
    /// <p>The amount of seconds that have elapsed since the resize operation began. After the
    ///             resize operation completes, this value shows the total actual time, in seconds, for the
    ///             resize operation.</p>
    public let elapsedTimeInSeconds: Swift.Int?
    /// <p>The estimated time remaining, in seconds, until the resize operation is complete.
    ///             This value is calculated based on the average resize rate and the estimated amount of
    ///             data remaining to be processed. Once the resize operation is complete, this value will
    ///             be 0.</p>
    public let estimatedTimeToCompletionInSeconds: Swift.Int?
    /// <p>The names of tables that have been completely imported .</p>
    ///         <p>Valid Values: List of table names.</p>
    public let importTablesCompleted: [Swift.String]?
    /// <p>The names of tables that are being currently imported.</p>
    ///         <p>Valid Values: List of table names.</p>
    public let importTablesInProgress: [Swift.String]?
    /// <p>The names of tables that have not been yet imported.</p>
    ///         <p>Valid Values: List of table names</p>
    public let importTablesNotStarted: [Swift.String]?
    /// <p>An optional string to provide additional details about the resize action.</p>
    public let message: Swift.String?
    /// <p>While the resize operation is in progress, this value shows the current amount of
    ///             data, in megabytes, that has been processed so far. When the resize operation is
    ///             complete, this value shows the total amount of data, in megabytes, on the cluster, which
    ///             may be more or less than TotalResizeDataInMegaBytes (the estimated total amount of data
    ///             before resize).</p>
    public let progressInMegaBytes: Swift.Int?
    /// <p>An enum with possible values of <code>ClassicResize</code> and
    ///                 <code>ElasticResize</code>. These values describe the type of resize operation being
    ///             performed. </p>
    public let resizeType: Swift.String?
    /// <p>The status of the resize operation.</p>
    ///         <p>Valid Values: <code>NONE</code> | <code>IN_PROGRESS</code> | <code>FAILED</code> |
    ///                 <code>SUCCEEDED</code> | <code>CANCELLING</code>
    ///         </p>
    public let status: Swift.String?
    /// <p>The cluster type after the resize operation is complete.</p>
    ///         <p>Valid Values: <code>multi-node</code> | <code>single-node</code>
    ///         </p>
    public let targetClusterType: Swift.String?
    /// <p>The type of encryption for the cluster after the resize is complete.</p>
    ///         <p>Possible values are <code>KMS</code> and <code>None</code>. </p>
    public let targetEncryptionType: Swift.String?
    /// <p>The node type that the cluster will have after the resize operation is
    ///             complete.</p>
    public let targetNodeType: Swift.String?
    /// <p>The number of nodes that the cluster will have after the resize operation is
    ///             complete.</p>
    public let targetNumberOfNodes: Swift.Int?
    /// <p>The estimated total amount of data, in megabytes, on the cluster before the resize
    ///             operation began.</p>
    public let totalResizeDataInMegaBytes: Swift.Int?

    public init (
        avgResizeRateInMegaBytesPerSecond: Swift.Double? = nil,
        dataTransferProgressPercent: Swift.Double? = nil,
        elapsedTimeInSeconds: Swift.Int? = nil,
        estimatedTimeToCompletionInSeconds: Swift.Int? = nil,
        importTablesCompleted: [Swift.String]? = nil,
        importTablesInProgress: [Swift.String]? = nil,
        importTablesNotStarted: [Swift.String]? = nil,
        message: Swift.String? = nil,
        progressInMegaBytes: Swift.Int? = nil,
        resizeType: Swift.String? = nil,
        status: Swift.String? = nil,
        targetClusterType: Swift.String? = nil,
        targetEncryptionType: Swift.String? = nil,
        targetNodeType: Swift.String? = nil,
        targetNumberOfNodes: Swift.Int? = nil,
        totalResizeDataInMegaBytes: Swift.Int? = nil
    )
    {
        self.avgResizeRateInMegaBytesPerSecond = avgResizeRateInMegaBytesPerSecond
        self.dataTransferProgressPercent = dataTransferProgressPercent
        self.elapsedTimeInSeconds = elapsedTimeInSeconds
        self.estimatedTimeToCompletionInSeconds = estimatedTimeToCompletionInSeconds
        self.importTablesCompleted = importTablesCompleted
        self.importTablesInProgress = importTablesInProgress
        self.importTablesNotStarted = importTablesNotStarted
        self.message = message
        self.progressInMegaBytes = progressInMegaBytes
        self.resizeType = resizeType
        self.status = status
        self.targetClusterType = targetClusterType
        self.targetEncryptionType = targetEncryptionType
        self.targetNodeType = targetNodeType
        self.targetNumberOfNodes = targetNumberOfNodes
        self.totalResizeDataInMegaBytes = totalResizeDataInMegaBytes
    }
}

struct CancelResizeOutputResponseBody: Swift.Equatable {
    public let targetNodeType: Swift.String?
    public let targetNumberOfNodes: Swift.Int?
    public let targetClusterType: Swift.String?
    public let status: Swift.String?
    public let importTablesCompleted: [Swift.String]?
    public let importTablesInProgress: [Swift.String]?
    public let importTablesNotStarted: [Swift.String]?
    public let avgResizeRateInMegaBytesPerSecond: Swift.Double?
    public let totalResizeDataInMegaBytes: Swift.Int?
    public let progressInMegaBytes: Swift.Int?
    public let elapsedTimeInSeconds: Swift.Int?
    public let estimatedTimeToCompletionInSeconds: Swift.Int?
    public let resizeType: Swift.String?
    public let message: Swift.String?
    public let targetEncryptionType: Swift.String?
    public let dataTransferProgressPercent: Swift.Double?
}

extension CancelResizeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case avgResizeRateInMegaBytesPerSecond = "AvgResizeRateInMegaBytesPerSecond"
        case dataTransferProgressPercent = "DataTransferProgressPercent"
        case elapsedTimeInSeconds = "ElapsedTimeInSeconds"
        case estimatedTimeToCompletionInSeconds = "EstimatedTimeToCompletionInSeconds"
        case importTablesCompleted = "ImportTablesCompleted"
        case importTablesInProgress = "ImportTablesInProgress"
        case importTablesNotStarted = "ImportTablesNotStarted"
        case message = "Message"
        case progressInMegaBytes = "ProgressInMegaBytes"
        case resizeType = "ResizeType"
        case status = "Status"
        case targetClusterType = "TargetClusterType"
        case targetEncryptionType = "TargetEncryptionType"
        case targetNodeType = "TargetNodeType"
        case targetNumberOfNodes = "TargetNumberOfNodes"
        case totalResizeDataInMegaBytes = "TotalResizeDataInMegaBytes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CancelResizeResult"))
        let targetNodeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetNodeType)
        targetNodeType = targetNodeTypeDecoded
        let targetNumberOfNodesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .targetNumberOfNodes)
        targetNumberOfNodes = targetNumberOfNodesDecoded
        let targetClusterTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetClusterType)
        targetClusterType = targetClusterTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        if containerValues.contains(.importTablesCompleted) {
            struct KeyVal0{struct member{}}
            let importTablesCompletedWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .importTablesCompleted)
            if let importTablesCompletedWrappedContainer = importTablesCompletedWrappedContainer {
                let importTablesCompletedContainer = try importTablesCompletedWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var importTablesCompletedBuffer:[Swift.String]? = nil
                if let importTablesCompletedContainer = importTablesCompletedContainer {
                    importTablesCompletedBuffer = [Swift.String]()
                    for stringContainer0 in importTablesCompletedContainer {
                        importTablesCompletedBuffer?.append(stringContainer0)
                    }
                }
                importTablesCompleted = importTablesCompletedBuffer
            } else {
                importTablesCompleted = []
            }
        } else {
            importTablesCompleted = nil
        }
        if containerValues.contains(.importTablesInProgress) {
            struct KeyVal0{struct member{}}
            let importTablesInProgressWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .importTablesInProgress)
            if let importTablesInProgressWrappedContainer = importTablesInProgressWrappedContainer {
                let importTablesInProgressContainer = try importTablesInProgressWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var importTablesInProgressBuffer:[Swift.String]? = nil
                if let importTablesInProgressContainer = importTablesInProgressContainer {
                    importTablesInProgressBuffer = [Swift.String]()
                    for stringContainer0 in importTablesInProgressContainer {
                        importTablesInProgressBuffer?.append(stringContainer0)
                    }
                }
                importTablesInProgress = importTablesInProgressBuffer
            } else {
                importTablesInProgress = []
            }
        } else {
            importTablesInProgress = nil
        }
        if containerValues.contains(.importTablesNotStarted) {
            struct KeyVal0{struct member{}}
            let importTablesNotStartedWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .importTablesNotStarted)
            if let importTablesNotStartedWrappedContainer = importTablesNotStartedWrappedContainer {
                let importTablesNotStartedContainer = try importTablesNotStartedWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var importTablesNotStartedBuffer:[Swift.String]? = nil
                if let importTablesNotStartedContainer = importTablesNotStartedContainer {
                    importTablesNotStartedBuffer = [Swift.String]()
                    for stringContainer0 in importTablesNotStartedContainer {
                        importTablesNotStartedBuffer?.append(stringContainer0)
                    }
                }
                importTablesNotStarted = importTablesNotStartedBuffer
            } else {
                importTablesNotStarted = []
            }
        } else {
            importTablesNotStarted = nil
        }
        let avgResizeRateInMegaBytesPerSecondDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .avgResizeRateInMegaBytesPerSecond)
        avgResizeRateInMegaBytesPerSecond = avgResizeRateInMegaBytesPerSecondDecoded
        let totalResizeDataInMegaBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalResizeDataInMegaBytes)
        totalResizeDataInMegaBytes = totalResizeDataInMegaBytesDecoded
        let progressInMegaBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .progressInMegaBytes)
        progressInMegaBytes = progressInMegaBytesDecoded
        let elapsedTimeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .elapsedTimeInSeconds)
        elapsedTimeInSeconds = elapsedTimeInSecondsDecoded
        let estimatedTimeToCompletionInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .estimatedTimeToCompletionInSeconds)
        estimatedTimeToCompletionInSeconds = estimatedTimeToCompletionInSecondsDecoded
        let resizeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resizeType)
        resizeType = resizeTypeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let targetEncryptionTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetEncryptionType)
        targetEncryptionType = targetEncryptionTypeDecoded
        let dataTransferProgressPercentDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .dataTransferProgressPercent)
        dataTransferProgressPercent = dataTransferProgressPercentDecoded
    }
}

extension RedshiftClientTypes.Cluster: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowVersionUpgrade = "AllowVersionUpgrade"
        case aquaConfiguration = "AquaConfiguration"
        case automatedSnapshotRetentionPeriod = "AutomatedSnapshotRetentionPeriod"
        case availabilityZone = "AvailabilityZone"
        case availabilityZoneRelocationStatus = "AvailabilityZoneRelocationStatus"
        case clusterAvailabilityStatus = "ClusterAvailabilityStatus"
        case clusterCreateTime = "ClusterCreateTime"
        case clusterIdentifier = "ClusterIdentifier"
        case clusterNamespaceArn = "ClusterNamespaceArn"
        case clusterNodes = "ClusterNodes"
        case clusterParameterGroups = "ClusterParameterGroups"
        case clusterPublicKey = "ClusterPublicKey"
        case clusterRevisionNumber = "ClusterRevisionNumber"
        case clusterSecurityGroups = "ClusterSecurityGroups"
        case clusterSnapshotCopyStatus = "ClusterSnapshotCopyStatus"
        case clusterStatus = "ClusterStatus"
        case clusterSubnetGroupName = "ClusterSubnetGroupName"
        case clusterVersion = "ClusterVersion"
        case dBName = "DBName"
        case dataTransferProgress = "DataTransferProgress"
        case deferredMaintenanceWindows = "DeferredMaintenanceWindows"
        case elasticIpStatus = "ElasticIpStatus"
        case elasticResizeNumberOfNodeOptions = "ElasticResizeNumberOfNodeOptions"
        case encrypted = "Encrypted"
        case endpoint = "Endpoint"
        case enhancedVpcRouting = "EnhancedVpcRouting"
        case expectedNextSnapshotScheduleTime = "ExpectedNextSnapshotScheduleTime"
        case expectedNextSnapshotScheduleTimeStatus = "ExpectedNextSnapshotScheduleTimeStatus"
        case hsmStatus = "HsmStatus"
        case iamRoles = "IamRoles"
        case kmsKeyId = "KmsKeyId"
        case maintenanceTrackName = "MaintenanceTrackName"
        case manualSnapshotRetentionPeriod = "ManualSnapshotRetentionPeriod"
        case masterUsername = "MasterUsername"
        case modifyStatus = "ModifyStatus"
        case nextMaintenanceWindowStartTime = "NextMaintenanceWindowStartTime"
        case nodeType = "NodeType"
        case numberOfNodes = "NumberOfNodes"
        case pendingActions = "PendingActions"
        case pendingModifiedValues = "PendingModifiedValues"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case publiclyAccessible = "PubliclyAccessible"
        case resizeInfo = "ResizeInfo"
        case restoreStatus = "RestoreStatus"
        case snapshotScheduleIdentifier = "SnapshotScheduleIdentifier"
        case snapshotScheduleState = "SnapshotScheduleState"
        case tags = "Tags"
        case totalStorageCapacityInMegaBytes = "TotalStorageCapacityInMegaBytes"
        case vpcId = "VpcId"
        case vpcSecurityGroups = "VpcSecurityGroups"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if allowVersionUpgrade != false {
            try container.encode(allowVersionUpgrade, forKey: ClientRuntime.Key("AllowVersionUpgrade"))
        }
        if let aquaConfiguration = aquaConfiguration {
            try container.encode(aquaConfiguration, forKey: ClientRuntime.Key("AquaConfiguration"))
        }
        if automatedSnapshotRetentionPeriod != 0 {
            try container.encode(automatedSnapshotRetentionPeriod, forKey: ClientRuntime.Key("AutomatedSnapshotRetentionPeriod"))
        }
        if let availabilityZone = availabilityZone {
            try container.encode(availabilityZone, forKey: ClientRuntime.Key("AvailabilityZone"))
        }
        if let availabilityZoneRelocationStatus = availabilityZoneRelocationStatus {
            try container.encode(availabilityZoneRelocationStatus, forKey: ClientRuntime.Key("AvailabilityZoneRelocationStatus"))
        }
        if let clusterAvailabilityStatus = clusterAvailabilityStatus {
            try container.encode(clusterAvailabilityStatus, forKey: ClientRuntime.Key("ClusterAvailabilityStatus"))
        }
        if let clusterCreateTime = clusterCreateTime {
            try container.encode(ClientRuntime.TimestampWrapper(clusterCreateTime, format: .dateTime), forKey: ClientRuntime.Key("clusterCreateTime"))
        }
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: ClientRuntime.Key("ClusterIdentifier"))
        }
        if let clusterNamespaceArn = clusterNamespaceArn {
            try container.encode(clusterNamespaceArn, forKey: ClientRuntime.Key("ClusterNamespaceArn"))
        }
        if let clusterNodes = clusterNodes {
            var clusterNodesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ClusterNodes"))
            for (index0, clusternode0) in clusterNodes.enumerated() {
                try clusterNodesContainer.encode(clusternode0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let clusterParameterGroups = clusterParameterGroups {
            var clusterParameterGroupsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ClusterParameterGroups"))
            for (index0, clusterparametergroupstatus0) in clusterParameterGroups.enumerated() {
                try clusterParameterGroupsContainer.encode(clusterparametergroupstatus0, forKey: ClientRuntime.Key("ClusterParameterGroup.\(index0.advanced(by: 1))"))
            }
        }
        if let clusterPublicKey = clusterPublicKey {
            try container.encode(clusterPublicKey, forKey: ClientRuntime.Key("ClusterPublicKey"))
        }
        if let clusterRevisionNumber = clusterRevisionNumber {
            try container.encode(clusterRevisionNumber, forKey: ClientRuntime.Key("ClusterRevisionNumber"))
        }
        if let clusterSecurityGroups = clusterSecurityGroups {
            var clusterSecurityGroupsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ClusterSecurityGroups"))
            for (index0, clustersecuritygroupmembership0) in clusterSecurityGroups.enumerated() {
                try clusterSecurityGroupsContainer.encode(clustersecuritygroupmembership0, forKey: ClientRuntime.Key("ClusterSecurityGroup.\(index0.advanced(by: 1))"))
            }
        }
        if let clusterSnapshotCopyStatus = clusterSnapshotCopyStatus {
            try container.encode(clusterSnapshotCopyStatus, forKey: ClientRuntime.Key("ClusterSnapshotCopyStatus"))
        }
        if let clusterStatus = clusterStatus {
            try container.encode(clusterStatus, forKey: ClientRuntime.Key("ClusterStatus"))
        }
        if let clusterSubnetGroupName = clusterSubnetGroupName {
            try container.encode(clusterSubnetGroupName, forKey: ClientRuntime.Key("ClusterSubnetGroupName"))
        }
        if let clusterVersion = clusterVersion {
            try container.encode(clusterVersion, forKey: ClientRuntime.Key("ClusterVersion"))
        }
        if let dBName = dBName {
            try container.encode(dBName, forKey: ClientRuntime.Key("DBName"))
        }
        if let dataTransferProgress = dataTransferProgress {
            try container.encode(dataTransferProgress, forKey: ClientRuntime.Key("DataTransferProgress"))
        }
        if let deferredMaintenanceWindows = deferredMaintenanceWindows {
            var deferredMaintenanceWindowsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DeferredMaintenanceWindows"))
            for (index0, deferredmaintenancewindow0) in deferredMaintenanceWindows.enumerated() {
                try deferredMaintenanceWindowsContainer.encode(deferredmaintenancewindow0, forKey: ClientRuntime.Key("DeferredMaintenanceWindow.\(index0.advanced(by: 1))"))
            }
        }
        if let elasticIpStatus = elasticIpStatus {
            try container.encode(elasticIpStatus, forKey: ClientRuntime.Key("ElasticIpStatus"))
        }
        if let elasticResizeNumberOfNodeOptions = elasticResizeNumberOfNodeOptions {
            try container.encode(elasticResizeNumberOfNodeOptions, forKey: ClientRuntime.Key("ElasticResizeNumberOfNodeOptions"))
        }
        if encrypted != false {
            try container.encode(encrypted, forKey: ClientRuntime.Key("Encrypted"))
        }
        if let endpoint = endpoint {
            try container.encode(endpoint, forKey: ClientRuntime.Key("Endpoint"))
        }
        if enhancedVpcRouting != false {
            try container.encode(enhancedVpcRouting, forKey: ClientRuntime.Key("EnhancedVpcRouting"))
        }
        if let expectedNextSnapshotScheduleTime = expectedNextSnapshotScheduleTime {
            try container.encode(ClientRuntime.TimestampWrapper(expectedNextSnapshotScheduleTime, format: .dateTime), forKey: ClientRuntime.Key("expectedNextSnapshotScheduleTime"))
        }
        if let expectedNextSnapshotScheduleTimeStatus = expectedNextSnapshotScheduleTimeStatus {
            try container.encode(expectedNextSnapshotScheduleTimeStatus, forKey: ClientRuntime.Key("ExpectedNextSnapshotScheduleTimeStatus"))
        }
        if let hsmStatus = hsmStatus {
            try container.encode(hsmStatus, forKey: ClientRuntime.Key("HsmStatus"))
        }
        if let iamRoles = iamRoles {
            var iamRolesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("IamRoles"))
            for (index0, clusteriamrole0) in iamRoles.enumerated() {
                try iamRolesContainer.encode(clusteriamrole0, forKey: ClientRuntime.Key("ClusterIamRole.\(index0.advanced(by: 1))"))
            }
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: ClientRuntime.Key("KmsKeyId"))
        }
        if let maintenanceTrackName = maintenanceTrackName {
            try container.encode(maintenanceTrackName, forKey: ClientRuntime.Key("MaintenanceTrackName"))
        }
        if manualSnapshotRetentionPeriod != 0 {
            try container.encode(manualSnapshotRetentionPeriod, forKey: ClientRuntime.Key("ManualSnapshotRetentionPeriod"))
        }
        if let masterUsername = masterUsername {
            try container.encode(masterUsername, forKey: ClientRuntime.Key("MasterUsername"))
        }
        if let modifyStatus = modifyStatus {
            try container.encode(modifyStatus, forKey: ClientRuntime.Key("ModifyStatus"))
        }
        if let nextMaintenanceWindowStartTime = nextMaintenanceWindowStartTime {
            try container.encode(ClientRuntime.TimestampWrapper(nextMaintenanceWindowStartTime, format: .dateTime), forKey: ClientRuntime.Key("nextMaintenanceWindowStartTime"))
        }
        if let nodeType = nodeType {
            try container.encode(nodeType, forKey: ClientRuntime.Key("NodeType"))
        }
        if numberOfNodes != 0 {
            try container.encode(numberOfNodes, forKey: ClientRuntime.Key("NumberOfNodes"))
        }
        if let pendingActions = pendingActions {
            var pendingActionsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PendingActions"))
            for (index0, string0) in pendingActions.enumerated() {
                try pendingActionsContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let pendingModifiedValues = pendingModifiedValues {
            try container.encode(pendingModifiedValues, forKey: ClientRuntime.Key("PendingModifiedValues"))
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try container.encode(preferredMaintenanceWindow, forKey: ClientRuntime.Key("PreferredMaintenanceWindow"))
        }
        if publiclyAccessible != false {
            try container.encode(publiclyAccessible, forKey: ClientRuntime.Key("PubliclyAccessible"))
        }
        if let resizeInfo = resizeInfo {
            try container.encode(resizeInfo, forKey: ClientRuntime.Key("ResizeInfo"))
        }
        if let restoreStatus = restoreStatus {
            try container.encode(restoreStatus, forKey: ClientRuntime.Key("RestoreStatus"))
        }
        if let snapshotScheduleIdentifier = snapshotScheduleIdentifier {
            try container.encode(snapshotScheduleIdentifier, forKey: ClientRuntime.Key("SnapshotScheduleIdentifier"))
        }
        if let snapshotScheduleState = snapshotScheduleState {
            try container.encode(snapshotScheduleState, forKey: ClientRuntime.Key("SnapshotScheduleState"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let totalStorageCapacityInMegaBytes = totalStorageCapacityInMegaBytes {
            try container.encode(totalStorageCapacityInMegaBytes, forKey: ClientRuntime.Key("TotalStorageCapacityInMegaBytes"))
        }
        if let vpcId = vpcId {
            try container.encode(vpcId, forKey: ClientRuntime.Key("VpcId"))
        }
        if let vpcSecurityGroups = vpcSecurityGroups {
            var vpcSecurityGroupsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSecurityGroups"))
            for (index0, vpcsecuritygroupmembership0) in vpcSecurityGroups.enumerated() {
                try vpcSecurityGroupsContainer.encode(vpcsecuritygroupmembership0, forKey: ClientRuntime.Key("VpcSecurityGroup.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let nodeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeType)
        nodeType = nodeTypeDecoded
        let clusterStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterStatus)
        clusterStatus = clusterStatusDecoded
        let clusterAvailabilityStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterAvailabilityStatus)
        clusterAvailabilityStatus = clusterAvailabilityStatusDecoded
        let modifyStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modifyStatus)
        modifyStatus = modifyStatusDecoded
        let masterUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterUsername)
        masterUsername = masterUsernameDecoded
        let dBNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBName)
        dBName = dBNameDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.Endpoint.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let clusterCreateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterCreateTime)
        var clusterCreateTimeBuffer:ClientRuntime.Date? = nil
        if let clusterCreateTimeDecoded = clusterCreateTimeDecoded {
            clusterCreateTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(clusterCreateTimeDecoded, format: .dateTime)
        }
        clusterCreateTime = clusterCreateTimeBuffer
        let automatedSnapshotRetentionPeriodDecoded = try containerValues.decode(Swift.Int.self, forKey: .automatedSnapshotRetentionPeriod)
        automatedSnapshotRetentionPeriod = automatedSnapshotRetentionPeriodDecoded
        let manualSnapshotRetentionPeriodDecoded = try containerValues.decode(Swift.Int.self, forKey: .manualSnapshotRetentionPeriod)
        manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriodDecoded
        if containerValues.contains(.clusterSecurityGroups) {
            struct KeyVal0{struct ClusterSecurityGroup{}}
            let clusterSecurityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ClusterSecurityGroup>.CodingKeys.self, forKey: .clusterSecurityGroups)
            if let clusterSecurityGroupsWrappedContainer = clusterSecurityGroupsWrappedContainer {
                let clusterSecurityGroupsContainer = try clusterSecurityGroupsWrappedContainer.decodeIfPresent([RedshiftClientTypes.ClusterSecurityGroupMembership].self, forKey: .member)
                var clusterSecurityGroupsBuffer:[RedshiftClientTypes.ClusterSecurityGroupMembership]? = nil
                if let clusterSecurityGroupsContainer = clusterSecurityGroupsContainer {
                    clusterSecurityGroupsBuffer = [RedshiftClientTypes.ClusterSecurityGroupMembership]()
                    for structureContainer0 in clusterSecurityGroupsContainer {
                        clusterSecurityGroupsBuffer?.append(structureContainer0)
                    }
                }
                clusterSecurityGroups = clusterSecurityGroupsBuffer
            } else {
                clusterSecurityGroups = []
            }
        } else {
            clusterSecurityGroups = nil
        }
        if containerValues.contains(.vpcSecurityGroups) {
            struct KeyVal0{struct VpcSecurityGroup{}}
            let vpcSecurityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.VpcSecurityGroup>.CodingKeys.self, forKey: .vpcSecurityGroups)
            if let vpcSecurityGroupsWrappedContainer = vpcSecurityGroupsWrappedContainer {
                let vpcSecurityGroupsContainer = try vpcSecurityGroupsWrappedContainer.decodeIfPresent([RedshiftClientTypes.VpcSecurityGroupMembership].self, forKey: .member)
                var vpcSecurityGroupsBuffer:[RedshiftClientTypes.VpcSecurityGroupMembership]? = nil
                if let vpcSecurityGroupsContainer = vpcSecurityGroupsContainer {
                    vpcSecurityGroupsBuffer = [RedshiftClientTypes.VpcSecurityGroupMembership]()
                    for structureContainer0 in vpcSecurityGroupsContainer {
                        vpcSecurityGroupsBuffer?.append(structureContainer0)
                    }
                }
                vpcSecurityGroups = vpcSecurityGroupsBuffer
            } else {
                vpcSecurityGroups = []
            }
        } else {
            vpcSecurityGroups = nil
        }
        if containerValues.contains(.clusterParameterGroups) {
            struct KeyVal0{struct ClusterParameterGroup{}}
            let clusterParameterGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ClusterParameterGroup>.CodingKeys.self, forKey: .clusterParameterGroups)
            if let clusterParameterGroupsWrappedContainer = clusterParameterGroupsWrappedContainer {
                let clusterParameterGroupsContainer = try clusterParameterGroupsWrappedContainer.decodeIfPresent([RedshiftClientTypes.ClusterParameterGroupStatus].self, forKey: .member)
                var clusterParameterGroupsBuffer:[RedshiftClientTypes.ClusterParameterGroupStatus]? = nil
                if let clusterParameterGroupsContainer = clusterParameterGroupsContainer {
                    clusterParameterGroupsBuffer = [RedshiftClientTypes.ClusterParameterGroupStatus]()
                    for structureContainer0 in clusterParameterGroupsContainer {
                        clusterParameterGroupsBuffer?.append(structureContainer0)
                    }
                }
                clusterParameterGroups = clusterParameterGroupsBuffer
            } else {
                clusterParameterGroups = []
            }
        } else {
            clusterParameterGroups = nil
        }
        let clusterSubnetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterSubnetGroupName)
        clusterSubnetGroupName = clusterSubnetGroupNameDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let pendingModifiedValuesDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.PendingModifiedValues.self, forKey: .pendingModifiedValues)
        pendingModifiedValues = pendingModifiedValuesDecoded
        let clusterVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterVersion)
        clusterVersion = clusterVersionDecoded
        let allowVersionUpgradeDecoded = try containerValues.decode(Swift.Bool.self, forKey: .allowVersionUpgrade)
        allowVersionUpgrade = allowVersionUpgradeDecoded
        let numberOfNodesDecoded = try containerValues.decode(Swift.Int.self, forKey: .numberOfNodes)
        numberOfNodes = numberOfNodesDecoded
        let publiclyAccessibleDecoded = try containerValues.decode(Swift.Bool.self, forKey: .publiclyAccessible)
        publiclyAccessible = publiclyAccessibleDecoded
        let encryptedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let restoreStatusDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.RestoreStatus.self, forKey: .restoreStatus)
        restoreStatus = restoreStatusDecoded
        let dataTransferProgressDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.DataTransferProgress.self, forKey: .dataTransferProgress)
        dataTransferProgress = dataTransferProgressDecoded
        let hsmStatusDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.HsmStatus.self, forKey: .hsmStatus)
        hsmStatus = hsmStatusDecoded
        let clusterSnapshotCopyStatusDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.ClusterSnapshotCopyStatus.self, forKey: .clusterSnapshotCopyStatus)
        clusterSnapshotCopyStatus = clusterSnapshotCopyStatusDecoded
        let clusterPublicKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterPublicKey)
        clusterPublicKey = clusterPublicKeyDecoded
        if containerValues.contains(.clusterNodes) {
            struct KeyVal0{struct member{}}
            let clusterNodesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .clusterNodes)
            if let clusterNodesWrappedContainer = clusterNodesWrappedContainer {
                let clusterNodesContainer = try clusterNodesWrappedContainer.decodeIfPresent([RedshiftClientTypes.ClusterNode].self, forKey: .member)
                var clusterNodesBuffer:[RedshiftClientTypes.ClusterNode]? = nil
                if let clusterNodesContainer = clusterNodesContainer {
                    clusterNodesBuffer = [RedshiftClientTypes.ClusterNode]()
                    for structureContainer0 in clusterNodesContainer {
                        clusterNodesBuffer?.append(structureContainer0)
                    }
                }
                clusterNodes = clusterNodesBuffer
            } else {
                clusterNodes = []
            }
        } else {
            clusterNodes = nil
        }
        let elasticIpStatusDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.ElasticIpStatus.self, forKey: .elasticIpStatus)
        elasticIpStatus = elasticIpStatusDecoded
        let clusterRevisionNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterRevisionNumber)
        clusterRevisionNumber = clusterRevisionNumberDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([RedshiftClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[RedshiftClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [RedshiftClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let enhancedVpcRoutingDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enhancedVpcRouting)
        enhancedVpcRouting = enhancedVpcRoutingDecoded
        if containerValues.contains(.iamRoles) {
            struct KeyVal0{struct ClusterIamRole{}}
            let iamRolesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ClusterIamRole>.CodingKeys.self, forKey: .iamRoles)
            if let iamRolesWrappedContainer = iamRolesWrappedContainer {
                let iamRolesContainer = try iamRolesWrappedContainer.decodeIfPresent([RedshiftClientTypes.ClusterIamRole].self, forKey: .member)
                var iamRolesBuffer:[RedshiftClientTypes.ClusterIamRole]? = nil
                if let iamRolesContainer = iamRolesContainer {
                    iamRolesBuffer = [RedshiftClientTypes.ClusterIamRole]()
                    for structureContainer0 in iamRolesContainer {
                        iamRolesBuffer?.append(structureContainer0)
                    }
                }
                iamRoles = iamRolesBuffer
            } else {
                iamRoles = []
            }
        } else {
            iamRoles = nil
        }
        if containerValues.contains(.pendingActions) {
            struct KeyVal0{struct member{}}
            let pendingActionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .pendingActions)
            if let pendingActionsWrappedContainer = pendingActionsWrappedContainer {
                let pendingActionsContainer = try pendingActionsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var pendingActionsBuffer:[Swift.String]? = nil
                if let pendingActionsContainer = pendingActionsContainer {
                    pendingActionsBuffer = [Swift.String]()
                    for stringContainer0 in pendingActionsContainer {
                        pendingActionsBuffer?.append(stringContainer0)
                    }
                }
                pendingActions = pendingActionsBuffer
            } else {
                pendingActions = []
            }
        } else {
            pendingActions = nil
        }
        let maintenanceTrackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maintenanceTrackName)
        maintenanceTrackName = maintenanceTrackNameDecoded
        let elasticResizeNumberOfNodeOptionsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .elasticResizeNumberOfNodeOptions)
        elasticResizeNumberOfNodeOptions = elasticResizeNumberOfNodeOptionsDecoded
        if containerValues.contains(.deferredMaintenanceWindows) {
            struct KeyVal0{struct DeferredMaintenanceWindow{}}
            let deferredMaintenanceWindowsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DeferredMaintenanceWindow>.CodingKeys.self, forKey: .deferredMaintenanceWindows)
            if let deferredMaintenanceWindowsWrappedContainer = deferredMaintenanceWindowsWrappedContainer {
                let deferredMaintenanceWindowsContainer = try deferredMaintenanceWindowsWrappedContainer.decodeIfPresent([RedshiftClientTypes.DeferredMaintenanceWindow].self, forKey: .member)
                var deferredMaintenanceWindowsBuffer:[RedshiftClientTypes.DeferredMaintenanceWindow]? = nil
                if let deferredMaintenanceWindowsContainer = deferredMaintenanceWindowsContainer {
                    deferredMaintenanceWindowsBuffer = [RedshiftClientTypes.DeferredMaintenanceWindow]()
                    for structureContainer0 in deferredMaintenanceWindowsContainer {
                        deferredMaintenanceWindowsBuffer?.append(structureContainer0)
                    }
                }
                deferredMaintenanceWindows = deferredMaintenanceWindowsBuffer
            } else {
                deferredMaintenanceWindows = []
            }
        } else {
            deferredMaintenanceWindows = nil
        }
        let snapshotScheduleIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotScheduleIdentifier)
        snapshotScheduleIdentifier = snapshotScheduleIdentifierDecoded
        let snapshotScheduleStateDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.ScheduleState.self, forKey: .snapshotScheduleState)
        snapshotScheduleState = snapshotScheduleStateDecoded
        let expectedNextSnapshotScheduleTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expectedNextSnapshotScheduleTime)
        var expectedNextSnapshotScheduleTimeBuffer:ClientRuntime.Date? = nil
        if let expectedNextSnapshotScheduleTimeDecoded = expectedNextSnapshotScheduleTimeDecoded {
            expectedNextSnapshotScheduleTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(expectedNextSnapshotScheduleTimeDecoded, format: .dateTime)
        }
        expectedNextSnapshotScheduleTime = expectedNextSnapshotScheduleTimeBuffer
        let expectedNextSnapshotScheduleTimeStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expectedNextSnapshotScheduleTimeStatus)
        expectedNextSnapshotScheduleTimeStatus = expectedNextSnapshotScheduleTimeStatusDecoded
        let nextMaintenanceWindowStartTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMaintenanceWindowStartTime)
        var nextMaintenanceWindowStartTimeBuffer:ClientRuntime.Date? = nil
        if let nextMaintenanceWindowStartTimeDecoded = nextMaintenanceWindowStartTimeDecoded {
            nextMaintenanceWindowStartTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(nextMaintenanceWindowStartTimeDecoded, format: .dateTime)
        }
        nextMaintenanceWindowStartTime = nextMaintenanceWindowStartTimeBuffer
        let resizeInfoDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.ResizeInfo.self, forKey: .resizeInfo)
        resizeInfo = resizeInfoDecoded
        let availabilityZoneRelocationStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZoneRelocationStatus)
        availabilityZoneRelocationStatus = availabilityZoneRelocationStatusDecoded
        let clusterNamespaceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterNamespaceArn)
        clusterNamespaceArn = clusterNamespaceArnDecoded
        let totalStorageCapacityInMegaBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalStorageCapacityInMegaBytes)
        totalStorageCapacityInMegaBytes = totalStorageCapacityInMegaBytesDecoded
        let aquaConfigurationDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.AquaConfiguration.self, forKey: .aquaConfiguration)
        aquaConfiguration = aquaConfigurationDecoded
    }
}

extension RedshiftClientTypes.Cluster: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Cluster(allowVersionUpgrade: \(Swift.String(describing: allowVersionUpgrade)), aquaConfiguration: \(Swift.String(describing: aquaConfiguration)), automatedSnapshotRetentionPeriod: \(Swift.String(describing: automatedSnapshotRetentionPeriod)), availabilityZone: \(Swift.String(describing: availabilityZone)), availabilityZoneRelocationStatus: \(Swift.String(describing: availabilityZoneRelocationStatus)), clusterAvailabilityStatus: \(Swift.String(describing: clusterAvailabilityStatus)), clusterCreateTime: \(Swift.String(describing: clusterCreateTime)), clusterIdentifier: \(Swift.String(describing: clusterIdentifier)), clusterNamespaceArn: \(Swift.String(describing: clusterNamespaceArn)), clusterNodes: \(Swift.String(describing: clusterNodes)), clusterParameterGroups: \(Swift.String(describing: clusterParameterGroups)), clusterPublicKey: \(Swift.String(describing: clusterPublicKey)), clusterRevisionNumber: \(Swift.String(describing: clusterRevisionNumber)), clusterSecurityGroups: \(Swift.String(describing: clusterSecurityGroups)), clusterSnapshotCopyStatus: \(Swift.String(describing: clusterSnapshotCopyStatus)), clusterStatus: \(Swift.String(describing: clusterStatus)), clusterSubnetGroupName: \(Swift.String(describing: clusterSubnetGroupName)), clusterVersion: \(Swift.String(describing: clusterVersion)), dBName: \(Swift.String(describing: dBName)), dataTransferProgress: \(Swift.String(describing: dataTransferProgress)), deferredMaintenanceWindows: \(Swift.String(describing: deferredMaintenanceWindows)), elasticIpStatus: \(Swift.String(describing: elasticIpStatus)), elasticResizeNumberOfNodeOptions: \(Swift.String(describing: elasticResizeNumberOfNodeOptions)), encrypted: \(Swift.String(describing: encrypted)), endpoint: \(Swift.String(describing: endpoint)), enhancedVpcRouting: \(Swift.String(describing: enhancedVpcRouting)), expectedNextSnapshotScheduleTime: \(Swift.String(describing: expectedNextSnapshotScheduleTime)), expectedNextSnapshotScheduleTimeStatus: \(Swift.String(describing: expectedNextSnapshotScheduleTimeStatus)), hsmStatus: \(Swift.String(describing: hsmStatus)), iamRoles: \(Swift.String(describing: iamRoles)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), maintenanceTrackName: \(Swift.String(describing: maintenanceTrackName)), manualSnapshotRetentionPeriod: \(Swift.String(describing: manualSnapshotRetentionPeriod)), masterUsername: \(Swift.String(describing: masterUsername)), modifyStatus: \(Swift.String(describing: modifyStatus)), nextMaintenanceWindowStartTime: \(Swift.String(describing: nextMaintenanceWindowStartTime)), nodeType: \(Swift.String(describing: nodeType)), numberOfNodes: \(Swift.String(describing: numberOfNodes)), pendingActions: \(Swift.String(describing: pendingActions)), pendingModifiedValues: \(Swift.String(describing: pendingModifiedValues)), preferredMaintenanceWindow: \(Swift.String(describing: preferredMaintenanceWindow)), publiclyAccessible: \(Swift.String(describing: publiclyAccessible)), resizeInfo: \(Swift.String(describing: resizeInfo)), restoreStatus: \(Swift.String(describing: restoreStatus)), snapshotScheduleIdentifier: \(Swift.String(describing: snapshotScheduleIdentifier)), snapshotScheduleState: \(Swift.String(describing: snapshotScheduleState)), tags: \(Swift.String(describing: tags)), totalStorageCapacityInMegaBytes: \(Swift.String(describing: totalStorageCapacityInMegaBytes)), vpcId: \(Swift.String(describing: vpcId)), vpcSecurityGroups: \(Swift.String(describing: vpcSecurityGroups)))"}
}

extension RedshiftClientTypes {
    /// <p>Describes a cluster.</p>
    public struct Cluster: Swift.Equatable {
        /// <p>A boolean value that, if <code>true</code>, indicates that major version upgrades
        ///             will be applied automatically to the cluster during the maintenance window. </p>
        public let allowVersionUpgrade: Swift.Bool
        /// <p>The AQUA (Advanced Query Accelerator) configuration of the cluster.</p>
        public let aquaConfiguration: RedshiftClientTypes.AquaConfiguration?
        /// <p>The number of days that automatic cluster snapshots are retained.</p>
        public let automatedSnapshotRetentionPeriod: Swift.Int
        /// <p>The name of the Availability Zone in which the cluster is located.</p>
        public let availabilityZone: Swift.String?
        /// <p>Describes the status of the Availability Zone relocation operation.</p>
        public let availabilityZoneRelocationStatus: Swift.String?
        /// <p>The availability status of the cluster for queries. Possible values are the following:</p>
        ///         <ul>
        ///             <li>
        ///                <p>Available - The cluster is available for queries. </p>
        ///             </li>
        ///             <li>
        ///                <p>Unavailable - The cluster is not available for queries.</p>
        ///             </li>
        ///             <li>
        ///                <p>Maintenance - The cluster is intermittently available for queries due to maintenance activities.</p>
        ///             </li>
        ///             <li>
        ///                <p>Modifying - The cluster is intermittently available for queries due to changes that modify the cluster.</p>
        ///             </li>
        ///             <li>
        ///                <p>Failed - The cluster failed and is not available for queries.</p>
        ///             </li>
        ///          </ul>
        public let clusterAvailabilityStatus: Swift.String?
        /// <p>The date and time that the cluster was created.</p>
        public let clusterCreateTime: ClientRuntime.Date?
        /// <p>The unique identifier of the cluster.</p>
        public let clusterIdentifier: Swift.String?
        /// <p>The namespace Amazon Resource Name (ARN) of the cluster.</p>
        public let clusterNamespaceArn: Swift.String?
        /// <p>The nodes in the cluster.</p>
        public let clusterNodes: [RedshiftClientTypes.ClusterNode]?
        /// <p>The list of cluster parameter groups that are associated with this cluster. Each
        ///             parameter group in the list is returned with its status.</p>
        public let clusterParameterGroups: [RedshiftClientTypes.ClusterParameterGroupStatus]?
        /// <p>The public key for the cluster.</p>
        public let clusterPublicKey: Swift.String?
        /// <p>The specific revision number of the database in the cluster.</p>
        public let clusterRevisionNumber: Swift.String?
        /// <p>A list of cluster security group that are associated with the cluster. Each
        ///             security group is represented by an element that contains
        ///                 <code>ClusterSecurityGroup.Name</code> and <code>ClusterSecurityGroup.Status</code>
        ///             subelements. </p>
        ///         <p>Cluster security groups are used when the cluster is not created in an Amazon
        ///             Virtual Private Cloud (VPC). Clusters that are created in a VPC use VPC security groups,
        ///             which are listed by the <b>VpcSecurityGroups</b> parameter.
        ///         </p>
        public let clusterSecurityGroups: [RedshiftClientTypes.ClusterSecurityGroupMembership]?
        /// <p>A value that returns the destination region and retention period that are
        ///             configured for cross-region snapshot copy.</p>
        public let clusterSnapshotCopyStatus: RedshiftClientTypes.ClusterSnapshotCopyStatus?
        /// <p> The current state of the cluster. Possible values are the following:</p>
        ///         <ul>
        ///             <li>
        ///                 <p>
        ///                     <code>available</code>
        ///                 </p>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                     <code>available, prep-for-resize</code>
        ///                 </p>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                     <code>available, resize-cleanup</code>
        ///                 </p>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                     <code>cancelling-resize</code>
        ///                 </p>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                     <code>creating</code>
        ///                 </p>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                     <code>deleting</code>
        ///                 </p>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                     <code>final-snapshot</code>
        ///                 </p>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                     <code>hardware-failure</code>
        ///                 </p>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                     <code>incompatible-hsm</code>
        ///                 </p>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                     <code>incompatible-network</code>
        ///                 </p>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                     <code>incompatible-parameters</code>
        ///                 </p>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                     <code>incompatible-restore</code>
        ///                 </p>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                     <code>modifying</code>
        ///                 </p>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                     <code>paused</code>
        ///                 </p>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                     <code>rebooting</code>
        ///                 </p>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                     <code>renaming</code>
        ///                 </p>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                     <code>resizing</code>
        ///                 </p>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                     <code>rotating-keys</code>
        ///                 </p>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                     <code>storage-full</code>
        ///                 </p>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                     <code>updating-hsm</code>
        ///                 </p>
        ///             </li>
        ///          </ul>
        public let clusterStatus: Swift.String?
        /// <p>The name of the subnet group that is associated with the cluster. This parameter is
        ///             valid only when the cluster is in a VPC.</p>
        public let clusterSubnetGroupName: Swift.String?
        /// <p>The version ID of the Amazon Redshift engine that is running on the cluster.</p>
        public let clusterVersion: Swift.String?
        /// <p>The name of the initial database that was created when the cluster was created.
        ///             This same name is returned for the life of the cluster. If an initial database was not
        ///             specified, a database named <code>dev</code>dev was created by default. </p>
        public let dBName: Swift.String?
        /// <p></p>
        public let dataTransferProgress: RedshiftClientTypes.DataTransferProgress?
        /// <p>Describes a group of <code>DeferredMaintenanceWindow</code> objects.</p>
        public let deferredMaintenanceWindows: [RedshiftClientTypes.DeferredMaintenanceWindow]?
        /// <p>The status of the elastic IP (EIP) address.</p>
        public let elasticIpStatus: RedshiftClientTypes.ElasticIpStatus?
        /// <p>The number of nodes that you can resize the cluster to with the elastic resize method.
        ///         </p>
        public let elasticResizeNumberOfNodeOptions: Swift.String?
        /// <p>A boolean value that, if <code>true</code>, indicates that data in the cluster is
        ///             encrypted at rest.</p>
        public let encrypted: Swift.Bool
        /// <p>The connection endpoint.</p>
        public let endpoint: RedshiftClientTypes.Endpoint?
        /// <p>An option that specifies whether to create the cluster with enhanced VPC routing
        ///             enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a
        ///             VPC. For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in
        ///             the Amazon Redshift Cluster Management Guide.</p>
        ///         <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p>
        ///         <p>Default: false</p>
        public let enhancedVpcRouting: Swift.Bool
        /// <p>The date and time when the next snapshot is expected to be taken for clusters with a valid snapshot schedule and backups enabled. </p>
        public let expectedNextSnapshotScheduleTime: ClientRuntime.Date?
        /// <p> The status of next expected snapshot for clusters having a valid snapshot schedule and backups enabled.  Possible values are the following:</p>
        ///         <ul>
        ///             <li>
        ///                <p>OnTrack - The next snapshot is expected to be taken on time. </p>
        ///             </li>
        ///             <li>
        ///                <p>Pending - The next snapshot is pending to be taken. </p>
        ///             </li>
        ///          </ul>
        public let expectedNextSnapshotScheduleTimeStatus: Swift.String?
        /// <p>A value that reports whether the Amazon Redshift cluster has finished applying any
        ///             hardware security module (HSM) settings changes specified in a modify cluster
        ///             command.</p>
        ///         <p>Values: active, applying</p>
        public let hsmStatus: RedshiftClientTypes.HsmStatus?
        /// <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the
        ///             cluster to access other AWS services.</p>
        public let iamRoles: [RedshiftClientTypes.ClusterIamRole]?
        /// <p>The AWS Key Management Service (AWS KMS) key ID of the encryption key used to
        ///             encrypt data in the cluster.</p>
        public let kmsKeyId: Swift.String?
        /// <p>The name of the maintenance track for the cluster.</p>
        public let maintenanceTrackName: Swift.String?
        /// <p>The default number of days to retain a manual snapshot. If the value is -1, the
        ///             snapshot is retained indefinitely. This setting doesn't change the retention period
        ///             of existing snapshots.</p>
        ///         <p>The value must be either -1 or an integer between 1 and 3,653.</p>
        public let manualSnapshotRetentionPeriod: Swift.Int
        /// <p>The master user name for the cluster. This name is used to connect to the database
        ///             that is specified in the <b>DBName</b> parameter. </p>
        public let masterUsername: Swift.String?
        /// <p>The status of a modify operation, if any, initiated for the cluster.</p>
        public let modifyStatus: Swift.String?
        /// <p>The date and time in UTC when system maintenance can begin.</p>
        public let nextMaintenanceWindowStartTime: ClientRuntime.Date?
        /// <p>The node type for the nodes in the cluster.</p>
        public let nodeType: Swift.String?
        /// <p>The number of compute nodes in the cluster.</p>
        public let numberOfNodes: Swift.Int
        /// <p>Cluster operations that are waiting to be started.</p>
        public let pendingActions: [Swift.String]?
        /// <p>A value that, if present, indicates that changes to the cluster are pending.
        ///             Specific pending changes are identified by subelements.</p>
        public let pendingModifiedValues: RedshiftClientTypes.PendingModifiedValues?
        /// <p>The weekly time range, in Universal Coordinated Time (UTC), during which system
        ///             maintenance can occur.</p>
        public let preferredMaintenanceWindow: Swift.String?
        /// <p>A boolean value that, if <code>true</code>, indicates that the cluster can be
        ///             accessed from a public network.</p>
        public let publiclyAccessible: Swift.Bool
        /// <p>Returns the following:</p>
        ///         <ul>
        ///             <li>
        ///                 <p>AllowCancelResize: a boolean value indicating if the resize operation can be
        ///                     cancelled.</p>
        ///             </li>
        ///             <li>
        ///                 <p>ResizeType: Returns ClassicResize</p>
        ///             </li>
        ///          </ul>
        public let resizeInfo: RedshiftClientTypes.ResizeInfo?
        /// <p>A value that describes the status of a cluster restore action. This parameter
        ///             returns null if the cluster was not created by restoring a snapshot.</p>
        public let restoreStatus: RedshiftClientTypes.RestoreStatus?
        /// <p>A unique identifier for the cluster snapshot schedule.</p>
        public let snapshotScheduleIdentifier: Swift.String?
        /// <p>The current state of the cluster snapshot schedule.</p>
        public let snapshotScheduleState: RedshiftClientTypes.ScheduleState?
        /// <p>The list of tags for the cluster.</p>
        public let tags: [RedshiftClientTypes.Tag]?
        /// <p>The total storage capacity of the cluster in megabytes. </p>
        public let totalStorageCapacityInMegaBytes: Swift.Int?
        /// <p>The identifier of the VPC the cluster is in, if the cluster is in a VPC.</p>
        public let vpcId: Swift.String?
        /// <p>A list of Amazon Virtual Private Cloud (Amazon VPC) security groups that are
        ///             associated with the cluster. This parameter is returned only if the cluster is in a
        ///             VPC.</p>
        public let vpcSecurityGroups: [RedshiftClientTypes.VpcSecurityGroupMembership]?

        public init (
            allowVersionUpgrade: Swift.Bool = false,
            aquaConfiguration: RedshiftClientTypes.AquaConfiguration? = nil,
            automatedSnapshotRetentionPeriod: Swift.Int = 0,
            availabilityZone: Swift.String? = nil,
            availabilityZoneRelocationStatus: Swift.String? = nil,
            clusterAvailabilityStatus: Swift.String? = nil,
            clusterCreateTime: ClientRuntime.Date? = nil,
            clusterIdentifier: Swift.String? = nil,
            clusterNamespaceArn: Swift.String? = nil,
            clusterNodes: [RedshiftClientTypes.ClusterNode]? = nil,
            clusterParameterGroups: [RedshiftClientTypes.ClusterParameterGroupStatus]? = nil,
            clusterPublicKey: Swift.String? = nil,
            clusterRevisionNumber: Swift.String? = nil,
            clusterSecurityGroups: [RedshiftClientTypes.ClusterSecurityGroupMembership]? = nil,
            clusterSnapshotCopyStatus: RedshiftClientTypes.ClusterSnapshotCopyStatus? = nil,
            clusterStatus: Swift.String? = nil,
            clusterSubnetGroupName: Swift.String? = nil,
            clusterVersion: Swift.String? = nil,
            dBName: Swift.String? = nil,
            dataTransferProgress: RedshiftClientTypes.DataTransferProgress? = nil,
            deferredMaintenanceWindows: [RedshiftClientTypes.DeferredMaintenanceWindow]? = nil,
            elasticIpStatus: RedshiftClientTypes.ElasticIpStatus? = nil,
            elasticResizeNumberOfNodeOptions: Swift.String? = nil,
            encrypted: Swift.Bool = false,
            endpoint: RedshiftClientTypes.Endpoint? = nil,
            enhancedVpcRouting: Swift.Bool = false,
            expectedNextSnapshotScheduleTime: ClientRuntime.Date? = nil,
            expectedNextSnapshotScheduleTimeStatus: Swift.String? = nil,
            hsmStatus: RedshiftClientTypes.HsmStatus? = nil,
            iamRoles: [RedshiftClientTypes.ClusterIamRole]? = nil,
            kmsKeyId: Swift.String? = nil,
            maintenanceTrackName: Swift.String? = nil,
            manualSnapshotRetentionPeriod: Swift.Int = 0,
            masterUsername: Swift.String? = nil,
            modifyStatus: Swift.String? = nil,
            nextMaintenanceWindowStartTime: ClientRuntime.Date? = nil,
            nodeType: Swift.String? = nil,
            numberOfNodes: Swift.Int = 0,
            pendingActions: [Swift.String]? = nil,
            pendingModifiedValues: RedshiftClientTypes.PendingModifiedValues? = nil,
            preferredMaintenanceWindow: Swift.String? = nil,
            publiclyAccessible: Swift.Bool = false,
            resizeInfo: RedshiftClientTypes.ResizeInfo? = nil,
            restoreStatus: RedshiftClientTypes.RestoreStatus? = nil,
            snapshotScheduleIdentifier: Swift.String? = nil,
            snapshotScheduleState: RedshiftClientTypes.ScheduleState? = nil,
            tags: [RedshiftClientTypes.Tag]? = nil,
            totalStorageCapacityInMegaBytes: Swift.Int? = nil,
            vpcId: Swift.String? = nil,
            vpcSecurityGroups: [RedshiftClientTypes.VpcSecurityGroupMembership]? = nil
        )
        {
            self.allowVersionUpgrade = allowVersionUpgrade
            self.aquaConfiguration = aquaConfiguration
            self.automatedSnapshotRetentionPeriod = automatedSnapshotRetentionPeriod
            self.availabilityZone = availabilityZone
            self.availabilityZoneRelocationStatus = availabilityZoneRelocationStatus
            self.clusterAvailabilityStatus = clusterAvailabilityStatus
            self.clusterCreateTime = clusterCreateTime
            self.clusterIdentifier = clusterIdentifier
            self.clusterNamespaceArn = clusterNamespaceArn
            self.clusterNodes = clusterNodes
            self.clusterParameterGroups = clusterParameterGroups
            self.clusterPublicKey = clusterPublicKey
            self.clusterRevisionNumber = clusterRevisionNumber
            self.clusterSecurityGroups = clusterSecurityGroups
            self.clusterSnapshotCopyStatus = clusterSnapshotCopyStatus
            self.clusterStatus = clusterStatus
            self.clusterSubnetGroupName = clusterSubnetGroupName
            self.clusterVersion = clusterVersion
            self.dBName = dBName
            self.dataTransferProgress = dataTransferProgress
            self.deferredMaintenanceWindows = deferredMaintenanceWindows
            self.elasticIpStatus = elasticIpStatus
            self.elasticResizeNumberOfNodeOptions = elasticResizeNumberOfNodeOptions
            self.encrypted = encrypted
            self.endpoint = endpoint
            self.enhancedVpcRouting = enhancedVpcRouting
            self.expectedNextSnapshotScheduleTime = expectedNextSnapshotScheduleTime
            self.expectedNextSnapshotScheduleTimeStatus = expectedNextSnapshotScheduleTimeStatus
            self.hsmStatus = hsmStatus
            self.iamRoles = iamRoles
            self.kmsKeyId = kmsKeyId
            self.maintenanceTrackName = maintenanceTrackName
            self.manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriod
            self.masterUsername = masterUsername
            self.modifyStatus = modifyStatus
            self.nextMaintenanceWindowStartTime = nextMaintenanceWindowStartTime
            self.nodeType = nodeType
            self.numberOfNodes = numberOfNodes
            self.pendingActions = pendingActions
            self.pendingModifiedValues = pendingModifiedValues
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.publiclyAccessible = publiclyAccessible
            self.resizeInfo = resizeInfo
            self.restoreStatus = restoreStatus
            self.snapshotScheduleIdentifier = snapshotScheduleIdentifier
            self.snapshotScheduleState = snapshotScheduleState
            self.tags = tags
            self.totalStorageCapacityInMegaBytes = totalStorageCapacityInMegaBytes
            self.vpcId = vpcId
            self.vpcSecurityGroups = vpcSecurityGroups
        }
    }

}

extension ClusterAlreadyExistsFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ClusterAlreadyExistsFault(message: \(Swift.String(describing: message)))"}
}

extension ClusterAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<ClusterAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The account already has a cluster with the given identifier.</p>
public struct ClusterAlreadyExistsFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ClusterAlreadyExistsFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ClusterAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RedshiftClientTypes.ClusterAssociatedToSchedule: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterIdentifier = "ClusterIdentifier"
        case scheduleAssociationState = "ScheduleAssociationState"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: ClientRuntime.Key("ClusterIdentifier"))
        }
        if let scheduleAssociationState = scheduleAssociationState {
            try container.encode(scheduleAssociationState, forKey: ClientRuntime.Key("ScheduleAssociationState"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let scheduleAssociationStateDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.ScheduleState.self, forKey: .scheduleAssociationState)
        scheduleAssociationState = scheduleAssociationStateDecoded
    }
}

extension RedshiftClientTypes.ClusterAssociatedToSchedule: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ClusterAssociatedToSchedule(clusterIdentifier: \(Swift.String(describing: clusterIdentifier)), scheduleAssociationState: \(Swift.String(describing: scheduleAssociationState)))"}
}

extension RedshiftClientTypes {
    /// <p></p>
    public struct ClusterAssociatedToSchedule: Swift.Equatable {
        /// <p></p>
        public let clusterIdentifier: Swift.String?
        /// <p></p>
        public let scheduleAssociationState: RedshiftClientTypes.ScheduleState?

        public init (
            clusterIdentifier: Swift.String? = nil,
            scheduleAssociationState: RedshiftClientTypes.ScheduleState? = nil
        )
        {
            self.clusterIdentifier = clusterIdentifier
            self.scheduleAssociationState = scheduleAssociationState
        }
    }

}

extension RedshiftClientTypes.ClusterDbRevision: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterIdentifier = "ClusterIdentifier"
        case currentDatabaseRevision = "CurrentDatabaseRevision"
        case databaseRevisionReleaseDate = "DatabaseRevisionReleaseDate"
        case revisionTargets = "RevisionTargets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: ClientRuntime.Key("ClusterIdentifier"))
        }
        if let currentDatabaseRevision = currentDatabaseRevision {
            try container.encode(currentDatabaseRevision, forKey: ClientRuntime.Key("CurrentDatabaseRevision"))
        }
        if let databaseRevisionReleaseDate = databaseRevisionReleaseDate {
            try container.encode(ClientRuntime.TimestampWrapper(databaseRevisionReleaseDate, format: .dateTime), forKey: ClientRuntime.Key("databaseRevisionReleaseDate"))
        }
        if let revisionTargets = revisionTargets {
            var revisionTargetsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("RevisionTargets"))
            for (index0, revisiontarget0) in revisionTargets.enumerated() {
                try revisionTargetsContainer.encode(revisiontarget0, forKey: ClientRuntime.Key("RevisionTarget.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let currentDatabaseRevisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentDatabaseRevision)
        currentDatabaseRevision = currentDatabaseRevisionDecoded
        let databaseRevisionReleaseDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseRevisionReleaseDate)
        var databaseRevisionReleaseDateBuffer:ClientRuntime.Date? = nil
        if let databaseRevisionReleaseDateDecoded = databaseRevisionReleaseDateDecoded {
            databaseRevisionReleaseDateBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(databaseRevisionReleaseDateDecoded, format: .dateTime)
        }
        databaseRevisionReleaseDate = databaseRevisionReleaseDateBuffer
        if containerValues.contains(.revisionTargets) {
            struct KeyVal0{struct RevisionTarget{}}
            let revisionTargetsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.RevisionTarget>.CodingKeys.self, forKey: .revisionTargets)
            if let revisionTargetsWrappedContainer = revisionTargetsWrappedContainer {
                let revisionTargetsContainer = try revisionTargetsWrappedContainer.decodeIfPresent([RedshiftClientTypes.RevisionTarget].self, forKey: .member)
                var revisionTargetsBuffer:[RedshiftClientTypes.RevisionTarget]? = nil
                if let revisionTargetsContainer = revisionTargetsContainer {
                    revisionTargetsBuffer = [RedshiftClientTypes.RevisionTarget]()
                    for structureContainer0 in revisionTargetsContainer {
                        revisionTargetsBuffer?.append(structureContainer0)
                    }
                }
                revisionTargets = revisionTargetsBuffer
            } else {
                revisionTargets = []
            }
        } else {
            revisionTargets = nil
        }
    }
}

extension RedshiftClientTypes.ClusterDbRevision: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ClusterDbRevision(clusterIdentifier: \(Swift.String(describing: clusterIdentifier)), currentDatabaseRevision: \(Swift.String(describing: currentDatabaseRevision)), databaseRevisionReleaseDate: \(Swift.String(describing: databaseRevisionReleaseDate)), revisionTargets: \(Swift.String(describing: revisionTargets)))"}
}

extension RedshiftClientTypes {
    /// <p>Describes a <code>ClusterDbRevision</code>.</p>
    public struct ClusterDbRevision: Swift.Equatable {
        /// <p>The unique identifier of the cluster.</p>
        public let clusterIdentifier: Swift.String?
        /// <p>A string representing the current cluster version.</p>
        public let currentDatabaseRevision: Swift.String?
        /// <p>The date on which the database revision was released.</p>
        public let databaseRevisionReleaseDate: ClientRuntime.Date?
        /// <p>A list of <code>RevisionTarget</code> objects, where each object describes the
        ///             database revision that a cluster can be updated to.</p>
        public let revisionTargets: [RedshiftClientTypes.RevisionTarget]?

        public init (
            clusterIdentifier: Swift.String? = nil,
            currentDatabaseRevision: Swift.String? = nil,
            databaseRevisionReleaseDate: ClientRuntime.Date? = nil,
            revisionTargets: [RedshiftClientTypes.RevisionTarget]? = nil
        )
        {
            self.clusterIdentifier = clusterIdentifier
            self.currentDatabaseRevision = currentDatabaseRevision
            self.databaseRevisionReleaseDate = databaseRevisionReleaseDate
            self.revisionTargets = revisionTargets
        }
    }

}

extension RedshiftClientTypes.ClusterIamRole: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applyStatus = "ApplyStatus"
        case iamRoleArn = "IamRoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let applyStatus = applyStatus {
            try container.encode(applyStatus, forKey: ClientRuntime.Key("ApplyStatus"))
        }
        if let iamRoleArn = iamRoleArn {
            try container.encode(iamRoleArn, forKey: ClientRuntime.Key("IamRoleArn"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let applyStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applyStatus)
        applyStatus = applyStatusDecoded
    }
}

extension RedshiftClientTypes.ClusterIamRole: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ClusterIamRole(applyStatus: \(Swift.String(describing: applyStatus)), iamRoleArn: \(Swift.String(describing: iamRoleArn)))"}
}

extension RedshiftClientTypes {
    /// <p>An AWS Identity and Access Management (IAM) role that can be used by the associated
    ///             Amazon Redshift cluster to access other AWS services.</p>
    public struct ClusterIamRole: Swift.Equatable {
        /// <p>A value that describes the status of the IAM role's association with an Amazon
        ///             Redshift cluster.</p>
        ///         <p>The following are possible statuses and descriptions.</p>
        ///         <ul>
        ///             <li>
        ///                 <p>
        ///                     <code>in-sync</code>: The role is available for use by the cluster.</p>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                     <code>adding</code>: The role is in the process of being associated with the
        ///                     cluster.</p>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                     <code>removing</code>: The role is in the process of being disassociated with
        ///                     the cluster.</p>
        ///             </li>
        ///          </ul>
        public let applyStatus: Swift.String?
        /// <p>The Amazon Resource Name (ARN) of the IAM role, for example,
        ///                 <code>arn:aws:iam::123456789012:role/RedshiftCopyUnload</code>. </p>
        public let iamRoleArn: Swift.String?

        public init (
            applyStatus: Swift.String? = nil,
            iamRoleArn: Swift.String? = nil
        )
        {
            self.applyStatus = applyStatus
            self.iamRoleArn = iamRoleArn
        }
    }

}

extension RedshiftClientTypes.ClusterNode: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nodeRole = "NodeRole"
        case privateIPAddress = "PrivateIPAddress"
        case publicIPAddress = "PublicIPAddress"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let nodeRole = nodeRole {
            try container.encode(nodeRole, forKey: ClientRuntime.Key("NodeRole"))
        }
        if let privateIPAddress = privateIPAddress {
            try container.encode(privateIPAddress, forKey: ClientRuntime.Key("PrivateIPAddress"))
        }
        if let publicIPAddress = publicIPAddress {
            try container.encode(publicIPAddress, forKey: ClientRuntime.Key("PublicIPAddress"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nodeRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeRole)
        nodeRole = nodeRoleDecoded
        let privateIPAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateIPAddress)
        privateIPAddress = privateIPAddressDecoded
        let publicIPAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publicIPAddress)
        publicIPAddress = publicIPAddressDecoded
    }
}

extension RedshiftClientTypes.ClusterNode: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ClusterNode(nodeRole: \(Swift.String(describing: nodeRole)), privateIPAddress: \(Swift.String(describing: privateIPAddress)), publicIPAddress: \(Swift.String(describing: publicIPAddress)))"}
}

extension RedshiftClientTypes {
    /// <p>The identifier of a node in a cluster.</p>
    public struct ClusterNode: Swift.Equatable {
        /// <p>Whether the node is a leader node or a compute node.</p>
        public let nodeRole: Swift.String?
        /// <p>The private IP address of a node within a cluster.</p>
        public let privateIPAddress: Swift.String?
        /// <p>The public IP address of a node within a cluster.</p>
        public let publicIPAddress: Swift.String?

        public init (
            nodeRole: Swift.String? = nil,
            privateIPAddress: Swift.String? = nil,
            publicIPAddress: Swift.String? = nil
        )
        {
            self.nodeRole = nodeRole
            self.privateIPAddress = privateIPAddress
            self.publicIPAddress = publicIPAddress
        }
    }

}

extension ClusterNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ClusterNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension ClusterNotFoundFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<ClusterNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The <code>ClusterIdentifier</code> parameter does not refer to an existing cluster.
///         </p>
public struct ClusterNotFoundFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ClusterNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ClusterNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ClusterOnLatestRevisionFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ClusterOnLatestRevisionFault(message: \(Swift.String(describing: message)))"}
}

extension ClusterOnLatestRevisionFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<ClusterOnLatestRevisionFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Cluster is already on the latest database revision.</p>
public struct ClusterOnLatestRevisionFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ClusterOnLatestRevisionFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ClusterOnLatestRevisionFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RedshiftClientTypes.ClusterParameterGroup: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case parameterGroupFamily = "ParameterGroupFamily"
        case parameterGroupName = "ParameterGroupName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let parameterGroupFamily = parameterGroupFamily {
            try container.encode(parameterGroupFamily, forKey: ClientRuntime.Key("ParameterGroupFamily"))
        }
        if let parameterGroupName = parameterGroupName {
            try container.encode(parameterGroupName, forKey: ClientRuntime.Key("ParameterGroupName"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterGroupName)
        parameterGroupName = parameterGroupNameDecoded
        let parameterGroupFamilyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterGroupFamily)
        parameterGroupFamily = parameterGroupFamilyDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([RedshiftClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[RedshiftClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [RedshiftClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension RedshiftClientTypes.ClusterParameterGroup: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ClusterParameterGroup(description: \(Swift.String(describing: description)), parameterGroupFamily: \(Swift.String(describing: parameterGroupFamily)), parameterGroupName: \(Swift.String(describing: parameterGroupName)), tags: \(Swift.String(describing: tags)))"}
}

extension RedshiftClientTypes {
    /// <p>Describes a parameter group.</p>
    public struct ClusterParameterGroup: Swift.Equatable {
        /// <p>The description of the parameter group.</p>
        public let description: Swift.String?
        /// <p>The name of the cluster parameter group family that this cluster parameter group is
        ///             compatible with.</p>
        public let parameterGroupFamily: Swift.String?
        /// <p>The name of the cluster parameter group.</p>
        public let parameterGroupName: Swift.String?
        /// <p>The list of tags for the cluster parameter group.</p>
        public let tags: [RedshiftClientTypes.Tag]?

        public init (
            description: Swift.String? = nil,
            parameterGroupFamily: Swift.String? = nil,
            parameterGroupName: Swift.String? = nil,
            tags: [RedshiftClientTypes.Tag]? = nil
        )
        {
            self.description = description
            self.parameterGroupFamily = parameterGroupFamily
            self.parameterGroupName = parameterGroupName
            self.tags = tags
        }
    }

}

extension ClusterParameterGroupAlreadyExistsFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ClusterParameterGroupAlreadyExistsFault(message: \(Swift.String(describing: message)))"}
}

extension ClusterParameterGroupAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<ClusterParameterGroupAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A cluster parameter group with the same name already exists.</p>
public struct ClusterParameterGroupAlreadyExistsFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ClusterParameterGroupAlreadyExistsFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ClusterParameterGroupAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ClusterParameterGroupNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ClusterParameterGroupNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension ClusterParameterGroupNotFoundFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<ClusterParameterGroupNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The parameter group name does not refer to an existing parameter group.</p>
public struct ClusterParameterGroupNotFoundFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ClusterParameterGroupNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ClusterParameterGroupNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ClusterParameterGroupQuotaExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ClusterParameterGroupQuotaExceededFault(message: \(Swift.String(describing: message)))"}
}

extension ClusterParameterGroupQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<ClusterParameterGroupQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request would result in the user exceeding the allowed number of cluster
///             parameter groups.
/// For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a>
/// in the <i>Amazon Redshift Cluster Management Guide</i>.
/// </p>
public struct ClusterParameterGroupQuotaExceededFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ClusterParameterGroupQuotaExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ClusterParameterGroupQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RedshiftClientTypes.ClusterParameterGroupStatus: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterParameterStatusList = "ClusterParameterStatusList"
        case parameterApplyStatus = "ParameterApplyStatus"
        case parameterGroupName = "ParameterGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let clusterParameterStatusList = clusterParameterStatusList {
            var clusterParameterStatusListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ClusterParameterStatusList"))
            for (index0, clusterparameterstatus0) in clusterParameterStatusList.enumerated() {
                try clusterParameterStatusListContainer.encode(clusterparameterstatus0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let parameterApplyStatus = parameterApplyStatus {
            try container.encode(parameterApplyStatus, forKey: ClientRuntime.Key("ParameterApplyStatus"))
        }
        if let parameterGroupName = parameterGroupName {
            try container.encode(parameterGroupName, forKey: ClientRuntime.Key("ParameterGroupName"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterGroupName)
        parameterGroupName = parameterGroupNameDecoded
        let parameterApplyStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterApplyStatus)
        parameterApplyStatus = parameterApplyStatusDecoded
        if containerValues.contains(.clusterParameterStatusList) {
            struct KeyVal0{struct member{}}
            let clusterParameterStatusListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .clusterParameterStatusList)
            if let clusterParameterStatusListWrappedContainer = clusterParameterStatusListWrappedContainer {
                let clusterParameterStatusListContainer = try clusterParameterStatusListWrappedContainer.decodeIfPresent([RedshiftClientTypes.ClusterParameterStatus].self, forKey: .member)
                var clusterParameterStatusListBuffer:[RedshiftClientTypes.ClusterParameterStatus]? = nil
                if let clusterParameterStatusListContainer = clusterParameterStatusListContainer {
                    clusterParameterStatusListBuffer = [RedshiftClientTypes.ClusterParameterStatus]()
                    for structureContainer0 in clusterParameterStatusListContainer {
                        clusterParameterStatusListBuffer?.append(structureContainer0)
                    }
                }
                clusterParameterStatusList = clusterParameterStatusListBuffer
            } else {
                clusterParameterStatusList = []
            }
        } else {
            clusterParameterStatusList = nil
        }
    }
}

extension RedshiftClientTypes.ClusterParameterGroupStatus: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ClusterParameterGroupStatus(clusterParameterStatusList: \(Swift.String(describing: clusterParameterStatusList)), parameterApplyStatus: \(Swift.String(describing: parameterApplyStatus)), parameterGroupName: \(Swift.String(describing: parameterGroupName)))"}
}

extension RedshiftClientTypes {
    /// <p>Describes the status of a parameter group.</p>
    public struct ClusterParameterGroupStatus: Swift.Equatable {
        /// <p>The list of parameter statuses.</p>
        ///         <p>
        /// For more information about parameters and parameter groups, go to
        /// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a>
        /// in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
        public let clusterParameterStatusList: [RedshiftClientTypes.ClusterParameterStatus]?
        /// <p>The status of parameter updates.</p>
        public let parameterApplyStatus: Swift.String?
        /// <p>The name of the cluster parameter group.</p>
        public let parameterGroupName: Swift.String?

        public init (
            clusterParameterStatusList: [RedshiftClientTypes.ClusterParameterStatus]? = nil,
            parameterApplyStatus: Swift.String? = nil,
            parameterGroupName: Swift.String? = nil
        )
        {
            self.clusterParameterStatusList = clusterParameterStatusList
            self.parameterApplyStatus = parameterApplyStatus
            self.parameterGroupName = parameterGroupName
        }
    }

}

extension RedshiftClientTypes.ClusterParameterStatus: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterApplyErrorDescription = "ParameterApplyErrorDescription"
        case parameterApplyStatus = "ParameterApplyStatus"
        case parameterName = "ParameterName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let parameterApplyErrorDescription = parameterApplyErrorDescription {
            try container.encode(parameterApplyErrorDescription, forKey: ClientRuntime.Key("ParameterApplyErrorDescription"))
        }
        if let parameterApplyStatus = parameterApplyStatus {
            try container.encode(parameterApplyStatus, forKey: ClientRuntime.Key("ParameterApplyStatus"))
        }
        if let parameterName = parameterName {
            try container.encode(parameterName, forKey: ClientRuntime.Key("ParameterName"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterName)
        parameterName = parameterNameDecoded
        let parameterApplyStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterApplyStatus)
        parameterApplyStatus = parameterApplyStatusDecoded
        let parameterApplyErrorDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterApplyErrorDescription)
        parameterApplyErrorDescription = parameterApplyErrorDescriptionDecoded
    }
}

extension RedshiftClientTypes.ClusterParameterStatus: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ClusterParameterStatus(parameterApplyErrorDescription: \(Swift.String(describing: parameterApplyErrorDescription)), parameterApplyStatus: \(Swift.String(describing: parameterApplyStatus)), parameterName: \(Swift.String(describing: parameterName)))"}
}

extension RedshiftClientTypes {
    /// <p>Describes the status of a parameter group.</p>
    public struct ClusterParameterStatus: Swift.Equatable {
        /// <p>The error that prevented the parameter from being applied to the
        ///             database.</p>
        public let parameterApplyErrorDescription: Swift.String?
        /// <p>The status of the parameter that indicates whether the parameter is in sync with
        ///             the database, waiting for a cluster reboot, or encountered an error when being
        ///             applied.</p>
        ///         <p>The following are possible statuses and descriptions.</p>
        ///         <ul>
        ///             <li>
        ///                 <p>
        ///                     <code>in-sync</code>: The parameter value is in sync with the
        ///                     database.</p>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                     <code>pending-reboot</code>: The parameter value will be applied after the
        ///                     cluster reboots.</p>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                     <code>applying</code>: The parameter value is being applied to the
        ///                     database.</p>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                     <code>invalid-parameter</code>: Cannot apply the parameter value because it has
        ///                     an invalid value or syntax.</p>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                     <code>apply-deferred</code>: The parameter contains static property changes. The
        ///                     changes are deferred until the cluster reboots.</p>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                     <code>apply-error</code>: Cannot connect to the cluster. The parameter change
        ///                     will be applied after the cluster reboots.</p>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                     <code>unknown-error</code>: Cannot apply the parameter change right now. The
        ///                     change will be applied after the cluster reboots.</p>
        ///             </li>
        ///          </ul>
        public let parameterApplyStatus: Swift.String?
        /// <p>The name of the parameter.</p>
        public let parameterName: Swift.String?

        public init (
            parameterApplyErrorDescription: Swift.String? = nil,
            parameterApplyStatus: Swift.String? = nil,
            parameterName: Swift.String? = nil
        )
        {
            self.parameterApplyErrorDescription = parameterApplyErrorDescription
            self.parameterApplyStatus = parameterApplyStatus
            self.parameterName = parameterName
        }
    }

}

extension ClusterQuotaExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ClusterQuotaExceededFault(message: \(Swift.String(describing: message)))"}
}

extension ClusterQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<ClusterQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request would exceed the allowed number of cluster instances for this account.
///
/// For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a>
/// in the <i>Amazon Redshift Cluster Management Guide</i>.
/// </p>
public struct ClusterQuotaExceededFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ClusterQuotaExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ClusterQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RedshiftClientTypes.ClusterSecurityGroup: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterSecurityGroupName = "ClusterSecurityGroupName"
        case description = "Description"
        case eC2SecurityGroups = "EC2SecurityGroups"
        case iPRanges = "IPRanges"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let clusterSecurityGroupName = clusterSecurityGroupName {
            try container.encode(clusterSecurityGroupName, forKey: ClientRuntime.Key("ClusterSecurityGroupName"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let eC2SecurityGroups = eC2SecurityGroups {
            var eC2SecurityGroupsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EC2SecurityGroups"))
            for (index0, ec2securitygroup0) in eC2SecurityGroups.enumerated() {
                try eC2SecurityGroupsContainer.encode(ec2securitygroup0, forKey: ClientRuntime.Key("EC2SecurityGroup.\(index0.advanced(by: 1))"))
            }
        }
        if let iPRanges = iPRanges {
            var iPRangesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("IPRanges"))
            for (index0, iprange0) in iPRanges.enumerated() {
                try iPRangesContainer.encode(iprange0, forKey: ClientRuntime.Key("IPRange.\(index0.advanced(by: 1))"))
            }
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterSecurityGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterSecurityGroupName)
        clusterSecurityGroupName = clusterSecurityGroupNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        if containerValues.contains(.eC2SecurityGroups) {
            struct KeyVal0{struct EC2SecurityGroup{}}
            let eC2SecurityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.EC2SecurityGroup>.CodingKeys.self, forKey: .eC2SecurityGroups)
            if let eC2SecurityGroupsWrappedContainer = eC2SecurityGroupsWrappedContainer {
                let eC2SecurityGroupsContainer = try eC2SecurityGroupsWrappedContainer.decodeIfPresent([RedshiftClientTypes.EC2SecurityGroup].self, forKey: .member)
                var eC2SecurityGroupsBuffer:[RedshiftClientTypes.EC2SecurityGroup]? = nil
                if let eC2SecurityGroupsContainer = eC2SecurityGroupsContainer {
                    eC2SecurityGroupsBuffer = [RedshiftClientTypes.EC2SecurityGroup]()
                    for structureContainer0 in eC2SecurityGroupsContainer {
                        eC2SecurityGroupsBuffer?.append(structureContainer0)
                    }
                }
                eC2SecurityGroups = eC2SecurityGroupsBuffer
            } else {
                eC2SecurityGroups = []
            }
        } else {
            eC2SecurityGroups = nil
        }
        if containerValues.contains(.iPRanges) {
            struct KeyVal0{struct IPRange{}}
            let iPRangesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.IPRange>.CodingKeys.self, forKey: .iPRanges)
            if let iPRangesWrappedContainer = iPRangesWrappedContainer {
                let iPRangesContainer = try iPRangesWrappedContainer.decodeIfPresent([RedshiftClientTypes.IPRange].self, forKey: .member)
                var iPRangesBuffer:[RedshiftClientTypes.IPRange]? = nil
                if let iPRangesContainer = iPRangesContainer {
                    iPRangesBuffer = [RedshiftClientTypes.IPRange]()
                    for structureContainer0 in iPRangesContainer {
                        iPRangesBuffer?.append(structureContainer0)
                    }
                }
                iPRanges = iPRangesBuffer
            } else {
                iPRanges = []
            }
        } else {
            iPRanges = nil
        }
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([RedshiftClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[RedshiftClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [RedshiftClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension RedshiftClientTypes.ClusterSecurityGroup: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ClusterSecurityGroup(clusterSecurityGroupName: \(Swift.String(describing: clusterSecurityGroupName)), description: \(Swift.String(describing: description)), eC2SecurityGroups: \(Swift.String(describing: eC2SecurityGroups)), iPRanges: \(Swift.String(describing: iPRanges)), tags: \(Swift.String(describing: tags)))"}
}

extension RedshiftClientTypes {
    /// <p>Describes a security group.</p>
    public struct ClusterSecurityGroup: Swift.Equatable {
        /// <p>The name of the cluster security group to which the operation was
        ///             applied.</p>
        public let clusterSecurityGroupName: Swift.String?
        /// <p>A description of the security group.</p>
        public let description: Swift.String?
        /// <p>A list of EC2 security groups that are permitted to access clusters associated with
        ///             this cluster security group.</p>
        public let eC2SecurityGroups: [RedshiftClientTypes.EC2SecurityGroup]?
        /// <p>A list of IP ranges (CIDR blocks) that are permitted to access clusters associated
        ///             with this cluster security group.</p>
        public let iPRanges: [RedshiftClientTypes.IPRange]?
        /// <p>The list of tags for the cluster security group.</p>
        public let tags: [RedshiftClientTypes.Tag]?

        public init (
            clusterSecurityGroupName: Swift.String? = nil,
            description: Swift.String? = nil,
            eC2SecurityGroups: [RedshiftClientTypes.EC2SecurityGroup]? = nil,
            iPRanges: [RedshiftClientTypes.IPRange]? = nil,
            tags: [RedshiftClientTypes.Tag]? = nil
        )
        {
            self.clusterSecurityGroupName = clusterSecurityGroupName
            self.description = description
            self.eC2SecurityGroups = eC2SecurityGroups
            self.iPRanges = iPRanges
            self.tags = tags
        }
    }

}

extension ClusterSecurityGroupAlreadyExistsFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ClusterSecurityGroupAlreadyExistsFault(message: \(Swift.String(describing: message)))"}
}

extension ClusterSecurityGroupAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<ClusterSecurityGroupAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A cluster security group with the same name already exists.</p>
public struct ClusterSecurityGroupAlreadyExistsFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ClusterSecurityGroupAlreadyExistsFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ClusterSecurityGroupAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RedshiftClientTypes.ClusterSecurityGroupMembership: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterSecurityGroupName = "ClusterSecurityGroupName"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let clusterSecurityGroupName = clusterSecurityGroupName {
            try container.encode(clusterSecurityGroupName, forKey: ClientRuntime.Key("ClusterSecurityGroupName"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterSecurityGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterSecurityGroupName)
        clusterSecurityGroupName = clusterSecurityGroupNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension RedshiftClientTypes.ClusterSecurityGroupMembership: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ClusterSecurityGroupMembership(clusterSecurityGroupName: \(Swift.String(describing: clusterSecurityGroupName)), status: \(Swift.String(describing: status)))"}
}

extension RedshiftClientTypes {
    /// <p>Describes a cluster security group.</p>
    public struct ClusterSecurityGroupMembership: Swift.Equatable {
        /// <p>The name of the cluster security group.</p>
        public let clusterSecurityGroupName: Swift.String?
        /// <p>The status of the cluster security group.</p>
        public let status: Swift.String?

        public init (
            clusterSecurityGroupName: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.clusterSecurityGroupName = clusterSecurityGroupName
            self.status = status
        }
    }

}

extension ClusterSecurityGroupNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ClusterSecurityGroupNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension ClusterSecurityGroupNotFoundFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<ClusterSecurityGroupNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The cluster security group name does not refer to an existing cluster security
///             group.</p>
public struct ClusterSecurityGroupNotFoundFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ClusterSecurityGroupNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ClusterSecurityGroupNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ClusterSecurityGroupQuotaExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ClusterSecurityGroupQuotaExceededFault(message: \(Swift.String(describing: message)))"}
}

extension ClusterSecurityGroupQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<ClusterSecurityGroupQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request would result in the user exceeding the allowed number of cluster
///             security groups.
/// For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a>
/// in the <i>Amazon Redshift Cluster Management Guide</i>.
/// </p>
public struct ClusterSecurityGroupQuotaExceededFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ClusterSecurityGroupQuotaExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ClusterSecurityGroupQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ClusterSnapshotAlreadyExistsFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ClusterSnapshotAlreadyExistsFault(message: \(Swift.String(describing: message)))"}
}

extension ClusterSnapshotAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<ClusterSnapshotAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The value specified as a snapshot identifier is already used by an existing
///             snapshot.</p>
public struct ClusterSnapshotAlreadyExistsFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ClusterSnapshotAlreadyExistsFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ClusterSnapshotAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RedshiftClientTypes.ClusterSnapshotCopyStatus: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationRegion = "DestinationRegion"
        case manualSnapshotRetentionPeriod = "ManualSnapshotRetentionPeriod"
        case retentionPeriod = "RetentionPeriod"
        case snapshotCopyGrantName = "SnapshotCopyGrantName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let destinationRegion = destinationRegion {
            try container.encode(destinationRegion, forKey: ClientRuntime.Key("DestinationRegion"))
        }
        if manualSnapshotRetentionPeriod != 0 {
            try container.encode(manualSnapshotRetentionPeriod, forKey: ClientRuntime.Key("ManualSnapshotRetentionPeriod"))
        }
        if retentionPeriod != 0 {
            try container.encode(retentionPeriod, forKey: ClientRuntime.Key("RetentionPeriod"))
        }
        if let snapshotCopyGrantName = snapshotCopyGrantName {
            try container.encode(snapshotCopyGrantName, forKey: ClientRuntime.Key("SnapshotCopyGrantName"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationRegion)
        destinationRegion = destinationRegionDecoded
        let retentionPeriodDecoded = try containerValues.decode(Swift.Int.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let manualSnapshotRetentionPeriodDecoded = try containerValues.decode(Swift.Int.self, forKey: .manualSnapshotRetentionPeriod)
        manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriodDecoded
        let snapshotCopyGrantNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotCopyGrantName)
        snapshotCopyGrantName = snapshotCopyGrantNameDecoded
    }
}

extension RedshiftClientTypes.ClusterSnapshotCopyStatus: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ClusterSnapshotCopyStatus(destinationRegion: \(Swift.String(describing: destinationRegion)), manualSnapshotRetentionPeriod: \(Swift.String(describing: manualSnapshotRetentionPeriod)), retentionPeriod: \(Swift.String(describing: retentionPeriod)), snapshotCopyGrantName: \(Swift.String(describing: snapshotCopyGrantName)))"}
}

extension RedshiftClientTypes {
    /// <p>Returns the destination region and retention period that are configured for
    ///             cross-region snapshot copy.</p>
    public struct ClusterSnapshotCopyStatus: Swift.Equatable {
        /// <p>The destination region that snapshots are automatically copied to when cross-region
        ///             snapshot copy is enabled.</p>
        public let destinationRegion: Swift.String?
        /// <p>The number of days that automated snapshots are retained in the destination region
        ///             after they are copied from a source region. If the value is -1, the manual snapshot is
        ///             retained indefinitely. </p>
        ///         <p>The value must be either -1 or an integer between 1 and 3,653.</p>
        public let manualSnapshotRetentionPeriod: Swift.Int
        /// <p>The number of days that automated snapshots are retained in the destination region
        ///             after they are copied from a source region.</p>
        public let retentionPeriod: Swift.Int
        /// <p>The name of the snapshot copy grant.</p>
        public let snapshotCopyGrantName: Swift.String?

        public init (
            destinationRegion: Swift.String? = nil,
            manualSnapshotRetentionPeriod: Swift.Int = 0,
            retentionPeriod: Swift.Int = 0,
            snapshotCopyGrantName: Swift.String? = nil
        )
        {
            self.destinationRegion = destinationRegion
            self.manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriod
            self.retentionPeriod = retentionPeriod
            self.snapshotCopyGrantName = snapshotCopyGrantName
        }
    }

}

extension ClusterSnapshotNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ClusterSnapshotNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension ClusterSnapshotNotFoundFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<ClusterSnapshotNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The snapshot identifier does not refer to an existing cluster snapshot.</p>
public struct ClusterSnapshotNotFoundFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ClusterSnapshotNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ClusterSnapshotNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ClusterSnapshotQuotaExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ClusterSnapshotQuotaExceededFault(message: \(Swift.String(describing: message)))"}
}

extension ClusterSnapshotQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<ClusterSnapshotQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request would result in the user exceeding the allowed number of cluster
///             snapshots.</p>
public struct ClusterSnapshotQuotaExceededFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ClusterSnapshotQuotaExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ClusterSnapshotQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RedshiftClientTypes.ClusterSubnetGroup: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterSubnetGroupName = "ClusterSubnetGroupName"
        case description = "Description"
        case subnetGroupStatus = "SubnetGroupStatus"
        case subnets = "Subnets"
        case tags = "Tags"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let clusterSubnetGroupName = clusterSubnetGroupName {
            try container.encode(clusterSubnetGroupName, forKey: ClientRuntime.Key("ClusterSubnetGroupName"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let subnetGroupStatus = subnetGroupStatus {
            try container.encode(subnetGroupStatus, forKey: ClientRuntime.Key("SubnetGroupStatus"))
        }
        if let subnets = subnets {
            var subnetsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Subnets"))
            for (index0, subnet0) in subnets.enumerated() {
                try subnetsContainer.encode(subnet0, forKey: ClientRuntime.Key("Subnet.\(index0.advanced(by: 1))"))
            }
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let vpcId = vpcId {
            try container.encode(vpcId, forKey: ClientRuntime.Key("VpcId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterSubnetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterSubnetGroupName)
        clusterSubnetGroupName = clusterSubnetGroupNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetGroupStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetGroupStatus)
        subnetGroupStatus = subnetGroupStatusDecoded
        if containerValues.contains(.subnets) {
            struct KeyVal0{struct Subnet{}}
            let subnetsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Subnet>.CodingKeys.self, forKey: .subnets)
            if let subnetsWrappedContainer = subnetsWrappedContainer {
                let subnetsContainer = try subnetsWrappedContainer.decodeIfPresent([RedshiftClientTypes.Subnet].self, forKey: .member)
                var subnetsBuffer:[RedshiftClientTypes.Subnet]? = nil
                if let subnetsContainer = subnetsContainer {
                    subnetsBuffer = [RedshiftClientTypes.Subnet]()
                    for structureContainer0 in subnetsContainer {
                        subnetsBuffer?.append(structureContainer0)
                    }
                }
                subnets = subnetsBuffer
            } else {
                subnets = []
            }
        } else {
            subnets = nil
        }
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([RedshiftClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[RedshiftClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [RedshiftClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension RedshiftClientTypes.ClusterSubnetGroup: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ClusterSubnetGroup(clusterSubnetGroupName: \(Swift.String(describing: clusterSubnetGroupName)), description: \(Swift.String(describing: description)), subnetGroupStatus: \(Swift.String(describing: subnetGroupStatus)), subnets: \(Swift.String(describing: subnets)), tags: \(Swift.String(describing: tags)), vpcId: \(Swift.String(describing: vpcId)))"}
}

extension RedshiftClientTypes {
    /// <p>Describes a subnet group.</p>
    public struct ClusterSubnetGroup: Swift.Equatable {
        /// <p>The name of the cluster subnet group.</p>
        public let clusterSubnetGroupName: Swift.String?
        /// <p>The description of the cluster subnet group.</p>
        public let description: Swift.String?
        /// <p>The status of the cluster subnet group. Possible values are <code>Complete</code>,
        ///                 <code>Incomplete</code> and <code>Invalid</code>. </p>
        public let subnetGroupStatus: Swift.String?
        /// <p>A list of the VPC <a>Subnet</a> elements. </p>
        public let subnets: [RedshiftClientTypes.Subnet]?
        /// <p>The list of tags for the cluster subnet group.</p>
        public let tags: [RedshiftClientTypes.Tag]?
        /// <p>The VPC ID of the cluster subnet group.</p>
        public let vpcId: Swift.String?

        public init (
            clusterSubnetGroupName: Swift.String? = nil,
            description: Swift.String? = nil,
            subnetGroupStatus: Swift.String? = nil,
            subnets: [RedshiftClientTypes.Subnet]? = nil,
            tags: [RedshiftClientTypes.Tag]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.clusterSubnetGroupName = clusterSubnetGroupName
            self.description = description
            self.subnetGroupStatus = subnetGroupStatus
            self.subnets = subnets
            self.tags = tags
            self.vpcId = vpcId
        }
    }

}

extension ClusterSubnetGroupAlreadyExistsFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ClusterSubnetGroupAlreadyExistsFault(message: \(Swift.String(describing: message)))"}
}

extension ClusterSubnetGroupAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<ClusterSubnetGroupAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A <i>ClusterSubnetGroupName</i> is already used by an existing
///             cluster subnet group. </p>
public struct ClusterSubnetGroupAlreadyExistsFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ClusterSubnetGroupAlreadyExistsFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ClusterSubnetGroupAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ClusterSubnetGroupNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ClusterSubnetGroupNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension ClusterSubnetGroupNotFoundFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<ClusterSubnetGroupNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The cluster subnet group name does not refer to an existing cluster subnet
///             group.</p>
public struct ClusterSubnetGroupNotFoundFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ClusterSubnetGroupNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ClusterSubnetGroupNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ClusterSubnetGroupQuotaExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ClusterSubnetGroupQuotaExceededFault(message: \(Swift.String(describing: message)))"}
}

extension ClusterSubnetGroupQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<ClusterSubnetGroupQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request would result in user exceeding the allowed number of cluster subnet
///             groups.
/// For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a>
/// in the <i>Amazon Redshift Cluster Management Guide</i>.
/// </p>
public struct ClusterSubnetGroupQuotaExceededFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ClusterSubnetGroupQuotaExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ClusterSubnetGroupQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ClusterSubnetQuotaExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ClusterSubnetQuotaExceededFault(message: \(Swift.String(describing: message)))"}
}

extension ClusterSubnetQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<ClusterSubnetQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request would result in user exceeding the allowed number of subnets in a
///             cluster subnet groups.
/// For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a>
/// in the <i>Amazon Redshift Cluster Management Guide</i>.
/// </p>
public struct ClusterSubnetQuotaExceededFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ClusterSubnetQuotaExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ClusterSubnetQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RedshiftClientTypes.ClusterVersion: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterParameterGroupFamily = "ClusterParameterGroupFamily"
        case clusterVersion = "ClusterVersion"
        case description = "Description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let clusterParameterGroupFamily = clusterParameterGroupFamily {
            try container.encode(clusterParameterGroupFamily, forKey: ClientRuntime.Key("ClusterParameterGroupFamily"))
        }
        if let clusterVersion = clusterVersion {
            try container.encode(clusterVersion, forKey: ClientRuntime.Key("ClusterVersion"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterVersion)
        clusterVersion = clusterVersionDecoded
        let clusterParameterGroupFamilyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterParameterGroupFamily)
        clusterParameterGroupFamily = clusterParameterGroupFamilyDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension RedshiftClientTypes.ClusterVersion: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ClusterVersion(clusterParameterGroupFamily: \(Swift.String(describing: clusterParameterGroupFamily)), clusterVersion: \(Swift.String(describing: clusterVersion)), description: \(Swift.String(describing: description)))"}
}

extension RedshiftClientTypes {
    /// <p>Describes a cluster version, including the parameter group family and description
    ///             of the version.</p>
    public struct ClusterVersion: Swift.Equatable {
        /// <p>The name of the cluster parameter group family for the cluster.</p>
        public let clusterParameterGroupFamily: Swift.String?
        /// <p>The version number used by the cluster.</p>
        public let clusterVersion: Swift.String?
        /// <p>The description of the cluster version.</p>
        public let description: Swift.String?

        public init (
            clusterParameterGroupFamily: Swift.String? = nil,
            clusterVersion: Swift.String? = nil,
            description: Swift.String? = nil
        )
        {
            self.clusterParameterGroupFamily = clusterParameterGroupFamily
            self.clusterVersion = clusterVersion
            self.description = description
        }
    }

}

public struct CopyClusterSnapshotInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CopyClusterSnapshotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CopyClusterSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CopyClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CopyClusterSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CopyClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CopyClusterSnapshotOutputError>
}

extension CopyClusterSnapshotInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CopyClusterSnapshotInput(manualSnapshotRetentionPeriod: \(Swift.String(describing: manualSnapshotRetentionPeriod)), sourceSnapshotClusterIdentifier: \(Swift.String(describing: sourceSnapshotClusterIdentifier)), sourceSnapshotIdentifier: \(Swift.String(describing: sourceSnapshotIdentifier)), targetSnapshotIdentifier: \(Swift.String(describing: targetSnapshotIdentifier)))"}
}

extension CopyClusterSnapshotInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriod {
            try container.encode(manualSnapshotRetentionPeriod, forKey: ClientRuntime.Key("ManualSnapshotRetentionPeriod"))
        }
        if let sourceSnapshotClusterIdentifier = sourceSnapshotClusterIdentifier {
            try container.encode(sourceSnapshotClusterIdentifier, forKey: ClientRuntime.Key("SourceSnapshotClusterIdentifier"))
        }
        if let sourceSnapshotIdentifier = sourceSnapshotIdentifier {
            try container.encode(sourceSnapshotIdentifier, forKey: ClientRuntime.Key("SourceSnapshotIdentifier"))
        }
        if let targetSnapshotIdentifier = targetSnapshotIdentifier {
            try container.encode(targetSnapshotIdentifier, forKey: ClientRuntime.Key("TargetSnapshotIdentifier"))
        }
        try container.encode("CopyClusterSnapshot", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CopyClusterSnapshotInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CopyClusterSnapshotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CopyClusterSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CopyClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CopyClusterSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CopyClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CopyClusterSnapshotOutputError>
}

public struct CopyClusterSnapshotInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CopyClusterSnapshotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CopyClusterSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CopyClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CopyClusterSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CopyClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CopyClusterSnapshotOutputError>
}

/// <p></p>
public struct CopyClusterSnapshotInput: Swift.Equatable {
    /// <p>The number of days that a manual snapshot is retained. If the value is -1, the manual
    ///             snapshot is retained indefinitely. </p>
    ///         <p>The value must be either -1 or an integer between 1 and 3,653.</p>
    ///         <p>The default value is -1.</p>
    public let manualSnapshotRetentionPeriod: Swift.Int?
    /// <p>The identifier of the cluster the source snapshot was created from. This parameter
    ///             is required if your IAM user has a policy containing a snapshot resource element that
    ///             specifies anything other than * for the cluster name.</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Must be the identifier for a valid cluster.</p>
    ///             </li>
    ///          </ul>
    public let sourceSnapshotClusterIdentifier: Swift.String?
    /// <p>The identifier for the source snapshot.</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Must be the identifier for a valid automated snapshot whose state is
    ///                         <code>available</code>.</p>
    ///             </li>
    ///          </ul>
    public let sourceSnapshotIdentifier: Swift.String?
    /// <p>The identifier given to the new manual snapshot.</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Cannot be null, empty, or blank.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                 <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Cannot end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Must be unique for the AWS account that is making the request.</p>
    ///             </li>
    ///          </ul>
    public let targetSnapshotIdentifier: Swift.String?

    public init (
        manualSnapshotRetentionPeriod: Swift.Int? = nil,
        sourceSnapshotClusterIdentifier: Swift.String? = nil,
        sourceSnapshotIdentifier: Swift.String? = nil,
        targetSnapshotIdentifier: Swift.String? = nil
    )
    {
        self.manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriod
        self.sourceSnapshotClusterIdentifier = sourceSnapshotClusterIdentifier
        self.sourceSnapshotIdentifier = sourceSnapshotIdentifier
        self.targetSnapshotIdentifier = targetSnapshotIdentifier
    }
}

extension CopyClusterSnapshotOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CopyClusterSnapshotOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterSnapshotAlreadyExistsFault" : self = .clusterSnapshotAlreadyExistsFault(try ClusterSnapshotAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterSnapshotNotFoundFault" : self = .clusterSnapshotNotFoundFault(try ClusterSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterSnapshotQuotaExceededFault" : self = .clusterSnapshotQuotaExceededFault(try ClusterSnapshotQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterSnapshotStateFault" : self = .invalidClusterSnapshotStateFault(try InvalidClusterSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRetentionPeriodFault" : self = .invalidRetentionPeriodFault(try InvalidRetentionPeriodFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CopyClusterSnapshotOutputError: Swift.Error, Swift.Equatable {
    case clusterSnapshotAlreadyExistsFault(ClusterSnapshotAlreadyExistsFault)
    case clusterSnapshotNotFoundFault(ClusterSnapshotNotFoundFault)
    case clusterSnapshotQuotaExceededFault(ClusterSnapshotQuotaExceededFault)
    case invalidClusterSnapshotStateFault(InvalidClusterSnapshotStateFault)
    case invalidRetentionPeriodFault(InvalidRetentionPeriodFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CopyClusterSnapshotOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CopyClusterSnapshotOutputResponse(snapshot: \(Swift.String(describing: snapshot)))"}
}

extension CopyClusterSnapshotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CopyClusterSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.snapshot = output.snapshot
        } else {
            self.snapshot = nil
        }
    }
}

public struct CopyClusterSnapshotOutputResponse: Swift.Equatable {
    /// <p>Describes a snapshot.</p>
    public let snapshot: RedshiftClientTypes.Snapshot?

    public init (
        snapshot: RedshiftClientTypes.Snapshot? = nil
    )
    {
        self.snapshot = snapshot
    }
}

struct CopyClusterSnapshotOutputResponseBody: Swift.Equatable {
    public let snapshot: RedshiftClientTypes.Snapshot?
}

extension CopyClusterSnapshotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshot = "Snapshot"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CopyClusterSnapshotResult"))
        let snapshotDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.Snapshot.self, forKey: .snapshot)
        snapshot = snapshotDecoded
    }
}

extension CopyToRegionDisabledFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CopyToRegionDisabledFault(message: \(Swift.String(describing: message)))"}
}

extension CopyToRegionDisabledFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<CopyToRegionDisabledFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Cross-region snapshot copy was temporarily disabled. Try your request
///             again.</p>
public struct CopyToRegionDisabledFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CopyToRegionDisabledFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension CopyToRegionDisabledFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateClusterInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateClusterOutputError>
}

extension CreateClusterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateClusterInput(additionalInfo: \(Swift.String(describing: additionalInfo)), allowVersionUpgrade: \(Swift.String(describing: allowVersionUpgrade)), aquaConfigurationStatus: \(Swift.String(describing: aquaConfigurationStatus)), automatedSnapshotRetentionPeriod: \(Swift.String(describing: automatedSnapshotRetentionPeriod)), availabilityZone: \(Swift.String(describing: availabilityZone)), availabilityZoneRelocation: \(Swift.String(describing: availabilityZoneRelocation)), clusterIdentifier: \(Swift.String(describing: clusterIdentifier)), clusterParameterGroupName: \(Swift.String(describing: clusterParameterGroupName)), clusterSecurityGroups: \(Swift.String(describing: clusterSecurityGroups)), clusterSubnetGroupName: \(Swift.String(describing: clusterSubnetGroupName)), clusterType: \(Swift.String(describing: clusterType)), clusterVersion: \(Swift.String(describing: clusterVersion)), dBName: \(Swift.String(describing: dBName)), elasticIp: \(Swift.String(describing: elasticIp)), encrypted: \(Swift.String(describing: encrypted)), enhancedVpcRouting: \(Swift.String(describing: enhancedVpcRouting)), hsmClientCertificateIdentifier: \(Swift.String(describing: hsmClientCertificateIdentifier)), hsmConfigurationIdentifier: \(Swift.String(describing: hsmConfigurationIdentifier)), iamRoles: \(Swift.String(describing: iamRoles)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), maintenanceTrackName: \(Swift.String(describing: maintenanceTrackName)), manualSnapshotRetentionPeriod: \(Swift.String(describing: manualSnapshotRetentionPeriod)), masterUserPassword: \(Swift.String(describing: masterUserPassword)), masterUsername: \(Swift.String(describing: masterUsername)), nodeType: \(Swift.String(describing: nodeType)), numberOfNodes: \(Swift.String(describing: numberOfNodes)), port: \(Swift.String(describing: port)), preferredMaintenanceWindow: \(Swift.String(describing: preferredMaintenanceWindow)), publiclyAccessible: \(Swift.String(describing: publiclyAccessible)), snapshotScheduleIdentifier: \(Swift.String(describing: snapshotScheduleIdentifier)), tags: \(Swift.String(describing: tags)), vpcSecurityGroupIds: \(Swift.String(describing: vpcSecurityGroupIds)))"}
}

extension CreateClusterInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let additionalInfo = additionalInfo {
            try container.encode(additionalInfo, forKey: ClientRuntime.Key("AdditionalInfo"))
        }
        if let allowVersionUpgrade = allowVersionUpgrade {
            try container.encode(allowVersionUpgrade, forKey: ClientRuntime.Key("AllowVersionUpgrade"))
        }
        if let aquaConfigurationStatus = aquaConfigurationStatus {
            try container.encode(aquaConfigurationStatus, forKey: ClientRuntime.Key("AquaConfigurationStatus"))
        }
        if let automatedSnapshotRetentionPeriod = automatedSnapshotRetentionPeriod {
            try container.encode(automatedSnapshotRetentionPeriod, forKey: ClientRuntime.Key("AutomatedSnapshotRetentionPeriod"))
        }
        if let availabilityZone = availabilityZone {
            try container.encode(availabilityZone, forKey: ClientRuntime.Key("AvailabilityZone"))
        }
        if let availabilityZoneRelocation = availabilityZoneRelocation {
            try container.encode(availabilityZoneRelocation, forKey: ClientRuntime.Key("AvailabilityZoneRelocation"))
        }
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: ClientRuntime.Key("ClusterIdentifier"))
        }
        if let clusterParameterGroupName = clusterParameterGroupName {
            try container.encode(clusterParameterGroupName, forKey: ClientRuntime.Key("ClusterParameterGroupName"))
        }
        if let clusterSecurityGroups = clusterSecurityGroups {
            var clusterSecurityGroupsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ClusterSecurityGroups"))
            for (index0, string0) in clusterSecurityGroups.enumerated() {
                try clusterSecurityGroupsContainer.encode(string0, forKey: ClientRuntime.Key("ClusterSecurityGroupName.\(index0.advanced(by: 1))"))
            }
        }
        if let clusterSubnetGroupName = clusterSubnetGroupName {
            try container.encode(clusterSubnetGroupName, forKey: ClientRuntime.Key("ClusterSubnetGroupName"))
        }
        if let clusterType = clusterType {
            try container.encode(clusterType, forKey: ClientRuntime.Key("ClusterType"))
        }
        if let clusterVersion = clusterVersion {
            try container.encode(clusterVersion, forKey: ClientRuntime.Key("ClusterVersion"))
        }
        if let dBName = dBName {
            try container.encode(dBName, forKey: ClientRuntime.Key("DBName"))
        }
        if let elasticIp = elasticIp {
            try container.encode(elasticIp, forKey: ClientRuntime.Key("ElasticIp"))
        }
        if let encrypted = encrypted {
            try container.encode(encrypted, forKey: ClientRuntime.Key("Encrypted"))
        }
        if let enhancedVpcRouting = enhancedVpcRouting {
            try container.encode(enhancedVpcRouting, forKey: ClientRuntime.Key("EnhancedVpcRouting"))
        }
        if let hsmClientCertificateIdentifier = hsmClientCertificateIdentifier {
            try container.encode(hsmClientCertificateIdentifier, forKey: ClientRuntime.Key("HsmClientCertificateIdentifier"))
        }
        if let hsmConfigurationIdentifier = hsmConfigurationIdentifier {
            try container.encode(hsmConfigurationIdentifier, forKey: ClientRuntime.Key("HsmConfigurationIdentifier"))
        }
        if let iamRoles = iamRoles {
            var iamRolesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("IamRoles"))
            for (index0, string0) in iamRoles.enumerated() {
                try iamRolesContainer.encode(string0, forKey: ClientRuntime.Key("IamRoleArn.\(index0.advanced(by: 1))"))
            }
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: ClientRuntime.Key("KmsKeyId"))
        }
        if let maintenanceTrackName = maintenanceTrackName {
            try container.encode(maintenanceTrackName, forKey: ClientRuntime.Key("MaintenanceTrackName"))
        }
        if let manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriod {
            try container.encode(manualSnapshotRetentionPeriod, forKey: ClientRuntime.Key("ManualSnapshotRetentionPeriod"))
        }
        if let masterUserPassword = masterUserPassword {
            try container.encode(masterUserPassword, forKey: ClientRuntime.Key("MasterUserPassword"))
        }
        if let masterUsername = masterUsername {
            try container.encode(masterUsername, forKey: ClientRuntime.Key("MasterUsername"))
        }
        if let nodeType = nodeType {
            try container.encode(nodeType, forKey: ClientRuntime.Key("NodeType"))
        }
        if let numberOfNodes = numberOfNodes {
            try container.encode(numberOfNodes, forKey: ClientRuntime.Key("NumberOfNodes"))
        }
        if let port = port {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try container.encode(preferredMaintenanceWindow, forKey: ClientRuntime.Key("PreferredMaintenanceWindow"))
        }
        if let publiclyAccessible = publiclyAccessible {
            try container.encode(publiclyAccessible, forKey: ClientRuntime.Key("PubliclyAccessible"))
        }
        if let snapshotScheduleIdentifier = snapshotScheduleIdentifier {
            try container.encode(snapshotScheduleIdentifier, forKey: ClientRuntime.Key("SnapshotScheduleIdentifier"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: ClientRuntime.Key("VpcSecurityGroupId.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateCluster", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CreateClusterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateClusterOutputError>
}

public struct CreateClusterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateClusterOutputError>
}

/// <p></p>
public struct CreateClusterInput: Swift.Equatable {
    /// <p>Reserved.</p>
    public let additionalInfo: Swift.String?
    /// <p>If <code>true</code>, major version upgrades can be applied during the maintenance
    ///             window to the Amazon Redshift engine that is running on the cluster.</p>
    ///         <p>When a new major version of the Amazon Redshift engine is released, you can request that
    ///             the service automatically apply upgrades during the maintenance window to the Amazon Redshift
    ///             engine that is running on your cluster.</p>
    ///         <p>Default: <code>true</code>
    ///         </p>
    public let allowVersionUpgrade: Swift.Bool?
    /// <p>The value represents how the cluster is configured to use AQUA (Advanced Query Accelerator) when it is created. Possible values include the following.</p>
    ///         <ul>
    ///             <li>
    ///                <p>enabled - Use AQUA if it is available for the current AWS Region and Amazon Redshift node type.</p>
    ///             </li>
    ///             <li>
    ///                <p>disabled - Don't use AQUA. </p>
    ///             </li>
    ///             <li>
    ///                <p>auto - Amazon Redshift determines whether to use AQUA.</p>
    ///             </li>
    ///          </ul>
    public let aquaConfigurationStatus: RedshiftClientTypes.AquaConfigurationStatus?
    /// <p>The number of days that automated snapshots are retained. If the value is 0,
    ///             automated snapshots are disabled. Even if automated snapshots are disabled, you can
    ///             still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p>
    ///
    ///         <p>You can't disable automated snapshots for RA3 node types. Set the automated retention period from 1-35 days.</p>
    ///         <p>Default: <code>1</code>
    ///         </p>
    ///         <p>Constraints: Must be a value from 0 to 35.</p>
    public let automatedSnapshotRetentionPeriod: Swift.Int?
    /// <p>The EC2 Availability Zone (AZ) in which you want Amazon Redshift to provision the
    ///             cluster. For example, if you have several EC2 instances running in a specific
    ///             Availability Zone, then you might want the cluster to be provisioned in the same zone in
    ///             order to decrease network latency.</p>
    ///         <p>Default: A random, system-chosen Availability Zone in the region that is specified
    ///             by the endpoint.</p>
    ///         <p>Example: <code>us-east-2d</code>
    ///         </p>
    ///         <p>Constraint: The specified Availability Zone must be in the same region as the
    ///             current endpoint.</p>
    public let availabilityZone: Swift.String?
    /// <p>The option to enable relocation for an Amazon Redshift cluster between Availability Zones after the cluster is created.</p>
    public let availabilityZoneRelocation: Swift.Bool?
    /// <p>A unique identifier for the cluster. You use this identifier to refer to the
    ///             cluster for any subsequent cluster operations such as deleting or modifying. The
    ///             identifier also appears in the Amazon Redshift console.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>Alphabetic characters must be lowercase.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>Must be unique for all clusters within an AWS account.</p>
    ///             </li>
    ///          </ul>
    ///
    ///             <p>Example: <code>myexamplecluster</code>
    ///         </p>
    public let clusterIdentifier: Swift.String?
    /// <p>The name of the parameter group to be associated with this cluster.</p>
    ///         <p>Default: The default Amazon Redshift cluster parameter group. For information about the
    ///             default parameter group, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon
    ///                 Redshift Parameter Groups</a>
    ///         </p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Must be 1 to 255 alphanumeric characters or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                 <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Cannot end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///          </ul>
    public let clusterParameterGroupName: Swift.String?
    /// <p>A list of security groups to be associated with this cluster.</p>
    ///         <p>Default: The default cluster security group for Amazon Redshift.</p>
    public let clusterSecurityGroups: [Swift.String]?
    /// <p>The name of a cluster subnet group to be associated with this cluster.</p>
    ///         <p>If this parameter is not provided the resulting cluster will be deployed outside
    ///             virtual private cloud (VPC).</p>
    public let clusterSubnetGroupName: Swift.String?
    /// <p>The type of the cluster. When cluster type is specified as</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                     <code>single-node</code>, the <b>NumberOfNodes</b>
    ///                     parameter is not required.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>multi-node</code>, the <b>NumberOfNodes</b>
    ///                     parameter is required.</p>
    ///             </li>
    ///          </ul>
    ///         <p>Valid Values: <code>multi-node</code> | <code>single-node</code>
    ///         </p>
    ///         <p>Default: <code>multi-node</code>
    ///         </p>
    public let clusterType: Swift.String?
    /// <p>The version of the Amazon Redshift engine software that you want to deploy on the
    ///             cluster.</p>
    ///         <p>The version selected runs on all the nodes in the cluster.</p>
    ///         <p>Constraints: Only version 1.0 is currently available.</p>
    ///         <p>Example: <code>1.0</code>
    ///         </p>
    public let clusterVersion: Swift.String?
    /// <p>The name of the first database to be created when the cluster is created.</p>
    ///         <p>To create additional databases after the cluster is created, connect to the cluster
    ///             with a SQL client and use SQL commands to create a database. For more information, go to
    ///                 <a href="https://docs.aws.amazon.com/redshift/latest/dg/t_creating_database.html">Create
    ///                 a Database</a> in the Amazon Redshift Database Developer Guide. </p>
    ///         <p>Default: <code>dev</code>
    ///         </p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Must contain 1 to 64 alphanumeric characters.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Must contain only lowercase letters.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Cannot be a word that is reserved by the service. A list of reserved words
    ///                     can be found in <a href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the
    ///                     Amazon Redshift Database Developer Guide. </p>
    ///             </li>
    ///          </ul>
    public let dBName: Swift.String?
    /// <p>The Elastic IP (EIP) address for the cluster.</p>
    ///         <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible
    ///             through an Internet gateway. For more information about provisioning clusters in
    ///             EC2-VPC, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported
    ///                 Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
    public let elasticIp: Swift.String?
    /// <p>If <code>true</code>, the data in the cluster is encrypted at rest. </p>
    ///         <p>Default: false</p>
    public let encrypted: Swift.Bool?
    /// <p>An option that specifies whether to create the cluster with enhanced VPC routing
    ///             enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a
    ///             VPC. For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in
    ///             the Amazon Redshift Cluster Management Guide.</p>
    ///         <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p>
    ///         <p>Default: false</p>
    public let enhancedVpcRouting: Swift.Bool?
    /// <p>Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to
    ///             retrieve the data encryption keys stored in an HSM.</p>
    public let hsmClientCertificateIdentifier: Swift.String?
    /// <p>Specifies the name of the HSM configuration that contains the information the
    ///             Amazon Redshift cluster can use to retrieve and store keys in an HSM.</p>
    public let hsmConfigurationIdentifier: Swift.String?
    /// <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the
    ///             cluster to access other AWS services. You must supply the IAM roles in their Amazon
    ///             Resource Name (ARN) format. You can supply up to 10 IAM roles in a single
    ///             request.</p>
    ///         <p>A cluster can have up to 10 IAM roles associated with it at any time.</p>
    public let iamRoles: [Swift.String]?
    /// <p>The AWS Key Management Service (KMS) key ID of the encryption key that you want to
    ///             use to encrypt data in the cluster.</p>
    public let kmsKeyId: Swift.String?
    /// <p>An optional parameter for the name of the maintenance track for the cluster. If you
    ///             don't provide a maintenance track name, the cluster is assigned to the
    ///                 <code>current</code> track.</p>
    public let maintenanceTrackName: Swift.String?
    /// <p>The default number of days to retain a manual snapshot. If the value is -1, the
    ///             snapshot is retained indefinitely. This setting doesn't change the retention period
    ///             of existing snapshots.</p>
    ///         <p>The value must be either -1 or an integer between 1 and 3,653.</p>
    public let manualSnapshotRetentionPeriod: Swift.Int?
    /// <p>The password associated with the master user account for the cluster that is being
    ///             created.</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Must be between 8 and 64 characters in length.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Must contain at least one uppercase letter.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Must contain at least one lowercase letter.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Must contain one number.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Can be any printable ASCII character (ASCII code 33 to 126) except '
    ///                     (single quote), " (double quote), \, /, @, or space.</p>
    ///             </li>
    ///          </ul>
    public let masterUserPassword: Swift.String?
    /// <p>The user name associated with the master user account for the cluster that is being
    ///             created.</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Must be 1 - 128 alphanumeric characters. The user name can't be
    ///                         <code>PUBLIC</code>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///
    ///                 <p>Cannot be a reserved word. A list of reserved words can be found in <a href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved
    ///                         Words</a> in the Amazon Redshift Database Developer Guide. </p>
    ///             </li>
    ///          </ul>
    public let masterUsername: Swift.String?
    /// <p>The node type to be provisioned for the cluster. For information about node types,
    ///             go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with
    ///                 Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
    ///         <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> |
    ///                 <code>dc1.large</code> | <code>dc1.8xlarge</code> |
    ///                 <code>dc2.large</code> | <code>dc2.8xlarge</code> |
    ///                 <code>ra3.xlplus</code> |  <code>ra3.4xlarge</code> | <code>ra3.16xlarge</code>
    ///          </p>
    public let nodeType: Swift.String?
    /// <p>The number of compute nodes in the cluster. This parameter is required when the
    ///                 <b>ClusterType</b> parameter is specified as
    ///                 <code>multi-node</code>. </p>
    ///         <p>For information about determining how many nodes you need, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with
    ///                 Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
    ///         <p>If you don't specify this parameter, you get a single-node cluster. When requesting
    ///             a multi-node cluster, you must specify the number of nodes that you want in the
    ///             cluster.</p>
    ///         <p>Default: <code>1</code>
    ///         </p>
    ///         <p>Constraints: Value must be at least 1 and no more than 100.</p>
    public let numberOfNodes: Swift.Int?
    /// <p>The port number on which the cluster accepts incoming connections.</p>
    ///         <p>The cluster is accessible only via the JDBC and ODBC connection strings. Part of
    ///             the connection string requires the port on which the cluster will listen for incoming
    ///             connections.</p>
    ///         <p>Default: <code>5439</code>
    ///         </p>
    ///         <p>Valid Values: <code>1150-65535</code>
    ///         </p>
    public let port: Swift.Int?
    /// <p>The weekly time range (in UTC) during which automated cluster maintenance can
    ///             occur.</p>
    ///         <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code>
    ///         </p>
    ///         <p> Default: A 30-minute window selected at random from an 8-hour block of time per
    ///             region, occurring on a random day of the week. For more information about the time
    ///             blocks for each region, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide.</p>
    ///         <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p>
    ///         <p>Constraints: Minimum 30-minute window.</p>
    public let preferredMaintenanceWindow: Swift.String?
    /// <p>If <code>true</code>, the cluster can be accessed from a public network. </p>
    public let publiclyAccessible: Swift.Bool?
    /// <p>A unique identifier for the snapshot schedule.</p>
    public let snapshotScheduleIdentifier: Swift.String?
    /// <p>A list of tag instances.</p>
    public let tags: [RedshiftClientTypes.Tag]?
    /// <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the
    ///             cluster.</p>
    ///         <p>Default: The default VPC security group is associated with the cluster.</p>
    public let vpcSecurityGroupIds: [Swift.String]?

    public init (
        additionalInfo: Swift.String? = nil,
        allowVersionUpgrade: Swift.Bool? = nil,
        aquaConfigurationStatus: RedshiftClientTypes.AquaConfigurationStatus? = nil,
        automatedSnapshotRetentionPeriod: Swift.Int? = nil,
        availabilityZone: Swift.String? = nil,
        availabilityZoneRelocation: Swift.Bool? = nil,
        clusterIdentifier: Swift.String? = nil,
        clusterParameterGroupName: Swift.String? = nil,
        clusterSecurityGroups: [Swift.String]? = nil,
        clusterSubnetGroupName: Swift.String? = nil,
        clusterType: Swift.String? = nil,
        clusterVersion: Swift.String? = nil,
        dBName: Swift.String? = nil,
        elasticIp: Swift.String? = nil,
        encrypted: Swift.Bool? = nil,
        enhancedVpcRouting: Swift.Bool? = nil,
        hsmClientCertificateIdentifier: Swift.String? = nil,
        hsmConfigurationIdentifier: Swift.String? = nil,
        iamRoles: [Swift.String]? = nil,
        kmsKeyId: Swift.String? = nil,
        maintenanceTrackName: Swift.String? = nil,
        manualSnapshotRetentionPeriod: Swift.Int? = nil,
        masterUserPassword: Swift.String? = nil,
        masterUsername: Swift.String? = nil,
        nodeType: Swift.String? = nil,
        numberOfNodes: Swift.Int? = nil,
        port: Swift.Int? = nil,
        preferredMaintenanceWindow: Swift.String? = nil,
        publiclyAccessible: Swift.Bool? = nil,
        snapshotScheduleIdentifier: Swift.String? = nil,
        tags: [RedshiftClientTypes.Tag]? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil
    )
    {
        self.additionalInfo = additionalInfo
        self.allowVersionUpgrade = allowVersionUpgrade
        self.aquaConfigurationStatus = aquaConfigurationStatus
        self.automatedSnapshotRetentionPeriod = automatedSnapshotRetentionPeriod
        self.availabilityZone = availabilityZone
        self.availabilityZoneRelocation = availabilityZoneRelocation
        self.clusterIdentifier = clusterIdentifier
        self.clusterParameterGroupName = clusterParameterGroupName
        self.clusterSecurityGroups = clusterSecurityGroups
        self.clusterSubnetGroupName = clusterSubnetGroupName
        self.clusterType = clusterType
        self.clusterVersion = clusterVersion
        self.dBName = dBName
        self.elasticIp = elasticIp
        self.encrypted = encrypted
        self.enhancedVpcRouting = enhancedVpcRouting
        self.hsmClientCertificateIdentifier = hsmClientCertificateIdentifier
        self.hsmConfigurationIdentifier = hsmConfigurationIdentifier
        self.iamRoles = iamRoles
        self.kmsKeyId = kmsKeyId
        self.maintenanceTrackName = maintenanceTrackName
        self.manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriod
        self.masterUserPassword = masterUserPassword
        self.masterUsername = masterUsername
        self.nodeType = nodeType
        self.numberOfNodes = numberOfNodes
        self.port = port
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.publiclyAccessible = publiclyAccessible
        self.snapshotScheduleIdentifier = snapshotScheduleIdentifier
        self.tags = tags
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

extension CreateClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterAlreadyExistsFault" : self = .clusterAlreadyExistsFault(try ClusterAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterParameterGroupNotFoundFault" : self = .clusterParameterGroupNotFoundFault(try ClusterParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterQuotaExceededFault" : self = .clusterQuotaExceededFault(try ClusterQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterSecurityGroupNotFoundFault" : self = .clusterSecurityGroupNotFoundFault(try ClusterSecurityGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterSubnetGroupNotFoundFault" : self = .clusterSubnetGroupNotFoundFault(try ClusterSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependentServiceRequestThrottlingFault" : self = .dependentServiceRequestThrottlingFault(try DependentServiceRequestThrottlingFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HsmClientCertificateNotFoundFault" : self = .hsmClientCertificateNotFoundFault(try HsmClientCertificateNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HsmConfigurationNotFoundFault" : self = .hsmConfigurationNotFoundFault(try HsmConfigurationNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientClusterCapacityFault" : self = .insufficientClusterCapacityFault(try InsufficientClusterCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterSubnetGroupStateFault" : self = .invalidClusterSubnetGroupStateFault(try InvalidClusterSubnetGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterTrackFault" : self = .invalidClusterTrackFault(try InvalidClusterTrackFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidElasticIpFault" : self = .invalidElasticIpFault(try InvalidElasticIpFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRetentionPeriodFault" : self = .invalidRetentionPeriodFault(try InvalidRetentionPeriodFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagFault" : self = .invalidTagFault(try InvalidTagFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededFault" : self = .limitExceededFault(try LimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NumberOfNodesPerClusterLimitExceededFault" : self = .numberOfNodesPerClusterLimitExceededFault(try NumberOfNodesPerClusterLimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NumberOfNodesQuotaExceededFault" : self = .numberOfNodesQuotaExceededFault(try NumberOfNodesQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotScheduleNotFoundFault" : self = .snapshotScheduleNotFoundFault(try SnapshotScheduleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagLimitExceededFault" : self = .tagLimitExceededFault(try TagLimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateClusterOutputError: Swift.Error, Swift.Equatable {
    case clusterAlreadyExistsFault(ClusterAlreadyExistsFault)
    case clusterParameterGroupNotFoundFault(ClusterParameterGroupNotFoundFault)
    case clusterQuotaExceededFault(ClusterQuotaExceededFault)
    case clusterSecurityGroupNotFoundFault(ClusterSecurityGroupNotFoundFault)
    case clusterSubnetGroupNotFoundFault(ClusterSubnetGroupNotFoundFault)
    case dependentServiceRequestThrottlingFault(DependentServiceRequestThrottlingFault)
    case hsmClientCertificateNotFoundFault(HsmClientCertificateNotFoundFault)
    case hsmConfigurationNotFoundFault(HsmConfigurationNotFoundFault)
    case insufficientClusterCapacityFault(InsufficientClusterCapacityFault)
    case invalidClusterSubnetGroupStateFault(InvalidClusterSubnetGroupStateFault)
    case invalidClusterTrackFault(InvalidClusterTrackFault)
    case invalidElasticIpFault(InvalidElasticIpFault)
    case invalidRetentionPeriodFault(InvalidRetentionPeriodFault)
    case invalidSubnet(InvalidSubnet)
    case invalidTagFault(InvalidTagFault)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case limitExceededFault(LimitExceededFault)
    case numberOfNodesPerClusterLimitExceededFault(NumberOfNodesPerClusterLimitExceededFault)
    case numberOfNodesQuotaExceededFault(NumberOfNodesQuotaExceededFault)
    case snapshotScheduleNotFoundFault(SnapshotScheduleNotFoundFault)
    case tagLimitExceededFault(TagLimitExceededFault)
    case unauthorizedOperation(UnauthorizedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateClusterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateClusterOutputResponse(cluster: \(Swift.String(describing: cluster)))"}
}

extension CreateClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct CreateClusterOutputResponse: Swift.Equatable {
    /// <p>Describes a cluster.</p>
    public let cluster: RedshiftClientTypes.Cluster?

    public init (
        cluster: RedshiftClientTypes.Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct CreateClusterOutputResponseBody: Swift.Equatable {
    public let cluster: RedshiftClientTypes.Cluster?
}

extension CreateClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cluster = "Cluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateClusterResult"))
        let clusterDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

public struct CreateClusterParameterGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateClusterParameterGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateClusterParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateClusterParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateClusterParameterGroupOutputError>
}

extension CreateClusterParameterGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateClusterParameterGroupInput(description: \(Swift.String(describing: description)), parameterGroupFamily: \(Swift.String(describing: parameterGroupFamily)), parameterGroupName: \(Swift.String(describing: parameterGroupName)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateClusterParameterGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let parameterGroupFamily = parameterGroupFamily {
            try container.encode(parameterGroupFamily, forKey: ClientRuntime.Key("ParameterGroupFamily"))
        }
        if let parameterGroupName = parameterGroupName {
            try container.encode(parameterGroupName, forKey: ClientRuntime.Key("ParameterGroupName"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateClusterParameterGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CreateClusterParameterGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateClusterParameterGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateClusterParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateClusterParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateClusterParameterGroupOutputError>
}

public struct CreateClusterParameterGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateClusterParameterGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateClusterParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateClusterParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateClusterParameterGroupOutputError>
}

/// <p></p>
public struct CreateClusterParameterGroupInput: Swift.Equatable {
    /// <p>A description of the parameter group.</p>
    public let description: Swift.String?
    /// <p>The Amazon Redshift engine version to which the cluster parameter group applies. The
    ///             cluster engine version determines the set of parameters.</p>
    ///         <p>To get a list of valid parameter group family names, you can call <a>DescribeClusterParameterGroups</a>. By default, Amazon Redshift returns a list of
    ///             all the parameter groups that are owned by your AWS account, including the default
    ///             parameter groups for each Amazon Redshift engine version. The parameter group family names
    ///             associated with the default parameter groups provide you the valid values. For example,
    ///             a valid family name is "redshift-1.0". </p>
    public let parameterGroupFamily: Swift.String?
    /// <p>The name of the cluster parameter group.</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Must be 1 to 255 alphanumeric characters or hyphens</p>
    ///             </li>
    ///             <li>
    ///                 <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Cannot end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Must be unique withing your AWS account.</p>
    ///             </li>
    ///          </ul>
    ///         <note>
    ///             <p>This value is stored as a lower-case string.</p>
    ///         </note>
    public let parameterGroupName: Swift.String?
    /// <p>A list of tag instances.</p>
    public let tags: [RedshiftClientTypes.Tag]?

    public init (
        description: Swift.String? = nil,
        parameterGroupFamily: Swift.String? = nil,
        parameterGroupName: Swift.String? = nil,
        tags: [RedshiftClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.parameterGroupFamily = parameterGroupFamily
        self.parameterGroupName = parameterGroupName
        self.tags = tags
    }
}

extension CreateClusterParameterGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateClusterParameterGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterParameterGroupAlreadyExistsFault" : self = .clusterParameterGroupAlreadyExistsFault(try ClusterParameterGroupAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterParameterGroupQuotaExceededFault" : self = .clusterParameterGroupQuotaExceededFault(try ClusterParameterGroupQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagFault" : self = .invalidTagFault(try InvalidTagFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagLimitExceededFault" : self = .tagLimitExceededFault(try TagLimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateClusterParameterGroupOutputError: Swift.Error, Swift.Equatable {
    case clusterParameterGroupAlreadyExistsFault(ClusterParameterGroupAlreadyExistsFault)
    case clusterParameterGroupQuotaExceededFault(ClusterParameterGroupQuotaExceededFault)
    case invalidTagFault(InvalidTagFault)
    case tagLimitExceededFault(TagLimitExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateClusterParameterGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateClusterParameterGroupOutputResponse(clusterParameterGroup: \(Swift.String(describing: clusterParameterGroup)))"}
}

extension CreateClusterParameterGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateClusterParameterGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clusterParameterGroup = output.clusterParameterGroup
        } else {
            self.clusterParameterGroup = nil
        }
    }
}

public struct CreateClusterParameterGroupOutputResponse: Swift.Equatable {
    /// <p>Describes a parameter group.</p>
    public let clusterParameterGroup: RedshiftClientTypes.ClusterParameterGroup?

    public init (
        clusterParameterGroup: RedshiftClientTypes.ClusterParameterGroup? = nil
    )
    {
        self.clusterParameterGroup = clusterParameterGroup
    }
}

struct CreateClusterParameterGroupOutputResponseBody: Swift.Equatable {
    public let clusterParameterGroup: RedshiftClientTypes.ClusterParameterGroup?
}

extension CreateClusterParameterGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterParameterGroup = "ClusterParameterGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateClusterParameterGroupResult"))
        let clusterParameterGroupDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.ClusterParameterGroup.self, forKey: .clusterParameterGroup)
        clusterParameterGroup = clusterParameterGroupDecoded
    }
}

public struct CreateClusterSecurityGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateClusterSecurityGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateClusterSecurityGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateClusterSecurityGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateClusterSecurityGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateClusterSecurityGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateClusterSecurityGroupOutputError>
}

extension CreateClusterSecurityGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateClusterSecurityGroupInput(clusterSecurityGroupName: \(Swift.String(describing: clusterSecurityGroupName)), description: \(Swift.String(describing: description)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateClusterSecurityGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let clusterSecurityGroupName = clusterSecurityGroupName {
            try container.encode(clusterSecurityGroupName, forKey: ClientRuntime.Key("ClusterSecurityGroupName"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateClusterSecurityGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CreateClusterSecurityGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateClusterSecurityGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateClusterSecurityGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateClusterSecurityGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateClusterSecurityGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateClusterSecurityGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateClusterSecurityGroupOutputError>
}

public struct CreateClusterSecurityGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateClusterSecurityGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateClusterSecurityGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateClusterSecurityGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateClusterSecurityGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateClusterSecurityGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateClusterSecurityGroupOutputError>
}

/// <p></p>
public struct CreateClusterSecurityGroupInput: Swift.Equatable {
    /// <p>The name for the security group. Amazon Redshift stores the value as a lowercase
    ///             string.</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Must contain no more than 255 alphanumeric characters or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Must not be "Default".</p>
    ///             </li>
    ///             <li>
    ///                 <p>Must be unique for all security groups that are created by your AWS
    ///                     account.</p>
    ///             </li>
    ///          </ul>
    ///         <p>Example: <code>examplesecuritygroup</code>
    ///         </p>
    public let clusterSecurityGroupName: Swift.String?
    /// <p>A description for the security group.</p>
    public let description: Swift.String?
    /// <p>A list of tag instances.</p>
    public let tags: [RedshiftClientTypes.Tag]?

    public init (
        clusterSecurityGroupName: Swift.String? = nil,
        description: Swift.String? = nil,
        tags: [RedshiftClientTypes.Tag]? = nil
    )
    {
        self.clusterSecurityGroupName = clusterSecurityGroupName
        self.description = description
        self.tags = tags
    }
}

extension CreateClusterSecurityGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateClusterSecurityGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterSecurityGroupAlreadyExistsFault" : self = .clusterSecurityGroupAlreadyExistsFault(try ClusterSecurityGroupAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterSecurityGroupQuotaExceededFault" : self = .clusterSecurityGroupQuotaExceededFault(try ClusterSecurityGroupQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagFault" : self = .invalidTagFault(try InvalidTagFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagLimitExceededFault" : self = .tagLimitExceededFault(try TagLimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateClusterSecurityGroupOutputError: Swift.Error, Swift.Equatable {
    case clusterSecurityGroupAlreadyExistsFault(ClusterSecurityGroupAlreadyExistsFault)
    case clusterSecurityGroupQuotaExceededFault(ClusterSecurityGroupQuotaExceededFault)
    case invalidTagFault(InvalidTagFault)
    case tagLimitExceededFault(TagLimitExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateClusterSecurityGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateClusterSecurityGroupOutputResponse(clusterSecurityGroup: \(Swift.String(describing: clusterSecurityGroup)))"}
}

extension CreateClusterSecurityGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateClusterSecurityGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clusterSecurityGroup = output.clusterSecurityGroup
        } else {
            self.clusterSecurityGroup = nil
        }
    }
}

public struct CreateClusterSecurityGroupOutputResponse: Swift.Equatable {
    /// <p>Describes a security group.</p>
    public let clusterSecurityGroup: RedshiftClientTypes.ClusterSecurityGroup?

    public init (
        clusterSecurityGroup: RedshiftClientTypes.ClusterSecurityGroup? = nil
    )
    {
        self.clusterSecurityGroup = clusterSecurityGroup
    }
}

struct CreateClusterSecurityGroupOutputResponseBody: Swift.Equatable {
    public let clusterSecurityGroup: RedshiftClientTypes.ClusterSecurityGroup?
}

extension CreateClusterSecurityGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterSecurityGroup = "ClusterSecurityGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateClusterSecurityGroupResult"))
        let clusterSecurityGroupDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.ClusterSecurityGroup.self, forKey: .clusterSecurityGroup)
        clusterSecurityGroup = clusterSecurityGroupDecoded
    }
}

public struct CreateClusterSnapshotInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateClusterSnapshotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateClusterSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateClusterSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateClusterSnapshotOutputError>
}

extension CreateClusterSnapshotInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateClusterSnapshotInput(clusterIdentifier: \(Swift.String(describing: clusterIdentifier)), manualSnapshotRetentionPeriod: \(Swift.String(describing: manualSnapshotRetentionPeriod)), snapshotIdentifier: \(Swift.String(describing: snapshotIdentifier)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateClusterSnapshotInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: ClientRuntime.Key("ClusterIdentifier"))
        }
        if let manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriod {
            try container.encode(manualSnapshotRetentionPeriod, forKey: ClientRuntime.Key("ManualSnapshotRetentionPeriod"))
        }
        if let snapshotIdentifier = snapshotIdentifier {
            try container.encode(snapshotIdentifier, forKey: ClientRuntime.Key("SnapshotIdentifier"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateClusterSnapshot", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CreateClusterSnapshotInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateClusterSnapshotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateClusterSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateClusterSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateClusterSnapshotOutputError>
}

public struct CreateClusterSnapshotInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateClusterSnapshotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateClusterSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateClusterSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateClusterSnapshotOutputError>
}

/// <p></p>
public struct CreateClusterSnapshotInput: Swift.Equatable {
    /// <p>The cluster identifier for which you want a snapshot.</p>
    public let clusterIdentifier: Swift.String?
    /// <p>The number of days that a manual snapshot is retained. If the value is -1, the manual
    ///             snapshot is retained indefinitely. </p>
    ///
    ///         <p>The value must be either -1 or an integer between 1 and 3,653.</p>
    ///
    ///         <p>The default value is -1.</p>
    public let manualSnapshotRetentionPeriod: Swift.Int?
    /// <p>A unique identifier for the snapshot that you are requesting. This identifier must
    ///             be unique for all snapshots within the AWS account.</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Cannot be null, empty, or blank</p>
    ///             </li>
    ///             <li>
    ///                 <p>Must contain from 1 to 255 alphanumeric characters or hyphens</p>
    ///             </li>
    ///             <li>
    ///                 <p>First character must be a letter</p>
    ///             </li>
    ///             <li>
    ///                 <p>Cannot end with a hyphen or contain two consecutive hyphens</p>
    ///             </li>
    ///          </ul>
    ///         <p>Example: <code>my-snapshot-id</code>
    ///         </p>
    public let snapshotIdentifier: Swift.String?
    /// <p>A list of tag instances.</p>
    public let tags: [RedshiftClientTypes.Tag]?

    public init (
        clusterIdentifier: Swift.String? = nil,
        manualSnapshotRetentionPeriod: Swift.Int? = nil,
        snapshotIdentifier: Swift.String? = nil,
        tags: [RedshiftClientTypes.Tag]? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
        self.manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriod
        self.snapshotIdentifier = snapshotIdentifier
        self.tags = tags
    }
}

extension CreateClusterSnapshotOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateClusterSnapshotOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterSnapshotAlreadyExistsFault" : self = .clusterSnapshotAlreadyExistsFault(try ClusterSnapshotAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterSnapshotQuotaExceededFault" : self = .clusterSnapshotQuotaExceededFault(try ClusterSnapshotQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRetentionPeriodFault" : self = .invalidRetentionPeriodFault(try InvalidRetentionPeriodFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagFault" : self = .invalidTagFault(try InvalidTagFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagLimitExceededFault" : self = .tagLimitExceededFault(try TagLimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateClusterSnapshotOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case clusterSnapshotAlreadyExistsFault(ClusterSnapshotAlreadyExistsFault)
    case clusterSnapshotQuotaExceededFault(ClusterSnapshotQuotaExceededFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidRetentionPeriodFault(InvalidRetentionPeriodFault)
    case invalidTagFault(InvalidTagFault)
    case tagLimitExceededFault(TagLimitExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateClusterSnapshotOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateClusterSnapshotOutputResponse(snapshot: \(Swift.String(describing: snapshot)))"}
}

extension CreateClusterSnapshotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateClusterSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.snapshot = output.snapshot
        } else {
            self.snapshot = nil
        }
    }
}

public struct CreateClusterSnapshotOutputResponse: Swift.Equatable {
    /// <p>Describes a snapshot.</p>
    public let snapshot: RedshiftClientTypes.Snapshot?

    public init (
        snapshot: RedshiftClientTypes.Snapshot? = nil
    )
    {
        self.snapshot = snapshot
    }
}

struct CreateClusterSnapshotOutputResponseBody: Swift.Equatable {
    public let snapshot: RedshiftClientTypes.Snapshot?
}

extension CreateClusterSnapshotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshot = "Snapshot"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateClusterSnapshotResult"))
        let snapshotDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.Snapshot.self, forKey: .snapshot)
        snapshot = snapshotDecoded
    }
}

public struct CreateClusterSubnetGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateClusterSubnetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateClusterSubnetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateClusterSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateClusterSubnetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateClusterSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateClusterSubnetGroupOutputError>
}

extension CreateClusterSubnetGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateClusterSubnetGroupInput(clusterSubnetGroupName: \(Swift.String(describing: clusterSubnetGroupName)), description: \(Swift.String(describing: description)), subnetIds: \(Swift.String(describing: subnetIds)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateClusterSubnetGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let clusterSubnetGroupName = clusterSubnetGroupName {
            try container.encode(clusterSubnetGroupName, forKey: ClientRuntime.Key("ClusterSubnetGroupName"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SubnetIds"))
            for (index0, string0) in subnetIds.enumerated() {
                try subnetIdsContainer.encode(string0, forKey: ClientRuntime.Key("SubnetIdentifier.\(index0.advanced(by: 1))"))
            }
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateClusterSubnetGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CreateClusterSubnetGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateClusterSubnetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateClusterSubnetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateClusterSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateClusterSubnetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateClusterSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateClusterSubnetGroupOutputError>
}

public struct CreateClusterSubnetGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateClusterSubnetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateClusterSubnetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateClusterSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateClusterSubnetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateClusterSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateClusterSubnetGroupOutputError>
}

/// <p></p>
public struct CreateClusterSubnetGroupInput: Swift.Equatable {
    /// <p>The name for the subnet group. Amazon Redshift stores the value as a lowercase
    ///             string.</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Must contain no more than 255 alphanumeric characters or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Must not be "Default".</p>
    ///             </li>
    ///             <li>
    ///                 <p>Must be unique for all subnet groups that are created by your AWS
    ///                     account.</p>
    ///             </li>
    ///          </ul>
    ///         <p>Example: <code>examplesubnetgroup</code>
    ///         </p>
    public let clusterSubnetGroupName: Swift.String?
    /// <p>A description for the subnet group.</p>
    public let description: Swift.String?
    /// <p>An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single
    ///             request.</p>
    public let subnetIds: [Swift.String]?
    /// <p>A list of tag instances.</p>
    public let tags: [RedshiftClientTypes.Tag]?

    public init (
        clusterSubnetGroupName: Swift.String? = nil,
        description: Swift.String? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [RedshiftClientTypes.Tag]? = nil
    )
    {
        self.clusterSubnetGroupName = clusterSubnetGroupName
        self.description = description
        self.subnetIds = subnetIds
        self.tags = tags
    }
}

extension CreateClusterSubnetGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateClusterSubnetGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterSubnetGroupAlreadyExistsFault" : self = .clusterSubnetGroupAlreadyExistsFault(try ClusterSubnetGroupAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterSubnetGroupQuotaExceededFault" : self = .clusterSubnetGroupQuotaExceededFault(try ClusterSubnetGroupQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterSubnetQuotaExceededFault" : self = .clusterSubnetQuotaExceededFault(try ClusterSubnetQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependentServiceRequestThrottlingFault" : self = .dependentServiceRequestThrottlingFault(try DependentServiceRequestThrottlingFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagFault" : self = .invalidTagFault(try InvalidTagFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagLimitExceededFault" : self = .tagLimitExceededFault(try TagLimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateClusterSubnetGroupOutputError: Swift.Error, Swift.Equatable {
    case clusterSubnetGroupAlreadyExistsFault(ClusterSubnetGroupAlreadyExistsFault)
    case clusterSubnetGroupQuotaExceededFault(ClusterSubnetGroupQuotaExceededFault)
    case clusterSubnetQuotaExceededFault(ClusterSubnetQuotaExceededFault)
    case dependentServiceRequestThrottlingFault(DependentServiceRequestThrottlingFault)
    case invalidSubnet(InvalidSubnet)
    case invalidTagFault(InvalidTagFault)
    case tagLimitExceededFault(TagLimitExceededFault)
    case unauthorizedOperation(UnauthorizedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateClusterSubnetGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateClusterSubnetGroupOutputResponse(clusterSubnetGroup: \(Swift.String(describing: clusterSubnetGroup)))"}
}

extension CreateClusterSubnetGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateClusterSubnetGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clusterSubnetGroup = output.clusterSubnetGroup
        } else {
            self.clusterSubnetGroup = nil
        }
    }
}

public struct CreateClusterSubnetGroupOutputResponse: Swift.Equatable {
    /// <p>Describes a subnet group.</p>
    public let clusterSubnetGroup: RedshiftClientTypes.ClusterSubnetGroup?

    public init (
        clusterSubnetGroup: RedshiftClientTypes.ClusterSubnetGroup? = nil
    )
    {
        self.clusterSubnetGroup = clusterSubnetGroup
    }
}

struct CreateClusterSubnetGroupOutputResponseBody: Swift.Equatable {
    public let clusterSubnetGroup: RedshiftClientTypes.ClusterSubnetGroup?
}

extension CreateClusterSubnetGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterSubnetGroup = "ClusterSubnetGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateClusterSubnetGroupResult"))
        let clusterSubnetGroupDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.ClusterSubnetGroup.self, forKey: .clusterSubnetGroup)
        clusterSubnetGroup = clusterSubnetGroupDecoded
    }
}

public struct CreateEndpointAccessInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEndpointAccessInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateEndpointAccessInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEndpointAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateEndpointAccessInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEndpointAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEndpointAccessOutputError>
}

extension CreateEndpointAccessInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEndpointAccessInput(clusterIdentifier: \(Swift.String(describing: clusterIdentifier)), endpointName: \(Swift.String(describing: endpointName)), resourceOwner: \(Swift.String(describing: resourceOwner)), subnetGroupName: \(Swift.String(describing: subnetGroupName)), vpcSecurityGroupIds: \(Swift.String(describing: vpcSecurityGroupIds)))"}
}

extension CreateEndpointAccessInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: ClientRuntime.Key("ClusterIdentifier"))
        }
        if let endpointName = endpointName {
            try container.encode(endpointName, forKey: ClientRuntime.Key("EndpointName"))
        }
        if let resourceOwner = resourceOwner {
            try container.encode(resourceOwner, forKey: ClientRuntime.Key("ResourceOwner"))
        }
        if let subnetGroupName = subnetGroupName {
            try container.encode(subnetGroupName, forKey: ClientRuntime.Key("SubnetGroupName"))
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: ClientRuntime.Key("VpcSecurityGroupId.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateEndpointAccess", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CreateEndpointAccessInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEndpointAccessInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateEndpointAccessInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEndpointAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateEndpointAccessInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEndpointAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEndpointAccessOutputError>
}

public struct CreateEndpointAccessInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEndpointAccessInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateEndpointAccessInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEndpointAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateEndpointAccessInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEndpointAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEndpointAccessOutputError>
}

public struct CreateEndpointAccessInput: Swift.Equatable {
    /// <p>The cluster identifier of the cluster to access.</p>
    public let clusterIdentifier: Swift.String?
    /// <p>The Redshift-managed VPC endpoint name.</p>
    ///          <p>An endpoint name must contain 1-30 characters.
    ///           Valid characters are A-Z, a-z, 0-9, and hyphen(-).
    ///           The first character must be a letter.
    ///           The name can't contain two consecutive hyphens or end with a hyphen.</p>
    public let endpointName: Swift.String?
    /// <p>The AWS account ID of the owner of the cluster. This is only required if the cluster is in another AWS account.</p>
    public let resourceOwner: Swift.String?
    /// <p>The subnet group from which Amazon Redshift chooses the subnet to deploy the endpoint.</p>
    public let subnetGroupName: Swift.String?
    /// <p>The security group that defines the ports, protocols, and sources for inbound traffic that you are authorizing into your endpoint.</p>
    public let vpcSecurityGroupIds: [Swift.String]?

    public init (
        clusterIdentifier: Swift.String? = nil,
        endpointName: Swift.String? = nil,
        resourceOwner: Swift.String? = nil,
        subnetGroupName: Swift.String? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
        self.endpointName = endpointName
        self.resourceOwner = resourceOwner
        self.subnetGroupName = subnetGroupName
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

extension CreateEndpointAccessOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateEndpointAccessOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessToClusterDeniedFault" : self = .accessToClusterDeniedFault(try AccessToClusterDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterSubnetGroupNotFoundFault" : self = .clusterSubnetGroupNotFoundFault(try ClusterSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EndpointAlreadyExistsFault" : self = .endpointAlreadyExistsFault(try EndpointAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EndpointsPerAuthorizationLimitExceededFault" : self = .endpointsPerAuthorizationLimitExceededFault(try EndpointsPerAuthorizationLimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EndpointsPerClusterLimitExceededFault" : self = .endpointsPerClusterLimitExceededFault(try EndpointsPerClusterLimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterSecurityGroupStateFault" : self = .invalidClusterSecurityGroupStateFault(try InvalidClusterSecurityGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationFault" : self = .unsupportedOperationFault(try UnsupportedOperationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateEndpointAccessOutputError: Swift.Error, Swift.Equatable {
    case accessToClusterDeniedFault(AccessToClusterDeniedFault)
    case clusterNotFoundFault(ClusterNotFoundFault)
    case clusterSubnetGroupNotFoundFault(ClusterSubnetGroupNotFoundFault)
    case endpointAlreadyExistsFault(EndpointAlreadyExistsFault)
    case endpointsPerAuthorizationLimitExceededFault(EndpointsPerAuthorizationLimitExceededFault)
    case endpointsPerClusterLimitExceededFault(EndpointsPerClusterLimitExceededFault)
    case invalidClusterSecurityGroupStateFault(InvalidClusterSecurityGroupStateFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case unauthorizedOperation(UnauthorizedOperation)
    case unsupportedOperationFault(UnsupportedOperationFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateEndpointAccessOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEndpointAccessOutputResponse(address: \(Swift.String(describing: address)), clusterIdentifier: \(Swift.String(describing: clusterIdentifier)), endpointCreateTime: \(Swift.String(describing: endpointCreateTime)), endpointName: \(Swift.String(describing: endpointName)), endpointStatus: \(Swift.String(describing: endpointStatus)), port: \(Swift.String(describing: port)), resourceOwner: \(Swift.String(describing: resourceOwner)), subnetGroupName: \(Swift.String(describing: subnetGroupName)), vpcEndpoint: \(Swift.String(describing: vpcEndpoint)), vpcSecurityGroups: \(Swift.String(describing: vpcSecurityGroups)))"}
}

extension CreateEndpointAccessOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateEndpointAccessOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.address = output.address
            self.clusterIdentifier = output.clusterIdentifier
            self.endpointCreateTime = output.endpointCreateTime
            self.endpointName = output.endpointName
            self.endpointStatus = output.endpointStatus
            self.port = output.port
            self.resourceOwner = output.resourceOwner
            self.subnetGroupName = output.subnetGroupName
            self.vpcEndpoint = output.vpcEndpoint
            self.vpcSecurityGroups = output.vpcSecurityGroups
        } else {
            self.address = nil
            self.clusterIdentifier = nil
            self.endpointCreateTime = nil
            self.endpointName = nil
            self.endpointStatus = nil
            self.port = 0
            self.resourceOwner = nil
            self.subnetGroupName = nil
            self.vpcEndpoint = nil
            self.vpcSecurityGroups = nil
        }
    }
}

/// <p>Describes a Redshift-managed VPC endpoint.</p>
public struct CreateEndpointAccessOutputResponse: Swift.Equatable {
    /// <p>The DNS address of the endpoint.</p>
    public let address: Swift.String?
    /// <p>The cluster identifier of the cluster associated with the endpoint.</p>
    public let clusterIdentifier: Swift.String?
    /// <p>The time (UTC) that the endpoint was created.</p>
    public let endpointCreateTime: ClientRuntime.Date?
    /// <p>The name of the endpoint.</p>
    public let endpointName: Swift.String?
    /// <p>The status of the endpoint.</p>
    public let endpointStatus: Swift.String?
    /// <p>The port number on which the cluster accepts incoming connections.</p>
    public let port: Swift.Int
    /// <p>The AWS account ID of the owner of the cluster.</p>
    public let resourceOwner: Swift.String?
    /// <p>The subnet group name where Amazon Redshift chooses to deploy the endpoint.</p>
    public let subnetGroupName: Swift.String?
    /// <p>The connection endpoint for connecting to an Amazon Redshift cluster through the proxy.</p>
    public let vpcEndpoint: RedshiftClientTypes.VpcEndpoint?
    /// <p>The security groups associated with the endpoint.</p>
    public let vpcSecurityGroups: [RedshiftClientTypes.VpcSecurityGroupMembership]?

    public init (
        address: Swift.String? = nil,
        clusterIdentifier: Swift.String? = nil,
        endpointCreateTime: ClientRuntime.Date? = nil,
        endpointName: Swift.String? = nil,
        endpointStatus: Swift.String? = nil,
        port: Swift.Int = 0,
        resourceOwner: Swift.String? = nil,
        subnetGroupName: Swift.String? = nil,
        vpcEndpoint: RedshiftClientTypes.VpcEndpoint? = nil,
        vpcSecurityGroups: [RedshiftClientTypes.VpcSecurityGroupMembership]? = nil
    )
    {
        self.address = address
        self.clusterIdentifier = clusterIdentifier
        self.endpointCreateTime = endpointCreateTime
        self.endpointName = endpointName
        self.endpointStatus = endpointStatus
        self.port = port
        self.resourceOwner = resourceOwner
        self.subnetGroupName = subnetGroupName
        self.vpcEndpoint = vpcEndpoint
        self.vpcSecurityGroups = vpcSecurityGroups
    }
}

struct CreateEndpointAccessOutputResponseBody: Swift.Equatable {
    public let clusterIdentifier: Swift.String?
    public let resourceOwner: Swift.String?
    public let subnetGroupName: Swift.String?
    public let endpointStatus: Swift.String?
    public let endpointName: Swift.String?
    public let endpointCreateTime: ClientRuntime.Date?
    public let port: Swift.Int
    public let address: Swift.String?
    public let vpcSecurityGroups: [RedshiftClientTypes.VpcSecurityGroupMembership]?
    public let vpcEndpoint: RedshiftClientTypes.VpcEndpoint?
}

extension CreateEndpointAccessOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
        case clusterIdentifier = "ClusterIdentifier"
        case endpointCreateTime = "EndpointCreateTime"
        case endpointName = "EndpointName"
        case endpointStatus = "EndpointStatus"
        case port = "Port"
        case resourceOwner = "ResourceOwner"
        case subnetGroupName = "SubnetGroupName"
        case vpcEndpoint = "VpcEndpoint"
        case vpcSecurityGroups = "VpcSecurityGroups"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateEndpointAccessResult"))
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let resourceOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceOwner)
        resourceOwner = resourceOwnerDecoded
        let subnetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetGroupName)
        subnetGroupName = subnetGroupNameDecoded
        let endpointStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointStatus)
        endpointStatus = endpointStatusDecoded
        let endpointNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointName)
        endpointName = endpointNameDecoded
        let endpointCreateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointCreateTime)
        var endpointCreateTimeBuffer:ClientRuntime.Date? = nil
        if let endpointCreateTimeDecoded = endpointCreateTimeDecoded {
            endpointCreateTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(endpointCreateTimeDecoded, format: .dateTime)
        }
        endpointCreateTime = endpointCreateTimeBuffer
        let portDecoded = try containerValues.decode(Swift.Int.self, forKey: .port)
        port = portDecoded
        let addressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .address)
        address = addressDecoded
        if containerValues.contains(.vpcSecurityGroups) {
            struct KeyVal0{struct VpcSecurityGroup{}}
            let vpcSecurityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.VpcSecurityGroup>.CodingKeys.self, forKey: .vpcSecurityGroups)
            if let vpcSecurityGroupsWrappedContainer = vpcSecurityGroupsWrappedContainer {
                let vpcSecurityGroupsContainer = try vpcSecurityGroupsWrappedContainer.decodeIfPresent([RedshiftClientTypes.VpcSecurityGroupMembership].self, forKey: .member)
                var vpcSecurityGroupsBuffer:[RedshiftClientTypes.VpcSecurityGroupMembership]? = nil
                if let vpcSecurityGroupsContainer = vpcSecurityGroupsContainer {
                    vpcSecurityGroupsBuffer = [RedshiftClientTypes.VpcSecurityGroupMembership]()
                    for structureContainer0 in vpcSecurityGroupsContainer {
                        vpcSecurityGroupsBuffer?.append(structureContainer0)
                    }
                }
                vpcSecurityGroups = vpcSecurityGroupsBuffer
            } else {
                vpcSecurityGroups = []
            }
        } else {
            vpcSecurityGroups = nil
        }
        let vpcEndpointDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.VpcEndpoint.self, forKey: .vpcEndpoint)
        vpcEndpoint = vpcEndpointDecoded
    }
}

public struct CreateEventSubscriptionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEventSubscriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateEventSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateEventSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEventSubscriptionOutputError>
}

extension CreateEventSubscriptionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEventSubscriptionInput(enabled: \(Swift.String(describing: enabled)), eventCategories: \(Swift.String(describing: eventCategories)), severity: \(Swift.String(describing: severity)), snsTopicArn: \(Swift.String(describing: snsTopicArn)), sourceIds: \(Swift.String(describing: sourceIds)), sourceType: \(Swift.String(describing: sourceType)), subscriptionName: \(Swift.String(describing: subscriptionName)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateEventSubscriptionInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let enabled = enabled {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let eventCategories = eventCategories {
            var eventCategoriesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EventCategories"))
            for (index0, string0) in eventCategories.enumerated() {
                try eventCategoriesContainer.encode(string0, forKey: ClientRuntime.Key("EventCategory.\(index0.advanced(by: 1))"))
            }
        }
        if let severity = severity {
            try container.encode(severity, forKey: ClientRuntime.Key("Severity"))
        }
        if let snsTopicArn = snsTopicArn {
            try container.encode(snsTopicArn, forKey: ClientRuntime.Key("SnsTopicArn"))
        }
        if let sourceIds = sourceIds {
            var sourceIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SourceIds"))
            for (index0, string0) in sourceIds.enumerated() {
                try sourceIdsContainer.encode(string0, forKey: ClientRuntime.Key("SourceId.\(index0.advanced(by: 1))"))
            }
        }
        if let sourceType = sourceType {
            try container.encode(sourceType, forKey: ClientRuntime.Key("SourceType"))
        }
        if let subscriptionName = subscriptionName {
            try container.encode(subscriptionName, forKey: ClientRuntime.Key("SubscriptionName"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateEventSubscription", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CreateEventSubscriptionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEventSubscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateEventSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateEventSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEventSubscriptionOutputError>
}

public struct CreateEventSubscriptionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEventSubscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateEventSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateEventSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEventSubscriptionOutputError>
}

/// <p></p>
public struct CreateEventSubscriptionInput: Swift.Equatable {
    /// <p>A boolean value; set to <code>true</code> to activate the subscription, and set to
    ///                 <code>false</code> to create the subscription but not activate it. </p>
    public let enabled: Swift.Bool?
    /// <p>Specifies the Amazon Redshift event categories to be published by the event notification
    ///             subscription.</p>
    ///         <p>Values: configuration, management, monitoring, security</p>
    public let eventCategories: [Swift.String]?
    /// <p>Specifies the Amazon Redshift event severity to be published by the event notification
    ///             subscription.</p>
    ///         <p>Values: ERROR, INFO</p>
    public let severity: Swift.String?
    /// <p>The Amazon Resource Name (ARN) of the Amazon SNS topic used to transmit the event
    ///             notifications. The ARN is created by Amazon SNS when you create a topic and subscribe to
    ///             it.</p>
    public let snsTopicArn: Swift.String?
    /// <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects
    ///             must be of the same type as was specified in the source type parameter. The event
    ///             subscription will return only events generated by the specified objects. If not
    ///             specified, then events are returned for all objects within the source type
    ///             specified.</p>
    ///         <p>Example: my-cluster-1, my-cluster-2</p>
    ///         <p>Example: my-snapshot-20131010</p>
    public let sourceIds: [Swift.String]?
    /// <p>The type of source that will be generating the events. For example, if you want to
    ///             be notified of events generated by a cluster, you would set this parameter to cluster.
    ///             If this value is not specified, events are returned for all Amazon Redshift objects in your
    ///             AWS account. You must specify a source type in order to specify source IDs.</p>
    ///         <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, cluster-snapshot, and scheduled-action.</p>
    public let sourceType: Swift.String?
    /// <p>The name of the event subscription to be created.</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Cannot be null, empty, or blank.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                 <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Cannot end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///          </ul>
    public let subscriptionName: Swift.String?
    /// <p>A list of tag instances.</p>
    public let tags: [RedshiftClientTypes.Tag]?

    public init (
        enabled: Swift.Bool? = nil,
        eventCategories: [Swift.String]? = nil,
        severity: Swift.String? = nil,
        snsTopicArn: Swift.String? = nil,
        sourceIds: [Swift.String]? = nil,
        sourceType: Swift.String? = nil,
        subscriptionName: Swift.String? = nil,
        tags: [RedshiftClientTypes.Tag]? = nil
    )
    {
        self.enabled = enabled
        self.eventCategories = eventCategories
        self.severity = severity
        self.snsTopicArn = snsTopicArn
        self.sourceIds = sourceIds
        self.sourceType = sourceType
        self.subscriptionName = subscriptionName
        self.tags = tags
    }
}

extension CreateEventSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateEventSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EventSubscriptionQuotaExceededFault" : self = .eventSubscriptionQuotaExceededFault(try EventSubscriptionQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagFault" : self = .invalidTagFault(try InvalidTagFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SNSInvalidTopicFault" : self = .sNSInvalidTopicFault(try SNSInvalidTopicFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SNSNoAuthorizationFault" : self = .sNSNoAuthorizationFault(try SNSNoAuthorizationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SNSTopicArnNotFoundFault" : self = .sNSTopicArnNotFoundFault(try SNSTopicArnNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SourceNotFoundFault" : self = .sourceNotFoundFault(try SourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionAlreadyExistFault" : self = .subscriptionAlreadyExistFault(try SubscriptionAlreadyExistFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionCategoryNotFoundFault" : self = .subscriptionCategoryNotFoundFault(try SubscriptionCategoryNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionEventIdNotFoundFault" : self = .subscriptionEventIdNotFoundFault(try SubscriptionEventIdNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionSeverityNotFoundFault" : self = .subscriptionSeverityNotFoundFault(try SubscriptionSeverityNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagLimitExceededFault" : self = .tagLimitExceededFault(try TagLimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateEventSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case eventSubscriptionQuotaExceededFault(EventSubscriptionQuotaExceededFault)
    case invalidTagFault(InvalidTagFault)
    case sNSInvalidTopicFault(SNSInvalidTopicFault)
    case sNSNoAuthorizationFault(SNSNoAuthorizationFault)
    case sNSTopicArnNotFoundFault(SNSTopicArnNotFoundFault)
    case sourceNotFoundFault(SourceNotFoundFault)
    case subscriptionAlreadyExistFault(SubscriptionAlreadyExistFault)
    case subscriptionCategoryNotFoundFault(SubscriptionCategoryNotFoundFault)
    case subscriptionEventIdNotFoundFault(SubscriptionEventIdNotFoundFault)
    case subscriptionSeverityNotFoundFault(SubscriptionSeverityNotFoundFault)
    case tagLimitExceededFault(TagLimitExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateEventSubscriptionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEventSubscriptionOutputResponse(eventSubscription: \(Swift.String(describing: eventSubscription)))"}
}

extension CreateEventSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateEventSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventSubscription = output.eventSubscription
        } else {
            self.eventSubscription = nil
        }
    }
}

public struct CreateEventSubscriptionOutputResponse: Swift.Equatable {
    /// <p>Describes event subscriptions.</p>
    public let eventSubscription: RedshiftClientTypes.EventSubscription?

    public init (
        eventSubscription: RedshiftClientTypes.EventSubscription? = nil
    )
    {
        self.eventSubscription = eventSubscription
    }
}

struct CreateEventSubscriptionOutputResponseBody: Swift.Equatable {
    public let eventSubscription: RedshiftClientTypes.EventSubscription?
}

extension CreateEventSubscriptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSubscription = "EventSubscription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateEventSubscriptionResult"))
        let eventSubscriptionDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.EventSubscription.self, forKey: .eventSubscription)
        eventSubscription = eventSubscriptionDecoded
    }
}

public struct CreateHsmClientCertificateInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateHsmClientCertificateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateHsmClientCertificateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateHsmClientCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateHsmClientCertificateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateHsmClientCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateHsmClientCertificateOutputError>
}

extension CreateHsmClientCertificateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateHsmClientCertificateInput(hsmClientCertificateIdentifier: \(Swift.String(describing: hsmClientCertificateIdentifier)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateHsmClientCertificateInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let hsmClientCertificateIdentifier = hsmClientCertificateIdentifier {
            try container.encode(hsmClientCertificateIdentifier, forKey: ClientRuntime.Key("HsmClientCertificateIdentifier"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateHsmClientCertificate", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CreateHsmClientCertificateInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateHsmClientCertificateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateHsmClientCertificateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateHsmClientCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateHsmClientCertificateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateHsmClientCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateHsmClientCertificateOutputError>
}

public struct CreateHsmClientCertificateInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateHsmClientCertificateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateHsmClientCertificateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateHsmClientCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateHsmClientCertificateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateHsmClientCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateHsmClientCertificateOutputError>
}

/// <p></p>
public struct CreateHsmClientCertificateInput: Swift.Equatable {
    /// <p>The identifier to be assigned to the new HSM client certificate that the cluster
    ///             will use to connect to the HSM to use the database encryption keys.</p>
    public let hsmClientCertificateIdentifier: Swift.String?
    /// <p>A list of tag instances.</p>
    public let tags: [RedshiftClientTypes.Tag]?

    public init (
        hsmClientCertificateIdentifier: Swift.String? = nil,
        tags: [RedshiftClientTypes.Tag]? = nil
    )
    {
        self.hsmClientCertificateIdentifier = hsmClientCertificateIdentifier
        self.tags = tags
    }
}

extension CreateHsmClientCertificateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateHsmClientCertificateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "HsmClientCertificateAlreadyExistsFault" : self = .hsmClientCertificateAlreadyExistsFault(try HsmClientCertificateAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HsmClientCertificateQuotaExceededFault" : self = .hsmClientCertificateQuotaExceededFault(try HsmClientCertificateQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagFault" : self = .invalidTagFault(try InvalidTagFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagLimitExceededFault" : self = .tagLimitExceededFault(try TagLimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateHsmClientCertificateOutputError: Swift.Error, Swift.Equatable {
    case hsmClientCertificateAlreadyExistsFault(HsmClientCertificateAlreadyExistsFault)
    case hsmClientCertificateQuotaExceededFault(HsmClientCertificateQuotaExceededFault)
    case invalidTagFault(InvalidTagFault)
    case tagLimitExceededFault(TagLimitExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateHsmClientCertificateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateHsmClientCertificateOutputResponse(hsmClientCertificate: \(Swift.String(describing: hsmClientCertificate)))"}
}

extension CreateHsmClientCertificateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateHsmClientCertificateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.hsmClientCertificate = output.hsmClientCertificate
        } else {
            self.hsmClientCertificate = nil
        }
    }
}

public struct CreateHsmClientCertificateOutputResponse: Swift.Equatable {
    /// <p>Returns information about an HSM client certificate. The certificate is stored in a
    ///             secure Hardware Storage Module (HSM), and used by the Amazon Redshift cluster to encrypt data
    ///             files.</p>
    public let hsmClientCertificate: RedshiftClientTypes.HsmClientCertificate?

    public init (
        hsmClientCertificate: RedshiftClientTypes.HsmClientCertificate? = nil
    )
    {
        self.hsmClientCertificate = hsmClientCertificate
    }
}

struct CreateHsmClientCertificateOutputResponseBody: Swift.Equatable {
    public let hsmClientCertificate: RedshiftClientTypes.HsmClientCertificate?
}

extension CreateHsmClientCertificateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hsmClientCertificate = "HsmClientCertificate"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateHsmClientCertificateResult"))
        let hsmClientCertificateDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.HsmClientCertificate.self, forKey: .hsmClientCertificate)
        hsmClientCertificate = hsmClientCertificateDecoded
    }
}

public struct CreateHsmConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateHsmConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateHsmConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateHsmConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateHsmConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateHsmConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateHsmConfigurationOutputError>
}

extension CreateHsmConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateHsmConfigurationInput(description: \(Swift.String(describing: description)), hsmConfigurationIdentifier: \(Swift.String(describing: hsmConfigurationIdentifier)), hsmIpAddress: \(Swift.String(describing: hsmIpAddress)), hsmPartitionName: \(Swift.String(describing: hsmPartitionName)), hsmPartitionPassword: \(Swift.String(describing: hsmPartitionPassword)), hsmServerPublicCertificate: \(Swift.String(describing: hsmServerPublicCertificate)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateHsmConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let hsmConfigurationIdentifier = hsmConfigurationIdentifier {
            try container.encode(hsmConfigurationIdentifier, forKey: ClientRuntime.Key("HsmConfigurationIdentifier"))
        }
        if let hsmIpAddress = hsmIpAddress {
            try container.encode(hsmIpAddress, forKey: ClientRuntime.Key("HsmIpAddress"))
        }
        if let hsmPartitionName = hsmPartitionName {
            try container.encode(hsmPartitionName, forKey: ClientRuntime.Key("HsmPartitionName"))
        }
        if let hsmPartitionPassword = hsmPartitionPassword {
            try container.encode(hsmPartitionPassword, forKey: ClientRuntime.Key("HsmPartitionPassword"))
        }
        if let hsmServerPublicCertificate = hsmServerPublicCertificate {
            try container.encode(hsmServerPublicCertificate, forKey: ClientRuntime.Key("HsmServerPublicCertificate"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateHsmConfiguration", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CreateHsmConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateHsmConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateHsmConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateHsmConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateHsmConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateHsmConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateHsmConfigurationOutputError>
}

public struct CreateHsmConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateHsmConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateHsmConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateHsmConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateHsmConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateHsmConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateHsmConfigurationOutputError>
}

/// <p></p>
public struct CreateHsmConfigurationInput: Swift.Equatable {
    /// <p>A text description of the HSM configuration to be created.</p>
    public let description: Swift.String?
    /// <p>The identifier to be assigned to the new Amazon Redshift HSM configuration.</p>
    public let hsmConfigurationIdentifier: Swift.String?
    /// <p>The IP address that the Amazon Redshift cluster must use to access the HSM.</p>
    public let hsmIpAddress: Swift.String?
    /// <p>The name of the partition in the HSM where the Amazon Redshift clusters will store their
    ///             database encryption keys.</p>
    public let hsmPartitionName: Swift.String?
    /// <p>The password required to access the HSM partition.</p>
    public let hsmPartitionPassword: Swift.String?
    /// <p>The HSMs public certificate file. When using Cloud HSM, the file name is
    ///             server.pem.</p>
    public let hsmServerPublicCertificate: Swift.String?
    /// <p>A list of tag instances.</p>
    public let tags: [RedshiftClientTypes.Tag]?

    public init (
        description: Swift.String? = nil,
        hsmConfigurationIdentifier: Swift.String? = nil,
        hsmIpAddress: Swift.String? = nil,
        hsmPartitionName: Swift.String? = nil,
        hsmPartitionPassword: Swift.String? = nil,
        hsmServerPublicCertificate: Swift.String? = nil,
        tags: [RedshiftClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.hsmConfigurationIdentifier = hsmConfigurationIdentifier
        self.hsmIpAddress = hsmIpAddress
        self.hsmPartitionName = hsmPartitionName
        self.hsmPartitionPassword = hsmPartitionPassword
        self.hsmServerPublicCertificate = hsmServerPublicCertificate
        self.tags = tags
    }
}

extension CreateHsmConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateHsmConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "HsmConfigurationAlreadyExistsFault" : self = .hsmConfigurationAlreadyExistsFault(try HsmConfigurationAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HsmConfigurationQuotaExceededFault" : self = .hsmConfigurationQuotaExceededFault(try HsmConfigurationQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagFault" : self = .invalidTagFault(try InvalidTagFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagLimitExceededFault" : self = .tagLimitExceededFault(try TagLimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateHsmConfigurationOutputError: Swift.Error, Swift.Equatable {
    case hsmConfigurationAlreadyExistsFault(HsmConfigurationAlreadyExistsFault)
    case hsmConfigurationQuotaExceededFault(HsmConfigurationQuotaExceededFault)
    case invalidTagFault(InvalidTagFault)
    case tagLimitExceededFault(TagLimitExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateHsmConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateHsmConfigurationOutputResponse(hsmConfiguration: \(Swift.String(describing: hsmConfiguration)))"}
}

extension CreateHsmConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateHsmConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.hsmConfiguration = output.hsmConfiguration
        } else {
            self.hsmConfiguration = nil
        }
    }
}

public struct CreateHsmConfigurationOutputResponse: Swift.Equatable {
    /// <p>Returns information about an HSM configuration, which is an object that describes
    ///             to Amazon Redshift clusters the information they require to connect to an HSM where they can
    ///             store database encryption keys.</p>
    public let hsmConfiguration: RedshiftClientTypes.HsmConfiguration?

    public init (
        hsmConfiguration: RedshiftClientTypes.HsmConfiguration? = nil
    )
    {
        self.hsmConfiguration = hsmConfiguration
    }
}

struct CreateHsmConfigurationOutputResponseBody: Swift.Equatable {
    public let hsmConfiguration: RedshiftClientTypes.HsmConfiguration?
}

extension CreateHsmConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hsmConfiguration = "HsmConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateHsmConfigurationResult"))
        let hsmConfigurationDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.HsmConfiguration.self, forKey: .hsmConfiguration)
        hsmConfiguration = hsmConfigurationDecoded
    }
}

public struct CreateScheduledActionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateScheduledActionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateScheduledActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateScheduledActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateScheduledActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateScheduledActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateScheduledActionOutputError>
}

extension CreateScheduledActionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateScheduledActionInput(enable: \(Swift.String(describing: enable)), endTime: \(Swift.String(describing: endTime)), iamRole: \(Swift.String(describing: iamRole)), schedule: \(Swift.String(describing: schedule)), scheduledActionDescription: \(Swift.String(describing: scheduledActionDescription)), scheduledActionName: \(Swift.String(describing: scheduledActionName)), startTime: \(Swift.String(describing: startTime)), targetAction: \(Swift.String(describing: targetAction)))"}
}

extension CreateScheduledActionInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let enable = enable {
            try container.encode(enable, forKey: ClientRuntime.Key("Enable"))
        }
        if let endTime = endTime {
            try container.encode(ClientRuntime.TimestampWrapper(endTime, format: .dateTime), forKey: ClientRuntime.Key("endTime"))
        }
        if let iamRole = iamRole {
            try container.encode(iamRole, forKey: ClientRuntime.Key("IamRole"))
        }
        if let schedule = schedule {
            try container.encode(schedule, forKey: ClientRuntime.Key("Schedule"))
        }
        if let scheduledActionDescription = scheduledActionDescription {
            try container.encode(scheduledActionDescription, forKey: ClientRuntime.Key("ScheduledActionDescription"))
        }
        if let scheduledActionName = scheduledActionName {
            try container.encode(scheduledActionName, forKey: ClientRuntime.Key("ScheduledActionName"))
        }
        if let startTime = startTime {
            try container.encode(ClientRuntime.TimestampWrapper(startTime, format: .dateTime), forKey: ClientRuntime.Key("startTime"))
        }
        if let targetAction = targetAction {
            try container.encode(targetAction, forKey: ClientRuntime.Key("TargetAction"))
        }
        try container.encode("CreateScheduledAction", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CreateScheduledActionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateScheduledActionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateScheduledActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateScheduledActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateScheduledActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateScheduledActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateScheduledActionOutputError>
}

public struct CreateScheduledActionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateScheduledActionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateScheduledActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateScheduledActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateScheduledActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateScheduledActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateScheduledActionOutputError>
}

public struct CreateScheduledActionInput: Swift.Equatable {
    /// <p>If true, the schedule is enabled. If false, the scheduled action does not trigger.
    ///             For more information about <code>state</code> of the scheduled action, see <a>ScheduledAction</a>. </p>
    public let enable: Swift.Bool?
    /// <p>The end time in UTC of the scheduled action. After this time, the scheduled action does not trigger.
    ///             For more information about this parameter, see <a>ScheduledAction</a>. </p>
    public let endTime: ClientRuntime.Date?
    /// <p>The IAM role to assume to run the target action.
    ///             For more information about this parameter, see <a>ScheduledAction</a>. </p>
    public let iamRole: Swift.String?
    /// <p>The schedule in <code>at( )</code> or <code>cron( )</code> format.
    ///             For more information about this parameter, see <a>ScheduledAction</a>.</p>
    public let schedule: Swift.String?
    /// <p>The description of the scheduled action.
    ///             </p>
    public let scheduledActionDescription: Swift.String?
    /// <p>The name of the scheduled action. The name must be unique within an account.
    ///             For more information about this parameter, see <a>ScheduledAction</a>. </p>
    public let scheduledActionName: Swift.String?
    /// <p>The start time in UTC of the scheduled action.
    ///             Before this time, the scheduled action does not trigger.
    ///             For more information about this parameter, see <a>ScheduledAction</a>.</p>
    public let startTime: ClientRuntime.Date?
    /// <p>A JSON format string of the Amazon Redshift API operation with input parameters.
    ///             For more information about this parameter, see <a>ScheduledAction</a>. </p>
    public let targetAction: RedshiftClientTypes.ScheduledActionType?

    public init (
        enable: Swift.Bool? = nil,
        endTime: ClientRuntime.Date? = nil,
        iamRole: Swift.String? = nil,
        schedule: Swift.String? = nil,
        scheduledActionDescription: Swift.String? = nil,
        scheduledActionName: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        targetAction: RedshiftClientTypes.ScheduledActionType? = nil
    )
    {
        self.enable = enable
        self.endTime = endTime
        self.iamRole = iamRole
        self.schedule = schedule
        self.scheduledActionDescription = scheduledActionDescription
        self.scheduledActionName = scheduledActionName
        self.startTime = startTime
        self.targetAction = targetAction
    }
}

extension CreateScheduledActionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateScheduledActionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidScheduledActionFault" : self = .invalidScheduledActionFault(try InvalidScheduledActionFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidScheduleFault" : self = .invalidScheduleFault(try InvalidScheduleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ScheduledActionAlreadyExistsFault" : self = .scheduledActionAlreadyExistsFault(try ScheduledActionAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ScheduledActionQuotaExceededFault" : self = .scheduledActionQuotaExceededFault(try ScheduledActionQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ScheduledActionTypeUnsupportedFault" : self = .scheduledActionTypeUnsupportedFault(try ScheduledActionTypeUnsupportedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateScheduledActionOutputError: Swift.Error, Swift.Equatable {
    case invalidScheduledActionFault(InvalidScheduledActionFault)
    case invalidScheduleFault(InvalidScheduleFault)
    case scheduledActionAlreadyExistsFault(ScheduledActionAlreadyExistsFault)
    case scheduledActionQuotaExceededFault(ScheduledActionQuotaExceededFault)
    case scheduledActionTypeUnsupportedFault(ScheduledActionTypeUnsupportedFault)
    case unauthorizedOperation(UnauthorizedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateScheduledActionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateScheduledActionOutputResponse(endTime: \(Swift.String(describing: endTime)), iamRole: \(Swift.String(describing: iamRole)), nextInvocations: \(Swift.String(describing: nextInvocations)), schedule: \(Swift.String(describing: schedule)), scheduledActionDescription: \(Swift.String(describing: scheduledActionDescription)), scheduledActionName: \(Swift.String(describing: scheduledActionName)), startTime: \(Swift.String(describing: startTime)), state: \(Swift.String(describing: state)), targetAction: \(Swift.String(describing: targetAction)))"}
}

extension CreateScheduledActionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateScheduledActionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endTime = output.endTime
            self.iamRole = output.iamRole
            self.nextInvocations = output.nextInvocations
            self.schedule = output.schedule
            self.scheduledActionDescription = output.scheduledActionDescription
            self.scheduledActionName = output.scheduledActionName
            self.startTime = output.startTime
            self.state = output.state
            self.targetAction = output.targetAction
        } else {
            self.endTime = nil
            self.iamRole = nil
            self.nextInvocations = nil
            self.schedule = nil
            self.scheduledActionDescription = nil
            self.scheduledActionName = nil
            self.startTime = nil
            self.state = nil
            self.targetAction = nil
        }
    }
}

/// <p>Describes a scheduled action. You can use a scheduled action to trigger some Amazon Redshift API operations on a schedule.
///             For information about which API operations can be scheduled, see  <a>ScheduledActionType</a>. </p>
public struct CreateScheduledActionOutputResponse: Swift.Equatable {
    /// <p>The end time in UTC when the schedule is no longer active. After this time, the scheduled action does not trigger. </p>
    public let endTime: ClientRuntime.Date?
    /// <p>The IAM role to assume to run the scheduled action.
    ///             This IAM role must have permission to run the Amazon Redshift API operation in the scheduled action.
    ///             This IAM role must allow the Amazon Redshift scheduler (Principal scheduler.redshift.amazonaws.com) to assume permissions on your behalf.
    ///
    /// For more information about the IAM role to use with the Amazon Redshift scheduler, see
    /// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html">Using Identity-Based Policies for Amazon Redshift</a>
    /// in the <i>Amazon Redshift Cluster Management Guide</i>.
    /// </p>
    public let iamRole: Swift.String?
    /// <p>List of times when the scheduled action will run. </p>
    public let nextInvocations: [ClientRuntime.Date]?
    /// <p>The schedule for a one-time (at format) or recurring (cron format) scheduled action.
    ///             Schedule invocations must be separated by at least one hour.</p>
    ///         <p>Format of at expressions is "<code>at(yyyy-mm-ddThh:mm:ss)</code>". For example, "<code>at(2016-03-04T17:27:00)</code>".</p>
    ///         <p>Format of cron expressions is "<code>cron(Minutes Hours Day-of-month Month Day-of-week Year)</code>".
    ///             For example, "<code>cron(0 10 ? * MON *)</code>". For more information, see
    ///             <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/events/ScheduledEvents.html#CronExpressions">Cron Expressions</a>
    ///             in the <i>Amazon CloudWatch Events User Guide</i>.</p>
    public let schedule: Swift.String?
    /// <p>The description of the scheduled action. </p>
    public let scheduledActionDescription: Swift.String?
    /// <p>The name of the scheduled action. </p>
    public let scheduledActionName: Swift.String?
    /// <p>The start time in UTC when the schedule is active. Before this time, the scheduled action does not trigger. </p>
    public let startTime: ClientRuntime.Date?
    /// <p>The state of the scheduled action. For example, <code>DISABLED</code>. </p>
    public let state: RedshiftClientTypes.ScheduledActionState?
    /// <p>A JSON format string of the Amazon Redshift API operation with input parameters. </p>
    ///         <p>"<code>{\"ResizeCluster\":{\"NodeType\":\"ds2.8xlarge\",\"ClusterIdentifier\":\"my-test-cluster\",\"NumberOfNodes\":3}}</code>". </p>
    public let targetAction: RedshiftClientTypes.ScheduledActionType?

    public init (
        endTime: ClientRuntime.Date? = nil,
        iamRole: Swift.String? = nil,
        nextInvocations: [ClientRuntime.Date]? = nil,
        schedule: Swift.String? = nil,
        scheduledActionDescription: Swift.String? = nil,
        scheduledActionName: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        state: RedshiftClientTypes.ScheduledActionState? = nil,
        targetAction: RedshiftClientTypes.ScheduledActionType? = nil
    )
    {
        self.endTime = endTime
        self.iamRole = iamRole
        self.nextInvocations = nextInvocations
        self.schedule = schedule
        self.scheduledActionDescription = scheduledActionDescription
        self.scheduledActionName = scheduledActionName
        self.startTime = startTime
        self.state = state
        self.targetAction = targetAction
    }
}

struct CreateScheduledActionOutputResponseBody: Swift.Equatable {
    public let scheduledActionName: Swift.String?
    public let targetAction: RedshiftClientTypes.ScheduledActionType?
    public let schedule: Swift.String?
    public let iamRole: Swift.String?
    public let scheduledActionDescription: Swift.String?
    public let state: RedshiftClientTypes.ScheduledActionState?
    public let nextInvocations: [ClientRuntime.Date]?
    public let startTime: ClientRuntime.Date?
    public let endTime: ClientRuntime.Date?
}

extension CreateScheduledActionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case iamRole = "IamRole"
        case nextInvocations = "NextInvocations"
        case schedule = "Schedule"
        case scheduledActionDescription = "ScheduledActionDescription"
        case scheduledActionName = "ScheduledActionName"
        case startTime = "StartTime"
        case state = "State"
        case targetAction = "TargetAction"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateScheduledActionResult"))
        let scheduledActionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduledActionName)
        scheduledActionName = scheduledActionNameDecoded
        let targetActionDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.ScheduledActionType.self, forKey: .targetAction)
        targetAction = targetActionDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schedule)
        schedule = scheduleDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
        let scheduledActionDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduledActionDescription)
        scheduledActionDescription = scheduledActionDescriptionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.ScheduledActionState.self, forKey: .state)
        state = stateDecoded
        if containerValues.contains(.nextInvocations) {
            struct KeyVal0{struct ScheduledActionTime{}}
            let nextInvocationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ScheduledActionTime>.CodingKeys.self, forKey: .nextInvocations)
            if let nextInvocationsWrappedContainer = nextInvocationsWrappedContainer {
                let nextInvocationsContainer = try nextInvocationsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var nextInvocationsBuffer:[ClientRuntime.Date]? = nil
                if let nextInvocationsContainer = nextInvocationsContainer {
                    nextInvocationsBuffer = [ClientRuntime.Date]()
                    for timestampContainer0 in nextInvocationsContainer {
                        try nextInvocationsBuffer?.append(ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(timestampContainer0, format: .dateTime))
                    }
                }
                nextInvocations = nextInvocationsBuffer
            } else {
                nextInvocations = []
            }
        } else {
            nextInvocations = nil
        }
        let startTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startTime)
        var startTimeBuffer:ClientRuntime.Date? = nil
        if let startTimeDecoded = startTimeDecoded {
            startTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(startTimeDecoded, format: .dateTime)
        }
        startTime = startTimeBuffer
        let endTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endTime)
        var endTimeBuffer:ClientRuntime.Date? = nil
        if let endTimeDecoded = endTimeDecoded {
            endTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(endTimeDecoded, format: .dateTime)
        }
        endTime = endTimeBuffer
    }
}

public struct CreateSnapshotCopyGrantInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSnapshotCopyGrantInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSnapshotCopyGrantInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSnapshotCopyGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSnapshotCopyGrantInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSnapshotCopyGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSnapshotCopyGrantOutputError>
}

extension CreateSnapshotCopyGrantInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSnapshotCopyGrantInput(kmsKeyId: \(Swift.String(describing: kmsKeyId)), snapshotCopyGrantName: \(Swift.String(describing: snapshotCopyGrantName)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateSnapshotCopyGrantInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: ClientRuntime.Key("KmsKeyId"))
        }
        if let snapshotCopyGrantName = snapshotCopyGrantName {
            try container.encode(snapshotCopyGrantName, forKey: ClientRuntime.Key("SnapshotCopyGrantName"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateSnapshotCopyGrant", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CreateSnapshotCopyGrantInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSnapshotCopyGrantInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSnapshotCopyGrantInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSnapshotCopyGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSnapshotCopyGrantInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSnapshotCopyGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSnapshotCopyGrantOutputError>
}

public struct CreateSnapshotCopyGrantInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSnapshotCopyGrantInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSnapshotCopyGrantInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSnapshotCopyGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSnapshotCopyGrantInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSnapshotCopyGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSnapshotCopyGrantOutputError>
}

/// <p>The result of the <code>CreateSnapshotCopyGrant</code> action.</p>
public struct CreateSnapshotCopyGrantInput: Swift.Equatable {
    /// <p>The unique identifier of the customer master key (CMK) to which to grant Amazon Redshift
    ///             permission. If no key is specified, the default key is used.</p>
    public let kmsKeyId: Swift.String?
    /// <p>The name of the snapshot copy grant. This name must be unique in the region for the
    ///             AWS account.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>Alphabetic characters must be lowercase.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>Must be unique for all clusters within an AWS account.</p>
    ///             </li>
    ///          </ul>
    public let snapshotCopyGrantName: Swift.String?
    /// <p>A list of tag instances.</p>
    public let tags: [RedshiftClientTypes.Tag]?

    public init (
        kmsKeyId: Swift.String? = nil,
        snapshotCopyGrantName: Swift.String? = nil,
        tags: [RedshiftClientTypes.Tag]? = nil
    )
    {
        self.kmsKeyId = kmsKeyId
        self.snapshotCopyGrantName = snapshotCopyGrantName
        self.tags = tags
    }
}

extension CreateSnapshotCopyGrantOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateSnapshotCopyGrantOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependentServiceRequestThrottlingFault" : self = .dependentServiceRequestThrottlingFault(try DependentServiceRequestThrottlingFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagFault" : self = .invalidTagFault(try InvalidTagFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededFault" : self = .limitExceededFault(try LimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotCopyGrantAlreadyExistsFault" : self = .snapshotCopyGrantAlreadyExistsFault(try SnapshotCopyGrantAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotCopyGrantQuotaExceededFault" : self = .snapshotCopyGrantQuotaExceededFault(try SnapshotCopyGrantQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagLimitExceededFault" : self = .tagLimitExceededFault(try TagLimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSnapshotCopyGrantOutputError: Swift.Error, Swift.Equatable {
    case dependentServiceRequestThrottlingFault(DependentServiceRequestThrottlingFault)
    case invalidTagFault(InvalidTagFault)
    case limitExceededFault(LimitExceededFault)
    case snapshotCopyGrantAlreadyExistsFault(SnapshotCopyGrantAlreadyExistsFault)
    case snapshotCopyGrantQuotaExceededFault(SnapshotCopyGrantQuotaExceededFault)
    case tagLimitExceededFault(TagLimitExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSnapshotCopyGrantOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSnapshotCopyGrantOutputResponse(snapshotCopyGrant: \(Swift.String(describing: snapshotCopyGrant)))"}
}

extension CreateSnapshotCopyGrantOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateSnapshotCopyGrantOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.snapshotCopyGrant = output.snapshotCopyGrant
        } else {
            self.snapshotCopyGrant = nil
        }
    }
}

public struct CreateSnapshotCopyGrantOutputResponse: Swift.Equatable {
    /// <p>The snapshot copy grant that grants Amazon Redshift permission to encrypt copied
    ///             snapshots with the specified customer master key (CMK) from AWS KMS in the destination
    ///             region.</p>
    ///         <p>
    /// For more information about managing snapshot copy grants, go to
    /// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a>
    /// in the <i>Amazon Redshift Cluster Management Guide</i>.
    /// </p>
    public let snapshotCopyGrant: RedshiftClientTypes.SnapshotCopyGrant?

    public init (
        snapshotCopyGrant: RedshiftClientTypes.SnapshotCopyGrant? = nil
    )
    {
        self.snapshotCopyGrant = snapshotCopyGrant
    }
}

struct CreateSnapshotCopyGrantOutputResponseBody: Swift.Equatable {
    public let snapshotCopyGrant: RedshiftClientTypes.SnapshotCopyGrant?
}

extension CreateSnapshotCopyGrantOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshotCopyGrant = "SnapshotCopyGrant"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateSnapshotCopyGrantResult"))
        let snapshotCopyGrantDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.SnapshotCopyGrant.self, forKey: .snapshotCopyGrant)
        snapshotCopyGrant = snapshotCopyGrantDecoded
    }
}

public struct CreateSnapshotScheduleInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSnapshotScheduleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSnapshotScheduleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSnapshotScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSnapshotScheduleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSnapshotScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSnapshotScheduleOutputError>
}

extension CreateSnapshotScheduleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSnapshotScheduleInput(dryRun: \(Swift.String(describing: dryRun)), nextInvocations: \(Swift.String(describing: nextInvocations)), scheduleDefinitions: \(Swift.String(describing: scheduleDefinitions)), scheduleDescription: \(Swift.String(describing: scheduleDescription)), scheduleIdentifier: \(Swift.String(describing: scheduleIdentifier)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateSnapshotScheduleInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dryRun = dryRun {
            try container.encode(dryRun, forKey: ClientRuntime.Key("DryRun"))
        }
        if let nextInvocations = nextInvocations {
            try container.encode(nextInvocations, forKey: ClientRuntime.Key("NextInvocations"))
        }
        if let scheduleDefinitions = scheduleDefinitions {
            var scheduleDefinitionsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ScheduleDefinitions"))
            for (index0, string0) in scheduleDefinitions.enumerated() {
                try scheduleDefinitionsContainer.encode(string0, forKey: ClientRuntime.Key("ScheduleDefinition.\(index0.advanced(by: 1))"))
            }
        }
        if let scheduleDescription = scheduleDescription {
            try container.encode(scheduleDescription, forKey: ClientRuntime.Key("ScheduleDescription"))
        }
        if let scheduleIdentifier = scheduleIdentifier {
            try container.encode(scheduleIdentifier, forKey: ClientRuntime.Key("ScheduleIdentifier"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateSnapshotSchedule", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CreateSnapshotScheduleInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSnapshotScheduleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSnapshotScheduleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSnapshotScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSnapshotScheduleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSnapshotScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSnapshotScheduleOutputError>
}

public struct CreateSnapshotScheduleInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSnapshotScheduleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSnapshotScheduleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSnapshotScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSnapshotScheduleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSnapshotScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSnapshotScheduleOutputError>
}

public struct CreateSnapshotScheduleInput: Swift.Equatable {
    /// <p></p>
    public let dryRun: Swift.Bool?
    /// <p></p>
    public let nextInvocations: Swift.Int?
    /// <p>The definition of the snapshot schedule. The definition is made up of schedule
    ///             expressions, for example "cron(30 12 *)" or "rate(12 hours)". </p>
    public let scheduleDefinitions: [Swift.String]?
    /// <p>The description of the snapshot schedule.</p>
    public let scheduleDescription: Swift.String?
    /// <p>A unique identifier for a snapshot schedule. Only alphanumeric characters are allowed
    ///             for the identifier.</p>
    public let scheduleIdentifier: Swift.String?
    /// <p>An optional set of tags you can use to search for the schedule.</p>
    public let tags: [RedshiftClientTypes.Tag]?

    public init (
        dryRun: Swift.Bool? = nil,
        nextInvocations: Swift.Int? = nil,
        scheduleDefinitions: [Swift.String]? = nil,
        scheduleDescription: Swift.String? = nil,
        scheduleIdentifier: Swift.String? = nil,
        tags: [RedshiftClientTypes.Tag]? = nil
    )
    {
        self.dryRun = dryRun
        self.nextInvocations = nextInvocations
        self.scheduleDefinitions = scheduleDefinitions
        self.scheduleDescription = scheduleDescription
        self.scheduleIdentifier = scheduleIdentifier
        self.tags = tags
    }
}

extension CreateSnapshotScheduleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateSnapshotScheduleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidScheduleFault" : self = .invalidScheduleFault(try InvalidScheduleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagFault" : self = .invalidTagFault(try InvalidTagFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ScheduleDefinitionTypeUnsupportedFault" : self = .scheduleDefinitionTypeUnsupportedFault(try ScheduleDefinitionTypeUnsupportedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotScheduleAlreadyExistsFault" : self = .snapshotScheduleAlreadyExistsFault(try SnapshotScheduleAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotScheduleQuotaExceededFault" : self = .snapshotScheduleQuotaExceededFault(try SnapshotScheduleQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagLimitExceededFault" : self = .tagLimitExceededFault(try TagLimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSnapshotScheduleOutputError: Swift.Error, Swift.Equatable {
    case invalidScheduleFault(InvalidScheduleFault)
    case invalidTagFault(InvalidTagFault)
    case scheduleDefinitionTypeUnsupportedFault(ScheduleDefinitionTypeUnsupportedFault)
    case snapshotScheduleAlreadyExistsFault(SnapshotScheduleAlreadyExistsFault)
    case snapshotScheduleQuotaExceededFault(SnapshotScheduleQuotaExceededFault)
    case tagLimitExceededFault(TagLimitExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSnapshotScheduleOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSnapshotScheduleOutputResponse(associatedClusterCount: \(Swift.String(describing: associatedClusterCount)), associatedClusters: \(Swift.String(describing: associatedClusters)), nextInvocations: \(Swift.String(describing: nextInvocations)), scheduleDefinitions: \(Swift.String(describing: scheduleDefinitions)), scheduleDescription: \(Swift.String(describing: scheduleDescription)), scheduleIdentifier: \(Swift.String(describing: scheduleIdentifier)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateSnapshotScheduleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateSnapshotScheduleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.associatedClusterCount = output.associatedClusterCount
            self.associatedClusters = output.associatedClusters
            self.nextInvocations = output.nextInvocations
            self.scheduleDefinitions = output.scheduleDefinitions
            self.scheduleDescription = output.scheduleDescription
            self.scheduleIdentifier = output.scheduleIdentifier
            self.tags = output.tags
        } else {
            self.associatedClusterCount = nil
            self.associatedClusters = nil
            self.nextInvocations = nil
            self.scheduleDefinitions = nil
            self.scheduleDescription = nil
            self.scheduleIdentifier = nil
            self.tags = nil
        }
    }
}

/// <p>Describes a snapshot schedule. You can set a regular interval for creating
///             snapshots of a cluster. You can also schedule snapshots for specific dates. </p>
public struct CreateSnapshotScheduleOutputResponse: Swift.Equatable {
    /// <p>The number of clusters associated with the schedule.</p>
    public let associatedClusterCount: Swift.Int?
    /// <p>A list of clusters associated with the schedule. A maximum of 100 clusters is returned.</p>
    public let associatedClusters: [RedshiftClientTypes.ClusterAssociatedToSchedule]?
    /// <p></p>
    public let nextInvocations: [ClientRuntime.Date]?
    /// <p>A list of ScheduleDefinitions.</p>
    public let scheduleDefinitions: [Swift.String]?
    /// <p>The description of the schedule.</p>
    public let scheduleDescription: Swift.String?
    /// <p>A unique identifier for the schedule.</p>
    public let scheduleIdentifier: Swift.String?
    /// <p>An optional set of tags describing the schedule.</p>
    public let tags: [RedshiftClientTypes.Tag]?

    public init (
        associatedClusterCount: Swift.Int? = nil,
        associatedClusters: [RedshiftClientTypes.ClusterAssociatedToSchedule]? = nil,
        nextInvocations: [ClientRuntime.Date]? = nil,
        scheduleDefinitions: [Swift.String]? = nil,
        scheduleDescription: Swift.String? = nil,
        scheduleIdentifier: Swift.String? = nil,
        tags: [RedshiftClientTypes.Tag]? = nil
    )
    {
        self.associatedClusterCount = associatedClusterCount
        self.associatedClusters = associatedClusters
        self.nextInvocations = nextInvocations
        self.scheduleDefinitions = scheduleDefinitions
        self.scheduleDescription = scheduleDescription
        self.scheduleIdentifier = scheduleIdentifier
        self.tags = tags
    }
}

struct CreateSnapshotScheduleOutputResponseBody: Swift.Equatable {
    public let scheduleDefinitions: [Swift.String]?
    public let scheduleIdentifier: Swift.String?
    public let scheduleDescription: Swift.String?
    public let tags: [RedshiftClientTypes.Tag]?
    public let nextInvocations: [ClientRuntime.Date]?
    public let associatedClusterCount: Swift.Int?
    public let associatedClusters: [RedshiftClientTypes.ClusterAssociatedToSchedule]?
}

extension CreateSnapshotScheduleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedClusterCount = "AssociatedClusterCount"
        case associatedClusters = "AssociatedClusters"
        case nextInvocations = "NextInvocations"
        case scheduleDefinitions = "ScheduleDefinitions"
        case scheduleDescription = "ScheduleDescription"
        case scheduleIdentifier = "ScheduleIdentifier"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateSnapshotScheduleResult"))
        if containerValues.contains(.scheduleDefinitions) {
            struct KeyVal0{struct ScheduleDefinition{}}
            let scheduleDefinitionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ScheduleDefinition>.CodingKeys.self, forKey: .scheduleDefinitions)
            if let scheduleDefinitionsWrappedContainer = scheduleDefinitionsWrappedContainer {
                let scheduleDefinitionsContainer = try scheduleDefinitionsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var scheduleDefinitionsBuffer:[Swift.String]? = nil
                if let scheduleDefinitionsContainer = scheduleDefinitionsContainer {
                    scheduleDefinitionsBuffer = [Swift.String]()
                    for stringContainer0 in scheduleDefinitionsContainer {
                        scheduleDefinitionsBuffer?.append(stringContainer0)
                    }
                }
                scheduleDefinitions = scheduleDefinitionsBuffer
            } else {
                scheduleDefinitions = []
            }
        } else {
            scheduleDefinitions = nil
        }
        let scheduleIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleIdentifier)
        scheduleIdentifier = scheduleIdentifierDecoded
        let scheduleDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleDescription)
        scheduleDescription = scheduleDescriptionDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([RedshiftClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[RedshiftClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [RedshiftClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        if containerValues.contains(.nextInvocations) {
            struct KeyVal0{struct SnapshotTime{}}
            let nextInvocationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.SnapshotTime>.CodingKeys.self, forKey: .nextInvocations)
            if let nextInvocationsWrappedContainer = nextInvocationsWrappedContainer {
                let nextInvocationsContainer = try nextInvocationsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var nextInvocationsBuffer:[ClientRuntime.Date]? = nil
                if let nextInvocationsContainer = nextInvocationsContainer {
                    nextInvocationsBuffer = [ClientRuntime.Date]()
                    for timestampContainer0 in nextInvocationsContainer {
                        try nextInvocationsBuffer?.append(ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(timestampContainer0, format: .dateTime))
                    }
                }
                nextInvocations = nextInvocationsBuffer
            } else {
                nextInvocations = []
            }
        } else {
            nextInvocations = nil
        }
        let associatedClusterCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .associatedClusterCount)
        associatedClusterCount = associatedClusterCountDecoded
        if containerValues.contains(.associatedClusters) {
            struct KeyVal0{struct ClusterAssociatedToSchedule{}}
            let associatedClustersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ClusterAssociatedToSchedule>.CodingKeys.self, forKey: .associatedClusters)
            if let associatedClustersWrappedContainer = associatedClustersWrappedContainer {
                let associatedClustersContainer = try associatedClustersWrappedContainer.decodeIfPresent([RedshiftClientTypes.ClusterAssociatedToSchedule].self, forKey: .member)
                var associatedClustersBuffer:[RedshiftClientTypes.ClusterAssociatedToSchedule]? = nil
                if let associatedClustersContainer = associatedClustersContainer {
                    associatedClustersBuffer = [RedshiftClientTypes.ClusterAssociatedToSchedule]()
                    for structureContainer0 in associatedClustersContainer {
                        associatedClustersBuffer?.append(structureContainer0)
                    }
                }
                associatedClusters = associatedClustersBuffer
            } else {
                associatedClusters = []
            }
        } else {
            associatedClusters = nil
        }
    }
}

public struct CreateTagsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTagsOutputError>
}

extension CreateTagsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateTagsInput(resourceName: \(Swift.String(describing: resourceName)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateTagsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let resourceName = resourceName {
            try container.encode(resourceName, forKey: ClientRuntime.Key("ResourceName"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateTags", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CreateTagsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTagsOutputError>
}

public struct CreateTagsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTagsOutputError>
}

/// <p>Contains the output from the <code>CreateTags</code> action. </p>
public struct CreateTagsInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) to which you want to add the tag or tags. For
    ///             example, <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>. </p>
    public let resourceName: Swift.String?
    /// <p>One or more name/value pairs to add as tags to the specified resource. Each tag
    ///             name is passed in with the parameter <code>Key</code> and the corresponding value is
    ///             passed in with the parameter <code>Value</code>. The <code>Key</code> and
    ///                 <code>Value</code> parameters are separated by a comma (,). Separate multiple tags
    ///             with a space. For example, <code>--tags "Key"="owner","Value"="admin"
    ///                 "Key"="environment","Value"="test" "Key"="version","Value"="1.0"</code>. </p>
    public let tags: [RedshiftClientTypes.Tag]?

    public init (
        resourceName: Swift.String? = nil,
        tags: [RedshiftClientTypes.Tag]? = nil
    )
    {
        self.resourceName = resourceName
        self.tags = tags
    }
}

extension CreateTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagFault" : self = .invalidTagFault(try InvalidTagFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagLimitExceededFault" : self = .tagLimitExceededFault(try TagLimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateTagsOutputError: Swift.Error, Swift.Equatable {
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidTagFault(InvalidTagFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case tagLimitExceededFault(TagLimitExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTagsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateTagsOutputResponse()"}
}

extension CreateTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CreateTagsOutputResponse: Swift.Equatable {

    public init() {}
}

struct CreateTagsOutputResponseBody: Swift.Equatable {
}

extension CreateTagsOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct CreateUsageLimitInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateUsageLimitInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateUsageLimitInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateUsageLimitOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateUsageLimitInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateUsageLimitOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateUsageLimitOutputError>
}

extension CreateUsageLimitInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateUsageLimitInput(amount: \(Swift.String(describing: amount)), breachAction: \(Swift.String(describing: breachAction)), clusterIdentifier: \(Swift.String(describing: clusterIdentifier)), featureType: \(Swift.String(describing: featureType)), limitType: \(Swift.String(describing: limitType)), period: \(Swift.String(describing: period)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateUsageLimitInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if amount != 0 {
            try container.encode(amount, forKey: ClientRuntime.Key("Amount"))
        }
        if let breachAction = breachAction {
            try container.encode(breachAction, forKey: ClientRuntime.Key("BreachAction"))
        }
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: ClientRuntime.Key("ClusterIdentifier"))
        }
        if let featureType = featureType {
            try container.encode(featureType, forKey: ClientRuntime.Key("FeatureType"))
        }
        if let limitType = limitType {
            try container.encode(limitType, forKey: ClientRuntime.Key("LimitType"))
        }
        if let period = period {
            try container.encode(period, forKey: ClientRuntime.Key("Period"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateUsageLimit", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CreateUsageLimitInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateUsageLimitInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateUsageLimitInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateUsageLimitOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateUsageLimitInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateUsageLimitOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateUsageLimitOutputError>
}

public struct CreateUsageLimitInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateUsageLimitInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateUsageLimitInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateUsageLimitOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateUsageLimitInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateUsageLimitOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateUsageLimitOutputError>
}

public struct CreateUsageLimitInput: Swift.Equatable {
    /// <p>The limit amount. If time-based, this amount is in minutes. If data-based, this amount is in terabytes (TB).
    ///             The value must be a positive number.
    ///             </p>
    public let amount: Swift.Int
    /// <p>The action that Amazon Redshift takes when the limit is reached. The default is log.
    ///             For more information about this parameter, see <a>UsageLimit</a>.</p>
    public let breachAction: RedshiftClientTypes.UsageLimitBreachAction?
    /// <p>The identifier of the cluster that you want to limit usage.</p>
    public let clusterIdentifier: Swift.String?
    /// <p>The Amazon Redshift feature that you want to limit.</p>
    public let featureType: RedshiftClientTypes.UsageLimitFeatureType?
    /// <p>The type of limit. Depending on the feature type, this can be based on a time duration or data size.
    ///             If <code>FeatureType</code> is <code>spectrum</code>, then <code>LimitType</code> must be <code>data-scanned</code>.
    ///             If <code>FeatureType</code> is <code>concurrency-scaling</code>, then <code>LimitType</code> must be <code>time</code>.
    ///            </p>
    public let limitType: RedshiftClientTypes.UsageLimitLimitType?
    /// <p>The time period that the amount applies to. A <code>weekly</code> period begins on Sunday. The default is <code>monthly</code>.
    ///             </p>
    public let period: RedshiftClientTypes.UsageLimitPeriod?
    /// <p>A list of tag instances.</p>
    public let tags: [RedshiftClientTypes.Tag]?

    public init (
        amount: Swift.Int = 0,
        breachAction: RedshiftClientTypes.UsageLimitBreachAction? = nil,
        clusterIdentifier: Swift.String? = nil,
        featureType: RedshiftClientTypes.UsageLimitFeatureType? = nil,
        limitType: RedshiftClientTypes.UsageLimitLimitType? = nil,
        period: RedshiftClientTypes.UsageLimitPeriod? = nil,
        tags: [RedshiftClientTypes.Tag]? = nil
    )
    {
        self.amount = amount
        self.breachAction = breachAction
        self.clusterIdentifier = clusterIdentifier
        self.featureType = featureType
        self.limitType = limitType
        self.period = period
        self.tags = tags
    }
}

extension CreateUsageLimitOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateUsageLimitOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidUsageLimitFault" : self = .invalidUsageLimitFault(try InvalidUsageLimitFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededFault" : self = .limitExceededFault(try LimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagLimitExceededFault" : self = .tagLimitExceededFault(try TagLimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationFault" : self = .unsupportedOperationFault(try UnsupportedOperationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UsageLimitAlreadyExistsFault" : self = .usageLimitAlreadyExistsFault(try UsageLimitAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateUsageLimitOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidUsageLimitFault(InvalidUsageLimitFault)
    case limitExceededFault(LimitExceededFault)
    case tagLimitExceededFault(TagLimitExceededFault)
    case unsupportedOperationFault(UnsupportedOperationFault)
    case usageLimitAlreadyExistsFault(UsageLimitAlreadyExistsFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUsageLimitOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateUsageLimitOutputResponse(amount: \(Swift.String(describing: amount)), breachAction: \(Swift.String(describing: breachAction)), clusterIdentifier: \(Swift.String(describing: clusterIdentifier)), featureType: \(Swift.String(describing: featureType)), limitType: \(Swift.String(describing: limitType)), period: \(Swift.String(describing: period)), tags: \(Swift.String(describing: tags)), usageLimitId: \(Swift.String(describing: usageLimitId)))"}
}

extension CreateUsageLimitOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateUsageLimitOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.amount = output.amount
            self.breachAction = output.breachAction
            self.clusterIdentifier = output.clusterIdentifier
            self.featureType = output.featureType
            self.limitType = output.limitType
            self.period = output.period
            self.tags = output.tags
            self.usageLimitId = output.usageLimitId
        } else {
            self.amount = 0
            self.breachAction = nil
            self.clusterIdentifier = nil
            self.featureType = nil
            self.limitType = nil
            self.period = nil
            self.tags = nil
            self.usageLimitId = nil
        }
    }
}

/// <p>Describes a usage limit object for a cluster. </p>
public struct CreateUsageLimitOutputResponse: Swift.Equatable {
    /// <p>The limit amount. If time-based, this amount is in minutes. If data-based, this amount is in terabytes (TB).</p>
    public let amount: Swift.Int
    /// <p>The action that Amazon Redshift takes when the limit is reached. Possible values are: </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>log</b> - To log an event in a system table. The default is log.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>emit-metric</b> - To emit CloudWatch metrics.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>disable</b> - To disable the feature until the next usage period begins.</p>
    ///             </li>
    ///          </ul>
    public let breachAction: RedshiftClientTypes.UsageLimitBreachAction?
    /// <p>The identifier of the cluster with a usage limit.</p>
    public let clusterIdentifier: Swift.String?
    /// <p>The Amazon Redshift feature to which the limit applies.</p>
    public let featureType: RedshiftClientTypes.UsageLimitFeatureType?
    /// <p>The type of limit. Depending on the feature type, this can be based on a time duration or data size.</p>
    public let limitType: RedshiftClientTypes.UsageLimitLimitType?
    /// <p>The time period that the amount applies to. A <code>weekly</code> period begins on Sunday. The default is <code>monthly</code>. </p>
    public let period: RedshiftClientTypes.UsageLimitPeriod?
    /// <p>A list of tag instances.</p>
    public let tags: [RedshiftClientTypes.Tag]?
    /// <p>The identifier of the usage limit.</p>
    public let usageLimitId: Swift.String?

    public init (
        amount: Swift.Int = 0,
        breachAction: RedshiftClientTypes.UsageLimitBreachAction? = nil,
        clusterIdentifier: Swift.String? = nil,
        featureType: RedshiftClientTypes.UsageLimitFeatureType? = nil,
        limitType: RedshiftClientTypes.UsageLimitLimitType? = nil,
        period: RedshiftClientTypes.UsageLimitPeriod? = nil,
        tags: [RedshiftClientTypes.Tag]? = nil,
        usageLimitId: Swift.String? = nil
    )
    {
        self.amount = amount
        self.breachAction = breachAction
        self.clusterIdentifier = clusterIdentifier
        self.featureType = featureType
        self.limitType = limitType
        self.period = period
        self.tags = tags
        self.usageLimitId = usageLimitId
    }
}

struct CreateUsageLimitOutputResponseBody: Swift.Equatable {
    public let usageLimitId: Swift.String?
    public let clusterIdentifier: Swift.String?
    public let featureType: RedshiftClientTypes.UsageLimitFeatureType?
    public let limitType: RedshiftClientTypes.UsageLimitLimitType?
    public let amount: Swift.Int
    public let period: RedshiftClientTypes.UsageLimitPeriod?
    public let breachAction: RedshiftClientTypes.UsageLimitBreachAction?
    public let tags: [RedshiftClientTypes.Tag]?
}

extension CreateUsageLimitOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amount = "Amount"
        case breachAction = "BreachAction"
        case clusterIdentifier = "ClusterIdentifier"
        case featureType = "FeatureType"
        case limitType = "LimitType"
        case period = "Period"
        case tags = "Tags"
        case usageLimitId = "UsageLimitId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateUsageLimitResult"))
        let usageLimitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .usageLimitId)
        usageLimitId = usageLimitIdDecoded
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let featureTypeDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.UsageLimitFeatureType.self, forKey: .featureType)
        featureType = featureTypeDecoded
        let limitTypeDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.UsageLimitLimitType.self, forKey: .limitType)
        limitType = limitTypeDecoded
        let amountDecoded = try containerValues.decode(Swift.Int.self, forKey: .amount)
        amount = amountDecoded
        let periodDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.UsageLimitPeriod.self, forKey: .period)
        period = periodDecoded
        let breachActionDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.UsageLimitBreachAction.self, forKey: .breachAction)
        breachAction = breachActionDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([RedshiftClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[RedshiftClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [RedshiftClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension RedshiftClientTypes.DataTransferProgress: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentRateInMegaBytesPerSecond = "CurrentRateInMegaBytesPerSecond"
        case dataTransferredInMegaBytes = "DataTransferredInMegaBytes"
        case elapsedTimeInSeconds = "ElapsedTimeInSeconds"
        case estimatedTimeToCompletionInSeconds = "EstimatedTimeToCompletionInSeconds"
        case status = "Status"
        case totalDataInMegaBytes = "TotalDataInMegaBytes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let currentRateInMegaBytesPerSecond = currentRateInMegaBytesPerSecond {
            try container.encode(currentRateInMegaBytesPerSecond, forKey: ClientRuntime.Key("CurrentRateInMegaBytesPerSecond"))
        }
        if dataTransferredInMegaBytes != 0 {
            try container.encode(dataTransferredInMegaBytes, forKey: ClientRuntime.Key("DataTransferredInMegaBytes"))
        }
        if let elapsedTimeInSeconds = elapsedTimeInSeconds {
            try container.encode(elapsedTimeInSeconds, forKey: ClientRuntime.Key("ElapsedTimeInSeconds"))
        }
        if let estimatedTimeToCompletionInSeconds = estimatedTimeToCompletionInSeconds {
            try container.encode(estimatedTimeToCompletionInSeconds, forKey: ClientRuntime.Key("EstimatedTimeToCompletionInSeconds"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if totalDataInMegaBytes != 0 {
            try container.encode(totalDataInMegaBytes, forKey: ClientRuntime.Key("TotalDataInMegaBytes"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let currentRateInMegaBytesPerSecondDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .currentRateInMegaBytesPerSecond)
        currentRateInMegaBytesPerSecond = currentRateInMegaBytesPerSecondDecoded
        let totalDataInMegaBytesDecoded = try containerValues.decode(Swift.Int.self, forKey: .totalDataInMegaBytes)
        totalDataInMegaBytes = totalDataInMegaBytesDecoded
        let dataTransferredInMegaBytesDecoded = try containerValues.decode(Swift.Int.self, forKey: .dataTransferredInMegaBytes)
        dataTransferredInMegaBytes = dataTransferredInMegaBytesDecoded
        let estimatedTimeToCompletionInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .estimatedTimeToCompletionInSeconds)
        estimatedTimeToCompletionInSeconds = estimatedTimeToCompletionInSecondsDecoded
        let elapsedTimeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .elapsedTimeInSeconds)
        elapsedTimeInSeconds = elapsedTimeInSecondsDecoded
    }
}

extension RedshiftClientTypes.DataTransferProgress: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataTransferProgress(currentRateInMegaBytesPerSecond: \(Swift.String(describing: currentRateInMegaBytesPerSecond)), dataTransferredInMegaBytes: \(Swift.String(describing: dataTransferredInMegaBytes)), elapsedTimeInSeconds: \(Swift.String(describing: elapsedTimeInSeconds)), estimatedTimeToCompletionInSeconds: \(Swift.String(describing: estimatedTimeToCompletionInSeconds)), status: \(Swift.String(describing: status)), totalDataInMegaBytes: \(Swift.String(describing: totalDataInMegaBytes)))"}
}

extension RedshiftClientTypes {
    /// <p>Describes the status of a cluster while it is in the process of resizing with an
    ///             incremental resize.</p>
    public struct DataTransferProgress: Swift.Equatable {
        /// <p>Describes the data transfer rate in MB's per second.</p>
        public let currentRateInMegaBytesPerSecond: Swift.Double?
        /// <p>Describes the total amount of data that has been transfered in MB's.</p>
        public let dataTransferredInMegaBytes: Swift.Int
        /// <p>Describes the number of seconds that have elapsed during the data transfer.</p>
        public let elapsedTimeInSeconds: Swift.Int?
        /// <p>Describes the estimated number of seconds remaining to complete the transfer.</p>
        public let estimatedTimeToCompletionInSeconds: Swift.Int?
        /// <p>Describes the status of the cluster. While the transfer is in progress the status is
        ///                 <code>transferringdata</code>.</p>
        public let status: Swift.String?
        /// <p>Describes the total amount of data to be transfered in megabytes.</p>
        public let totalDataInMegaBytes: Swift.Int

        public init (
            currentRateInMegaBytesPerSecond: Swift.Double? = nil,
            dataTransferredInMegaBytes: Swift.Int = 0,
            elapsedTimeInSeconds: Swift.Int? = nil,
            estimatedTimeToCompletionInSeconds: Swift.Int? = nil,
            status: Swift.String? = nil,
            totalDataInMegaBytes: Swift.Int = 0
        )
        {
            self.currentRateInMegaBytesPerSecond = currentRateInMegaBytesPerSecond
            self.dataTransferredInMegaBytes = dataTransferredInMegaBytes
            self.elapsedTimeInSeconds = elapsedTimeInSeconds
            self.estimatedTimeToCompletionInSeconds = estimatedTimeToCompletionInSeconds
            self.status = status
            self.totalDataInMegaBytes = totalDataInMegaBytes
        }
    }

}

extension RedshiftClientTypes.DefaultClusterParameters: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case parameterGroupFamily = "ParameterGroupFamily"
        case parameters = "Parameters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let parameterGroupFamily = parameterGroupFamily {
            try container.encode(parameterGroupFamily, forKey: ClientRuntime.Key("ParameterGroupFamily"))
        }
        if let parameters = parameters {
            var parametersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Parameters"))
            for (index0, parameter0) in parameters.enumerated() {
                try parametersContainer.encode(parameter0, forKey: ClientRuntime.Key("Parameter.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterGroupFamilyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterGroupFamily)
        parameterGroupFamily = parameterGroupFamilyDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.parameters) {
            struct KeyVal0{struct Parameter{}}
            let parametersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Parameter>.CodingKeys.self, forKey: .parameters)
            if let parametersWrappedContainer = parametersWrappedContainer {
                let parametersContainer = try parametersWrappedContainer.decodeIfPresent([RedshiftClientTypes.Parameter].self, forKey: .member)
                var parametersBuffer:[RedshiftClientTypes.Parameter]? = nil
                if let parametersContainer = parametersContainer {
                    parametersBuffer = [RedshiftClientTypes.Parameter]()
                    for structureContainer0 in parametersContainer {
                        parametersBuffer?.append(structureContainer0)
                    }
                }
                parameters = parametersBuffer
            } else {
                parameters = []
            }
        } else {
            parameters = nil
        }
    }
}

extension RedshiftClientTypes.DefaultClusterParameters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DefaultClusterParameters(marker: \(Swift.String(describing: marker)), parameterGroupFamily: \(Swift.String(describing: parameterGroupFamily)), parameters: \(Swift.String(describing: parameters)))"}
}

extension RedshiftClientTypes {
    /// <p>Describes the default cluster parameters for a parameter group family.</p>
    public struct DefaultClusterParameters: Swift.Equatable {
        /// <p>A value that indicates the starting point for the next set of response records in a
        ///             subsequent request. If a value is returned in a response, you can retrieve the next set
        ///             of records by providing this returned marker value in the <code>Marker</code> parameter
        ///             and retrying the command. If the <code>Marker</code> field is empty, all response
        ///             records have been retrieved for the request. </p>
        public let marker: Swift.String?
        /// <p>The name of the cluster parameter group family to which the engine default
        ///             parameters apply.</p>
        public let parameterGroupFamily: Swift.String?
        /// <p>The list of cluster default parameters.</p>
        public let parameters: [RedshiftClientTypes.Parameter]?

        public init (
            marker: Swift.String? = nil,
            parameterGroupFamily: Swift.String? = nil,
            parameters: [RedshiftClientTypes.Parameter]? = nil
        )
        {
            self.marker = marker
            self.parameterGroupFamily = parameterGroupFamily
            self.parameters = parameters
        }
    }

}

extension RedshiftClientTypes.DeferredMaintenanceWindow: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deferMaintenanceEndTime = "DeferMaintenanceEndTime"
        case deferMaintenanceIdentifier = "DeferMaintenanceIdentifier"
        case deferMaintenanceStartTime = "DeferMaintenanceStartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let deferMaintenanceEndTime = deferMaintenanceEndTime {
            try container.encode(ClientRuntime.TimestampWrapper(deferMaintenanceEndTime, format: .dateTime), forKey: ClientRuntime.Key("deferMaintenanceEndTime"))
        }
        if let deferMaintenanceIdentifier = deferMaintenanceIdentifier {
            try container.encode(deferMaintenanceIdentifier, forKey: ClientRuntime.Key("DeferMaintenanceIdentifier"))
        }
        if let deferMaintenanceStartTime = deferMaintenanceStartTime {
            try container.encode(ClientRuntime.TimestampWrapper(deferMaintenanceStartTime, format: .dateTime), forKey: ClientRuntime.Key("deferMaintenanceStartTime"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deferMaintenanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deferMaintenanceIdentifier)
        deferMaintenanceIdentifier = deferMaintenanceIdentifierDecoded
        let deferMaintenanceStartTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deferMaintenanceStartTime)
        var deferMaintenanceStartTimeBuffer:ClientRuntime.Date? = nil
        if let deferMaintenanceStartTimeDecoded = deferMaintenanceStartTimeDecoded {
            deferMaintenanceStartTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(deferMaintenanceStartTimeDecoded, format: .dateTime)
        }
        deferMaintenanceStartTime = deferMaintenanceStartTimeBuffer
        let deferMaintenanceEndTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deferMaintenanceEndTime)
        var deferMaintenanceEndTimeBuffer:ClientRuntime.Date? = nil
        if let deferMaintenanceEndTimeDecoded = deferMaintenanceEndTimeDecoded {
            deferMaintenanceEndTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(deferMaintenanceEndTimeDecoded, format: .dateTime)
        }
        deferMaintenanceEndTime = deferMaintenanceEndTimeBuffer
    }
}

extension RedshiftClientTypes.DeferredMaintenanceWindow: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeferredMaintenanceWindow(deferMaintenanceEndTime: \(Swift.String(describing: deferMaintenanceEndTime)), deferMaintenanceIdentifier: \(Swift.String(describing: deferMaintenanceIdentifier)), deferMaintenanceStartTime: \(Swift.String(describing: deferMaintenanceStartTime)))"}
}

extension RedshiftClientTypes {
    /// <p>Describes a deferred maintenance window</p>
    public struct DeferredMaintenanceWindow: Swift.Equatable {
        /// <p> A timestamp for the end of the time period when we defer maintenance.</p>
        public let deferMaintenanceEndTime: ClientRuntime.Date?
        /// <p>A unique identifier for the maintenance window.</p>
        public let deferMaintenanceIdentifier: Swift.String?
        /// <p> A timestamp for the beginning of the time period when we defer maintenance.</p>
        public let deferMaintenanceStartTime: ClientRuntime.Date?

        public init (
            deferMaintenanceEndTime: ClientRuntime.Date? = nil,
            deferMaintenanceIdentifier: Swift.String? = nil,
            deferMaintenanceStartTime: ClientRuntime.Date? = nil
        )
        {
            self.deferMaintenanceEndTime = deferMaintenanceEndTime
            self.deferMaintenanceIdentifier = deferMaintenanceIdentifier
            self.deferMaintenanceStartTime = deferMaintenanceStartTime
        }
    }

}

public struct DeleteClusterInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteClusterOutputError>
}

extension DeleteClusterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteClusterInput(clusterIdentifier: \(Swift.String(describing: clusterIdentifier)), finalClusterSnapshotIdentifier: \(Swift.String(describing: finalClusterSnapshotIdentifier)), finalClusterSnapshotRetentionPeriod: \(Swift.String(describing: finalClusterSnapshotRetentionPeriod)), skipFinalClusterSnapshot: \(Swift.String(describing: skipFinalClusterSnapshot)))"}
}

extension DeleteClusterInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: ClientRuntime.Key("ClusterIdentifier"))
        }
        if let finalClusterSnapshotIdentifier = finalClusterSnapshotIdentifier {
            try container.encode(finalClusterSnapshotIdentifier, forKey: ClientRuntime.Key("FinalClusterSnapshotIdentifier"))
        }
        if let finalClusterSnapshotRetentionPeriod = finalClusterSnapshotRetentionPeriod {
            try container.encode(finalClusterSnapshotRetentionPeriod, forKey: ClientRuntime.Key("FinalClusterSnapshotRetentionPeriod"))
        }
        if skipFinalClusterSnapshot != false {
            try container.encode(skipFinalClusterSnapshot, forKey: ClientRuntime.Key("SkipFinalClusterSnapshot"))
        }
        try container.encode("DeleteCluster", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DeleteClusterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteClusterOutputError>
}

public struct DeleteClusterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteClusterOutputError>
}

/// <p></p>
public struct DeleteClusterInput: Swift.Equatable {
    /// <p>The identifier of the cluster to be deleted.</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Must contain lowercase characters.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                 <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Cannot end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///          </ul>
    public let clusterIdentifier: Swift.String?
    /// <p>The identifier of the final snapshot that is to be created immediately before
    ///             deleting the cluster. If this parameter is provided,
    ///                 <i>SkipFinalClusterSnapshot</i> must be <code>false</code>. </p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Must be 1 to 255 alphanumeric characters.</p>
    ///             </li>
    ///             <li>
    ///                 <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Cannot end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///          </ul>
    public let finalClusterSnapshotIdentifier: Swift.String?
    /// <p>The number of days that a manual snapshot is retained. If the value is -1, the manual
    ///             snapshot is retained indefinitely.</p>
    ///         <p>The value must be either -1 or an integer between 1 and 3,653.</p>
    ///         <p>The default value is -1.</p>
    public let finalClusterSnapshotRetentionPeriod: Swift.Int?
    /// <p>Determines whether a final snapshot of the cluster is created before Amazon Redshift
    ///             deletes the cluster. If <code>true</code>, a final cluster snapshot is not created. If
    ///                 <code>false</code>, a final cluster snapshot is created before the cluster is
    ///             deleted. </p>
    ///         <note>
    ///             <p>The <i>FinalClusterSnapshotIdentifier</i> parameter must be
    ///                 specified if <i>SkipFinalClusterSnapshot</i> is
    ///                 <code>false</code>.</p>
    ///         </note>
    ///         <p>Default: <code>false</code>
    ///         </p>
    public let skipFinalClusterSnapshot: Swift.Bool

    public init (
        clusterIdentifier: Swift.String? = nil,
        finalClusterSnapshotIdentifier: Swift.String? = nil,
        finalClusterSnapshotRetentionPeriod: Swift.Int? = nil,
        skipFinalClusterSnapshot: Swift.Bool = false
    )
    {
        self.clusterIdentifier = clusterIdentifier
        self.finalClusterSnapshotIdentifier = finalClusterSnapshotIdentifier
        self.finalClusterSnapshotRetentionPeriod = finalClusterSnapshotRetentionPeriod
        self.skipFinalClusterSnapshot = skipFinalClusterSnapshot
    }
}

extension DeleteClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterSnapshotAlreadyExistsFault" : self = .clusterSnapshotAlreadyExistsFault(try ClusterSnapshotAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterSnapshotQuotaExceededFault" : self = .clusterSnapshotQuotaExceededFault(try ClusterSnapshotQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRetentionPeriodFault" : self = .invalidRetentionPeriodFault(try InvalidRetentionPeriodFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteClusterOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case clusterSnapshotAlreadyExistsFault(ClusterSnapshotAlreadyExistsFault)
    case clusterSnapshotQuotaExceededFault(ClusterSnapshotQuotaExceededFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidRetentionPeriodFault(InvalidRetentionPeriodFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteClusterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteClusterOutputResponse(cluster: \(Swift.String(describing: cluster)))"}
}

extension DeleteClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct DeleteClusterOutputResponse: Swift.Equatable {
    /// <p>Describes a cluster.</p>
    public let cluster: RedshiftClientTypes.Cluster?

    public init (
        cluster: RedshiftClientTypes.Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct DeleteClusterOutputResponseBody: Swift.Equatable {
    public let cluster: RedshiftClientTypes.Cluster?
}

extension DeleteClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cluster = "Cluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DeleteClusterResult"))
        let clusterDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

public struct DeleteClusterParameterGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteClusterParameterGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteClusterParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteClusterParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteClusterParameterGroupOutputError>
}

extension DeleteClusterParameterGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteClusterParameterGroupInput(parameterGroupName: \(Swift.String(describing: parameterGroupName)))"}
}

extension DeleteClusterParameterGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let parameterGroupName = parameterGroupName {
            try container.encode(parameterGroupName, forKey: ClientRuntime.Key("ParameterGroupName"))
        }
        try container.encode("DeleteClusterParameterGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DeleteClusterParameterGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteClusterParameterGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteClusterParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteClusterParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteClusterParameterGroupOutputError>
}

public struct DeleteClusterParameterGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteClusterParameterGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteClusterParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteClusterParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteClusterParameterGroupOutputError>
}

/// <p></p>
public struct DeleteClusterParameterGroupInput: Swift.Equatable {
    /// <p>The name of the parameter group to be deleted.</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Must be the name of an existing cluster parameter group.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Cannot delete a default cluster parameter group.</p>
    ///             </li>
    ///          </ul>
    public let parameterGroupName: Swift.String?

    public init (
        parameterGroupName: Swift.String? = nil
    )
    {
        self.parameterGroupName = parameterGroupName
    }
}

extension DeleteClusterParameterGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteClusterParameterGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterParameterGroupNotFoundFault" : self = .clusterParameterGroupNotFoundFault(try ClusterParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterParameterGroupStateFault" : self = .invalidClusterParameterGroupStateFault(try InvalidClusterParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteClusterParameterGroupOutputError: Swift.Error, Swift.Equatable {
    case clusterParameterGroupNotFoundFault(ClusterParameterGroupNotFoundFault)
    case invalidClusterParameterGroupStateFault(InvalidClusterParameterGroupStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteClusterParameterGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteClusterParameterGroupOutputResponse()"}
}

extension DeleteClusterParameterGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteClusterParameterGroupOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteClusterParameterGroupOutputResponseBody: Swift.Equatable {
}

extension DeleteClusterParameterGroupOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteClusterSecurityGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteClusterSecurityGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteClusterSecurityGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteClusterSecurityGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteClusterSecurityGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteClusterSecurityGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteClusterSecurityGroupOutputError>
}

extension DeleteClusterSecurityGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteClusterSecurityGroupInput(clusterSecurityGroupName: \(Swift.String(describing: clusterSecurityGroupName)))"}
}

extension DeleteClusterSecurityGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let clusterSecurityGroupName = clusterSecurityGroupName {
            try container.encode(clusterSecurityGroupName, forKey: ClientRuntime.Key("ClusterSecurityGroupName"))
        }
        try container.encode("DeleteClusterSecurityGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DeleteClusterSecurityGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteClusterSecurityGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteClusterSecurityGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteClusterSecurityGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteClusterSecurityGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteClusterSecurityGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteClusterSecurityGroupOutputError>
}

public struct DeleteClusterSecurityGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteClusterSecurityGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteClusterSecurityGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteClusterSecurityGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteClusterSecurityGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteClusterSecurityGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteClusterSecurityGroupOutputError>
}

/// <p></p>
public struct DeleteClusterSecurityGroupInput: Swift.Equatable {
    /// <p>The name of the cluster security group to be deleted.</p>
    public let clusterSecurityGroupName: Swift.String?

    public init (
        clusterSecurityGroupName: Swift.String? = nil
    )
    {
        self.clusterSecurityGroupName = clusterSecurityGroupName
    }
}

extension DeleteClusterSecurityGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteClusterSecurityGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterSecurityGroupNotFoundFault" : self = .clusterSecurityGroupNotFoundFault(try ClusterSecurityGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterSecurityGroupStateFault" : self = .invalidClusterSecurityGroupStateFault(try InvalidClusterSecurityGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteClusterSecurityGroupOutputError: Swift.Error, Swift.Equatable {
    case clusterSecurityGroupNotFoundFault(ClusterSecurityGroupNotFoundFault)
    case invalidClusterSecurityGroupStateFault(InvalidClusterSecurityGroupStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteClusterSecurityGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteClusterSecurityGroupOutputResponse()"}
}

extension DeleteClusterSecurityGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteClusterSecurityGroupOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteClusterSecurityGroupOutputResponseBody: Swift.Equatable {
}

extension DeleteClusterSecurityGroupOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteClusterSnapshotInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteClusterSnapshotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteClusterSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteClusterSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteClusterSnapshotOutputError>
}

extension DeleteClusterSnapshotInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteClusterSnapshotInput(snapshotClusterIdentifier: \(Swift.String(describing: snapshotClusterIdentifier)), snapshotIdentifier: \(Swift.String(describing: snapshotIdentifier)))"}
}

extension DeleteClusterSnapshotInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let snapshotClusterIdentifier = snapshotClusterIdentifier {
            try container.encode(snapshotClusterIdentifier, forKey: ClientRuntime.Key("SnapshotClusterIdentifier"))
        }
        if let snapshotIdentifier = snapshotIdentifier {
            try container.encode(snapshotIdentifier, forKey: ClientRuntime.Key("SnapshotIdentifier"))
        }
        try container.encode("DeleteClusterSnapshot", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DeleteClusterSnapshotInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteClusterSnapshotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteClusterSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteClusterSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteClusterSnapshotOutputError>
}

public struct DeleteClusterSnapshotInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteClusterSnapshotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteClusterSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteClusterSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteClusterSnapshotOutputError>
}

/// <p></p>
public struct DeleteClusterSnapshotInput: Swift.Equatable {
    /// <p>The unique identifier of the cluster the snapshot was created from. This parameter
    ///             is required if your IAM user has a policy containing a snapshot resource element that
    ///             specifies anything other than * for the cluster name.</p>
    ///         <p>Constraints: Must be the name of valid cluster.</p>
    public let snapshotClusterIdentifier: Swift.String?
    /// <p>The unique identifier of the manual snapshot to be deleted.</p>
    ///         <p>Constraints: Must be the name of an existing snapshot that is in the
    ///                 <code>available</code>, <code>failed</code>, or <code>cancelled</code>
    ///             state.</p>
    public let snapshotIdentifier: Swift.String?

    public init (
        snapshotClusterIdentifier: Swift.String? = nil,
        snapshotIdentifier: Swift.String? = nil
    )
    {
        self.snapshotClusterIdentifier = snapshotClusterIdentifier
        self.snapshotIdentifier = snapshotIdentifier
    }
}

extension RedshiftClientTypes.DeleteClusterSnapshotMessage: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshotClusterIdentifier = "SnapshotClusterIdentifier"
        case snapshotIdentifier = "SnapshotIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let snapshotClusterIdentifier = snapshotClusterIdentifier {
            try container.encode(snapshotClusterIdentifier, forKey: ClientRuntime.Key("SnapshotClusterIdentifier"))
        }
        if let snapshotIdentifier = snapshotIdentifier {
            try container.encode(snapshotIdentifier, forKey: ClientRuntime.Key("SnapshotIdentifier"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotIdentifier)
        snapshotIdentifier = snapshotIdentifierDecoded
        let snapshotClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotClusterIdentifier)
        snapshotClusterIdentifier = snapshotClusterIdentifierDecoded
    }
}

extension RedshiftClientTypes.DeleteClusterSnapshotMessage: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteClusterSnapshotMessage(snapshotClusterIdentifier: \(Swift.String(describing: snapshotClusterIdentifier)), snapshotIdentifier: \(Swift.String(describing: snapshotIdentifier)))"}
}

extension RedshiftClientTypes {
    /// <p></p>
    public struct DeleteClusterSnapshotMessage: Swift.Equatable {
        /// <p>The unique identifier of the cluster the snapshot was created from. This parameter
        ///             is required if your IAM user has a policy containing a snapshot resource element that
        ///             specifies anything other than * for the cluster name.</p>
        ///         <p>Constraints: Must be the name of valid cluster.</p>
        public let snapshotClusterIdentifier: Swift.String?
        /// <p>The unique identifier of the manual snapshot to be deleted.</p>
        ///         <p>Constraints: Must be the name of an existing snapshot that is in the
        ///                 <code>available</code>, <code>failed</code>, or <code>cancelled</code>
        ///             state.</p>
        public let snapshotIdentifier: Swift.String?

        public init (
            snapshotClusterIdentifier: Swift.String? = nil,
            snapshotIdentifier: Swift.String? = nil
        )
        {
            self.snapshotClusterIdentifier = snapshotClusterIdentifier
            self.snapshotIdentifier = snapshotIdentifier
        }
    }

}

extension DeleteClusterSnapshotOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteClusterSnapshotOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterSnapshotNotFoundFault" : self = .clusterSnapshotNotFoundFault(try ClusterSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterSnapshotStateFault" : self = .invalidClusterSnapshotStateFault(try InvalidClusterSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteClusterSnapshotOutputError: Swift.Error, Swift.Equatable {
    case clusterSnapshotNotFoundFault(ClusterSnapshotNotFoundFault)
    case invalidClusterSnapshotStateFault(InvalidClusterSnapshotStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteClusterSnapshotOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteClusterSnapshotOutputResponse(snapshot: \(Swift.String(describing: snapshot)))"}
}

extension DeleteClusterSnapshotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteClusterSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.snapshot = output.snapshot
        } else {
            self.snapshot = nil
        }
    }
}

public struct DeleteClusterSnapshotOutputResponse: Swift.Equatable {
    /// <p>Describes a snapshot.</p>
    public let snapshot: RedshiftClientTypes.Snapshot?

    public init (
        snapshot: RedshiftClientTypes.Snapshot? = nil
    )
    {
        self.snapshot = snapshot
    }
}

struct DeleteClusterSnapshotOutputResponseBody: Swift.Equatable {
    public let snapshot: RedshiftClientTypes.Snapshot?
}

extension DeleteClusterSnapshotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshot = "Snapshot"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DeleteClusterSnapshotResult"))
        let snapshotDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.Snapshot.self, forKey: .snapshot)
        snapshot = snapshotDecoded
    }
}

public struct DeleteClusterSubnetGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteClusterSubnetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteClusterSubnetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteClusterSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteClusterSubnetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteClusterSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteClusterSubnetGroupOutputError>
}

extension DeleteClusterSubnetGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteClusterSubnetGroupInput(clusterSubnetGroupName: \(Swift.String(describing: clusterSubnetGroupName)))"}
}

extension DeleteClusterSubnetGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let clusterSubnetGroupName = clusterSubnetGroupName {
            try container.encode(clusterSubnetGroupName, forKey: ClientRuntime.Key("ClusterSubnetGroupName"))
        }
        try container.encode("DeleteClusterSubnetGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DeleteClusterSubnetGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteClusterSubnetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteClusterSubnetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteClusterSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteClusterSubnetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteClusterSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteClusterSubnetGroupOutputError>
}

public struct DeleteClusterSubnetGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteClusterSubnetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteClusterSubnetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteClusterSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteClusterSubnetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteClusterSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteClusterSubnetGroupOutputError>
}

/// <p></p>
public struct DeleteClusterSubnetGroupInput: Swift.Equatable {
    /// <p>The name of the cluster subnet group name to be deleted.</p>
    public let clusterSubnetGroupName: Swift.String?

    public init (
        clusterSubnetGroupName: Swift.String? = nil
    )
    {
        self.clusterSubnetGroupName = clusterSubnetGroupName
    }
}

extension DeleteClusterSubnetGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteClusterSubnetGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterSubnetGroupNotFoundFault" : self = .clusterSubnetGroupNotFoundFault(try ClusterSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterSubnetGroupStateFault" : self = .invalidClusterSubnetGroupStateFault(try InvalidClusterSubnetGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterSubnetStateFault" : self = .invalidClusterSubnetStateFault(try InvalidClusterSubnetStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteClusterSubnetGroupOutputError: Swift.Error, Swift.Equatable {
    case clusterSubnetGroupNotFoundFault(ClusterSubnetGroupNotFoundFault)
    case invalidClusterSubnetGroupStateFault(InvalidClusterSubnetGroupStateFault)
    case invalidClusterSubnetStateFault(InvalidClusterSubnetStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteClusterSubnetGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteClusterSubnetGroupOutputResponse()"}
}

extension DeleteClusterSubnetGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteClusterSubnetGroupOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteClusterSubnetGroupOutputResponseBody: Swift.Equatable {
}

extension DeleteClusterSubnetGroupOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteEndpointAccessInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEndpointAccessInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEndpointAccessInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEndpointAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEndpointAccessInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEndpointAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEndpointAccessOutputError>
}

extension DeleteEndpointAccessInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteEndpointAccessInput(endpointName: \(Swift.String(describing: endpointName)))"}
}

extension DeleteEndpointAccessInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let endpointName = endpointName {
            try container.encode(endpointName, forKey: ClientRuntime.Key("EndpointName"))
        }
        try container.encode("DeleteEndpointAccess", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DeleteEndpointAccessInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEndpointAccessInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEndpointAccessInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEndpointAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEndpointAccessInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEndpointAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEndpointAccessOutputError>
}

public struct DeleteEndpointAccessInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEndpointAccessInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEndpointAccessInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEndpointAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEndpointAccessInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEndpointAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEndpointAccessOutputError>
}

public struct DeleteEndpointAccessInput: Swift.Equatable {
    /// <p>The Redshift-managed VPC endpoint to delete.</p>
    public let endpointName: Swift.String?

    public init (
        endpointName: Swift.String? = nil
    )
    {
        self.endpointName = endpointName
    }
}

extension DeleteEndpointAccessOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteEndpointAccessOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EndpointNotFoundFault" : self = .endpointNotFoundFault(try EndpointNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterSecurityGroupStateFault" : self = .invalidClusterSecurityGroupStateFault(try InvalidClusterSecurityGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointStateFault" : self = .invalidEndpointStateFault(try InvalidEndpointStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEndpointAccessOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case endpointNotFoundFault(EndpointNotFoundFault)
    case invalidClusterSecurityGroupStateFault(InvalidClusterSecurityGroupStateFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidEndpointStateFault(InvalidEndpointStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEndpointAccessOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteEndpointAccessOutputResponse(address: \(Swift.String(describing: address)), clusterIdentifier: \(Swift.String(describing: clusterIdentifier)), endpointCreateTime: \(Swift.String(describing: endpointCreateTime)), endpointName: \(Swift.String(describing: endpointName)), endpointStatus: \(Swift.String(describing: endpointStatus)), port: \(Swift.String(describing: port)), resourceOwner: \(Swift.String(describing: resourceOwner)), subnetGroupName: \(Swift.String(describing: subnetGroupName)), vpcEndpoint: \(Swift.String(describing: vpcEndpoint)), vpcSecurityGroups: \(Swift.String(describing: vpcSecurityGroups)))"}
}

extension DeleteEndpointAccessOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteEndpointAccessOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.address = output.address
            self.clusterIdentifier = output.clusterIdentifier
            self.endpointCreateTime = output.endpointCreateTime
            self.endpointName = output.endpointName
            self.endpointStatus = output.endpointStatus
            self.port = output.port
            self.resourceOwner = output.resourceOwner
            self.subnetGroupName = output.subnetGroupName
            self.vpcEndpoint = output.vpcEndpoint
            self.vpcSecurityGroups = output.vpcSecurityGroups
        } else {
            self.address = nil
            self.clusterIdentifier = nil
            self.endpointCreateTime = nil
            self.endpointName = nil
            self.endpointStatus = nil
            self.port = 0
            self.resourceOwner = nil
            self.subnetGroupName = nil
            self.vpcEndpoint = nil
            self.vpcSecurityGroups = nil
        }
    }
}

/// <p>Describes a Redshift-managed VPC endpoint.</p>
public struct DeleteEndpointAccessOutputResponse: Swift.Equatable {
    /// <p>The DNS address of the endpoint.</p>
    public let address: Swift.String?
    /// <p>The cluster identifier of the cluster associated with the endpoint.</p>
    public let clusterIdentifier: Swift.String?
    /// <p>The time (UTC) that the endpoint was created.</p>
    public let endpointCreateTime: ClientRuntime.Date?
    /// <p>The name of the endpoint.</p>
    public let endpointName: Swift.String?
    /// <p>The status of the endpoint.</p>
    public let endpointStatus: Swift.String?
    /// <p>The port number on which the cluster accepts incoming connections.</p>
    public let port: Swift.Int
    /// <p>The AWS account ID of the owner of the cluster.</p>
    public let resourceOwner: Swift.String?
    /// <p>The subnet group name where Amazon Redshift chooses to deploy the endpoint.</p>
    public let subnetGroupName: Swift.String?
    /// <p>The connection endpoint for connecting to an Amazon Redshift cluster through the proxy.</p>
    public let vpcEndpoint: RedshiftClientTypes.VpcEndpoint?
    /// <p>The security groups associated with the endpoint.</p>
    public let vpcSecurityGroups: [RedshiftClientTypes.VpcSecurityGroupMembership]?

    public init (
        address: Swift.String? = nil,
        clusterIdentifier: Swift.String? = nil,
        endpointCreateTime: ClientRuntime.Date? = nil,
        endpointName: Swift.String? = nil,
        endpointStatus: Swift.String? = nil,
        port: Swift.Int = 0,
        resourceOwner: Swift.String? = nil,
        subnetGroupName: Swift.String? = nil,
        vpcEndpoint: RedshiftClientTypes.VpcEndpoint? = nil,
        vpcSecurityGroups: [RedshiftClientTypes.VpcSecurityGroupMembership]? = nil
    )
    {
        self.address = address
        self.clusterIdentifier = clusterIdentifier
        self.endpointCreateTime = endpointCreateTime
        self.endpointName = endpointName
        self.endpointStatus = endpointStatus
        self.port = port
        self.resourceOwner = resourceOwner
        self.subnetGroupName = subnetGroupName
        self.vpcEndpoint = vpcEndpoint
        self.vpcSecurityGroups = vpcSecurityGroups
    }
}

struct DeleteEndpointAccessOutputResponseBody: Swift.Equatable {
    public let clusterIdentifier: Swift.String?
    public let resourceOwner: Swift.String?
    public let subnetGroupName: Swift.String?
    public let endpointStatus: Swift.String?
    public let endpointName: Swift.String?
    public let endpointCreateTime: ClientRuntime.Date?
    public let port: Swift.Int
    public let address: Swift.String?
    public let vpcSecurityGroups: [RedshiftClientTypes.VpcSecurityGroupMembership]?
    public let vpcEndpoint: RedshiftClientTypes.VpcEndpoint?
}

extension DeleteEndpointAccessOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
        case clusterIdentifier = "ClusterIdentifier"
        case endpointCreateTime = "EndpointCreateTime"
        case endpointName = "EndpointName"
        case endpointStatus = "EndpointStatus"
        case port = "Port"
        case resourceOwner = "ResourceOwner"
        case subnetGroupName = "SubnetGroupName"
        case vpcEndpoint = "VpcEndpoint"
        case vpcSecurityGroups = "VpcSecurityGroups"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DeleteEndpointAccessResult"))
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let resourceOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceOwner)
        resourceOwner = resourceOwnerDecoded
        let subnetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetGroupName)
        subnetGroupName = subnetGroupNameDecoded
        let endpointStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointStatus)
        endpointStatus = endpointStatusDecoded
        let endpointNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointName)
        endpointName = endpointNameDecoded
        let endpointCreateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointCreateTime)
        var endpointCreateTimeBuffer:ClientRuntime.Date? = nil
        if let endpointCreateTimeDecoded = endpointCreateTimeDecoded {
            endpointCreateTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(endpointCreateTimeDecoded, format: .dateTime)
        }
        endpointCreateTime = endpointCreateTimeBuffer
        let portDecoded = try containerValues.decode(Swift.Int.self, forKey: .port)
        port = portDecoded
        let addressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .address)
        address = addressDecoded
        if containerValues.contains(.vpcSecurityGroups) {
            struct KeyVal0{struct VpcSecurityGroup{}}
            let vpcSecurityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.VpcSecurityGroup>.CodingKeys.self, forKey: .vpcSecurityGroups)
            if let vpcSecurityGroupsWrappedContainer = vpcSecurityGroupsWrappedContainer {
                let vpcSecurityGroupsContainer = try vpcSecurityGroupsWrappedContainer.decodeIfPresent([RedshiftClientTypes.VpcSecurityGroupMembership].self, forKey: .member)
                var vpcSecurityGroupsBuffer:[RedshiftClientTypes.VpcSecurityGroupMembership]? = nil
                if let vpcSecurityGroupsContainer = vpcSecurityGroupsContainer {
                    vpcSecurityGroupsBuffer = [RedshiftClientTypes.VpcSecurityGroupMembership]()
                    for structureContainer0 in vpcSecurityGroupsContainer {
                        vpcSecurityGroupsBuffer?.append(structureContainer0)
                    }
                }
                vpcSecurityGroups = vpcSecurityGroupsBuffer
            } else {
                vpcSecurityGroups = []
            }
        } else {
            vpcSecurityGroups = nil
        }
        let vpcEndpointDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.VpcEndpoint.self, forKey: .vpcEndpoint)
        vpcEndpoint = vpcEndpointDecoded
    }
}

public struct DeleteEventSubscriptionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEventSubscriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEventSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEventSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEventSubscriptionOutputError>
}

extension DeleteEventSubscriptionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteEventSubscriptionInput(subscriptionName: \(Swift.String(describing: subscriptionName)))"}
}

extension DeleteEventSubscriptionInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let subscriptionName = subscriptionName {
            try container.encode(subscriptionName, forKey: ClientRuntime.Key("SubscriptionName"))
        }
        try container.encode("DeleteEventSubscription", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DeleteEventSubscriptionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEventSubscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEventSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEventSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEventSubscriptionOutputError>
}

public struct DeleteEventSubscriptionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEventSubscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEventSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEventSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEventSubscriptionOutputError>
}

/// <p></p>
public struct DeleteEventSubscriptionInput: Swift.Equatable {
    /// <p>The name of the Amazon Redshift event notification subscription to be deleted.</p>
    public let subscriptionName: Swift.String?

    public init (
        subscriptionName: Swift.String? = nil
    )
    {
        self.subscriptionName = subscriptionName
    }
}

extension DeleteEventSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteEventSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidSubscriptionStateFault" : self = .invalidSubscriptionStateFault(try InvalidSubscriptionStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionNotFoundFault" : self = .subscriptionNotFoundFault(try SubscriptionNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEventSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case invalidSubscriptionStateFault(InvalidSubscriptionStateFault)
    case subscriptionNotFoundFault(SubscriptionNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEventSubscriptionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteEventSubscriptionOutputResponse()"}
}

extension DeleteEventSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteEventSubscriptionOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteEventSubscriptionOutputResponseBody: Swift.Equatable {
}

extension DeleteEventSubscriptionOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteHsmClientCertificateInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteHsmClientCertificateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteHsmClientCertificateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteHsmClientCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteHsmClientCertificateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteHsmClientCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteHsmClientCertificateOutputError>
}

extension DeleteHsmClientCertificateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteHsmClientCertificateInput(hsmClientCertificateIdentifier: \(Swift.String(describing: hsmClientCertificateIdentifier)))"}
}

extension DeleteHsmClientCertificateInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let hsmClientCertificateIdentifier = hsmClientCertificateIdentifier {
            try container.encode(hsmClientCertificateIdentifier, forKey: ClientRuntime.Key("HsmClientCertificateIdentifier"))
        }
        try container.encode("DeleteHsmClientCertificate", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DeleteHsmClientCertificateInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteHsmClientCertificateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteHsmClientCertificateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteHsmClientCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteHsmClientCertificateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteHsmClientCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteHsmClientCertificateOutputError>
}

public struct DeleteHsmClientCertificateInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteHsmClientCertificateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteHsmClientCertificateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteHsmClientCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteHsmClientCertificateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteHsmClientCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteHsmClientCertificateOutputError>
}

/// <p></p>
public struct DeleteHsmClientCertificateInput: Swift.Equatable {
    /// <p>The identifier of the HSM client certificate to be deleted.</p>
    public let hsmClientCertificateIdentifier: Swift.String?

    public init (
        hsmClientCertificateIdentifier: Swift.String? = nil
    )
    {
        self.hsmClientCertificateIdentifier = hsmClientCertificateIdentifier
    }
}

extension DeleteHsmClientCertificateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteHsmClientCertificateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "HsmClientCertificateNotFoundFault" : self = .hsmClientCertificateNotFoundFault(try HsmClientCertificateNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidHsmClientCertificateStateFault" : self = .invalidHsmClientCertificateStateFault(try InvalidHsmClientCertificateStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteHsmClientCertificateOutputError: Swift.Error, Swift.Equatable {
    case hsmClientCertificateNotFoundFault(HsmClientCertificateNotFoundFault)
    case invalidHsmClientCertificateStateFault(InvalidHsmClientCertificateStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteHsmClientCertificateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteHsmClientCertificateOutputResponse()"}
}

extension DeleteHsmClientCertificateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteHsmClientCertificateOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteHsmClientCertificateOutputResponseBody: Swift.Equatable {
}

extension DeleteHsmClientCertificateOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteHsmConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteHsmConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteHsmConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteHsmConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteHsmConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteHsmConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteHsmConfigurationOutputError>
}

extension DeleteHsmConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteHsmConfigurationInput(hsmConfigurationIdentifier: \(Swift.String(describing: hsmConfigurationIdentifier)))"}
}

extension DeleteHsmConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let hsmConfigurationIdentifier = hsmConfigurationIdentifier {
            try container.encode(hsmConfigurationIdentifier, forKey: ClientRuntime.Key("HsmConfigurationIdentifier"))
        }
        try container.encode("DeleteHsmConfiguration", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DeleteHsmConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteHsmConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteHsmConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteHsmConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteHsmConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteHsmConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteHsmConfigurationOutputError>
}

public struct DeleteHsmConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteHsmConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteHsmConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteHsmConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteHsmConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteHsmConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteHsmConfigurationOutputError>
}

/// <p></p>
public struct DeleteHsmConfigurationInput: Swift.Equatable {
    /// <p>The identifier of the Amazon Redshift HSM configuration to be deleted.</p>
    public let hsmConfigurationIdentifier: Swift.String?

    public init (
        hsmConfigurationIdentifier: Swift.String? = nil
    )
    {
        self.hsmConfigurationIdentifier = hsmConfigurationIdentifier
    }
}

extension DeleteHsmConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteHsmConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "HsmConfigurationNotFoundFault" : self = .hsmConfigurationNotFoundFault(try HsmConfigurationNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidHsmConfigurationStateFault" : self = .invalidHsmConfigurationStateFault(try InvalidHsmConfigurationStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteHsmConfigurationOutputError: Swift.Error, Swift.Equatable {
    case hsmConfigurationNotFoundFault(HsmConfigurationNotFoundFault)
    case invalidHsmConfigurationStateFault(InvalidHsmConfigurationStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteHsmConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteHsmConfigurationOutputResponse()"}
}

extension DeleteHsmConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteHsmConfigurationOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteHsmConfigurationOutputResponseBody: Swift.Equatable {
}

extension DeleteHsmConfigurationOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeletePartnerInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePartnerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePartnerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePartnerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePartnerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePartnerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePartnerOutputError>
}

extension DeletePartnerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeletePartnerInput(accountId: \(Swift.String(describing: accountId)), clusterIdentifier: \(Swift.String(describing: clusterIdentifier)), databaseName: \(Swift.String(describing: databaseName)), partnerName: \(Swift.String(describing: partnerName)))"}
}

extension DeletePartnerInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let accountId = accountId {
            try container.encode(accountId, forKey: ClientRuntime.Key("AccountId"))
        }
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: ClientRuntime.Key("ClusterIdentifier"))
        }
        if let databaseName = databaseName {
            try container.encode(databaseName, forKey: ClientRuntime.Key("DatabaseName"))
        }
        if let partnerName = partnerName {
            try container.encode(partnerName, forKey: ClientRuntime.Key("PartnerName"))
        }
        try container.encode("DeletePartner", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DeletePartnerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePartnerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePartnerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePartnerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePartnerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePartnerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePartnerOutputError>
}

public struct DeletePartnerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePartnerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePartnerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePartnerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePartnerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePartnerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePartnerOutputError>
}

public struct DeletePartnerInput: Swift.Equatable {
    /// <p>The AWS account ID that owns the cluster.</p>
    public let accountId: Swift.String?
    /// <p>The cluster identifier of the cluster that receives data from the partner.</p>
    public let clusterIdentifier: Swift.String?
    /// <p>The name of the database that receives data from the partner.</p>
    public let databaseName: Swift.String?
    /// <p>The name of the partner that is authorized to send data.</p>
    public let partnerName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        clusterIdentifier: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        partnerName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.clusterIdentifier = clusterIdentifier
        self.databaseName = databaseName
        self.partnerName = partnerName
    }
}

extension DeletePartnerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeletePartnerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PartnerNotFoundFault" : self = .partnerNotFoundFault(try PartnerNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedPartnerIntegrationFault" : self = .unauthorizedPartnerIntegrationFault(try UnauthorizedPartnerIntegrationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePartnerOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case partnerNotFoundFault(PartnerNotFoundFault)
    case unauthorizedPartnerIntegrationFault(UnauthorizedPartnerIntegrationFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePartnerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeletePartnerOutputResponse(databaseName: \(Swift.String(describing: databaseName)), partnerName: \(Swift.String(describing: partnerName)))"}
}

extension DeletePartnerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeletePartnerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.databaseName = output.databaseName
            self.partnerName = output.partnerName
        } else {
            self.databaseName = nil
            self.partnerName = nil
        }
    }
}

public struct DeletePartnerOutputResponse: Swift.Equatable {
    /// <p>The name of the database that receives data from the partner.</p>
    public let databaseName: Swift.String?
    /// <p>The name of the partner that is authorized to send data.</p>
    public let partnerName: Swift.String?

    public init (
        databaseName: Swift.String? = nil,
        partnerName: Swift.String? = nil
    )
    {
        self.databaseName = databaseName
        self.partnerName = partnerName
    }
}

struct DeletePartnerOutputResponseBody: Swift.Equatable {
    public let databaseName: Swift.String?
    public let partnerName: Swift.String?
}

extension DeletePartnerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName = "DatabaseName"
        case partnerName = "PartnerName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DeletePartnerResult"))
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let partnerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .partnerName)
        partnerName = partnerNameDecoded
    }
}

public struct DeleteScheduledActionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteScheduledActionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteScheduledActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteScheduledActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteScheduledActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteScheduledActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteScheduledActionOutputError>
}

extension DeleteScheduledActionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteScheduledActionInput(scheduledActionName: \(Swift.String(describing: scheduledActionName)))"}
}

extension DeleteScheduledActionInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let scheduledActionName = scheduledActionName {
            try container.encode(scheduledActionName, forKey: ClientRuntime.Key("ScheduledActionName"))
        }
        try container.encode("DeleteScheduledAction", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DeleteScheduledActionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteScheduledActionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteScheduledActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteScheduledActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteScheduledActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteScheduledActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteScheduledActionOutputError>
}

public struct DeleteScheduledActionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteScheduledActionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteScheduledActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteScheduledActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteScheduledActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteScheduledActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteScheduledActionOutputError>
}

public struct DeleteScheduledActionInput: Swift.Equatable {
    /// <p>The name of the scheduled action to delete. </p>
    public let scheduledActionName: Swift.String?

    public init (
        scheduledActionName: Swift.String? = nil
    )
    {
        self.scheduledActionName = scheduledActionName
    }
}

extension DeleteScheduledActionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteScheduledActionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ScheduledActionNotFoundFault" : self = .scheduledActionNotFoundFault(try ScheduledActionNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteScheduledActionOutputError: Swift.Error, Swift.Equatable {
    case scheduledActionNotFoundFault(ScheduledActionNotFoundFault)
    case unauthorizedOperation(UnauthorizedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteScheduledActionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteScheduledActionOutputResponse()"}
}

extension DeleteScheduledActionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteScheduledActionOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteScheduledActionOutputResponseBody: Swift.Equatable {
}

extension DeleteScheduledActionOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteSnapshotCopyGrantInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSnapshotCopyGrantInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSnapshotCopyGrantInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSnapshotCopyGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSnapshotCopyGrantInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSnapshotCopyGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSnapshotCopyGrantOutputError>
}

extension DeleteSnapshotCopyGrantInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteSnapshotCopyGrantInput(snapshotCopyGrantName: \(Swift.String(describing: snapshotCopyGrantName)))"}
}

extension DeleteSnapshotCopyGrantInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let snapshotCopyGrantName = snapshotCopyGrantName {
            try container.encode(snapshotCopyGrantName, forKey: ClientRuntime.Key("SnapshotCopyGrantName"))
        }
        try container.encode("DeleteSnapshotCopyGrant", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DeleteSnapshotCopyGrantInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSnapshotCopyGrantInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSnapshotCopyGrantInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSnapshotCopyGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSnapshotCopyGrantInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSnapshotCopyGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSnapshotCopyGrantOutputError>
}

public struct DeleteSnapshotCopyGrantInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSnapshotCopyGrantInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSnapshotCopyGrantInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSnapshotCopyGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSnapshotCopyGrantInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSnapshotCopyGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSnapshotCopyGrantOutputError>
}

/// <p>The result of the <code>DeleteSnapshotCopyGrant</code> action.</p>
public struct DeleteSnapshotCopyGrantInput: Swift.Equatable {
    /// <p>The name of the snapshot copy grant to delete.</p>
    public let snapshotCopyGrantName: Swift.String?

    public init (
        snapshotCopyGrantName: Swift.String? = nil
    )
    {
        self.snapshotCopyGrantName = snapshotCopyGrantName
    }
}

extension DeleteSnapshotCopyGrantOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteSnapshotCopyGrantOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidSnapshotCopyGrantStateFault" : self = .invalidSnapshotCopyGrantStateFault(try InvalidSnapshotCopyGrantStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotCopyGrantNotFoundFault" : self = .snapshotCopyGrantNotFoundFault(try SnapshotCopyGrantNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSnapshotCopyGrantOutputError: Swift.Error, Swift.Equatable {
    case invalidSnapshotCopyGrantStateFault(InvalidSnapshotCopyGrantStateFault)
    case snapshotCopyGrantNotFoundFault(SnapshotCopyGrantNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSnapshotCopyGrantOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteSnapshotCopyGrantOutputResponse()"}
}

extension DeleteSnapshotCopyGrantOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSnapshotCopyGrantOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteSnapshotCopyGrantOutputResponseBody: Swift.Equatable {
}

extension DeleteSnapshotCopyGrantOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteSnapshotScheduleInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSnapshotScheduleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSnapshotScheduleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSnapshotScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSnapshotScheduleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSnapshotScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSnapshotScheduleOutputError>
}

extension DeleteSnapshotScheduleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteSnapshotScheduleInput(scheduleIdentifier: \(Swift.String(describing: scheduleIdentifier)))"}
}

extension DeleteSnapshotScheduleInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let scheduleIdentifier = scheduleIdentifier {
            try container.encode(scheduleIdentifier, forKey: ClientRuntime.Key("ScheduleIdentifier"))
        }
        try container.encode("DeleteSnapshotSchedule", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DeleteSnapshotScheduleInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSnapshotScheduleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSnapshotScheduleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSnapshotScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSnapshotScheduleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSnapshotScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSnapshotScheduleOutputError>
}

public struct DeleteSnapshotScheduleInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSnapshotScheduleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSnapshotScheduleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSnapshotScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSnapshotScheduleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSnapshotScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSnapshotScheduleOutputError>
}

public struct DeleteSnapshotScheduleInput: Swift.Equatable {
    /// <p>A unique identifier of the snapshot schedule to delete.</p>
    public let scheduleIdentifier: Swift.String?

    public init (
        scheduleIdentifier: Swift.String? = nil
    )
    {
        self.scheduleIdentifier = scheduleIdentifier
    }
}

extension DeleteSnapshotScheduleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteSnapshotScheduleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidClusterSnapshotScheduleStateFault" : self = .invalidClusterSnapshotScheduleStateFault(try InvalidClusterSnapshotScheduleStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotScheduleNotFoundFault" : self = .snapshotScheduleNotFoundFault(try SnapshotScheduleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSnapshotScheduleOutputError: Swift.Error, Swift.Equatable {
    case invalidClusterSnapshotScheduleStateFault(InvalidClusterSnapshotScheduleStateFault)
    case snapshotScheduleNotFoundFault(SnapshotScheduleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSnapshotScheduleOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteSnapshotScheduleOutputResponse()"}
}

extension DeleteSnapshotScheduleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSnapshotScheduleOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteSnapshotScheduleOutputResponseBody: Swift.Equatable {
}

extension DeleteSnapshotScheduleOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteTagsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTagsOutputError>
}

extension DeleteTagsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteTagsInput(resourceName: \(Swift.String(describing: resourceName)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension DeleteTagsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let resourceName = resourceName {
            try container.encode(resourceName, forKey: ClientRuntime.Key("ResourceName"))
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
            for (index0, string0) in tagKeys.enumerated() {
                try tagKeysContainer.encode(string0, forKey: ClientRuntime.Key("TagKey.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("DeleteTags", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DeleteTagsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTagsOutputError>
}

public struct DeleteTagsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTagsOutputError>
}

/// <p>Contains the output from the <code>DeleteTags</code> action. </p>
public struct DeleteTagsInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) from which you want to remove the tag or tags. For
    ///             example, <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>. </p>
    public let resourceName: Swift.String?
    /// <p>The tag key that you want to delete.</p>
    public let tagKeys: [Swift.String]?

    public init (
        resourceName: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceName = resourceName
        self.tagKeys = tagKeys
    }
}

extension DeleteTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidTagFault" : self = .invalidTagFault(try InvalidTagFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTagsOutputError: Swift.Error, Swift.Equatable {
    case invalidTagFault(InvalidTagFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTagsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteTagsOutputResponse()"}
}

extension DeleteTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteTagsOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteTagsOutputResponseBody: Swift.Equatable {
}

extension DeleteTagsOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteUsageLimitInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteUsageLimitInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteUsageLimitInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteUsageLimitOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteUsageLimitInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteUsageLimitOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteUsageLimitOutputError>
}

extension DeleteUsageLimitInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteUsageLimitInput(usageLimitId: \(Swift.String(describing: usageLimitId)))"}
}

extension DeleteUsageLimitInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let usageLimitId = usageLimitId {
            try container.encode(usageLimitId, forKey: ClientRuntime.Key("UsageLimitId"))
        }
        try container.encode("DeleteUsageLimit", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DeleteUsageLimitInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteUsageLimitInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteUsageLimitInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteUsageLimitOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteUsageLimitInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteUsageLimitOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteUsageLimitOutputError>
}

public struct DeleteUsageLimitInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteUsageLimitInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteUsageLimitInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteUsageLimitOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteUsageLimitInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteUsageLimitOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteUsageLimitOutputError>
}

public struct DeleteUsageLimitInput: Swift.Equatable {
    /// <p>The identifier of the usage limit to delete.</p>
    public let usageLimitId: Swift.String?

    public init (
        usageLimitId: Swift.String? = nil
    )
    {
        self.usageLimitId = usageLimitId
    }
}

extension DeleteUsageLimitOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteUsageLimitOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "UnsupportedOperationFault" : self = .unsupportedOperationFault(try UnsupportedOperationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UsageLimitNotFoundFault" : self = .usageLimitNotFoundFault(try UsageLimitNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteUsageLimitOutputError: Swift.Error, Swift.Equatable {
    case unsupportedOperationFault(UnsupportedOperationFault)
    case usageLimitNotFoundFault(UsageLimitNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUsageLimitOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteUsageLimitOutputResponse()"}
}

extension DeleteUsageLimitOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteUsageLimitOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteUsageLimitOutputResponseBody: Swift.Equatable {
}

extension DeleteUsageLimitOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DependentServiceRequestThrottlingFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DependentServiceRequestThrottlingFault(message: \(Swift.String(describing: message)))"}
}

extension DependentServiceRequestThrottlingFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<DependentServiceRequestThrottlingFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request cannot be completed because a dependent service is throttling requests
///             made by Amazon Redshift on your behalf. Wait and retry the request.</p>
public struct DependentServiceRequestThrottlingFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DependentServiceRequestThrottlingFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DependentServiceRequestThrottlingFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DependentServiceUnavailableFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DependentServiceUnavailableFault(message: \(Swift.String(describing: message)))"}
}

extension DependentServiceUnavailableFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<DependentServiceUnavailableFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Your request cannot be completed because a dependent internal service is
///             temporarily unavailable. Wait 30 to 60 seconds and try again.</p>
public struct DependentServiceUnavailableFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DependentServiceUnavailableFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DependentServiceUnavailableFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct DescribeAccountAttributesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAccountAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAccountAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAccountAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAccountAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAccountAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAccountAttributesOutputError>
}

extension DescribeAccountAttributesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAccountAttributesInput(attributeNames: \(Swift.String(describing: attributeNames)))"}
}

extension DescribeAccountAttributesInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let attributeNames = attributeNames {
            var attributeNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AttributeNames"))
            for (index0, string0) in attributeNames.enumerated() {
                try attributeNamesContainer.encode(string0, forKey: ClientRuntime.Key("AttributeName.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("DescribeAccountAttributes", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeAccountAttributesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAccountAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAccountAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAccountAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAccountAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAccountAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAccountAttributesOutputError>
}

public struct DescribeAccountAttributesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAccountAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAccountAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAccountAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAccountAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAccountAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAccountAttributesOutputError>
}

public struct DescribeAccountAttributesInput: Swift.Equatable {
    /// <p>A list of attribute names.</p>
    public let attributeNames: [Swift.String]?

    public init (
        attributeNames: [Swift.String]? = nil
    )
    {
        self.attributeNames = attributeNames
    }
}

extension DescribeAccountAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeAccountAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAccountAttributesOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAccountAttributesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAccountAttributesOutputResponse(accountAttributes: \(Swift.String(describing: accountAttributes)))"}
}

extension DescribeAccountAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAccountAttributesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountAttributes = output.accountAttributes
        } else {
            self.accountAttributes = nil
        }
    }
}

public struct DescribeAccountAttributesOutputResponse: Swift.Equatable {
    /// <p>A list of attributes assigned to an account.</p>
    public let accountAttributes: [RedshiftClientTypes.AccountAttribute]?

    public init (
        accountAttributes: [RedshiftClientTypes.AccountAttribute]? = nil
    )
    {
        self.accountAttributes = accountAttributes
    }
}

struct DescribeAccountAttributesOutputResponseBody: Swift.Equatable {
    public let accountAttributes: [RedshiftClientTypes.AccountAttribute]?
}

extension DescribeAccountAttributesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAttributes = "AccountAttributes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeAccountAttributesResult"))
        if containerValues.contains(.accountAttributes) {
            struct KeyVal0{struct AccountAttribute{}}
            let accountAttributesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AccountAttribute>.CodingKeys.self, forKey: .accountAttributes)
            if let accountAttributesWrappedContainer = accountAttributesWrappedContainer {
                let accountAttributesContainer = try accountAttributesWrappedContainer.decodeIfPresent([RedshiftClientTypes.AccountAttribute].self, forKey: .member)
                var accountAttributesBuffer:[RedshiftClientTypes.AccountAttribute]? = nil
                if let accountAttributesContainer = accountAttributesContainer {
                    accountAttributesBuffer = [RedshiftClientTypes.AccountAttribute]()
                    for structureContainer0 in accountAttributesContainer {
                        accountAttributesBuffer?.append(structureContainer0)
                    }
                }
                accountAttributes = accountAttributesBuffer
            } else {
                accountAttributes = []
            }
        } else {
            accountAttributes = nil
        }
    }
}

public struct DescribeClusterDbRevisionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeClusterDbRevisionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeClusterDbRevisionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeClusterDbRevisionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeClusterDbRevisionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeClusterDbRevisionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeClusterDbRevisionsOutputError>
}

extension DescribeClusterDbRevisionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeClusterDbRevisionsInput(clusterIdentifier: \(Swift.String(describing: clusterIdentifier)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)))"}
}

extension DescribeClusterDbRevisionsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: ClientRuntime.Key("ClusterIdentifier"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        try container.encode("DescribeClusterDbRevisions", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeClusterDbRevisionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeClusterDbRevisionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeClusterDbRevisionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeClusterDbRevisionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeClusterDbRevisionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeClusterDbRevisionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeClusterDbRevisionsOutputError>
}

public struct DescribeClusterDbRevisionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeClusterDbRevisionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeClusterDbRevisionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeClusterDbRevisionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeClusterDbRevisionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeClusterDbRevisionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeClusterDbRevisionsOutputError>
}

public struct DescribeClusterDbRevisionsInput: Swift.Equatable {
    /// <p>A unique identifier for a cluster whose <code>ClusterDbRevisions</code> you are
    ///             requesting. This parameter is case sensitive. All clusters defined for an account are
    ///             returned by default.</p>
    public let clusterIdentifier: Swift.String?
    /// <p>An optional parameter that specifies the starting point for returning a set of
    ///             response records. When the results of a <code>DescribeClusterDbRevisions</code> request
    ///             exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value
    ///             in the <code>marker</code> field of the response. You can retrieve the next set of
    ///             response records by providing the returned <code>marker</code> value in the
    ///                 <code>marker</code> parameter and retrying the request. </p>
    ///         <p>Constraints: You can specify either the <code>ClusterIdentifier</code> parameter, or
    ///             the <code>marker</code> parameter, but not both.</p>
    public let marker: Swift.String?
    /// <p>The maximum number of response records to return in each call. If the number of
    ///             remaining response records exceeds the specified MaxRecords value, a value is returned
    ///             in the <code>marker</code> field of the response. You can retrieve the next set of
    ///             response records by providing the returned <code>marker</code> value in the
    ///                 <code>marker</code> parameter and retrying the request. </p>
    ///         <p>Default: 100</p>
    ///         <p>Constraints: minimum 20, maximum 100.</p>
    public let maxRecords: Swift.Int?

    public init (
        clusterIdentifier: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeClusterDbRevisionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeClusterDbRevisionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeClusterDbRevisionsOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeClusterDbRevisionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeClusterDbRevisionsOutputResponse(clusterDbRevisions: \(Swift.String(describing: clusterDbRevisions)), marker: \(Swift.String(describing: marker)))"}
}

extension DescribeClusterDbRevisionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeClusterDbRevisionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clusterDbRevisions = output.clusterDbRevisions
            self.marker = output.marker
        } else {
            self.clusterDbRevisions = nil
            self.marker = nil
        }
    }
}

public struct DescribeClusterDbRevisionsOutputResponse: Swift.Equatable {
    /// <p>A list of revisions.</p>
    public let clusterDbRevisions: [RedshiftClientTypes.ClusterDbRevision]?
    /// <p>A string representing the starting point for the next set of revisions. If a value is
    ///             returned in a response, you can retrieve the next set of revisions by providing the
    ///             value in the <code>marker</code> parameter and retrying the command. If the
    ///                 <code>marker</code> field is empty, all revisions have already been returned.</p>
    public let marker: Swift.String?

    public init (
        clusterDbRevisions: [RedshiftClientTypes.ClusterDbRevision]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.clusterDbRevisions = clusterDbRevisions
        self.marker = marker
    }
}

struct DescribeClusterDbRevisionsOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let clusterDbRevisions: [RedshiftClientTypes.ClusterDbRevision]?
}

extension DescribeClusterDbRevisionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterDbRevisions = "ClusterDbRevisions"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeClusterDbRevisionsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.clusterDbRevisions) {
            struct KeyVal0{struct ClusterDbRevision{}}
            let clusterDbRevisionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ClusterDbRevision>.CodingKeys.self, forKey: .clusterDbRevisions)
            if let clusterDbRevisionsWrappedContainer = clusterDbRevisionsWrappedContainer {
                let clusterDbRevisionsContainer = try clusterDbRevisionsWrappedContainer.decodeIfPresent([RedshiftClientTypes.ClusterDbRevision].self, forKey: .member)
                var clusterDbRevisionsBuffer:[RedshiftClientTypes.ClusterDbRevision]? = nil
                if let clusterDbRevisionsContainer = clusterDbRevisionsContainer {
                    clusterDbRevisionsBuffer = [RedshiftClientTypes.ClusterDbRevision]()
                    for structureContainer0 in clusterDbRevisionsContainer {
                        clusterDbRevisionsBuffer?.append(structureContainer0)
                    }
                }
                clusterDbRevisions = clusterDbRevisionsBuffer
            } else {
                clusterDbRevisions = []
            }
        } else {
            clusterDbRevisions = nil
        }
    }
}

public struct DescribeClusterParameterGroupsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeClusterParameterGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeClusterParameterGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeClusterParameterGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeClusterParameterGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeClusterParameterGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeClusterParameterGroupsOutputError>
}

extension DescribeClusterParameterGroupsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeClusterParameterGroupsInput(marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)), parameterGroupName: \(Swift.String(describing: parameterGroupName)), tagKeys: \(Swift.String(describing: tagKeys)), tagValues: \(Swift.String(describing: tagValues)))"}
}

extension DescribeClusterParameterGroupsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let parameterGroupName = parameterGroupName {
            try container.encode(parameterGroupName, forKey: ClientRuntime.Key("ParameterGroupName"))
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
            for (index0, string0) in tagKeys.enumerated() {
                try tagKeysContainer.encode(string0, forKey: ClientRuntime.Key("TagKey.\(index0.advanced(by: 1))"))
            }
        }
        if let tagValues = tagValues {
            var tagValuesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagValues"))
            for (index0, string0) in tagValues.enumerated() {
                try tagValuesContainer.encode(string0, forKey: ClientRuntime.Key("TagValue.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("DescribeClusterParameterGroups", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeClusterParameterGroupsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeClusterParameterGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeClusterParameterGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeClusterParameterGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeClusterParameterGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeClusterParameterGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeClusterParameterGroupsOutputError>
}

public struct DescribeClusterParameterGroupsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeClusterParameterGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeClusterParameterGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeClusterParameterGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeClusterParameterGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeClusterParameterGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeClusterParameterGroupsOutputError>
}

/// <p></p>
public struct DescribeClusterParameterGroupsInput: Swift.Equatable {
    /// <p>An optional parameter that specifies the starting point to return a set of response
    ///             records. When the results of a <a>DescribeClusterParameterGroups</a> request
    ///             exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the
    ///                 <code>Marker</code> field of the response. You can retrieve the next set of response
    ///             records by providing the returned marker value in the <code>Marker</code> parameter and
    ///             retrying the request. </p>
    public let marker: Swift.String?
    /// <p>The maximum number of response records to return in each call. If the number of
    ///             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
    ///             is returned in a <code>marker</code> field of the response. You can retrieve the next
    ///             set of records by retrying the command with the returned marker value. </p>
    ///         <p>Default: <code>100</code>
    ///         </p>
    ///         <p>Constraints: minimum 20, maximum 100.</p>
    public let maxRecords: Swift.Int?
    /// <p>The name of a specific parameter group for which to return details. By default,
    ///             details about all parameter groups and the default parameter group are
    ///             returned.</p>
    public let parameterGroupName: Swift.String?
    /// <p>A tag key or keys for which you want to return all matching cluster parameter
    ///             groups that are associated with the specified key or keys. For example, suppose that you
    ///             have parameter groups that are tagged with keys called <code>owner</code> and
    ///                 <code>environment</code>. If you specify both of these tag keys in the request,
    ///             Amazon Redshift returns a response with the parameter groups that have either or both of these
    ///             tag keys associated with them.</p>
    public let tagKeys: [Swift.String]?
    /// <p>A tag value or values for which you want to return all matching cluster parameter
    ///             groups that are associated with the specified tag value or values. For example, suppose
    ///             that you have parameter groups that are tagged with values called <code>admin</code> and
    ///                 <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift
    ///             returns a response with the parameter groups that have either or both of these tag
    ///             values associated with them.</p>
    public let tagValues: [Swift.String]?

    public init (
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        parameterGroupName: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil,
        tagValues: [Swift.String]? = nil
    )
    {
        self.marker = marker
        self.maxRecords = maxRecords
        self.parameterGroupName = parameterGroupName
        self.tagKeys = tagKeys
        self.tagValues = tagValues
    }
}

extension DescribeClusterParameterGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeClusterParameterGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterParameterGroupNotFoundFault" : self = .clusterParameterGroupNotFoundFault(try ClusterParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagFault" : self = .invalidTagFault(try InvalidTagFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeClusterParameterGroupsOutputError: Swift.Error, Swift.Equatable {
    case clusterParameterGroupNotFoundFault(ClusterParameterGroupNotFoundFault)
    case invalidTagFault(InvalidTagFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeClusterParameterGroupsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeClusterParameterGroupsOutputResponse(marker: \(Swift.String(describing: marker)), parameterGroups: \(Swift.String(describing: parameterGroups)))"}
}

extension DescribeClusterParameterGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeClusterParameterGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.parameterGroups = output.parameterGroups
        } else {
            self.marker = nil
            self.parameterGroups = nil
        }
    }
}

/// <p>Contains the output from the <a>DescribeClusterParameterGroups</a>
///             action. </p>
public struct DescribeClusterParameterGroupsOutputResponse: Swift.Equatable {
    /// <p>A value that indicates the starting point for the next set of response records in a
    ///             subsequent request. If a value is returned in a response, you can retrieve the next set
    ///             of records by providing this returned marker value in the <code>Marker</code> parameter
    ///             and retrying the command. If the <code>Marker</code> field is empty, all response
    ///             records have been retrieved for the request. </p>
    public let marker: Swift.String?
    /// <p>A list of <a>ClusterParameterGroup</a> instances. Each instance
    ///             describes one cluster parameter group. </p>
    public let parameterGroups: [RedshiftClientTypes.ClusterParameterGroup]?

    public init (
        marker: Swift.String? = nil,
        parameterGroups: [RedshiftClientTypes.ClusterParameterGroup]? = nil
    )
    {
        self.marker = marker
        self.parameterGroups = parameterGroups
    }
}

struct DescribeClusterParameterGroupsOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let parameterGroups: [RedshiftClientTypes.ClusterParameterGroup]?
}

extension DescribeClusterParameterGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case parameterGroups = "ParameterGroups"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeClusterParameterGroupsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.parameterGroups) {
            struct KeyVal0{struct ClusterParameterGroup{}}
            let parameterGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ClusterParameterGroup>.CodingKeys.self, forKey: .parameterGroups)
            if let parameterGroupsWrappedContainer = parameterGroupsWrappedContainer {
                let parameterGroupsContainer = try parameterGroupsWrappedContainer.decodeIfPresent([RedshiftClientTypes.ClusterParameterGroup].self, forKey: .member)
                var parameterGroupsBuffer:[RedshiftClientTypes.ClusterParameterGroup]? = nil
                if let parameterGroupsContainer = parameterGroupsContainer {
                    parameterGroupsBuffer = [RedshiftClientTypes.ClusterParameterGroup]()
                    for structureContainer0 in parameterGroupsContainer {
                        parameterGroupsBuffer?.append(structureContainer0)
                    }
                }
                parameterGroups = parameterGroupsBuffer
            } else {
                parameterGroups = []
            }
        } else {
            parameterGroups = nil
        }
    }
}

public struct DescribeClusterParametersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeClusterParametersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeClusterParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeClusterParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeClusterParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeClusterParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeClusterParametersOutputError>
}

extension DescribeClusterParametersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeClusterParametersInput(marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)), parameterGroupName: \(Swift.String(describing: parameterGroupName)), source: \(Swift.String(describing: source)))"}
}

extension DescribeClusterParametersInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let parameterGroupName = parameterGroupName {
            try container.encode(parameterGroupName, forKey: ClientRuntime.Key("ParameterGroupName"))
        }
        if let source = source {
            try container.encode(source, forKey: ClientRuntime.Key("Source"))
        }
        try container.encode("DescribeClusterParameters", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeClusterParametersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeClusterParametersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeClusterParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeClusterParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeClusterParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeClusterParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeClusterParametersOutputError>
}

public struct DescribeClusterParametersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeClusterParametersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeClusterParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeClusterParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeClusterParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeClusterParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeClusterParametersOutputError>
}

/// <p></p>
public struct DescribeClusterParametersInput: Swift.Equatable {
    /// <p>An optional parameter that specifies the starting point to return a set of response
    ///             records. When the results of a <a>DescribeClusterParameters</a> request
    ///             exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the
    ///                 <code>Marker</code> field of the response. You can retrieve the next set of response
    ///             records by providing the returned marker value in the <code>Marker</code> parameter and
    ///             retrying the request. </p>
    public let marker: Swift.String?
    /// <p>The maximum number of response records to return in each call. If the number of
    ///             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
    ///             is returned in a <code>marker</code> field of the response. You can retrieve the next
    ///             set of records by retrying the command with the returned marker value. </p>
    ///         <p>Default: <code>100</code>
    ///         </p>
    ///         <p>Constraints: minimum 20, maximum 100.</p>
    public let maxRecords: Swift.Int?
    /// <p>The name of a cluster parameter group for which to return details.</p>
    public let parameterGroupName: Swift.String?
    /// <p>The parameter types to return. Specify <code>user</code> to show parameters that
    ///             are different form the default. Similarly, specify <code>engine-default</code> to show
    ///             parameters that are the same as the default parameter group. </p>
    ///         <p>Default: All parameter types returned.</p>
    ///         <p>Valid Values: <code>user</code> | <code>engine-default</code>
    ///         </p>
    public let source: Swift.String?

    public init (
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        parameterGroupName: Swift.String? = nil,
        source: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxRecords = maxRecords
        self.parameterGroupName = parameterGroupName
        self.source = source
    }
}

extension DescribeClusterParametersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeClusterParametersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterParameterGroupNotFoundFault" : self = .clusterParameterGroupNotFoundFault(try ClusterParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeClusterParametersOutputError: Swift.Error, Swift.Equatable {
    case clusterParameterGroupNotFoundFault(ClusterParameterGroupNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeClusterParametersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeClusterParametersOutputResponse(marker: \(Swift.String(describing: marker)), parameters: \(Swift.String(describing: parameters)))"}
}

extension DescribeClusterParametersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeClusterParametersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.parameters = output.parameters
        } else {
            self.marker = nil
            self.parameters = nil
        }
    }
}

/// <p>Contains the output from the <a>DescribeClusterParameters</a> action.
///         </p>
public struct DescribeClusterParametersOutputResponse: Swift.Equatable {
    /// <p>A value that indicates the starting point for the next set of response records in a
    ///             subsequent request. If a value is returned in a response, you can retrieve the next set
    ///             of records by providing this returned marker value in the <code>Marker</code> parameter
    ///             and retrying the command. If the <code>Marker</code> field is empty, all response
    ///             records have been retrieved for the request. </p>
    public let marker: Swift.String?
    /// <p>A list of <a>Parameter</a> instances. Each instance lists the parameters
    ///             of one cluster parameter group. </p>
    public let parameters: [RedshiftClientTypes.Parameter]?

    public init (
        marker: Swift.String? = nil,
        parameters: [RedshiftClientTypes.Parameter]? = nil
    )
    {
        self.marker = marker
        self.parameters = parameters
    }
}

struct DescribeClusterParametersOutputResponseBody: Swift.Equatable {
    public let parameters: [RedshiftClientTypes.Parameter]?
    public let marker: Swift.String?
}

extension DescribeClusterParametersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case parameters = "Parameters"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeClusterParametersResult"))
        if containerValues.contains(.parameters) {
            struct KeyVal0{struct Parameter{}}
            let parametersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Parameter>.CodingKeys.self, forKey: .parameters)
            if let parametersWrappedContainer = parametersWrappedContainer {
                let parametersContainer = try parametersWrappedContainer.decodeIfPresent([RedshiftClientTypes.Parameter].self, forKey: .member)
                var parametersBuffer:[RedshiftClientTypes.Parameter]? = nil
                if let parametersContainer = parametersContainer {
                    parametersBuffer = [RedshiftClientTypes.Parameter]()
                    for structureContainer0 in parametersContainer {
                        parametersBuffer?.append(structureContainer0)
                    }
                }
                parameters = parametersBuffer
            } else {
                parameters = []
            }
        } else {
            parameters = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribeClusterSecurityGroupsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeClusterSecurityGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeClusterSecurityGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeClusterSecurityGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeClusterSecurityGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeClusterSecurityGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeClusterSecurityGroupsOutputError>
}

extension DescribeClusterSecurityGroupsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeClusterSecurityGroupsInput(clusterSecurityGroupName: \(Swift.String(describing: clusterSecurityGroupName)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)), tagKeys: \(Swift.String(describing: tagKeys)), tagValues: \(Swift.String(describing: tagValues)))"}
}

extension DescribeClusterSecurityGroupsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let clusterSecurityGroupName = clusterSecurityGroupName {
            try container.encode(clusterSecurityGroupName, forKey: ClientRuntime.Key("ClusterSecurityGroupName"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
            for (index0, string0) in tagKeys.enumerated() {
                try tagKeysContainer.encode(string0, forKey: ClientRuntime.Key("TagKey.\(index0.advanced(by: 1))"))
            }
        }
        if let tagValues = tagValues {
            var tagValuesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagValues"))
            for (index0, string0) in tagValues.enumerated() {
                try tagValuesContainer.encode(string0, forKey: ClientRuntime.Key("TagValue.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("DescribeClusterSecurityGroups", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeClusterSecurityGroupsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeClusterSecurityGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeClusterSecurityGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeClusterSecurityGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeClusterSecurityGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeClusterSecurityGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeClusterSecurityGroupsOutputError>
}

public struct DescribeClusterSecurityGroupsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeClusterSecurityGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeClusterSecurityGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeClusterSecurityGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeClusterSecurityGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeClusterSecurityGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeClusterSecurityGroupsOutputError>
}

/// <p></p>
public struct DescribeClusterSecurityGroupsInput: Swift.Equatable {
    /// <p>The name of a cluster security group for which you are requesting details. You can
    ///             specify either the <b>Marker</b> parameter or a <b>ClusterSecurityGroupName</b> parameter, but not both. </p>
    ///         <p> Example: <code>securitygroup1</code>
    ///         </p>
    public let clusterSecurityGroupName: Swift.String?
    /// <p>An optional parameter that specifies the starting point to return a set of response
    ///             records. When the results of a <a>DescribeClusterSecurityGroups</a> request
    ///             exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the
    ///                 <code>Marker</code> field of the response. You can retrieve the next set of response
    ///             records by providing the returned marker value in the <code>Marker</code> parameter and
    ///             retrying the request. </p>
    ///         <p>Constraints: You can specify either the <b>ClusterSecurityGroupName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
    public let marker: Swift.String?
    /// <p>The maximum number of response records to return in each call. If the number of
    ///             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
    ///             is returned in a <code>marker</code> field of the response. You can retrieve the next
    ///             set of records by retrying the command with the returned marker value. </p>
    ///         <p>Default: <code>100</code>
    ///         </p>
    ///         <p>Constraints: minimum 20, maximum 100.</p>
    public let maxRecords: Swift.Int?
    /// <p>A tag key or keys for which you want to return all matching cluster security groups
    ///             that are associated with the specified key or keys. For example, suppose that you have
    ///             security groups that are tagged with keys called <code>owner</code> and
    ///                 <code>environment</code>. If you specify both of these tag keys in the request,
    ///             Amazon Redshift returns a response with the security groups that have either or both of these
    ///             tag keys associated with them.</p>
    public let tagKeys: [Swift.String]?
    /// <p>A tag value or values for which you want to return all matching cluster security
    ///             groups that are associated with the specified tag value or values. For example, suppose
    ///             that you have security groups that are tagged with values called <code>admin</code> and
    ///                 <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift
    ///             returns a response with the security groups that have either or both of these tag values
    ///             associated with them.</p>
    public let tagValues: [Swift.String]?

    public init (
        clusterSecurityGroupName: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        tagKeys: [Swift.String]? = nil,
        tagValues: [Swift.String]? = nil
    )
    {
        self.clusterSecurityGroupName = clusterSecurityGroupName
        self.marker = marker
        self.maxRecords = maxRecords
        self.tagKeys = tagKeys
        self.tagValues = tagValues
    }
}

extension DescribeClusterSecurityGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeClusterSecurityGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterSecurityGroupNotFoundFault" : self = .clusterSecurityGroupNotFoundFault(try ClusterSecurityGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagFault" : self = .invalidTagFault(try InvalidTagFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeClusterSecurityGroupsOutputError: Swift.Error, Swift.Equatable {
    case clusterSecurityGroupNotFoundFault(ClusterSecurityGroupNotFoundFault)
    case invalidTagFault(InvalidTagFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeClusterSecurityGroupsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeClusterSecurityGroupsOutputResponse(clusterSecurityGroups: \(Swift.String(describing: clusterSecurityGroups)), marker: \(Swift.String(describing: marker)))"}
}

extension DescribeClusterSecurityGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeClusterSecurityGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clusterSecurityGroups = output.clusterSecurityGroups
            self.marker = output.marker
        } else {
            self.clusterSecurityGroups = nil
            self.marker = nil
        }
    }
}

/// <p></p>
public struct DescribeClusterSecurityGroupsOutputResponse: Swift.Equatable {
    /// <p>A list of <a>ClusterSecurityGroup</a> instances. </p>
    public let clusterSecurityGroups: [RedshiftClientTypes.ClusterSecurityGroup]?
    /// <p>A value that indicates the starting point for the next set of response records in a
    ///             subsequent request. If a value is returned in a response, you can retrieve the next set
    ///             of records by providing this returned marker value in the <code>Marker</code> parameter
    ///             and retrying the command. If the <code>Marker</code> field is empty, all response
    ///             records have been retrieved for the request. </p>
    public let marker: Swift.String?

    public init (
        clusterSecurityGroups: [RedshiftClientTypes.ClusterSecurityGroup]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.clusterSecurityGroups = clusterSecurityGroups
        self.marker = marker
    }
}

struct DescribeClusterSecurityGroupsOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let clusterSecurityGroups: [RedshiftClientTypes.ClusterSecurityGroup]?
}

extension DescribeClusterSecurityGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterSecurityGroups = "ClusterSecurityGroups"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeClusterSecurityGroupsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.clusterSecurityGroups) {
            struct KeyVal0{struct ClusterSecurityGroup{}}
            let clusterSecurityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ClusterSecurityGroup>.CodingKeys.self, forKey: .clusterSecurityGroups)
            if let clusterSecurityGroupsWrappedContainer = clusterSecurityGroupsWrappedContainer {
                let clusterSecurityGroupsContainer = try clusterSecurityGroupsWrappedContainer.decodeIfPresent([RedshiftClientTypes.ClusterSecurityGroup].self, forKey: .member)
                var clusterSecurityGroupsBuffer:[RedshiftClientTypes.ClusterSecurityGroup]? = nil
                if let clusterSecurityGroupsContainer = clusterSecurityGroupsContainer {
                    clusterSecurityGroupsBuffer = [RedshiftClientTypes.ClusterSecurityGroup]()
                    for structureContainer0 in clusterSecurityGroupsContainer {
                        clusterSecurityGroupsBuffer?.append(structureContainer0)
                    }
                }
                clusterSecurityGroups = clusterSecurityGroupsBuffer
            } else {
                clusterSecurityGroups = []
            }
        } else {
            clusterSecurityGroups = nil
        }
    }
}

public struct DescribeClusterSnapshotsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeClusterSnapshotsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeClusterSnapshotsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeClusterSnapshotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeClusterSnapshotsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeClusterSnapshotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeClusterSnapshotsOutputError>
}

extension DescribeClusterSnapshotsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeClusterSnapshotsInput(clusterExists: \(Swift.String(describing: clusterExists)), clusterIdentifier: \(Swift.String(describing: clusterIdentifier)), endTime: \(Swift.String(describing: endTime)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)), ownerAccount: \(Swift.String(describing: ownerAccount)), snapshotIdentifier: \(Swift.String(describing: snapshotIdentifier)), snapshotType: \(Swift.String(describing: snapshotType)), sortingEntities: \(Swift.String(describing: sortingEntities)), startTime: \(Swift.String(describing: startTime)), tagKeys: \(Swift.String(describing: tagKeys)), tagValues: \(Swift.String(describing: tagValues)))"}
}

extension DescribeClusterSnapshotsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let clusterExists = clusterExists {
            try container.encode(clusterExists, forKey: ClientRuntime.Key("ClusterExists"))
        }
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: ClientRuntime.Key("ClusterIdentifier"))
        }
        if let endTime = endTime {
            try container.encode(ClientRuntime.TimestampWrapper(endTime, format: .dateTime), forKey: ClientRuntime.Key("endTime"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let ownerAccount = ownerAccount {
            try container.encode(ownerAccount, forKey: ClientRuntime.Key("OwnerAccount"))
        }
        if let snapshotIdentifier = snapshotIdentifier {
            try container.encode(snapshotIdentifier, forKey: ClientRuntime.Key("SnapshotIdentifier"))
        }
        if let snapshotType = snapshotType {
            try container.encode(snapshotType, forKey: ClientRuntime.Key("SnapshotType"))
        }
        if let sortingEntities = sortingEntities {
            var sortingEntitiesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SortingEntities"))
            for (index0, snapshotsortingentity0) in sortingEntities.enumerated() {
                try sortingEntitiesContainer.encode(snapshotsortingentity0, forKey: ClientRuntime.Key("SnapshotSortingEntity.\(index0.advanced(by: 1))"))
            }
        }
        if let startTime = startTime {
            try container.encode(ClientRuntime.TimestampWrapper(startTime, format: .dateTime), forKey: ClientRuntime.Key("startTime"))
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
            for (index0, string0) in tagKeys.enumerated() {
                try tagKeysContainer.encode(string0, forKey: ClientRuntime.Key("TagKey.\(index0.advanced(by: 1))"))
            }
        }
        if let tagValues = tagValues {
            var tagValuesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagValues"))
            for (index0, string0) in tagValues.enumerated() {
                try tagValuesContainer.encode(string0, forKey: ClientRuntime.Key("TagValue.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("DescribeClusterSnapshots", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeClusterSnapshotsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeClusterSnapshotsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeClusterSnapshotsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeClusterSnapshotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeClusterSnapshotsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeClusterSnapshotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeClusterSnapshotsOutputError>
}

public struct DescribeClusterSnapshotsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeClusterSnapshotsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeClusterSnapshotsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeClusterSnapshotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeClusterSnapshotsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeClusterSnapshotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeClusterSnapshotsOutputError>
}

/// <p></p>
public struct DescribeClusterSnapshotsInput: Swift.Equatable {
    /// <p>A value that indicates whether to return snapshots only for an existing cluster.
    ///             You can perform table-level restore only by using a snapshot of an existing cluster,
    ///             that is, a cluster that has not been deleted. Values for this parameter work as follows: </p>
    ///         <ul>
    ///             <li>
    ///                 <p>If <code>ClusterExists</code> is set to <code>true</code>,
    ///                         <code>ClusterIdentifier</code> is required.</p>
    ///             </li>
    ///             <li>
    ///                 <p>If <code>ClusterExists</code> is set to <code>false</code> and
    ///                         <code>ClusterIdentifier</code> isn't specified, all snapshots
    ///                     associated with deleted clusters (orphaned snapshots) are returned. </p>
    ///             </li>
    ///             <li>
    ///                 <p>If <code>ClusterExists</code> is set to <code>false</code> and
    ///                         <code>ClusterIdentifier</code> is specified for a deleted cluster, snapshots
    ///                     associated with that cluster are returned.</p>
    ///             </li>
    ///             <li>
    ///                 <p>If <code>ClusterExists</code> is set to <code>false</code> and
    ///                         <code>ClusterIdentifier</code> is specified for an existing cluster, no
    ///                     snapshots are returned. </p>
    ///             </li>
    ///          </ul>
    public let clusterExists: Swift.Bool?
    /// <p>The identifier of the cluster which generated the requested snapshots.</p>
    public let clusterIdentifier: Swift.String?
    /// <p>A time value that requests only snapshots created at or before the specified time.
    ///             The time value is specified in ISO 8601 format. For more information about ISO 8601, go
    ///             to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia
    ///                 page.</a>
    ///         </p>
    ///         <p>Example: <code>2012-07-16T18:00:00Z</code>
    ///         </p>
    public let endTime: ClientRuntime.Date?
    /// <p>An optional parameter that specifies the starting point to return a set of response
    ///             records. When the results of a <a>DescribeClusterSnapshots</a> request exceed
    ///             the value specified in <code>MaxRecords</code>, AWS returns a value in the
    ///                 <code>Marker</code> field of the response. You can retrieve the next set of response
    ///             records by providing the returned marker value in the <code>Marker</code> parameter and
    ///             retrying the request. </p>
    public let marker: Swift.String?
    /// <p>The maximum number of response records to return in each call. If the number of
    ///             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
    ///             is returned in a <code>marker</code> field of the response. You can retrieve the next
    ///             set of records by retrying the command with the returned marker value. </p>
    ///         <p>Default: <code>100</code>
    ///         </p>
    ///         <p>Constraints: minimum 20, maximum 100.</p>
    public let maxRecords: Swift.Int?
    /// <p>The AWS customer account used to create or copy the snapshot. Use this field to
    ///             filter the results to snapshots owned by a particular account. To describe snapshots you
    ///             own, either specify your AWS customer account, or do not specify the
    ///             parameter.</p>
    public let ownerAccount: Swift.String?
    /// <p>The snapshot identifier of the snapshot about which to return
    ///             information.</p>
    public let snapshotIdentifier: Swift.String?
    /// <p>The type of snapshots for which you are requesting information. By default,
    ///             snapshots of all types are returned.</p>
    ///         <p>Valid Values: <code>automated</code> | <code>manual</code>
    ///         </p>
    public let snapshotType: Swift.String?
    /// <p></p>
    public let sortingEntities: [RedshiftClientTypes.SnapshotSortingEntity]?
    /// <p>A value that requests only snapshots created at or after the specified time. The
    ///             time value is specified in ISO 8601 format. For more information about ISO 8601, go to
    ///             the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a>
    ///         </p>
    ///         <p>Example: <code>2012-07-16T18:00:00Z</code>
    ///         </p>
    public let startTime: ClientRuntime.Date?
    /// <p>A tag key or keys for which you want to return all matching cluster snapshots that
    ///             are associated with the specified key or keys. For example, suppose that you have
    ///             snapshots that are tagged with keys called <code>owner</code> and
    ///                 <code>environment</code>. If you specify both of these tag keys in the request,
    ///             Amazon Redshift returns a response with the snapshots that have either or both of these tag
    ///             keys associated with them.</p>
    public let tagKeys: [Swift.String]?
    /// <p>A tag value or values for which you want to return all matching cluster snapshots
    ///             that are associated with the specified tag value or values. For example, suppose that
    ///             you have snapshots that are tagged with values called <code>admin</code> and
    ///                 <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift
    ///             returns a response with the snapshots that have either or both of these tag values
    ///             associated with them.</p>
    public let tagValues: [Swift.String]?

    public init (
        clusterExists: Swift.Bool? = nil,
        clusterIdentifier: Swift.String? = nil,
        endTime: ClientRuntime.Date? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        ownerAccount: Swift.String? = nil,
        snapshotIdentifier: Swift.String? = nil,
        snapshotType: Swift.String? = nil,
        sortingEntities: [RedshiftClientTypes.SnapshotSortingEntity]? = nil,
        startTime: ClientRuntime.Date? = nil,
        tagKeys: [Swift.String]? = nil,
        tagValues: [Swift.String]? = nil
    )
    {
        self.clusterExists = clusterExists
        self.clusterIdentifier = clusterIdentifier
        self.endTime = endTime
        self.marker = marker
        self.maxRecords = maxRecords
        self.ownerAccount = ownerAccount
        self.snapshotIdentifier = snapshotIdentifier
        self.snapshotType = snapshotType
        self.sortingEntities = sortingEntities
        self.startTime = startTime
        self.tagKeys = tagKeys
        self.tagValues = tagValues
    }
}

extension DescribeClusterSnapshotsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeClusterSnapshotsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterSnapshotNotFoundFault" : self = .clusterSnapshotNotFoundFault(try ClusterSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagFault" : self = .invalidTagFault(try InvalidTagFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeClusterSnapshotsOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case clusterSnapshotNotFoundFault(ClusterSnapshotNotFoundFault)
    case invalidTagFault(InvalidTagFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeClusterSnapshotsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeClusterSnapshotsOutputResponse(marker: \(Swift.String(describing: marker)), snapshots: \(Swift.String(describing: snapshots)))"}
}

extension DescribeClusterSnapshotsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeClusterSnapshotsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.snapshots = output.snapshots
        } else {
            self.marker = nil
            self.snapshots = nil
        }
    }
}

/// <p>Contains the output from the <a>DescribeClusterSnapshots</a> action.
///         </p>
public struct DescribeClusterSnapshotsOutputResponse: Swift.Equatable {
    /// <p>A value that indicates the starting point for the next set of response records in a
    ///             subsequent request. If a value is returned in a response, you can retrieve the next set
    ///             of records by providing this returned marker value in the <code>Marker</code> parameter
    ///             and retrying the command. If the <code>Marker</code> field is empty, all response
    ///             records have been retrieved for the request. </p>
    public let marker: Swift.String?
    /// <p>A list of <a>Snapshot</a> instances. </p>
    public let snapshots: [RedshiftClientTypes.Snapshot]?

    public init (
        marker: Swift.String? = nil,
        snapshots: [RedshiftClientTypes.Snapshot]? = nil
    )
    {
        self.marker = marker
        self.snapshots = snapshots
    }
}

struct DescribeClusterSnapshotsOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let snapshots: [RedshiftClientTypes.Snapshot]?
}

extension DescribeClusterSnapshotsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case snapshots = "Snapshots"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeClusterSnapshotsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.snapshots) {
            struct KeyVal0{struct Snapshot{}}
            let snapshotsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Snapshot>.CodingKeys.self, forKey: .snapshots)
            if let snapshotsWrappedContainer = snapshotsWrappedContainer {
                let snapshotsContainer = try snapshotsWrappedContainer.decodeIfPresent([RedshiftClientTypes.Snapshot].self, forKey: .member)
                var snapshotsBuffer:[RedshiftClientTypes.Snapshot]? = nil
                if let snapshotsContainer = snapshotsContainer {
                    snapshotsBuffer = [RedshiftClientTypes.Snapshot]()
                    for structureContainer0 in snapshotsContainer {
                        snapshotsBuffer?.append(structureContainer0)
                    }
                }
                snapshots = snapshotsBuffer
            } else {
                snapshots = []
            }
        } else {
            snapshots = nil
        }
    }
}

public struct DescribeClusterSubnetGroupsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeClusterSubnetGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeClusterSubnetGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeClusterSubnetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeClusterSubnetGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeClusterSubnetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeClusterSubnetGroupsOutputError>
}

extension DescribeClusterSubnetGroupsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeClusterSubnetGroupsInput(clusterSubnetGroupName: \(Swift.String(describing: clusterSubnetGroupName)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)), tagKeys: \(Swift.String(describing: tagKeys)), tagValues: \(Swift.String(describing: tagValues)))"}
}

extension DescribeClusterSubnetGroupsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let clusterSubnetGroupName = clusterSubnetGroupName {
            try container.encode(clusterSubnetGroupName, forKey: ClientRuntime.Key("ClusterSubnetGroupName"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
            for (index0, string0) in tagKeys.enumerated() {
                try tagKeysContainer.encode(string0, forKey: ClientRuntime.Key("TagKey.\(index0.advanced(by: 1))"))
            }
        }
        if let tagValues = tagValues {
            var tagValuesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagValues"))
            for (index0, string0) in tagValues.enumerated() {
                try tagValuesContainer.encode(string0, forKey: ClientRuntime.Key("TagValue.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("DescribeClusterSubnetGroups", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeClusterSubnetGroupsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeClusterSubnetGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeClusterSubnetGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeClusterSubnetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeClusterSubnetGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeClusterSubnetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeClusterSubnetGroupsOutputError>
}

public struct DescribeClusterSubnetGroupsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeClusterSubnetGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeClusterSubnetGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeClusterSubnetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeClusterSubnetGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeClusterSubnetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeClusterSubnetGroupsOutputError>
}

/// <p></p>
public struct DescribeClusterSubnetGroupsInput: Swift.Equatable {
    /// <p>The name of the cluster subnet group for which information is requested.</p>
    public let clusterSubnetGroupName: Swift.String?
    /// <p>An optional parameter that specifies the starting point to return a set of response
    ///             records. When the results of a <a>DescribeClusterSubnetGroups</a> request
    ///             exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the
    ///                 <code>Marker</code> field of the response. You can retrieve the next set of response
    ///             records by providing the returned marker value in the <code>Marker</code> parameter and
    ///             retrying the request. </p>
    public let marker: Swift.String?
    /// <p>The maximum number of response records to return in each call. If the number of
    ///             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
    ///             is returned in a <code>marker</code> field of the response. You can retrieve the next
    ///             set of records by retrying the command with the returned marker value. </p>
    ///         <p>Default: <code>100</code>
    ///         </p>
    ///         <p>Constraints: minimum 20, maximum 100.</p>
    public let maxRecords: Swift.Int?
    /// <p>A tag key or keys for which you want to return all matching cluster subnet groups
    ///             that are associated with the specified key or keys. For example, suppose that you have
    ///             subnet groups that are tagged with keys called <code>owner</code> and
    ///                 <code>environment</code>. If you specify both of these tag keys in the request,
    ///             Amazon Redshift returns a response with the subnet groups that have either or both of these
    ///             tag keys associated with them.</p>
    public let tagKeys: [Swift.String]?
    /// <p>A tag value or values for which you want to return all matching cluster subnet
    ///             groups that are associated with the specified tag value or values. For example, suppose
    ///             that you have subnet groups that are tagged with values called <code>admin</code> and
    ///                 <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift
    ///             returns a response with the subnet groups that have either or both of these tag values
    ///             associated with them.</p>
    public let tagValues: [Swift.String]?

    public init (
        clusterSubnetGroupName: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        tagKeys: [Swift.String]? = nil,
        tagValues: [Swift.String]? = nil
    )
    {
        self.clusterSubnetGroupName = clusterSubnetGroupName
        self.marker = marker
        self.maxRecords = maxRecords
        self.tagKeys = tagKeys
        self.tagValues = tagValues
    }
}

extension DescribeClusterSubnetGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeClusterSubnetGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterSubnetGroupNotFoundFault" : self = .clusterSubnetGroupNotFoundFault(try ClusterSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagFault" : self = .invalidTagFault(try InvalidTagFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeClusterSubnetGroupsOutputError: Swift.Error, Swift.Equatable {
    case clusterSubnetGroupNotFoundFault(ClusterSubnetGroupNotFoundFault)
    case invalidTagFault(InvalidTagFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeClusterSubnetGroupsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeClusterSubnetGroupsOutputResponse(clusterSubnetGroups: \(Swift.String(describing: clusterSubnetGroups)), marker: \(Swift.String(describing: marker)))"}
}

extension DescribeClusterSubnetGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeClusterSubnetGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clusterSubnetGroups = output.clusterSubnetGroups
            self.marker = output.marker
        } else {
            self.clusterSubnetGroups = nil
            self.marker = nil
        }
    }
}

/// <p>Contains the output from the <a>DescribeClusterSubnetGroups</a> action.
///         </p>
public struct DescribeClusterSubnetGroupsOutputResponse: Swift.Equatable {
    /// <p>A list of <a>ClusterSubnetGroup</a> instances. </p>
    public let clusterSubnetGroups: [RedshiftClientTypes.ClusterSubnetGroup]?
    /// <p>A value that indicates the starting point for the next set of response records in a
    ///             subsequent request. If a value is returned in a response, you can retrieve the next set
    ///             of records by providing this returned marker value in the <code>Marker</code> parameter
    ///             and retrying the command. If the <code>Marker</code> field is empty, all response
    ///             records have been retrieved for the request. </p>
    public let marker: Swift.String?

    public init (
        clusterSubnetGroups: [RedshiftClientTypes.ClusterSubnetGroup]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.clusterSubnetGroups = clusterSubnetGroups
        self.marker = marker
    }
}

struct DescribeClusterSubnetGroupsOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let clusterSubnetGroups: [RedshiftClientTypes.ClusterSubnetGroup]?
}

extension DescribeClusterSubnetGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterSubnetGroups = "ClusterSubnetGroups"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeClusterSubnetGroupsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.clusterSubnetGroups) {
            struct KeyVal0{struct ClusterSubnetGroup{}}
            let clusterSubnetGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ClusterSubnetGroup>.CodingKeys.self, forKey: .clusterSubnetGroups)
            if let clusterSubnetGroupsWrappedContainer = clusterSubnetGroupsWrappedContainer {
                let clusterSubnetGroupsContainer = try clusterSubnetGroupsWrappedContainer.decodeIfPresent([RedshiftClientTypes.ClusterSubnetGroup].self, forKey: .member)
                var clusterSubnetGroupsBuffer:[RedshiftClientTypes.ClusterSubnetGroup]? = nil
                if let clusterSubnetGroupsContainer = clusterSubnetGroupsContainer {
                    clusterSubnetGroupsBuffer = [RedshiftClientTypes.ClusterSubnetGroup]()
                    for structureContainer0 in clusterSubnetGroupsContainer {
                        clusterSubnetGroupsBuffer?.append(structureContainer0)
                    }
                }
                clusterSubnetGroups = clusterSubnetGroupsBuffer
            } else {
                clusterSubnetGroups = []
            }
        } else {
            clusterSubnetGroups = nil
        }
    }
}

public struct DescribeClusterTracksInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeClusterTracksInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeClusterTracksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeClusterTracksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeClusterTracksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeClusterTracksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeClusterTracksOutputError>
}

extension DescribeClusterTracksInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeClusterTracksInput(maintenanceTrackName: \(Swift.String(describing: maintenanceTrackName)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)))"}
}

extension DescribeClusterTracksInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let maintenanceTrackName = maintenanceTrackName {
            try container.encode(maintenanceTrackName, forKey: ClientRuntime.Key("MaintenanceTrackName"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        try container.encode("DescribeClusterTracks", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeClusterTracksInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeClusterTracksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeClusterTracksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeClusterTracksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeClusterTracksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeClusterTracksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeClusterTracksOutputError>
}

public struct DescribeClusterTracksInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeClusterTracksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeClusterTracksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeClusterTracksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeClusterTracksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeClusterTracksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeClusterTracksOutputError>
}

public struct DescribeClusterTracksInput: Swift.Equatable {
    /// <p>The name of the maintenance track. </p>
    public let maintenanceTrackName: Swift.String?
    /// <p>An optional parameter that specifies the starting point to return a set of response
    ///             records. When the results of a <code>DescribeClusterTracks</code> request exceed the
    ///             value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the
    ///                 <code>Marker</code> field of the response. You can retrieve the next set of response
    ///             records by providing the returned marker value in the <code>Marker</code> parameter and
    ///             retrying the request. </p>
    public let marker: Swift.String?
    /// <p>An integer value for the maximum number of maintenance tracks to return.</p>
    public let maxRecords: Swift.Int?

    public init (
        maintenanceTrackName: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.maintenanceTrackName = maintenanceTrackName
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeClusterTracksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeClusterTracksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidClusterTrackFault" : self = .invalidClusterTrackFault(try InvalidClusterTrackFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeClusterTracksOutputError: Swift.Error, Swift.Equatable {
    case invalidClusterTrackFault(InvalidClusterTrackFault)
    case unauthorizedOperation(UnauthorizedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeClusterTracksOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeClusterTracksOutputResponse(maintenanceTracks: \(Swift.String(describing: maintenanceTracks)), marker: \(Swift.String(describing: marker)))"}
}

extension DescribeClusterTracksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeClusterTracksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.maintenanceTracks = output.maintenanceTracks
            self.marker = output.marker
        } else {
            self.maintenanceTracks = nil
            self.marker = nil
        }
    }
}

public struct DescribeClusterTracksOutputResponse: Swift.Equatable {
    /// <p>A list of maintenance tracks output by the <code>DescribeClusterTracks</code>
    ///             operation. </p>
    public let maintenanceTracks: [RedshiftClientTypes.MaintenanceTrack]?
    /// <p>The starting point to return a set of response tracklist records. You can retrieve the
    ///             next set of response records by providing the returned marker value in the
    ///                 <code>Marker</code> parameter and retrying the request.</p>
    public let marker: Swift.String?

    public init (
        maintenanceTracks: [RedshiftClientTypes.MaintenanceTrack]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.maintenanceTracks = maintenanceTracks
        self.marker = marker
    }
}

struct DescribeClusterTracksOutputResponseBody: Swift.Equatable {
    public let maintenanceTracks: [RedshiftClientTypes.MaintenanceTrack]?
    public let marker: Swift.String?
}

extension DescribeClusterTracksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maintenanceTracks = "MaintenanceTracks"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeClusterTracksResult"))
        if containerValues.contains(.maintenanceTracks) {
            struct KeyVal0{struct MaintenanceTrack{}}
            let maintenanceTracksWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.MaintenanceTrack>.CodingKeys.self, forKey: .maintenanceTracks)
            if let maintenanceTracksWrappedContainer = maintenanceTracksWrappedContainer {
                let maintenanceTracksContainer = try maintenanceTracksWrappedContainer.decodeIfPresent([RedshiftClientTypes.MaintenanceTrack].self, forKey: .member)
                var maintenanceTracksBuffer:[RedshiftClientTypes.MaintenanceTrack]? = nil
                if let maintenanceTracksContainer = maintenanceTracksContainer {
                    maintenanceTracksBuffer = [RedshiftClientTypes.MaintenanceTrack]()
                    for structureContainer0 in maintenanceTracksContainer {
                        maintenanceTracksBuffer?.append(structureContainer0)
                    }
                }
                maintenanceTracks = maintenanceTracksBuffer
            } else {
                maintenanceTracks = []
            }
        } else {
            maintenanceTracks = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribeClusterVersionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeClusterVersionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeClusterVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeClusterVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeClusterVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeClusterVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeClusterVersionsOutputError>
}

extension DescribeClusterVersionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeClusterVersionsInput(clusterParameterGroupFamily: \(Swift.String(describing: clusterParameterGroupFamily)), clusterVersion: \(Swift.String(describing: clusterVersion)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)))"}
}

extension DescribeClusterVersionsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let clusterParameterGroupFamily = clusterParameterGroupFamily {
            try container.encode(clusterParameterGroupFamily, forKey: ClientRuntime.Key("ClusterParameterGroupFamily"))
        }
        if let clusterVersion = clusterVersion {
            try container.encode(clusterVersion, forKey: ClientRuntime.Key("ClusterVersion"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        try container.encode("DescribeClusterVersions", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeClusterVersionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeClusterVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeClusterVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeClusterVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeClusterVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeClusterVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeClusterVersionsOutputError>
}

public struct DescribeClusterVersionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeClusterVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeClusterVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeClusterVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeClusterVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeClusterVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeClusterVersionsOutputError>
}

/// <p></p>
public struct DescribeClusterVersionsInput: Swift.Equatable {
    /// <p>The name of a specific cluster parameter group family to return details
    ///             for.</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Must be 1 to 255 alphanumeric characters</p>
    ///             </li>
    ///             <li>
    ///                 <p>First character must be a letter</p>
    ///             </li>
    ///             <li>
    ///                 <p>Cannot end with a hyphen or contain two consecutive hyphens</p>
    ///             </li>
    ///          </ul>
    public let clusterParameterGroupFamily: Swift.String?
    /// <p>The specific cluster version to return.</p>
    ///         <p>Example: <code>1.0</code>
    ///         </p>
    public let clusterVersion: Swift.String?
    /// <p>An optional parameter that specifies the starting point to return a set of response
    ///             records. When the results of a <a>DescribeClusterVersions</a> request exceed
    ///             the value specified in <code>MaxRecords</code>, AWS returns a value in the
    ///                 <code>Marker</code> field of the response. You can retrieve the next set of response
    ///             records by providing the returned marker value in the <code>Marker</code> parameter and
    ///             retrying the request. </p>
    public let marker: Swift.String?
    /// <p>The maximum number of response records to return in each call. If the number of
    ///             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
    ///             is returned in a <code>marker</code> field of the response. You can retrieve the next
    ///             set of records by retrying the command with the returned marker value. </p>
    ///         <p>Default: <code>100</code>
    ///         </p>
    ///         <p>Constraints: minimum 20, maximum 100.</p>
    public let maxRecords: Swift.Int?

    public init (
        clusterParameterGroupFamily: Swift.String? = nil,
        clusterVersion: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.clusterParameterGroupFamily = clusterParameterGroupFamily
        self.clusterVersion = clusterVersion
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeClusterVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeClusterVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeClusterVersionsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeClusterVersionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeClusterVersionsOutputResponse(clusterVersions: \(Swift.String(describing: clusterVersions)), marker: \(Swift.String(describing: marker)))"}
}

extension DescribeClusterVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeClusterVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clusterVersions = output.clusterVersions
            self.marker = output.marker
        } else {
            self.clusterVersions = nil
            self.marker = nil
        }
    }
}

/// <p>Contains the output from the <a>DescribeClusterVersions</a> action.
///         </p>
public struct DescribeClusterVersionsOutputResponse: Swift.Equatable {
    /// <p>A list of <code>Version</code> elements. </p>
    public let clusterVersions: [RedshiftClientTypes.ClusterVersion]?
    /// <p>A value that indicates the starting point for the next set of response records in a
    ///             subsequent request. If a value is returned in a response, you can retrieve the next set
    ///             of records by providing this returned marker value in the <code>Marker</code> parameter
    ///             and retrying the command. If the <code>Marker</code> field is empty, all response
    ///             records have been retrieved for the request. </p>
    public let marker: Swift.String?

    public init (
        clusterVersions: [RedshiftClientTypes.ClusterVersion]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.clusterVersions = clusterVersions
        self.marker = marker
    }
}

struct DescribeClusterVersionsOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let clusterVersions: [RedshiftClientTypes.ClusterVersion]?
}

extension DescribeClusterVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterVersions = "ClusterVersions"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeClusterVersionsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.clusterVersions) {
            struct KeyVal0{struct ClusterVersion{}}
            let clusterVersionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ClusterVersion>.CodingKeys.self, forKey: .clusterVersions)
            if let clusterVersionsWrappedContainer = clusterVersionsWrappedContainer {
                let clusterVersionsContainer = try clusterVersionsWrappedContainer.decodeIfPresent([RedshiftClientTypes.ClusterVersion].self, forKey: .member)
                var clusterVersionsBuffer:[RedshiftClientTypes.ClusterVersion]? = nil
                if let clusterVersionsContainer = clusterVersionsContainer {
                    clusterVersionsBuffer = [RedshiftClientTypes.ClusterVersion]()
                    for structureContainer0 in clusterVersionsContainer {
                        clusterVersionsBuffer?.append(structureContainer0)
                    }
                }
                clusterVersions = clusterVersionsBuffer
            } else {
                clusterVersions = []
            }
        } else {
            clusterVersions = nil
        }
    }
}

public struct DescribeClustersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeClustersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeClustersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeClustersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeClustersOutputError>
}

extension DescribeClustersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeClustersInput(clusterIdentifier: \(Swift.String(describing: clusterIdentifier)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)), tagKeys: \(Swift.String(describing: tagKeys)), tagValues: \(Swift.String(describing: tagValues)))"}
}

extension DescribeClustersInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: ClientRuntime.Key("ClusterIdentifier"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
            for (index0, string0) in tagKeys.enumerated() {
                try tagKeysContainer.encode(string0, forKey: ClientRuntime.Key("TagKey.\(index0.advanced(by: 1))"))
            }
        }
        if let tagValues = tagValues {
            var tagValuesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagValues"))
            for (index0, string0) in tagValues.enumerated() {
                try tagValuesContainer.encode(string0, forKey: ClientRuntime.Key("TagValue.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("DescribeClusters", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeClustersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeClustersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeClustersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeClustersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeClustersOutputError>
}

public struct DescribeClustersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeClustersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeClustersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeClustersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeClustersOutputError>
}

/// <p></p>
public struct DescribeClustersInput: Swift.Equatable {
    /// <p>The unique identifier of a cluster whose properties you are requesting. This
    ///             parameter is case sensitive.</p>
    ///         <p>The default is that all clusters defined for an account are returned.</p>
    public let clusterIdentifier: Swift.String?
    /// <p>An optional parameter that specifies the starting point to return a set of response
    ///             records. When the results of a <a>DescribeClusters</a> request exceed the
    ///             value specified in <code>MaxRecords</code>, AWS returns a value in the
    ///                 <code>Marker</code> field of the response. You can retrieve the next set of response
    ///             records by providing the returned marker value in the <code>Marker</code> parameter and
    ///             retrying the request. </p>
    ///         <p>Constraints: You can specify either the <b>ClusterIdentifier</b> parameter or the <b>Marker</b> parameter, but not both. </p>
    public let marker: Swift.String?
    /// <p>The maximum number of response records to return in each call. If the number of
    ///             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
    ///             is returned in a <code>marker</code> field of the response. You can retrieve the next
    ///             set of records by retrying the command with the returned marker value. </p>
    ///         <p>Default: <code>100</code>
    ///         </p>
    ///         <p>Constraints: minimum 20, maximum 100.</p>
    public let maxRecords: Swift.Int?
    /// <p>A tag key or keys for which you want to return all matching clusters that are
    ///             associated with the specified key or keys. For example, suppose that you have clusters
    ///             that are tagged with keys called <code>owner</code> and <code>environment</code>. If you
    ///             specify both of these tag keys in the request, Amazon Redshift returns a response with the
    ///             clusters that have either or both of these tag keys associated with them.</p>
    public let tagKeys: [Swift.String]?
    /// <p>A tag value or values for which you want to return all matching clusters that are
    ///             associated with the specified tag value or values. For example, suppose that you have
    ///             clusters that are tagged with values called <code>admin</code> and <code>test</code>. If
    ///             you specify both of these tag values in the request, Amazon Redshift returns a response with
    ///             the clusters that have either or both of these tag values associated with
    ///             them.</p>
    public let tagValues: [Swift.String]?

    public init (
        clusterIdentifier: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        tagKeys: [Swift.String]? = nil,
        tagValues: [Swift.String]? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
        self.marker = marker
        self.maxRecords = maxRecords
        self.tagKeys = tagKeys
        self.tagValues = tagValues
    }
}

extension DescribeClustersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeClustersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagFault" : self = .invalidTagFault(try InvalidTagFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeClustersOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case invalidTagFault(InvalidTagFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeClustersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeClustersOutputResponse(clusters: \(Swift.String(describing: clusters)), marker: \(Swift.String(describing: marker)))"}
}

extension DescribeClustersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeClustersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clusters = output.clusters
            self.marker = output.marker
        } else {
            self.clusters = nil
            self.marker = nil
        }
    }
}

/// <p>Contains the output from the <a>DescribeClusters</a> action. </p>
public struct DescribeClustersOutputResponse: Swift.Equatable {
    /// <p>A list of <code>Cluster</code> objects, where each object describes one cluster.
    ///         </p>
    public let clusters: [RedshiftClientTypes.Cluster]?
    /// <p>A value that indicates the starting point for the next set of response records in a
    ///             subsequent request. If a value is returned in a response, you can retrieve the next set
    ///             of records by providing this returned marker value in the <code>Marker</code> parameter
    ///             and retrying the command. If the <code>Marker</code> field is empty, all response
    ///             records have been retrieved for the request. </p>
    public let marker: Swift.String?

    public init (
        clusters: [RedshiftClientTypes.Cluster]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.clusters = clusters
        self.marker = marker
    }
}

struct DescribeClustersOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let clusters: [RedshiftClientTypes.Cluster]?
}

extension DescribeClustersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusters = "Clusters"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeClustersResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.clusters) {
            struct KeyVal0{struct Cluster{}}
            let clustersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Cluster>.CodingKeys.self, forKey: .clusters)
            if let clustersWrappedContainer = clustersWrappedContainer {
                let clustersContainer = try clustersWrappedContainer.decodeIfPresent([RedshiftClientTypes.Cluster].self, forKey: .member)
                var clustersBuffer:[RedshiftClientTypes.Cluster]? = nil
                if let clustersContainer = clustersContainer {
                    clustersBuffer = [RedshiftClientTypes.Cluster]()
                    for structureContainer0 in clustersContainer {
                        clustersBuffer?.append(structureContainer0)
                    }
                }
                clusters = clustersBuffer
            } else {
                clusters = []
            }
        } else {
            clusters = nil
        }
    }
}

public struct DescribeDefaultClusterParametersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDefaultClusterParametersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDefaultClusterParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDefaultClusterParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDefaultClusterParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDefaultClusterParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDefaultClusterParametersOutputError>
}

extension DescribeDefaultClusterParametersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDefaultClusterParametersInput(marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)), parameterGroupFamily: \(Swift.String(describing: parameterGroupFamily)))"}
}

extension DescribeDefaultClusterParametersInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let parameterGroupFamily = parameterGroupFamily {
            try container.encode(parameterGroupFamily, forKey: ClientRuntime.Key("ParameterGroupFamily"))
        }
        try container.encode("DescribeDefaultClusterParameters", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeDefaultClusterParametersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDefaultClusterParametersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDefaultClusterParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDefaultClusterParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDefaultClusterParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDefaultClusterParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDefaultClusterParametersOutputError>
}

public struct DescribeDefaultClusterParametersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDefaultClusterParametersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDefaultClusterParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDefaultClusterParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDefaultClusterParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDefaultClusterParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDefaultClusterParametersOutputError>
}

/// <p></p>
public struct DescribeDefaultClusterParametersInput: Swift.Equatable {
    /// <p>An optional parameter that specifies the starting point to return a set of response
    ///             records. When the results of a <a>DescribeDefaultClusterParameters</a>
    ///             request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in
    ///             the <code>Marker</code> field of the response. You can retrieve the next set of response
    ///             records by providing the returned marker value in the <code>Marker</code> parameter and
    ///             retrying the request. </p>
    public let marker: Swift.String?
    /// <p>The maximum number of response records to return in each call. If the number of
    ///             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
    ///             is returned in a <code>marker</code> field of the response. You can retrieve the next
    ///             set of records by retrying the command with the returned marker value. </p>
    ///         <p>Default: <code>100</code>
    ///         </p>
    ///         <p>Constraints: minimum 20, maximum 100.</p>
    public let maxRecords: Swift.Int?
    /// <p>The name of the cluster parameter group family.</p>
    public let parameterGroupFamily: Swift.String?

    public init (
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        parameterGroupFamily: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxRecords = maxRecords
        self.parameterGroupFamily = parameterGroupFamily
    }
}

extension DescribeDefaultClusterParametersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDefaultClusterParametersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDefaultClusterParametersOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDefaultClusterParametersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDefaultClusterParametersOutputResponse(defaultClusterParameters: \(Swift.String(describing: defaultClusterParameters)))"}
}

extension DescribeDefaultClusterParametersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDefaultClusterParametersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.defaultClusterParameters = output.defaultClusterParameters
        } else {
            self.defaultClusterParameters = nil
        }
    }
}

public struct DescribeDefaultClusterParametersOutputResponse: Swift.Equatable {
    /// <p>Describes the default cluster parameters for a parameter group family.</p>
    public let defaultClusterParameters: RedshiftClientTypes.DefaultClusterParameters?

    public init (
        defaultClusterParameters: RedshiftClientTypes.DefaultClusterParameters? = nil
    )
    {
        self.defaultClusterParameters = defaultClusterParameters
    }
}

struct DescribeDefaultClusterParametersOutputResponseBody: Swift.Equatable {
    public let defaultClusterParameters: RedshiftClientTypes.DefaultClusterParameters?
}

extension DescribeDefaultClusterParametersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultClusterParameters = "DefaultClusterParameters"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeDefaultClusterParametersResult"))
        let defaultClusterParametersDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.DefaultClusterParameters.self, forKey: .defaultClusterParameters)
        defaultClusterParameters = defaultClusterParametersDecoded
    }
}

public struct DescribeEndpointAccessInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEndpointAccessInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEndpointAccessInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEndpointAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEndpointAccessInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEndpointAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEndpointAccessOutputError>
}

extension DescribeEndpointAccessInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEndpointAccessInput(clusterIdentifier: \(Swift.String(describing: clusterIdentifier)), endpointName: \(Swift.String(describing: endpointName)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)), resourceOwner: \(Swift.String(describing: resourceOwner)), vpcId: \(Swift.String(describing: vpcId)))"}
}

extension DescribeEndpointAccessInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: ClientRuntime.Key("ClusterIdentifier"))
        }
        if let endpointName = endpointName {
            try container.encode(endpointName, forKey: ClientRuntime.Key("EndpointName"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let resourceOwner = resourceOwner {
            try container.encode(resourceOwner, forKey: ClientRuntime.Key("ResourceOwner"))
        }
        if let vpcId = vpcId {
            try container.encode(vpcId, forKey: ClientRuntime.Key("VpcId"))
        }
        try container.encode("DescribeEndpointAccess", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeEndpointAccessInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEndpointAccessInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEndpointAccessInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEndpointAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEndpointAccessInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEndpointAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEndpointAccessOutputError>
}

public struct DescribeEndpointAccessInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEndpointAccessInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEndpointAccessInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEndpointAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEndpointAccessInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEndpointAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEndpointAccessOutputError>
}

public struct DescribeEndpointAccessInput: Swift.Equatable {
    /// <p>The cluster identifier associated with the described endpoint.</p>
    public let clusterIdentifier: Swift.String?
    /// <p>The name of the endpoint to be described.</p>
    public let endpointName: Swift.String?
    /// <p>An optional pagination token provided by a previous
    ///             <code>DescribeEndpointAccess</code> request. If this parameter is specified, the
    ///             response includes only records beyond the marker, up to the value specified by the
    ///             <code>MaxRecords</code> parameter.</p>
    public let marker: Swift.String?
    /// <p>The maximum number of records to include in the response. If more records exist
    ///             than the specified <code>MaxRecords</code> value, a pagination token called a <code>Marker</code> is
    ///             included in the response so that the remaining results can be retrieved.</p>
    public let maxRecords: Swift.Int?
    /// <p>The AWS account ID of the owner of the cluster.</p>
    public let resourceOwner: Swift.String?
    /// <p>The virtual private cloud (VPC) identifier with access to the cluster.</p>
    public let vpcId: Swift.String?

    public init (
        clusterIdentifier: Swift.String? = nil,
        endpointName: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        resourceOwner: Swift.String? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
        self.endpointName = endpointName
        self.marker = marker
        self.maxRecords = maxRecords
        self.resourceOwner = resourceOwner
        self.vpcId = vpcId
    }
}

extension DescribeEndpointAccessOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeEndpointAccessOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EndpointNotFoundFault" : self = .endpointNotFoundFault(try EndpointNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEndpointAccessOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case endpointNotFoundFault(EndpointNotFoundFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEndpointAccessOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEndpointAccessOutputResponse(endpointAccessList: \(Swift.String(describing: endpointAccessList)), marker: \(Swift.String(describing: marker)))"}
}

extension DescribeEndpointAccessOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeEndpointAccessOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endpointAccessList = output.endpointAccessList
            self.marker = output.marker
        } else {
            self.endpointAccessList = nil
            self.marker = nil
        }
    }
}

public struct DescribeEndpointAccessOutputResponse: Swift.Equatable {
    /// <p>The list of endpoints with access to the cluster.</p>
    public let endpointAccessList: [RedshiftClientTypes.EndpointAccess]?
    /// <p>An optional pagination token provided by a previous
    ///             <code>DescribeEndpointAccess</code> request. If this parameter is specified, the
    ///             response includes only records beyond the marker, up to the value specified by the
    ///             <code>MaxRecords</code> parameter.</p>
    public let marker: Swift.String?

    public init (
        endpointAccessList: [RedshiftClientTypes.EndpointAccess]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.endpointAccessList = endpointAccessList
        self.marker = marker
    }
}

struct DescribeEndpointAccessOutputResponseBody: Swift.Equatable {
    public let endpointAccessList: [RedshiftClientTypes.EndpointAccess]?
    public let marker: Swift.String?
}

extension DescribeEndpointAccessOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointAccessList = "EndpointAccessList"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeEndpointAccessResult"))
        if containerValues.contains(.endpointAccessList) {
            struct KeyVal0{struct member{}}
            let endpointAccessListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .endpointAccessList)
            if let endpointAccessListWrappedContainer = endpointAccessListWrappedContainer {
                let endpointAccessListContainer = try endpointAccessListWrappedContainer.decodeIfPresent([RedshiftClientTypes.EndpointAccess].self, forKey: .member)
                var endpointAccessListBuffer:[RedshiftClientTypes.EndpointAccess]? = nil
                if let endpointAccessListContainer = endpointAccessListContainer {
                    endpointAccessListBuffer = [RedshiftClientTypes.EndpointAccess]()
                    for structureContainer0 in endpointAccessListContainer {
                        endpointAccessListBuffer?.append(structureContainer0)
                    }
                }
                endpointAccessList = endpointAccessListBuffer
            } else {
                endpointAccessList = []
            }
        } else {
            endpointAccessList = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribeEndpointAuthorizationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEndpointAuthorizationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEndpointAuthorizationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEndpointAuthorizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEndpointAuthorizationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEndpointAuthorizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEndpointAuthorizationOutputError>
}

extension DescribeEndpointAuthorizationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEndpointAuthorizationInput(account: \(Swift.String(describing: account)), clusterIdentifier: \(Swift.String(describing: clusterIdentifier)), grantee: \(Swift.String(describing: grantee)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)))"}
}

extension DescribeEndpointAuthorizationInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let account = account {
            try container.encode(account, forKey: ClientRuntime.Key("Account"))
        }
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: ClientRuntime.Key("ClusterIdentifier"))
        }
        if let grantee = grantee {
            try container.encode(grantee, forKey: ClientRuntime.Key("Grantee"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        try container.encode("DescribeEndpointAuthorization", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeEndpointAuthorizationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEndpointAuthorizationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEndpointAuthorizationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEndpointAuthorizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEndpointAuthorizationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEndpointAuthorizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEndpointAuthorizationOutputError>
}

public struct DescribeEndpointAuthorizationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEndpointAuthorizationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEndpointAuthorizationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEndpointAuthorizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEndpointAuthorizationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEndpointAuthorizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEndpointAuthorizationOutputError>
}

public struct DescribeEndpointAuthorizationInput: Swift.Equatable {
    /// <p>The AWS account ID of either the cluster owner (grantor) or grantee.
    ///        If <code>Grantee</code> parameter is true, then the <code>Account</code> value is of the grantor.</p>
    public let account: Swift.String?
    /// <p>The cluster identifier of the cluster to access.</p>
    public let clusterIdentifier: Swift.String?
    /// <p>Indicates whether to check authorization from a grantor or grantee point of view.
    ///            If true, Amazon Redshift returns endpoint authorizations that you've been granted.
    ///            If false (default), checks authorization from a grantor point of view.</p>
    public let grantee: Swift.Bool?
    /// <p>An optional pagination token provided by a previous
    ///             <code>DescribeEndpointAuthorization</code> request. If this parameter is specified, the
    ///             response includes only records beyond the marker, up to the value specified by the
    ///             <code>MaxRecords</code> parameter.</p>
    public let marker: Swift.String?
    /// <p>The maximum number of records to include in the response. If more records exist
    ///             than the specified <code>MaxRecords</code> value, a pagination token called a <code>Marker</code> is
    ///             included in the response so that the remaining results can be retrieved.</p>
    public let maxRecords: Swift.Int?

    public init (
        account: Swift.String? = nil,
        clusterIdentifier: Swift.String? = nil,
        grantee: Swift.Bool? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.account = account
        self.clusterIdentifier = clusterIdentifier
        self.grantee = grantee
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeEndpointAuthorizationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeEndpointAuthorizationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationFault" : self = .unsupportedOperationFault(try UnsupportedOperationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEndpointAuthorizationOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case unsupportedOperationFault(UnsupportedOperationFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEndpointAuthorizationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEndpointAuthorizationOutputResponse(endpointAuthorizationList: \(Swift.String(describing: endpointAuthorizationList)), marker: \(Swift.String(describing: marker)))"}
}

extension DescribeEndpointAuthorizationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeEndpointAuthorizationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endpointAuthorizationList = output.endpointAuthorizationList
            self.marker = output.marker
        } else {
            self.endpointAuthorizationList = nil
            self.marker = nil
        }
    }
}

public struct DescribeEndpointAuthorizationOutputResponse: Swift.Equatable {
    /// <p>The authorizations to an endpoint.</p>
    public let endpointAuthorizationList: [RedshiftClientTypes.EndpointAuthorization]?
    /// <p>An optional pagination token provided by a previous
    ///             <code>DescribeEndpointAuthorization</code> request. If this parameter is specified, the
    ///             response includes only records beyond the marker, up to the value specified by the
    ///             <code>MaxRecords</code> parameter.</p>
    public let marker: Swift.String?

    public init (
        endpointAuthorizationList: [RedshiftClientTypes.EndpointAuthorization]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.endpointAuthorizationList = endpointAuthorizationList
        self.marker = marker
    }
}

struct DescribeEndpointAuthorizationOutputResponseBody: Swift.Equatable {
    public let endpointAuthorizationList: [RedshiftClientTypes.EndpointAuthorization]?
    public let marker: Swift.String?
}

extension DescribeEndpointAuthorizationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointAuthorizationList = "EndpointAuthorizationList"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeEndpointAuthorizationResult"))
        if containerValues.contains(.endpointAuthorizationList) {
            struct KeyVal0{struct member{}}
            let endpointAuthorizationListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .endpointAuthorizationList)
            if let endpointAuthorizationListWrappedContainer = endpointAuthorizationListWrappedContainer {
                let endpointAuthorizationListContainer = try endpointAuthorizationListWrappedContainer.decodeIfPresent([RedshiftClientTypes.EndpointAuthorization].self, forKey: .member)
                var endpointAuthorizationListBuffer:[RedshiftClientTypes.EndpointAuthorization]? = nil
                if let endpointAuthorizationListContainer = endpointAuthorizationListContainer {
                    endpointAuthorizationListBuffer = [RedshiftClientTypes.EndpointAuthorization]()
                    for structureContainer0 in endpointAuthorizationListContainer {
                        endpointAuthorizationListBuffer?.append(structureContainer0)
                    }
                }
                endpointAuthorizationList = endpointAuthorizationListBuffer
            } else {
                endpointAuthorizationList = []
            }
        } else {
            endpointAuthorizationList = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribeEventCategoriesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventCategoriesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEventCategoriesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventCategoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEventCategoriesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventCategoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventCategoriesOutputError>
}

extension DescribeEventCategoriesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEventCategoriesInput(sourceType: \(Swift.String(describing: sourceType)))"}
}

extension DescribeEventCategoriesInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let sourceType = sourceType {
            try container.encode(sourceType, forKey: ClientRuntime.Key("SourceType"))
        }
        try container.encode("DescribeEventCategories", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeEventCategoriesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventCategoriesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEventCategoriesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventCategoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEventCategoriesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventCategoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventCategoriesOutputError>
}

public struct DescribeEventCategoriesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventCategoriesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEventCategoriesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventCategoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEventCategoriesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventCategoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventCategoriesOutputError>
}

/// <p></p>
public struct DescribeEventCategoriesInput: Swift.Equatable {
    /// <p>The source type, such as cluster or parameter group, to which the described event
    ///             categories apply.</p>
    ///         <p>Valid values: cluster, cluster-snapshot, cluster-parameter-group, cluster-security-group, and scheduled-action.</p>
    public let sourceType: Swift.String?

    public init (
        sourceType: Swift.String? = nil
    )
    {
        self.sourceType = sourceType
    }
}

extension DescribeEventCategoriesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeEventCategoriesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEventCategoriesOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventCategoriesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEventCategoriesOutputResponse(eventCategoriesMapList: \(Swift.String(describing: eventCategoriesMapList)))"}
}

extension DescribeEventCategoriesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeEventCategoriesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventCategoriesMapList = output.eventCategoriesMapList
        } else {
            self.eventCategoriesMapList = nil
        }
    }
}

/// <p></p>
public struct DescribeEventCategoriesOutputResponse: Swift.Equatable {
    /// <p>A list of event categories descriptions.</p>
    public let eventCategoriesMapList: [RedshiftClientTypes.EventCategoriesMap]?

    public init (
        eventCategoriesMapList: [RedshiftClientTypes.EventCategoriesMap]? = nil
    )
    {
        self.eventCategoriesMapList = eventCategoriesMapList
    }
}

struct DescribeEventCategoriesOutputResponseBody: Swift.Equatable {
    public let eventCategoriesMapList: [RedshiftClientTypes.EventCategoriesMap]?
}

extension DescribeEventCategoriesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventCategoriesMapList = "EventCategoriesMapList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeEventCategoriesResult"))
        if containerValues.contains(.eventCategoriesMapList) {
            struct KeyVal0{struct EventCategoriesMap{}}
            let eventCategoriesMapListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.EventCategoriesMap>.CodingKeys.self, forKey: .eventCategoriesMapList)
            if let eventCategoriesMapListWrappedContainer = eventCategoriesMapListWrappedContainer {
                let eventCategoriesMapListContainer = try eventCategoriesMapListWrappedContainer.decodeIfPresent([RedshiftClientTypes.EventCategoriesMap].self, forKey: .member)
                var eventCategoriesMapListBuffer:[RedshiftClientTypes.EventCategoriesMap]? = nil
                if let eventCategoriesMapListContainer = eventCategoriesMapListContainer {
                    eventCategoriesMapListBuffer = [RedshiftClientTypes.EventCategoriesMap]()
                    for structureContainer0 in eventCategoriesMapListContainer {
                        eventCategoriesMapListBuffer?.append(structureContainer0)
                    }
                }
                eventCategoriesMapList = eventCategoriesMapListBuffer
            } else {
                eventCategoriesMapList = []
            }
        } else {
            eventCategoriesMapList = nil
        }
    }
}

public struct DescribeEventSubscriptionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventSubscriptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEventSubscriptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventSubscriptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEventSubscriptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventSubscriptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventSubscriptionsOutputError>
}

extension DescribeEventSubscriptionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEventSubscriptionsInput(marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)), subscriptionName: \(Swift.String(describing: subscriptionName)), tagKeys: \(Swift.String(describing: tagKeys)), tagValues: \(Swift.String(describing: tagValues)))"}
}

extension DescribeEventSubscriptionsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let subscriptionName = subscriptionName {
            try container.encode(subscriptionName, forKey: ClientRuntime.Key("SubscriptionName"))
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
            for (index0, string0) in tagKeys.enumerated() {
                try tagKeysContainer.encode(string0, forKey: ClientRuntime.Key("TagKey.\(index0.advanced(by: 1))"))
            }
        }
        if let tagValues = tagValues {
            var tagValuesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagValues"))
            for (index0, string0) in tagValues.enumerated() {
                try tagValuesContainer.encode(string0, forKey: ClientRuntime.Key("TagValue.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("DescribeEventSubscriptions", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeEventSubscriptionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventSubscriptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEventSubscriptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventSubscriptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEventSubscriptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventSubscriptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventSubscriptionsOutputError>
}

public struct DescribeEventSubscriptionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventSubscriptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEventSubscriptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventSubscriptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEventSubscriptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventSubscriptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventSubscriptionsOutputError>
}

/// <p></p>
public struct DescribeEventSubscriptionsInput: Swift.Equatable {
    /// <p>An optional parameter that specifies the starting point to return a set of response
    ///             records. When the results of a DescribeEventSubscriptions request exceed the value
    ///             specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code>
    ///             field of the response. You can retrieve the next set of response records by providing
    ///             the returned marker value in the <code>Marker</code> parameter and retrying the request.
    ///         </p>
    public let marker: Swift.String?
    /// <p>The maximum number of response records to return in each call. If the number of
    ///             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
    ///             is returned in a <code>marker</code> field of the response. You can retrieve the next
    ///             set of records by retrying the command with the returned marker value. </p>
    ///         <p>Default: <code>100</code>
    ///         </p>
    ///         <p>Constraints: minimum 20, maximum 100.</p>
    public let maxRecords: Swift.Int?
    /// <p>The name of the Amazon Redshift event notification subscription to be
    ///             described.</p>
    public let subscriptionName: Swift.String?
    /// <p>A tag key or keys for which you want to return all matching event notification
    ///             subscriptions that are associated with the specified key or keys. For example, suppose
    ///             that you have subscriptions that are tagged with keys called <code>owner</code> and
    ///                 <code>environment</code>. If you specify both of these tag keys in the request,
    ///             Amazon Redshift returns a response with the subscriptions that have either or both of these
    ///             tag keys associated with them.</p>
    public let tagKeys: [Swift.String]?
    /// <p>A tag value or values for which you want to return all matching event notification
    ///             subscriptions that are associated with the specified tag value or values. For example,
    ///             suppose that you have subscriptions that are tagged with values called
    ///                 <code>admin</code> and <code>test</code>. If you specify both of these tag values in
    ///             the request, Amazon Redshift returns a response with the subscriptions that have either or
    ///             both of these tag values associated with them.</p>
    public let tagValues: [Swift.String]?

    public init (
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        subscriptionName: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil,
        tagValues: [Swift.String]? = nil
    )
    {
        self.marker = marker
        self.maxRecords = maxRecords
        self.subscriptionName = subscriptionName
        self.tagKeys = tagKeys
        self.tagValues = tagValues
    }
}

extension DescribeEventSubscriptionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeEventSubscriptionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidTagFault" : self = .invalidTagFault(try InvalidTagFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionNotFoundFault" : self = .subscriptionNotFoundFault(try SubscriptionNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEventSubscriptionsOutputError: Swift.Error, Swift.Equatable {
    case invalidTagFault(InvalidTagFault)
    case subscriptionNotFoundFault(SubscriptionNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventSubscriptionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEventSubscriptionsOutputResponse(eventSubscriptionsList: \(Swift.String(describing: eventSubscriptionsList)), marker: \(Swift.String(describing: marker)))"}
}

extension DescribeEventSubscriptionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeEventSubscriptionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventSubscriptionsList = output.eventSubscriptionsList
            self.marker = output.marker
        } else {
            self.eventSubscriptionsList = nil
            self.marker = nil
        }
    }
}

/// <p></p>
public struct DescribeEventSubscriptionsOutputResponse: Swift.Equatable {
    /// <p>A list of event subscriptions.</p>
    public let eventSubscriptionsList: [RedshiftClientTypes.EventSubscription]?
    /// <p>A value that indicates the starting point for the next set of response records in a
    ///             subsequent request. If a value is returned in a response, you can retrieve the next set
    ///             of records by providing this returned marker value in the <code>Marker</code> parameter
    ///             and retrying the command. If the <code>Marker</code> field is empty, all response
    ///             records have been retrieved for the request. </p>
    public let marker: Swift.String?

    public init (
        eventSubscriptionsList: [RedshiftClientTypes.EventSubscription]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.eventSubscriptionsList = eventSubscriptionsList
        self.marker = marker
    }
}

struct DescribeEventSubscriptionsOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let eventSubscriptionsList: [RedshiftClientTypes.EventSubscription]?
}

extension DescribeEventSubscriptionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSubscriptionsList = "EventSubscriptionsList"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeEventSubscriptionsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.eventSubscriptionsList) {
            struct KeyVal0{struct EventSubscription{}}
            let eventSubscriptionsListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.EventSubscription>.CodingKeys.self, forKey: .eventSubscriptionsList)
            if let eventSubscriptionsListWrappedContainer = eventSubscriptionsListWrappedContainer {
                let eventSubscriptionsListContainer = try eventSubscriptionsListWrappedContainer.decodeIfPresent([RedshiftClientTypes.EventSubscription].self, forKey: .member)
                var eventSubscriptionsListBuffer:[RedshiftClientTypes.EventSubscription]? = nil
                if let eventSubscriptionsListContainer = eventSubscriptionsListContainer {
                    eventSubscriptionsListBuffer = [RedshiftClientTypes.EventSubscription]()
                    for structureContainer0 in eventSubscriptionsListContainer {
                        eventSubscriptionsListBuffer?.append(structureContainer0)
                    }
                }
                eventSubscriptionsList = eventSubscriptionsListBuffer
            } else {
                eventSubscriptionsList = []
            }
        } else {
            eventSubscriptionsList = nil
        }
    }
}

public struct DescribeEventsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEventsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEventsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventsOutputError>
}

extension DescribeEventsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEventsInput(duration: \(Swift.String(describing: duration)), endTime: \(Swift.String(describing: endTime)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)), sourceIdentifier: \(Swift.String(describing: sourceIdentifier)), sourceType: \(Swift.String(describing: sourceType)), startTime: \(Swift.String(describing: startTime)))"}
}

extension DescribeEventsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let duration = duration {
            try container.encode(duration, forKey: ClientRuntime.Key("Duration"))
        }
        if let endTime = endTime {
            try container.encode(ClientRuntime.TimestampWrapper(endTime, format: .dateTime), forKey: ClientRuntime.Key("endTime"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let sourceIdentifier = sourceIdentifier {
            try container.encode(sourceIdentifier, forKey: ClientRuntime.Key("SourceIdentifier"))
        }
        if let sourceType = sourceType {
            try container.encode(sourceType, forKey: ClientRuntime.Key("SourceType"))
        }
        if let startTime = startTime {
            try container.encode(ClientRuntime.TimestampWrapper(startTime, format: .dateTime), forKey: ClientRuntime.Key("startTime"))
        }
        try container.encode("DescribeEvents", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeEventsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEventsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEventsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventsOutputError>
}

public struct DescribeEventsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEventsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEventsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventsOutputError>
}

/// <p></p>
public struct DescribeEventsInput: Swift.Equatable {
    /// <p>The number of minutes prior to the time of the request for which to retrieve
    ///             events. For example, if the request is sent at 18:00 and you specify a duration of 60,
    ///             then only events which have occurred after 17:00 will be returned.</p>
    ///         <p>Default: <code>60</code>
    ///         </p>
    public let duration: Swift.Int?
    /// <p>The end of the time interval for which to retrieve events, specified in ISO 8601
    ///             format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a>
    ///         </p>
    ///         <p>Example: <code>2009-07-08T18:00Z</code>
    ///         </p>
    public let endTime: ClientRuntime.Date?
    /// <p>An optional parameter that specifies the starting point to return a set of response
    ///             records. When the results of a <a>DescribeEvents</a> request exceed the value
    ///             specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code>
    ///             field of the response. You can retrieve the next set of response records by providing
    ///             the returned marker value in the <code>Marker</code> parameter and retrying the request.
    ///         </p>
    public let marker: Swift.String?
    /// <p>The maximum number of response records to return in each call. If the number of
    ///             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
    ///             is returned in a <code>marker</code> field of the response. You can retrieve the next
    ///             set of records by retrying the command with the returned marker value. </p>
    ///         <p>Default: <code>100</code>
    ///         </p>
    ///         <p>Constraints: minimum 20, maximum 100.</p>
    public let maxRecords: Swift.Int?
    /// <p>The identifier of the event source for which events will be returned. If this
    ///             parameter is not specified, then all sources are included in the response.</p>
    ///         <p>Constraints:</p>
    ///         <p>If <i>SourceIdentifier</i> is supplied,
    ///                 <i>SourceType</i> must also be provided.</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Specify a cluster identifier when <i>SourceType</i> is
    ///                         <code>cluster</code>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Specify a cluster security group name when <i>SourceType</i>
    ///                     is <code>cluster-security-group</code>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Specify a cluster parameter group name when <i>SourceType</i>
    ///                     is <code>cluster-parameter-group</code>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Specify a cluster snapshot identifier when <i>SourceType</i>
    ///                     is <code>cluster-snapshot</code>.</p>
    ///             </li>
    ///          </ul>
    public let sourceIdentifier: Swift.String?
    /// <p>The event source to retrieve events for. If no value is specified, all events are
    ///             returned.</p>
    ///         <p>Constraints:</p>
    ///         <p>If <i>SourceType</i> is supplied,
    ///                 <i>SourceIdentifier</i> must also be provided.</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Specify <code>cluster</code> when <i>SourceIdentifier</i> is
    ///                     a cluster identifier.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Specify <code>cluster-security-group</code> when
    ///                         <i>SourceIdentifier</i> is a cluster security group
    ///                     name.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Specify <code>cluster-parameter-group</code> when
    ///                         <i>SourceIdentifier</i> is a cluster parameter group
    ///                     name.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Specify <code>cluster-snapshot</code> when
    ///                         <i>SourceIdentifier</i> is a cluster snapshot
    ///                     identifier.</p>
    ///             </li>
    ///          </ul>
    public let sourceType: RedshiftClientTypes.SourceType?
    /// <p>The beginning of the time interval to retrieve events for, specified in ISO 8601
    ///             format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a>
    ///         </p>
    ///         <p>Example: <code>2009-07-08T18:00Z</code>
    ///         </p>
    public let startTime: ClientRuntime.Date?

    public init (
        duration: Swift.Int? = nil,
        endTime: ClientRuntime.Date? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        sourceIdentifier: Swift.String? = nil,
        sourceType: RedshiftClientTypes.SourceType? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.duration = duration
        self.endTime = endTime
        self.marker = marker
        self.maxRecords = maxRecords
        self.sourceIdentifier = sourceIdentifier
        self.sourceType = sourceType
        self.startTime = startTime
    }
}

extension DescribeEventsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeEventsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEventsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEventsOutputResponse(events: \(Swift.String(describing: events)), marker: \(Swift.String(describing: marker)))"}
}

extension DescribeEventsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeEventsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.events = output.events
            self.marker = output.marker
        } else {
            self.events = nil
            self.marker = nil
        }
    }
}

/// <p></p>
public struct DescribeEventsOutputResponse: Swift.Equatable {
    /// <p>A list of <code>Event</code> instances. </p>
    public let events: [RedshiftClientTypes.Event]?
    /// <p>A value that indicates the starting point for the next set of response records in a
    ///             subsequent request. If a value is returned in a response, you can retrieve the next set
    ///             of records by providing this returned marker value in the <code>Marker</code> parameter
    ///             and retrying the command. If the <code>Marker</code> field is empty, all response
    ///             records have been retrieved for the request. </p>
    public let marker: Swift.String?

    public init (
        events: [RedshiftClientTypes.Event]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.events = events
        self.marker = marker
    }
}

struct DescribeEventsOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let events: [RedshiftClientTypes.Event]?
}

extension DescribeEventsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events = "Events"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeEventsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.events) {
            struct KeyVal0{struct Event{}}
            let eventsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Event>.CodingKeys.self, forKey: .events)
            if let eventsWrappedContainer = eventsWrappedContainer {
                let eventsContainer = try eventsWrappedContainer.decodeIfPresent([RedshiftClientTypes.Event].self, forKey: .member)
                var eventsBuffer:[RedshiftClientTypes.Event]? = nil
                if let eventsContainer = eventsContainer {
                    eventsBuffer = [RedshiftClientTypes.Event]()
                    for structureContainer0 in eventsContainer {
                        eventsBuffer?.append(structureContainer0)
                    }
                }
                events = eventsBuffer
            } else {
                events = []
            }
        } else {
            events = nil
        }
    }
}

public struct DescribeHsmClientCertificatesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeHsmClientCertificatesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeHsmClientCertificatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeHsmClientCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeHsmClientCertificatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeHsmClientCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeHsmClientCertificatesOutputError>
}

extension DescribeHsmClientCertificatesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeHsmClientCertificatesInput(hsmClientCertificateIdentifier: \(Swift.String(describing: hsmClientCertificateIdentifier)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)), tagKeys: \(Swift.String(describing: tagKeys)), tagValues: \(Swift.String(describing: tagValues)))"}
}

extension DescribeHsmClientCertificatesInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let hsmClientCertificateIdentifier = hsmClientCertificateIdentifier {
            try container.encode(hsmClientCertificateIdentifier, forKey: ClientRuntime.Key("HsmClientCertificateIdentifier"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
            for (index0, string0) in tagKeys.enumerated() {
                try tagKeysContainer.encode(string0, forKey: ClientRuntime.Key("TagKey.\(index0.advanced(by: 1))"))
            }
        }
        if let tagValues = tagValues {
            var tagValuesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagValues"))
            for (index0, string0) in tagValues.enumerated() {
                try tagValuesContainer.encode(string0, forKey: ClientRuntime.Key("TagValue.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("DescribeHsmClientCertificates", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeHsmClientCertificatesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeHsmClientCertificatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeHsmClientCertificatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeHsmClientCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeHsmClientCertificatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeHsmClientCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeHsmClientCertificatesOutputError>
}

public struct DescribeHsmClientCertificatesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeHsmClientCertificatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeHsmClientCertificatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeHsmClientCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeHsmClientCertificatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeHsmClientCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeHsmClientCertificatesOutputError>
}

/// <p></p>
public struct DescribeHsmClientCertificatesInput: Swift.Equatable {
    /// <p>The identifier of a specific HSM client certificate for which you want information.
    ///             If no identifier is specified, information is returned for all HSM client certificates
    ///             owned by your AWS customer account.</p>
    public let hsmClientCertificateIdentifier: Swift.String?
    /// <p>An optional parameter that specifies the starting point to return a set of response
    ///             records. When the results of a <a>DescribeHsmClientCertificates</a> request
    ///             exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the
    ///                 <code>Marker</code> field of the response. You can retrieve the next set of response
    ///             records by providing the returned marker value in the <code>Marker</code> parameter and
    ///             retrying the request. </p>
    public let marker: Swift.String?
    /// <p>The maximum number of response records to return in each call. If the number of
    ///             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
    ///             is returned in a <code>marker</code> field of the response. You can retrieve the next
    ///             set of records by retrying the command with the returned marker value. </p>
    ///         <p>Default: <code>100</code>
    ///         </p>
    ///         <p>Constraints: minimum 20, maximum 100.</p>
    public let maxRecords: Swift.Int?
    /// <p>A tag key or keys for which you want to return all matching HSM client certificates
    ///             that are associated with the specified key or keys. For example, suppose that you have
    ///             HSM client certificates that are tagged with keys called <code>owner</code> and
    ///                 <code>environment</code>. If you specify both of these tag keys in the request,
    ///             Amazon Redshift returns a response with the HSM client certificates that have either or both
    ///             of these tag keys associated with them.</p>
    public let tagKeys: [Swift.String]?
    /// <p>A tag value or values for which you want to return all matching HSM client
    ///             certificates that are associated with the specified tag value or values. For example,
    ///             suppose that you have HSM client certificates that are tagged with values called
    ///                 <code>admin</code> and <code>test</code>. If you specify both of these tag values in
    ///             the request, Amazon Redshift returns a response with the HSM client certificates that have
    ///             either or both of these tag values associated with them.</p>
    public let tagValues: [Swift.String]?

    public init (
        hsmClientCertificateIdentifier: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        tagKeys: [Swift.String]? = nil,
        tagValues: [Swift.String]? = nil
    )
    {
        self.hsmClientCertificateIdentifier = hsmClientCertificateIdentifier
        self.marker = marker
        self.maxRecords = maxRecords
        self.tagKeys = tagKeys
        self.tagValues = tagValues
    }
}

extension DescribeHsmClientCertificatesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeHsmClientCertificatesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "HsmClientCertificateNotFoundFault" : self = .hsmClientCertificateNotFoundFault(try HsmClientCertificateNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagFault" : self = .invalidTagFault(try InvalidTagFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeHsmClientCertificatesOutputError: Swift.Error, Swift.Equatable {
    case hsmClientCertificateNotFoundFault(HsmClientCertificateNotFoundFault)
    case invalidTagFault(InvalidTagFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeHsmClientCertificatesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeHsmClientCertificatesOutputResponse(hsmClientCertificates: \(Swift.String(describing: hsmClientCertificates)), marker: \(Swift.String(describing: marker)))"}
}

extension DescribeHsmClientCertificatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeHsmClientCertificatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.hsmClientCertificates = output.hsmClientCertificates
            self.marker = output.marker
        } else {
            self.hsmClientCertificates = nil
            self.marker = nil
        }
    }
}

/// <p></p>
public struct DescribeHsmClientCertificatesOutputResponse: Swift.Equatable {
    /// <p>A list of the identifiers for one or more HSM client certificates used by Amazon Redshift
    ///             clusters to store and retrieve database encryption keys in an HSM.</p>
    public let hsmClientCertificates: [RedshiftClientTypes.HsmClientCertificate]?
    /// <p>A value that indicates the starting point for the next set of response records in a
    ///             subsequent request. If a value is returned in a response, you can retrieve the next set
    ///             of records by providing this returned marker value in the <code>Marker</code> parameter
    ///             and retrying the command. If the <code>Marker</code> field is empty, all response
    ///             records have been retrieved for the request. </p>
    public let marker: Swift.String?

    public init (
        hsmClientCertificates: [RedshiftClientTypes.HsmClientCertificate]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.hsmClientCertificates = hsmClientCertificates
        self.marker = marker
    }
}

struct DescribeHsmClientCertificatesOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let hsmClientCertificates: [RedshiftClientTypes.HsmClientCertificate]?
}

extension DescribeHsmClientCertificatesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hsmClientCertificates = "HsmClientCertificates"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeHsmClientCertificatesResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.hsmClientCertificates) {
            struct KeyVal0{struct HsmClientCertificate{}}
            let hsmClientCertificatesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.HsmClientCertificate>.CodingKeys.self, forKey: .hsmClientCertificates)
            if let hsmClientCertificatesWrappedContainer = hsmClientCertificatesWrappedContainer {
                let hsmClientCertificatesContainer = try hsmClientCertificatesWrappedContainer.decodeIfPresent([RedshiftClientTypes.HsmClientCertificate].self, forKey: .member)
                var hsmClientCertificatesBuffer:[RedshiftClientTypes.HsmClientCertificate]? = nil
                if let hsmClientCertificatesContainer = hsmClientCertificatesContainer {
                    hsmClientCertificatesBuffer = [RedshiftClientTypes.HsmClientCertificate]()
                    for structureContainer0 in hsmClientCertificatesContainer {
                        hsmClientCertificatesBuffer?.append(structureContainer0)
                    }
                }
                hsmClientCertificates = hsmClientCertificatesBuffer
            } else {
                hsmClientCertificates = []
            }
        } else {
            hsmClientCertificates = nil
        }
    }
}

public struct DescribeHsmConfigurationsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeHsmConfigurationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeHsmConfigurationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeHsmConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeHsmConfigurationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeHsmConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeHsmConfigurationsOutputError>
}

extension DescribeHsmConfigurationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeHsmConfigurationsInput(hsmConfigurationIdentifier: \(Swift.String(describing: hsmConfigurationIdentifier)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)), tagKeys: \(Swift.String(describing: tagKeys)), tagValues: \(Swift.String(describing: tagValues)))"}
}

extension DescribeHsmConfigurationsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let hsmConfigurationIdentifier = hsmConfigurationIdentifier {
            try container.encode(hsmConfigurationIdentifier, forKey: ClientRuntime.Key("HsmConfigurationIdentifier"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
            for (index0, string0) in tagKeys.enumerated() {
                try tagKeysContainer.encode(string0, forKey: ClientRuntime.Key("TagKey.\(index0.advanced(by: 1))"))
            }
        }
        if let tagValues = tagValues {
            var tagValuesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagValues"))
            for (index0, string0) in tagValues.enumerated() {
                try tagValuesContainer.encode(string0, forKey: ClientRuntime.Key("TagValue.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("DescribeHsmConfigurations", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeHsmConfigurationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeHsmConfigurationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeHsmConfigurationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeHsmConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeHsmConfigurationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeHsmConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeHsmConfigurationsOutputError>
}

public struct DescribeHsmConfigurationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeHsmConfigurationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeHsmConfigurationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeHsmConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeHsmConfigurationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeHsmConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeHsmConfigurationsOutputError>
}

/// <p></p>
public struct DescribeHsmConfigurationsInput: Swift.Equatable {
    /// <p>The identifier of a specific Amazon Redshift HSM configuration to be described. If no
    ///             identifier is specified, information is returned for all HSM configurations owned by
    ///             your AWS customer account.</p>
    public let hsmConfigurationIdentifier: Swift.String?
    /// <p>An optional parameter that specifies the starting point to return a set of response
    ///             records. When the results of a <a>DescribeHsmConfigurations</a> request
    ///             exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the
    ///                 <code>Marker</code> field of the response. You can retrieve the next set of response
    ///             records by providing the returned marker value in the <code>Marker</code> parameter and
    ///             retrying the request. </p>
    public let marker: Swift.String?
    /// <p>The maximum number of response records to return in each call. If the number of
    ///             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
    ///             is returned in a <code>marker</code> field of the response. You can retrieve the next
    ///             set of records by retrying the command with the returned marker value. </p>
    ///         <p>Default: <code>100</code>
    ///         </p>
    ///         <p>Constraints: minimum 20, maximum 100.</p>
    public let maxRecords: Swift.Int?
    /// <p>A tag key or keys for which you want to return all matching HSM configurations that
    ///             are associated with the specified key or keys. For example, suppose that you have HSM
    ///             configurations that are tagged with keys called <code>owner</code> and
    ///                 <code>environment</code>. If you specify both of these tag keys in the request,
    ///             Amazon Redshift returns a response with the HSM configurations that have either or both of
    ///             these tag keys associated with them.</p>
    public let tagKeys: [Swift.String]?
    /// <p>A tag value or values for which you want to return all matching HSM configurations
    ///             that are associated with the specified tag value or values. For example, suppose that
    ///             you have HSM configurations that are tagged with values called <code>admin</code> and
    ///                 <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift
    ///             returns a response with the HSM configurations that have either or both of these tag
    ///             values associated with them.</p>
    public let tagValues: [Swift.String]?

    public init (
        hsmConfigurationIdentifier: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        tagKeys: [Swift.String]? = nil,
        tagValues: [Swift.String]? = nil
    )
    {
        self.hsmConfigurationIdentifier = hsmConfigurationIdentifier
        self.marker = marker
        self.maxRecords = maxRecords
        self.tagKeys = tagKeys
        self.tagValues = tagValues
    }
}

extension DescribeHsmConfigurationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeHsmConfigurationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "HsmConfigurationNotFoundFault" : self = .hsmConfigurationNotFoundFault(try HsmConfigurationNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagFault" : self = .invalidTagFault(try InvalidTagFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeHsmConfigurationsOutputError: Swift.Error, Swift.Equatable {
    case hsmConfigurationNotFoundFault(HsmConfigurationNotFoundFault)
    case invalidTagFault(InvalidTagFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeHsmConfigurationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeHsmConfigurationsOutputResponse(hsmConfigurations: \(Swift.String(describing: hsmConfigurations)), marker: \(Swift.String(describing: marker)))"}
}

extension DescribeHsmConfigurationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeHsmConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.hsmConfigurations = output.hsmConfigurations
            self.marker = output.marker
        } else {
            self.hsmConfigurations = nil
            self.marker = nil
        }
    }
}

/// <p></p>
public struct DescribeHsmConfigurationsOutputResponse: Swift.Equatable {
    /// <p>A list of <code>HsmConfiguration</code> objects.</p>
    public let hsmConfigurations: [RedshiftClientTypes.HsmConfiguration]?
    /// <p>A value that indicates the starting point for the next set of response records in a
    ///             subsequent request. If a value is returned in a response, you can retrieve the next set
    ///             of records by providing this returned marker value in the <code>Marker</code> parameter
    ///             and retrying the command. If the <code>Marker</code> field is empty, all response
    ///             records have been retrieved for the request. </p>
    public let marker: Swift.String?

    public init (
        hsmConfigurations: [RedshiftClientTypes.HsmConfiguration]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.hsmConfigurations = hsmConfigurations
        self.marker = marker
    }
}

struct DescribeHsmConfigurationsOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let hsmConfigurations: [RedshiftClientTypes.HsmConfiguration]?
}

extension DescribeHsmConfigurationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hsmConfigurations = "HsmConfigurations"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeHsmConfigurationsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.hsmConfigurations) {
            struct KeyVal0{struct HsmConfiguration{}}
            let hsmConfigurationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.HsmConfiguration>.CodingKeys.self, forKey: .hsmConfigurations)
            if let hsmConfigurationsWrappedContainer = hsmConfigurationsWrappedContainer {
                let hsmConfigurationsContainer = try hsmConfigurationsWrappedContainer.decodeIfPresent([RedshiftClientTypes.HsmConfiguration].self, forKey: .member)
                var hsmConfigurationsBuffer:[RedshiftClientTypes.HsmConfiguration]? = nil
                if let hsmConfigurationsContainer = hsmConfigurationsContainer {
                    hsmConfigurationsBuffer = [RedshiftClientTypes.HsmConfiguration]()
                    for structureContainer0 in hsmConfigurationsContainer {
                        hsmConfigurationsBuffer?.append(structureContainer0)
                    }
                }
                hsmConfigurations = hsmConfigurationsBuffer
            } else {
                hsmConfigurations = []
            }
        } else {
            hsmConfigurations = nil
        }
    }
}

public struct DescribeLoggingStatusInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeLoggingStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeLoggingStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeLoggingStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeLoggingStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeLoggingStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeLoggingStatusOutputError>
}

extension DescribeLoggingStatusInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeLoggingStatusInput(clusterIdentifier: \(Swift.String(describing: clusterIdentifier)))"}
}

extension DescribeLoggingStatusInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: ClientRuntime.Key("ClusterIdentifier"))
        }
        try container.encode("DescribeLoggingStatus", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeLoggingStatusInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeLoggingStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeLoggingStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeLoggingStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeLoggingStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeLoggingStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeLoggingStatusOutputError>
}

public struct DescribeLoggingStatusInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeLoggingStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeLoggingStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeLoggingStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeLoggingStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeLoggingStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeLoggingStatusOutputError>
}

/// <p></p>
public struct DescribeLoggingStatusInput: Swift.Equatable {
    /// <p>The identifier of the cluster from which to get the logging status.</p>
    ///         <p>Example: <code>examplecluster</code>
    ///         </p>
    public let clusterIdentifier: Swift.String?

    public init (
        clusterIdentifier: Swift.String? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
    }
}

extension DescribeLoggingStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeLoggingStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeLoggingStatusOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeLoggingStatusOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeLoggingStatusOutputResponse(bucketName: \(Swift.String(describing: bucketName)), lastFailureMessage: \(Swift.String(describing: lastFailureMessage)), lastFailureTime: \(Swift.String(describing: lastFailureTime)), lastSuccessfulDeliveryTime: \(Swift.String(describing: lastSuccessfulDeliveryTime)), loggingEnabled: \(Swift.String(describing: loggingEnabled)), s3KeyPrefix: \(Swift.String(describing: s3KeyPrefix)))"}
}

extension DescribeLoggingStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeLoggingStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.bucketName = output.bucketName
            self.lastFailureMessage = output.lastFailureMessage
            self.lastFailureTime = output.lastFailureTime
            self.lastSuccessfulDeliveryTime = output.lastSuccessfulDeliveryTime
            self.loggingEnabled = output.loggingEnabled
            self.s3KeyPrefix = output.s3KeyPrefix
        } else {
            self.bucketName = nil
            self.lastFailureMessage = nil
            self.lastFailureTime = nil
            self.lastSuccessfulDeliveryTime = nil
            self.loggingEnabled = false
            self.s3KeyPrefix = nil
        }
    }
}

/// <p>Describes the status of logging for a cluster.</p>
public struct DescribeLoggingStatusOutputResponse: Swift.Equatable {
    /// <p>The name of the S3 bucket where the log files are stored.</p>
    public let bucketName: Swift.String?
    /// <p>The message indicating that logs failed to be delivered.</p>
    public let lastFailureMessage: Swift.String?
    /// <p>The last time when logs failed to be delivered.</p>
    public let lastFailureTime: ClientRuntime.Date?
    /// <p>The last time that logs were delivered.</p>
    public let lastSuccessfulDeliveryTime: ClientRuntime.Date?
    /// <p>
    ///             <code>true</code> if logging is on, <code>false</code> if logging is off.</p>
    public let loggingEnabled: Swift.Bool
    /// <p>The prefix applied to the log file names.</p>
    public let s3KeyPrefix: Swift.String?

    public init (
        bucketName: Swift.String? = nil,
        lastFailureMessage: Swift.String? = nil,
        lastFailureTime: ClientRuntime.Date? = nil,
        lastSuccessfulDeliveryTime: ClientRuntime.Date? = nil,
        loggingEnabled: Swift.Bool = false,
        s3KeyPrefix: Swift.String? = nil
    )
    {
        self.bucketName = bucketName
        self.lastFailureMessage = lastFailureMessage
        self.lastFailureTime = lastFailureTime
        self.lastSuccessfulDeliveryTime = lastSuccessfulDeliveryTime
        self.loggingEnabled = loggingEnabled
        self.s3KeyPrefix = s3KeyPrefix
    }
}

struct DescribeLoggingStatusOutputResponseBody: Swift.Equatable {
    public let loggingEnabled: Swift.Bool
    public let bucketName: Swift.String?
    public let s3KeyPrefix: Swift.String?
    public let lastSuccessfulDeliveryTime: ClientRuntime.Date?
    public let lastFailureTime: ClientRuntime.Date?
    public let lastFailureMessage: Swift.String?
}

extension DescribeLoggingStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName = "BucketName"
        case lastFailureMessage = "LastFailureMessage"
        case lastFailureTime = "LastFailureTime"
        case lastSuccessfulDeliveryTime = "LastSuccessfulDeliveryTime"
        case loggingEnabled = "LoggingEnabled"
        case s3KeyPrefix = "S3KeyPrefix"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeLoggingStatusResult"))
        let loggingEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .loggingEnabled)
        loggingEnabled = loggingEnabledDecoded
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let s3KeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3KeyPrefix)
        s3KeyPrefix = s3KeyPrefixDecoded
        let lastSuccessfulDeliveryTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastSuccessfulDeliveryTime)
        var lastSuccessfulDeliveryTimeBuffer:ClientRuntime.Date? = nil
        if let lastSuccessfulDeliveryTimeDecoded = lastSuccessfulDeliveryTimeDecoded {
            lastSuccessfulDeliveryTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(lastSuccessfulDeliveryTimeDecoded, format: .dateTime)
        }
        lastSuccessfulDeliveryTime = lastSuccessfulDeliveryTimeBuffer
        let lastFailureTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastFailureTime)
        var lastFailureTimeBuffer:ClientRuntime.Date? = nil
        if let lastFailureTimeDecoded = lastFailureTimeDecoded {
            lastFailureTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(lastFailureTimeDecoded, format: .dateTime)
        }
        lastFailureTime = lastFailureTimeBuffer
        let lastFailureMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastFailureMessage)
        lastFailureMessage = lastFailureMessageDecoded
    }
}

public struct DescribeNodeConfigurationOptionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeNodeConfigurationOptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeNodeConfigurationOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeNodeConfigurationOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeNodeConfigurationOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeNodeConfigurationOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeNodeConfigurationOptionsOutputError>
}

extension DescribeNodeConfigurationOptionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeNodeConfigurationOptionsInput(actionType: \(Swift.String(describing: actionType)), clusterIdentifier: \(Swift.String(describing: clusterIdentifier)), filters: \(Swift.String(describing: filters)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)), ownerAccount: \(Swift.String(describing: ownerAccount)), snapshotIdentifier: \(Swift.String(describing: snapshotIdentifier)))"}
}

extension DescribeNodeConfigurationOptionsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let actionType = actionType {
            try container.encode(actionType, forKey: ClientRuntime.Key("ActionType"))
        }
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: ClientRuntime.Key("ClusterIdentifier"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filter"))
            for (index0, nodeconfigurationoptionsfilter0) in filters.enumerated() {
                try filtersContainer.encode(nodeconfigurationoptionsfilter0, forKey: ClientRuntime.Key("NodeConfigurationOptionsFilter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let ownerAccount = ownerAccount {
            try container.encode(ownerAccount, forKey: ClientRuntime.Key("OwnerAccount"))
        }
        if let snapshotIdentifier = snapshotIdentifier {
            try container.encode(snapshotIdentifier, forKey: ClientRuntime.Key("SnapshotIdentifier"))
        }
        try container.encode("DescribeNodeConfigurationOptions", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeNodeConfigurationOptionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeNodeConfigurationOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeNodeConfigurationOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeNodeConfigurationOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeNodeConfigurationOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeNodeConfigurationOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeNodeConfigurationOptionsOutputError>
}

public struct DescribeNodeConfigurationOptionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeNodeConfigurationOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeNodeConfigurationOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeNodeConfigurationOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeNodeConfigurationOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeNodeConfigurationOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeNodeConfigurationOptionsOutputError>
}

public struct DescribeNodeConfigurationOptionsInput: Swift.Equatable {
    /// <p>The action type to evaluate for possible node configurations.
    ///             Specify "restore-cluster" to get configuration combinations based on an existing snapshot.
    ///             Specify "recommend-node-config" to get configuration recommendations based on an existing cluster or snapshot.
    ///             Specify "resize-cluster" to get configuration combinations for elastic resize based on an existing cluster.
    ///         </p>
    public let actionType: RedshiftClientTypes.ActionType?
    /// <p>The identifier of the cluster to evaluate for possible node configurations.</p>
    public let clusterIdentifier: Swift.String?
    /// <p>A set of name, operator, and value items to filter the results.</p>
    public let filters: [RedshiftClientTypes.NodeConfigurationOptionsFilter]?
    /// <p>An optional parameter that specifies the starting point to return a set of response
    ///             records. When the results of a <a>DescribeNodeConfigurationOptions</a> request
    ///             exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the
    ///             <code>Marker</code> field of the response. You can retrieve the next set of response
    ///             records by providing the returned marker value in the <code>Marker</code> parameter and
    ///             retrying the request. </p>
    public let marker: Swift.String?
    /// <p>The maximum number of response records to return in each call. If the number of
    ///             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
    ///             is returned in a <code>marker</code> field of the response. You can retrieve the next
    ///             set of records by retrying the command with the returned marker value. </p>
    ///         <p>Default: <code>500</code>
    ///         </p>
    ///         <p>Constraints: minimum 100, maximum 500.</p>
    public let maxRecords: Swift.Int?
    /// <p>The AWS customer account used to create or copy the snapshot.
    ///             Required if you are restoring a snapshot you do not own,
    ///             optional if you own the snapshot.</p>
    public let ownerAccount: Swift.String?
    /// <p>The identifier of the snapshot to evaluate for possible node configurations.</p>
    public let snapshotIdentifier: Swift.String?

    public init (
        actionType: RedshiftClientTypes.ActionType? = nil,
        clusterIdentifier: Swift.String? = nil,
        filters: [RedshiftClientTypes.NodeConfigurationOptionsFilter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        ownerAccount: Swift.String? = nil,
        snapshotIdentifier: Swift.String? = nil
    )
    {
        self.actionType = actionType
        self.clusterIdentifier = clusterIdentifier
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.ownerAccount = ownerAccount
        self.snapshotIdentifier = snapshotIdentifier
    }
}

extension DescribeNodeConfigurationOptionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeNodeConfigurationOptionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessToSnapshotDeniedFault" : self = .accessToSnapshotDeniedFault(try AccessToSnapshotDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterSnapshotNotFoundFault" : self = .clusterSnapshotNotFoundFault(try ClusterSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterSnapshotStateFault" : self = .invalidClusterSnapshotStateFault(try InvalidClusterSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeNodeConfigurationOptionsOutputError: Swift.Error, Swift.Equatable {
    case accessToSnapshotDeniedFault(AccessToSnapshotDeniedFault)
    case clusterNotFoundFault(ClusterNotFoundFault)
    case clusterSnapshotNotFoundFault(ClusterSnapshotNotFoundFault)
    case invalidClusterSnapshotStateFault(InvalidClusterSnapshotStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeNodeConfigurationOptionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeNodeConfigurationOptionsOutputResponse(marker: \(Swift.String(describing: marker)), nodeConfigurationOptionList: \(Swift.String(describing: nodeConfigurationOptionList)))"}
}

extension DescribeNodeConfigurationOptionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeNodeConfigurationOptionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.nodeConfigurationOptionList = output.nodeConfigurationOptionList
        } else {
            self.marker = nil
            self.nodeConfigurationOptionList = nil
        }
    }
}

public struct DescribeNodeConfigurationOptionsOutputResponse: Swift.Equatable {
    /// <p>A value that indicates the starting point for the next set of response records in a
    ///             subsequent request. If a value is returned in a response, you can retrieve the next set
    ///             of records by providing this returned marker value in the <code>Marker</code> parameter
    ///             and retrying the command. If the <code>Marker</code> field is empty, all response
    ///             records have been retrieved for the request. </p>
    public let marker: Swift.String?
    /// <p>A list of valid node configurations.</p>
    public let nodeConfigurationOptionList: [RedshiftClientTypes.NodeConfigurationOption]?

    public init (
        marker: Swift.String? = nil,
        nodeConfigurationOptionList: [RedshiftClientTypes.NodeConfigurationOption]? = nil
    )
    {
        self.marker = marker
        self.nodeConfigurationOptionList = nodeConfigurationOptionList
    }
}

struct DescribeNodeConfigurationOptionsOutputResponseBody: Swift.Equatable {
    public let nodeConfigurationOptionList: [RedshiftClientTypes.NodeConfigurationOption]?
    public let marker: Swift.String?
}

extension DescribeNodeConfigurationOptionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case nodeConfigurationOptionList = "NodeConfigurationOptionList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeNodeConfigurationOptionsResult"))
        if containerValues.contains(.nodeConfigurationOptionList) {
            struct KeyVal0{struct NodeConfigurationOption{}}
            let nodeConfigurationOptionListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.NodeConfigurationOption>.CodingKeys.self, forKey: .nodeConfigurationOptionList)
            if let nodeConfigurationOptionListWrappedContainer = nodeConfigurationOptionListWrappedContainer {
                let nodeConfigurationOptionListContainer = try nodeConfigurationOptionListWrappedContainer.decodeIfPresent([RedshiftClientTypes.NodeConfigurationOption].self, forKey: .member)
                var nodeConfigurationOptionListBuffer:[RedshiftClientTypes.NodeConfigurationOption]? = nil
                if let nodeConfigurationOptionListContainer = nodeConfigurationOptionListContainer {
                    nodeConfigurationOptionListBuffer = [RedshiftClientTypes.NodeConfigurationOption]()
                    for structureContainer0 in nodeConfigurationOptionListContainer {
                        nodeConfigurationOptionListBuffer?.append(structureContainer0)
                    }
                }
                nodeConfigurationOptionList = nodeConfigurationOptionListBuffer
            } else {
                nodeConfigurationOptionList = []
            }
        } else {
            nodeConfigurationOptionList = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribeOrderableClusterOptionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeOrderableClusterOptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeOrderableClusterOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeOrderableClusterOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeOrderableClusterOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeOrderableClusterOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeOrderableClusterOptionsOutputError>
}

extension DescribeOrderableClusterOptionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeOrderableClusterOptionsInput(clusterVersion: \(Swift.String(describing: clusterVersion)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)), nodeType: \(Swift.String(describing: nodeType)))"}
}

extension DescribeOrderableClusterOptionsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let clusterVersion = clusterVersion {
            try container.encode(clusterVersion, forKey: ClientRuntime.Key("ClusterVersion"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let nodeType = nodeType {
            try container.encode(nodeType, forKey: ClientRuntime.Key("NodeType"))
        }
        try container.encode("DescribeOrderableClusterOptions", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeOrderableClusterOptionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeOrderableClusterOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeOrderableClusterOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeOrderableClusterOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeOrderableClusterOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeOrderableClusterOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeOrderableClusterOptionsOutputError>
}

public struct DescribeOrderableClusterOptionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeOrderableClusterOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeOrderableClusterOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeOrderableClusterOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeOrderableClusterOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeOrderableClusterOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeOrderableClusterOptionsOutputError>
}

/// <p></p>
public struct DescribeOrderableClusterOptionsInput: Swift.Equatable {
    /// <p>The version filter value. Specify this parameter to show only the available
    ///             offerings matching the specified version.</p>
    ///         <p>Default: All versions.</p>
    ///         <p>Constraints: Must be one of the version returned from <a>DescribeClusterVersions</a>.</p>
    public let clusterVersion: Swift.String?
    /// <p>An optional parameter that specifies the starting point to return a set of response
    ///             records. When the results of a <a>DescribeOrderableClusterOptions</a> request
    ///             exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the
    ///                 <code>Marker</code> field of the response. You can retrieve the next set of response
    ///             records by providing the returned marker value in the <code>Marker</code> parameter and
    ///             retrying the request. </p>
    public let marker: Swift.String?
    /// <p>The maximum number of response records to return in each call. If the number of
    ///             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
    ///             is returned in a <code>marker</code> field of the response. You can retrieve the next
    ///             set of records by retrying the command with the returned marker value. </p>
    ///         <p>Default: <code>100</code>
    ///         </p>
    ///         <p>Constraints: minimum 20, maximum 100.</p>
    public let maxRecords: Swift.Int?
    /// <p>The node type filter value. Specify this parameter to show only the available
    ///             offerings matching the specified node type.</p>
    public let nodeType: Swift.String?

    public init (
        clusterVersion: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        nodeType: Swift.String? = nil
    )
    {
        self.clusterVersion = clusterVersion
        self.marker = marker
        self.maxRecords = maxRecords
        self.nodeType = nodeType
    }
}

extension DescribeOrderableClusterOptionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeOrderableClusterOptionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeOrderableClusterOptionsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeOrderableClusterOptionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeOrderableClusterOptionsOutputResponse(marker: \(Swift.String(describing: marker)), orderableClusterOptions: \(Swift.String(describing: orderableClusterOptions)))"}
}

extension DescribeOrderableClusterOptionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeOrderableClusterOptionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.orderableClusterOptions = output.orderableClusterOptions
        } else {
            self.marker = nil
            self.orderableClusterOptions = nil
        }
    }
}

/// <p>Contains the output from the <a>DescribeOrderableClusterOptions</a>
///             action. </p>
public struct DescribeOrderableClusterOptionsOutputResponse: Swift.Equatable {
    /// <p>A value that indicates the starting point for the next set of response records in a
    ///             subsequent request. If a value is returned in a response, you can retrieve the next set
    ///             of records by providing this returned marker value in the <code>Marker</code> parameter
    ///             and retrying the command. If the <code>Marker</code> field is empty, all response
    ///             records have been retrieved for the request. </p>
    public let marker: Swift.String?
    /// <p>An <code>OrderableClusterOption</code> structure containing information about
    ///             orderable options for the cluster.</p>
    public let orderableClusterOptions: [RedshiftClientTypes.OrderableClusterOption]?

    public init (
        marker: Swift.String? = nil,
        orderableClusterOptions: [RedshiftClientTypes.OrderableClusterOption]? = nil
    )
    {
        self.marker = marker
        self.orderableClusterOptions = orderableClusterOptions
    }
}

struct DescribeOrderableClusterOptionsOutputResponseBody: Swift.Equatable {
    public let orderableClusterOptions: [RedshiftClientTypes.OrderableClusterOption]?
    public let marker: Swift.String?
}

extension DescribeOrderableClusterOptionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case orderableClusterOptions = "OrderableClusterOptions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeOrderableClusterOptionsResult"))
        if containerValues.contains(.orderableClusterOptions) {
            struct KeyVal0{struct OrderableClusterOption{}}
            let orderableClusterOptionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OrderableClusterOption>.CodingKeys.self, forKey: .orderableClusterOptions)
            if let orderableClusterOptionsWrappedContainer = orderableClusterOptionsWrappedContainer {
                let orderableClusterOptionsContainer = try orderableClusterOptionsWrappedContainer.decodeIfPresent([RedshiftClientTypes.OrderableClusterOption].self, forKey: .member)
                var orderableClusterOptionsBuffer:[RedshiftClientTypes.OrderableClusterOption]? = nil
                if let orderableClusterOptionsContainer = orderableClusterOptionsContainer {
                    orderableClusterOptionsBuffer = [RedshiftClientTypes.OrderableClusterOption]()
                    for structureContainer0 in orderableClusterOptionsContainer {
                        orderableClusterOptionsBuffer?.append(structureContainer0)
                    }
                }
                orderableClusterOptions = orderableClusterOptionsBuffer
            } else {
                orderableClusterOptions = []
            }
        } else {
            orderableClusterOptions = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribePartnersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePartnersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePartnersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePartnersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePartnersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePartnersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePartnersOutputError>
}

extension DescribePartnersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribePartnersInput(accountId: \(Swift.String(describing: accountId)), clusterIdentifier: \(Swift.String(describing: clusterIdentifier)), databaseName: \(Swift.String(describing: databaseName)), partnerName: \(Swift.String(describing: partnerName)))"}
}

extension DescribePartnersInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let accountId = accountId {
            try container.encode(accountId, forKey: ClientRuntime.Key("AccountId"))
        }
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: ClientRuntime.Key("ClusterIdentifier"))
        }
        if let databaseName = databaseName {
            try container.encode(databaseName, forKey: ClientRuntime.Key("DatabaseName"))
        }
        if let partnerName = partnerName {
            try container.encode(partnerName, forKey: ClientRuntime.Key("PartnerName"))
        }
        try container.encode("DescribePartners", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribePartnersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePartnersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePartnersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePartnersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePartnersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePartnersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePartnersOutputError>
}

public struct DescribePartnersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePartnersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePartnersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePartnersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePartnersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePartnersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePartnersOutputError>
}

public struct DescribePartnersInput: Swift.Equatable {
    /// <p>The AWS account ID that owns the cluster.</p>
    public let accountId: Swift.String?
    /// <p>The cluster identifier of the cluster whose partner integration is being described.</p>
    public let clusterIdentifier: Swift.String?
    /// <p>The name of the database whose partner integration is being described. If database name is not specified, then all databases in the cluster are described.</p>
    public let databaseName: Swift.String?
    /// <p>The name of the partner that is being described. If partner name is not specified, then all partner integrations are described.</p>
    public let partnerName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        clusterIdentifier: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        partnerName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.clusterIdentifier = clusterIdentifier
        self.databaseName = databaseName
        self.partnerName = partnerName
    }
}

extension DescribePartnersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribePartnersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedPartnerIntegrationFault" : self = .unauthorizedPartnerIntegrationFault(try UnauthorizedPartnerIntegrationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePartnersOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case unauthorizedPartnerIntegrationFault(UnauthorizedPartnerIntegrationFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePartnersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribePartnersOutputResponse(partnerIntegrationInfoList: \(Swift.String(describing: partnerIntegrationInfoList)))"}
}

extension DescribePartnersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribePartnersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.partnerIntegrationInfoList = output.partnerIntegrationInfoList
        } else {
            self.partnerIntegrationInfoList = nil
        }
    }
}

public struct DescribePartnersOutputResponse: Swift.Equatable {
    /// <p>A list of partner integrations.</p>
    public let partnerIntegrationInfoList: [RedshiftClientTypes.PartnerIntegrationInfo]?

    public init (
        partnerIntegrationInfoList: [RedshiftClientTypes.PartnerIntegrationInfo]? = nil
    )
    {
        self.partnerIntegrationInfoList = partnerIntegrationInfoList
    }
}

struct DescribePartnersOutputResponseBody: Swift.Equatable {
    public let partnerIntegrationInfoList: [RedshiftClientTypes.PartnerIntegrationInfo]?
}

extension DescribePartnersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case partnerIntegrationInfoList = "PartnerIntegrationInfoList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribePartnersResult"))
        if containerValues.contains(.partnerIntegrationInfoList) {
            struct KeyVal0{struct PartnerIntegrationInfo{}}
            let partnerIntegrationInfoListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.PartnerIntegrationInfo>.CodingKeys.self, forKey: .partnerIntegrationInfoList)
            if let partnerIntegrationInfoListWrappedContainer = partnerIntegrationInfoListWrappedContainer {
                let partnerIntegrationInfoListContainer = try partnerIntegrationInfoListWrappedContainer.decodeIfPresent([RedshiftClientTypes.PartnerIntegrationInfo].self, forKey: .member)
                var partnerIntegrationInfoListBuffer:[RedshiftClientTypes.PartnerIntegrationInfo]? = nil
                if let partnerIntegrationInfoListContainer = partnerIntegrationInfoListContainer {
                    partnerIntegrationInfoListBuffer = [RedshiftClientTypes.PartnerIntegrationInfo]()
                    for structureContainer0 in partnerIntegrationInfoListContainer {
                        partnerIntegrationInfoListBuffer?.append(structureContainer0)
                    }
                }
                partnerIntegrationInfoList = partnerIntegrationInfoListBuffer
            } else {
                partnerIntegrationInfoList = []
            }
        } else {
            partnerIntegrationInfoList = nil
        }
    }
}

public struct DescribeReservedNodeOfferingsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeReservedNodeOfferingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeReservedNodeOfferingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeReservedNodeOfferingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeReservedNodeOfferingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeReservedNodeOfferingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeReservedNodeOfferingsOutputError>
}

extension DescribeReservedNodeOfferingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeReservedNodeOfferingsInput(marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)), reservedNodeOfferingId: \(Swift.String(describing: reservedNodeOfferingId)))"}
}

extension DescribeReservedNodeOfferingsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let reservedNodeOfferingId = reservedNodeOfferingId {
            try container.encode(reservedNodeOfferingId, forKey: ClientRuntime.Key("ReservedNodeOfferingId"))
        }
        try container.encode("DescribeReservedNodeOfferings", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeReservedNodeOfferingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeReservedNodeOfferingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeReservedNodeOfferingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeReservedNodeOfferingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeReservedNodeOfferingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeReservedNodeOfferingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeReservedNodeOfferingsOutputError>
}

public struct DescribeReservedNodeOfferingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeReservedNodeOfferingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeReservedNodeOfferingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeReservedNodeOfferingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeReservedNodeOfferingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeReservedNodeOfferingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeReservedNodeOfferingsOutputError>
}

/// <p></p>
public struct DescribeReservedNodeOfferingsInput: Swift.Equatable {
    /// <p>An optional parameter that specifies the starting point to return a set of response
    ///             records. When the results of a <a>DescribeReservedNodeOfferings</a> request
    ///             exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the
    ///                 <code>Marker</code> field of the response. You can retrieve the next set of response
    ///             records by providing the returned marker value in the <code>Marker</code> parameter and
    ///             retrying the request. </p>
    public let marker: Swift.String?
    /// <p>The maximum number of response records to return in each call. If the number of
    ///             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
    ///             is returned in a <code>marker</code> field of the response. You can retrieve the next
    ///             set of records by retrying the command with the returned marker value. </p>
    ///         <p>Default: <code>100</code>
    ///         </p>
    ///         <p>Constraints: minimum 20, maximum 100.</p>
    public let maxRecords: Swift.Int?
    /// <p>The unique identifier for the offering.</p>
    public let reservedNodeOfferingId: Swift.String?

    public init (
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        reservedNodeOfferingId: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxRecords = maxRecords
        self.reservedNodeOfferingId = reservedNodeOfferingId
    }
}

extension DescribeReservedNodeOfferingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeReservedNodeOfferingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependentServiceUnavailableFault" : self = .dependentServiceUnavailableFault(try DependentServiceUnavailableFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReservedNodeOfferingNotFoundFault" : self = .reservedNodeOfferingNotFoundFault(try ReservedNodeOfferingNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationFault" : self = .unsupportedOperationFault(try UnsupportedOperationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeReservedNodeOfferingsOutputError: Swift.Error, Swift.Equatable {
    case dependentServiceUnavailableFault(DependentServiceUnavailableFault)
    case reservedNodeOfferingNotFoundFault(ReservedNodeOfferingNotFoundFault)
    case unsupportedOperationFault(UnsupportedOperationFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeReservedNodeOfferingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeReservedNodeOfferingsOutputResponse(marker: \(Swift.String(describing: marker)), reservedNodeOfferings: \(Swift.String(describing: reservedNodeOfferings)))"}
}

extension DescribeReservedNodeOfferingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeReservedNodeOfferingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.reservedNodeOfferings = output.reservedNodeOfferings
        } else {
            self.marker = nil
            self.reservedNodeOfferings = nil
        }
    }
}

/// <p></p>
public struct DescribeReservedNodeOfferingsOutputResponse: Swift.Equatable {
    /// <p>A value that indicates the starting point for the next set of response records in a
    ///             subsequent request. If a value is returned in a response, you can retrieve the next set
    ///             of records by providing this returned marker value in the <code>Marker</code> parameter
    ///             and retrying the command. If the <code>Marker</code> field is empty, all response
    ///             records have been retrieved for the request. </p>
    public let marker: Swift.String?
    /// <p>A list of <code>ReservedNodeOffering</code> objects.</p>
    public let reservedNodeOfferings: [RedshiftClientTypes.ReservedNodeOffering]?

    public init (
        marker: Swift.String? = nil,
        reservedNodeOfferings: [RedshiftClientTypes.ReservedNodeOffering]? = nil
    )
    {
        self.marker = marker
        self.reservedNodeOfferings = reservedNodeOfferings
    }
}

struct DescribeReservedNodeOfferingsOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let reservedNodeOfferings: [RedshiftClientTypes.ReservedNodeOffering]?
}

extension DescribeReservedNodeOfferingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case reservedNodeOfferings = "ReservedNodeOfferings"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeReservedNodeOfferingsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.reservedNodeOfferings) {
            struct KeyVal0{struct ReservedNodeOffering{}}
            let reservedNodeOfferingsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ReservedNodeOffering>.CodingKeys.self, forKey: .reservedNodeOfferings)
            if let reservedNodeOfferingsWrappedContainer = reservedNodeOfferingsWrappedContainer {
                let reservedNodeOfferingsContainer = try reservedNodeOfferingsWrappedContainer.decodeIfPresent([RedshiftClientTypes.ReservedNodeOffering].self, forKey: .member)
                var reservedNodeOfferingsBuffer:[RedshiftClientTypes.ReservedNodeOffering]? = nil
                if let reservedNodeOfferingsContainer = reservedNodeOfferingsContainer {
                    reservedNodeOfferingsBuffer = [RedshiftClientTypes.ReservedNodeOffering]()
                    for structureContainer0 in reservedNodeOfferingsContainer {
                        reservedNodeOfferingsBuffer?.append(structureContainer0)
                    }
                }
                reservedNodeOfferings = reservedNodeOfferingsBuffer
            } else {
                reservedNodeOfferings = []
            }
        } else {
            reservedNodeOfferings = nil
        }
    }
}

public struct DescribeReservedNodesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeReservedNodesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeReservedNodesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeReservedNodesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeReservedNodesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeReservedNodesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeReservedNodesOutputError>
}

extension DescribeReservedNodesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeReservedNodesInput(marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)), reservedNodeId: \(Swift.String(describing: reservedNodeId)))"}
}

extension DescribeReservedNodesInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let reservedNodeId = reservedNodeId {
            try container.encode(reservedNodeId, forKey: ClientRuntime.Key("ReservedNodeId"))
        }
        try container.encode("DescribeReservedNodes", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeReservedNodesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeReservedNodesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeReservedNodesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeReservedNodesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeReservedNodesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeReservedNodesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeReservedNodesOutputError>
}

public struct DescribeReservedNodesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeReservedNodesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeReservedNodesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeReservedNodesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeReservedNodesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeReservedNodesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeReservedNodesOutputError>
}

/// <p></p>
public struct DescribeReservedNodesInput: Swift.Equatable {
    /// <p>An optional parameter that specifies the starting point to return a set of response
    ///             records. When the results of a <a>DescribeReservedNodes</a> request exceed
    ///             the value specified in <code>MaxRecords</code>, AWS returns a value in the
    ///                 <code>Marker</code> field of the response. You can retrieve the next set of response
    ///             records by providing the returned marker value in the <code>Marker</code> parameter and
    ///             retrying the request. </p>
    public let marker: Swift.String?
    /// <p>The maximum number of response records to return in each call. If the number of
    ///             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
    ///             is returned in a <code>marker</code> field of the response. You can retrieve the next
    ///             set of records by retrying the command with the returned marker value. </p>
    ///         <p>Default: <code>100</code>
    ///         </p>
    ///         <p>Constraints: minimum 20, maximum 100.</p>
    public let maxRecords: Swift.Int?
    /// <p>Identifier for the node reservation.</p>
    public let reservedNodeId: Swift.String?

    public init (
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        reservedNodeId: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxRecords = maxRecords
        self.reservedNodeId = reservedNodeId
    }
}

extension DescribeReservedNodesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeReservedNodesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependentServiceUnavailableFault" : self = .dependentServiceUnavailableFault(try DependentServiceUnavailableFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReservedNodeNotFoundFault" : self = .reservedNodeNotFoundFault(try ReservedNodeNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeReservedNodesOutputError: Swift.Error, Swift.Equatable {
    case dependentServiceUnavailableFault(DependentServiceUnavailableFault)
    case reservedNodeNotFoundFault(ReservedNodeNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeReservedNodesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeReservedNodesOutputResponse(marker: \(Swift.String(describing: marker)), reservedNodes: \(Swift.String(describing: reservedNodes)))"}
}

extension DescribeReservedNodesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeReservedNodesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.reservedNodes = output.reservedNodes
        } else {
            self.marker = nil
            self.reservedNodes = nil
        }
    }
}

/// <p></p>
public struct DescribeReservedNodesOutputResponse: Swift.Equatable {
    /// <p>A value that indicates the starting point for the next set of response records in a
    ///             subsequent request. If a value is returned in a response, you can retrieve the next set
    ///             of records by providing this returned marker value in the <code>Marker</code> parameter
    ///             and retrying the command. If the <code>Marker</code> field is empty, all response
    ///             records have been retrieved for the request. </p>
    public let marker: Swift.String?
    /// <p>The list of <code>ReservedNode</code> objects.</p>
    public let reservedNodes: [RedshiftClientTypes.ReservedNode]?

    public init (
        marker: Swift.String? = nil,
        reservedNodes: [RedshiftClientTypes.ReservedNode]? = nil
    )
    {
        self.marker = marker
        self.reservedNodes = reservedNodes
    }
}

struct DescribeReservedNodesOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let reservedNodes: [RedshiftClientTypes.ReservedNode]?
}

extension DescribeReservedNodesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case reservedNodes = "ReservedNodes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeReservedNodesResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.reservedNodes) {
            struct KeyVal0{struct ReservedNode{}}
            let reservedNodesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ReservedNode>.CodingKeys.self, forKey: .reservedNodes)
            if let reservedNodesWrappedContainer = reservedNodesWrappedContainer {
                let reservedNodesContainer = try reservedNodesWrappedContainer.decodeIfPresent([RedshiftClientTypes.ReservedNode].self, forKey: .member)
                var reservedNodesBuffer:[RedshiftClientTypes.ReservedNode]? = nil
                if let reservedNodesContainer = reservedNodesContainer {
                    reservedNodesBuffer = [RedshiftClientTypes.ReservedNode]()
                    for structureContainer0 in reservedNodesContainer {
                        reservedNodesBuffer?.append(structureContainer0)
                    }
                }
                reservedNodes = reservedNodesBuffer
            } else {
                reservedNodes = []
            }
        } else {
            reservedNodes = nil
        }
    }
}

public struct DescribeResizeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeResizeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeResizeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeResizeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeResizeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeResizeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeResizeOutputError>
}

extension DescribeResizeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeResizeInput(clusterIdentifier: \(Swift.String(describing: clusterIdentifier)))"}
}

extension DescribeResizeInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: ClientRuntime.Key("ClusterIdentifier"))
        }
        try container.encode("DescribeResize", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeResizeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeResizeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeResizeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeResizeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeResizeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeResizeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeResizeOutputError>
}

public struct DescribeResizeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeResizeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeResizeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeResizeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeResizeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeResizeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeResizeOutputError>
}

/// <p></p>
public struct DescribeResizeInput: Swift.Equatable {
    /// <p>The unique identifier of a cluster whose resize progress you are requesting. This
    ///             parameter is case-sensitive.</p>
    ///         <p>By default, resize operations for all clusters defined for an AWS account are
    ///             returned.</p>
    public let clusterIdentifier: Swift.String?

    public init (
        clusterIdentifier: Swift.String? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
    }
}

extension DescribeResizeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeResizeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResizeNotFoundFault" : self = .resizeNotFoundFault(try ResizeNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeResizeOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case resizeNotFoundFault(ResizeNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeResizeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeResizeOutputResponse(avgResizeRateInMegaBytesPerSecond: \(Swift.String(describing: avgResizeRateInMegaBytesPerSecond)), dataTransferProgressPercent: \(Swift.String(describing: dataTransferProgressPercent)), elapsedTimeInSeconds: \(Swift.String(describing: elapsedTimeInSeconds)), estimatedTimeToCompletionInSeconds: \(Swift.String(describing: estimatedTimeToCompletionInSeconds)), importTablesCompleted: \(Swift.String(describing: importTablesCompleted)), importTablesInProgress: \(Swift.String(describing: importTablesInProgress)), importTablesNotStarted: \(Swift.String(describing: importTablesNotStarted)), message: \(Swift.String(describing: message)), progressInMegaBytes: \(Swift.String(describing: progressInMegaBytes)), resizeType: \(Swift.String(describing: resizeType)), status: \(Swift.String(describing: status)), targetClusterType: \(Swift.String(describing: targetClusterType)), targetEncryptionType: \(Swift.String(describing: targetEncryptionType)), targetNodeType: \(Swift.String(describing: targetNodeType)), targetNumberOfNodes: \(Swift.String(describing: targetNumberOfNodes)), totalResizeDataInMegaBytes: \(Swift.String(describing: totalResizeDataInMegaBytes)))"}
}

extension DescribeResizeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeResizeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.avgResizeRateInMegaBytesPerSecond = output.avgResizeRateInMegaBytesPerSecond
            self.dataTransferProgressPercent = output.dataTransferProgressPercent
            self.elapsedTimeInSeconds = output.elapsedTimeInSeconds
            self.estimatedTimeToCompletionInSeconds = output.estimatedTimeToCompletionInSeconds
            self.importTablesCompleted = output.importTablesCompleted
            self.importTablesInProgress = output.importTablesInProgress
            self.importTablesNotStarted = output.importTablesNotStarted
            self.message = output.message
            self.progressInMegaBytes = output.progressInMegaBytes
            self.resizeType = output.resizeType
            self.status = output.status
            self.targetClusterType = output.targetClusterType
            self.targetEncryptionType = output.targetEncryptionType
            self.targetNodeType = output.targetNodeType
            self.targetNumberOfNodes = output.targetNumberOfNodes
            self.totalResizeDataInMegaBytes = output.totalResizeDataInMegaBytes
        } else {
            self.avgResizeRateInMegaBytesPerSecond = nil
            self.dataTransferProgressPercent = nil
            self.elapsedTimeInSeconds = nil
            self.estimatedTimeToCompletionInSeconds = nil
            self.importTablesCompleted = nil
            self.importTablesInProgress = nil
            self.importTablesNotStarted = nil
            self.message = nil
            self.progressInMegaBytes = nil
            self.resizeType = nil
            self.status = nil
            self.targetClusterType = nil
            self.targetEncryptionType = nil
            self.targetNodeType = nil
            self.targetNumberOfNodes = nil
            self.totalResizeDataInMegaBytes = nil
        }
    }
}

/// <p>Describes the result of a cluster resize operation.</p>
public struct DescribeResizeOutputResponse: Swift.Equatable {
    /// <p>The average rate of the resize operation over the last few minutes, measured in
    ///             megabytes per second. After the resize operation completes, this value shows the average
    ///             rate of the entire resize operation.</p>
    public let avgResizeRateInMegaBytesPerSecond: Swift.Double?
    /// <p>The percent of data transferred from source cluster to target cluster.</p>
    public let dataTransferProgressPercent: Swift.Double?
    /// <p>The amount of seconds that have elapsed since the resize operation began. After the
    ///             resize operation completes, this value shows the total actual time, in seconds, for the
    ///             resize operation.</p>
    public let elapsedTimeInSeconds: Swift.Int?
    /// <p>The estimated time remaining, in seconds, until the resize operation is complete.
    ///             This value is calculated based on the average resize rate and the estimated amount of
    ///             data remaining to be processed. Once the resize operation is complete, this value will
    ///             be 0.</p>
    public let estimatedTimeToCompletionInSeconds: Swift.Int?
    /// <p>The names of tables that have been completely imported .</p>
    ///         <p>Valid Values: List of table names.</p>
    public let importTablesCompleted: [Swift.String]?
    /// <p>The names of tables that are being currently imported.</p>
    ///         <p>Valid Values: List of table names.</p>
    public let importTablesInProgress: [Swift.String]?
    /// <p>The names of tables that have not been yet imported.</p>
    ///         <p>Valid Values: List of table names</p>
    public let importTablesNotStarted: [Swift.String]?
    /// <p>An optional string to provide additional details about the resize action.</p>
    public let message: Swift.String?
    /// <p>While the resize operation is in progress, this value shows the current amount of
    ///             data, in megabytes, that has been processed so far. When the resize operation is
    ///             complete, this value shows the total amount of data, in megabytes, on the cluster, which
    ///             may be more or less than TotalResizeDataInMegaBytes (the estimated total amount of data
    ///             before resize).</p>
    public let progressInMegaBytes: Swift.Int?
    /// <p>An enum with possible values of <code>ClassicResize</code> and
    ///                 <code>ElasticResize</code>. These values describe the type of resize operation being
    ///             performed. </p>
    public let resizeType: Swift.String?
    /// <p>The status of the resize operation.</p>
    ///         <p>Valid Values: <code>NONE</code> | <code>IN_PROGRESS</code> | <code>FAILED</code> |
    ///                 <code>SUCCEEDED</code> | <code>CANCELLING</code>
    ///         </p>
    public let status: Swift.String?
    /// <p>The cluster type after the resize operation is complete.</p>
    ///         <p>Valid Values: <code>multi-node</code> | <code>single-node</code>
    ///         </p>
    public let targetClusterType: Swift.String?
    /// <p>The type of encryption for the cluster after the resize is complete.</p>
    ///         <p>Possible values are <code>KMS</code> and <code>None</code>. </p>
    public let targetEncryptionType: Swift.String?
    /// <p>The node type that the cluster will have after the resize operation is
    ///             complete.</p>
    public let targetNodeType: Swift.String?
    /// <p>The number of nodes that the cluster will have after the resize operation is
    ///             complete.</p>
    public let targetNumberOfNodes: Swift.Int?
    /// <p>The estimated total amount of data, in megabytes, on the cluster before the resize
    ///             operation began.</p>
    public let totalResizeDataInMegaBytes: Swift.Int?

    public init (
        avgResizeRateInMegaBytesPerSecond: Swift.Double? = nil,
        dataTransferProgressPercent: Swift.Double? = nil,
        elapsedTimeInSeconds: Swift.Int? = nil,
        estimatedTimeToCompletionInSeconds: Swift.Int? = nil,
        importTablesCompleted: [Swift.String]? = nil,
        importTablesInProgress: [Swift.String]? = nil,
        importTablesNotStarted: [Swift.String]? = nil,
        message: Swift.String? = nil,
        progressInMegaBytes: Swift.Int? = nil,
        resizeType: Swift.String? = nil,
        status: Swift.String? = nil,
        targetClusterType: Swift.String? = nil,
        targetEncryptionType: Swift.String? = nil,
        targetNodeType: Swift.String? = nil,
        targetNumberOfNodes: Swift.Int? = nil,
        totalResizeDataInMegaBytes: Swift.Int? = nil
    )
    {
        self.avgResizeRateInMegaBytesPerSecond = avgResizeRateInMegaBytesPerSecond
        self.dataTransferProgressPercent = dataTransferProgressPercent
        self.elapsedTimeInSeconds = elapsedTimeInSeconds
        self.estimatedTimeToCompletionInSeconds = estimatedTimeToCompletionInSeconds
        self.importTablesCompleted = importTablesCompleted
        self.importTablesInProgress = importTablesInProgress
        self.importTablesNotStarted = importTablesNotStarted
        self.message = message
        self.progressInMegaBytes = progressInMegaBytes
        self.resizeType = resizeType
        self.status = status
        self.targetClusterType = targetClusterType
        self.targetEncryptionType = targetEncryptionType
        self.targetNodeType = targetNodeType
        self.targetNumberOfNodes = targetNumberOfNodes
        self.totalResizeDataInMegaBytes = totalResizeDataInMegaBytes
    }
}

struct DescribeResizeOutputResponseBody: Swift.Equatable {
    public let targetNodeType: Swift.String?
    public let targetNumberOfNodes: Swift.Int?
    public let targetClusterType: Swift.String?
    public let status: Swift.String?
    public let importTablesCompleted: [Swift.String]?
    public let importTablesInProgress: [Swift.String]?
    public let importTablesNotStarted: [Swift.String]?
    public let avgResizeRateInMegaBytesPerSecond: Swift.Double?
    public let totalResizeDataInMegaBytes: Swift.Int?
    public let progressInMegaBytes: Swift.Int?
    public let elapsedTimeInSeconds: Swift.Int?
    public let estimatedTimeToCompletionInSeconds: Swift.Int?
    public let resizeType: Swift.String?
    public let message: Swift.String?
    public let targetEncryptionType: Swift.String?
    public let dataTransferProgressPercent: Swift.Double?
}

extension DescribeResizeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case avgResizeRateInMegaBytesPerSecond = "AvgResizeRateInMegaBytesPerSecond"
        case dataTransferProgressPercent = "DataTransferProgressPercent"
        case elapsedTimeInSeconds = "ElapsedTimeInSeconds"
        case estimatedTimeToCompletionInSeconds = "EstimatedTimeToCompletionInSeconds"
        case importTablesCompleted = "ImportTablesCompleted"
        case importTablesInProgress = "ImportTablesInProgress"
        case importTablesNotStarted = "ImportTablesNotStarted"
        case message = "Message"
        case progressInMegaBytes = "ProgressInMegaBytes"
        case resizeType = "ResizeType"
        case status = "Status"
        case targetClusterType = "TargetClusterType"
        case targetEncryptionType = "TargetEncryptionType"
        case targetNodeType = "TargetNodeType"
        case targetNumberOfNodes = "TargetNumberOfNodes"
        case totalResizeDataInMegaBytes = "TotalResizeDataInMegaBytes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeResizeResult"))
        let targetNodeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetNodeType)
        targetNodeType = targetNodeTypeDecoded
        let targetNumberOfNodesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .targetNumberOfNodes)
        targetNumberOfNodes = targetNumberOfNodesDecoded
        let targetClusterTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetClusterType)
        targetClusterType = targetClusterTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        if containerValues.contains(.importTablesCompleted) {
            struct KeyVal0{struct member{}}
            let importTablesCompletedWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .importTablesCompleted)
            if let importTablesCompletedWrappedContainer = importTablesCompletedWrappedContainer {
                let importTablesCompletedContainer = try importTablesCompletedWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var importTablesCompletedBuffer:[Swift.String]? = nil
                if let importTablesCompletedContainer = importTablesCompletedContainer {
                    importTablesCompletedBuffer = [Swift.String]()
                    for stringContainer0 in importTablesCompletedContainer {
                        importTablesCompletedBuffer?.append(stringContainer0)
                    }
                }
                importTablesCompleted = importTablesCompletedBuffer
            } else {
                importTablesCompleted = []
            }
        } else {
            importTablesCompleted = nil
        }
        if containerValues.contains(.importTablesInProgress) {
            struct KeyVal0{struct member{}}
            let importTablesInProgressWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .importTablesInProgress)
            if let importTablesInProgressWrappedContainer = importTablesInProgressWrappedContainer {
                let importTablesInProgressContainer = try importTablesInProgressWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var importTablesInProgressBuffer:[Swift.String]? = nil
                if let importTablesInProgressContainer = importTablesInProgressContainer {
                    importTablesInProgressBuffer = [Swift.String]()
                    for stringContainer0 in importTablesInProgressContainer {
                        importTablesInProgressBuffer?.append(stringContainer0)
                    }
                }
                importTablesInProgress = importTablesInProgressBuffer
            } else {
                importTablesInProgress = []
            }
        } else {
            importTablesInProgress = nil
        }
        if containerValues.contains(.importTablesNotStarted) {
            struct KeyVal0{struct member{}}
            let importTablesNotStartedWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .importTablesNotStarted)
            if let importTablesNotStartedWrappedContainer = importTablesNotStartedWrappedContainer {
                let importTablesNotStartedContainer = try importTablesNotStartedWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var importTablesNotStartedBuffer:[Swift.String]? = nil
                if let importTablesNotStartedContainer = importTablesNotStartedContainer {
                    importTablesNotStartedBuffer = [Swift.String]()
                    for stringContainer0 in importTablesNotStartedContainer {
                        importTablesNotStartedBuffer?.append(stringContainer0)
                    }
                }
                importTablesNotStarted = importTablesNotStartedBuffer
            } else {
                importTablesNotStarted = []
            }
        } else {
            importTablesNotStarted = nil
        }
        let avgResizeRateInMegaBytesPerSecondDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .avgResizeRateInMegaBytesPerSecond)
        avgResizeRateInMegaBytesPerSecond = avgResizeRateInMegaBytesPerSecondDecoded
        let totalResizeDataInMegaBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalResizeDataInMegaBytes)
        totalResizeDataInMegaBytes = totalResizeDataInMegaBytesDecoded
        let progressInMegaBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .progressInMegaBytes)
        progressInMegaBytes = progressInMegaBytesDecoded
        let elapsedTimeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .elapsedTimeInSeconds)
        elapsedTimeInSeconds = elapsedTimeInSecondsDecoded
        let estimatedTimeToCompletionInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .estimatedTimeToCompletionInSeconds)
        estimatedTimeToCompletionInSeconds = estimatedTimeToCompletionInSecondsDecoded
        let resizeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resizeType)
        resizeType = resizeTypeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let targetEncryptionTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetEncryptionType)
        targetEncryptionType = targetEncryptionTypeDecoded
        let dataTransferProgressPercentDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .dataTransferProgressPercent)
        dataTransferProgressPercent = dataTransferProgressPercentDecoded
    }
}

public struct DescribeScheduledActionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeScheduledActionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeScheduledActionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeScheduledActionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeScheduledActionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeScheduledActionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeScheduledActionsOutputError>
}

extension DescribeScheduledActionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeScheduledActionsInput(active: \(Swift.String(describing: active)), endTime: \(Swift.String(describing: endTime)), filters: \(Swift.String(describing: filters)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)), scheduledActionName: \(Swift.String(describing: scheduledActionName)), startTime: \(Swift.String(describing: startTime)), targetActionType: \(Swift.String(describing: targetActionType)))"}
}

extension DescribeScheduledActionsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let active = active {
            try container.encode(active, forKey: ClientRuntime.Key("Active"))
        }
        if let endTime = endTime {
            try container.encode(ClientRuntime.TimestampWrapper(endTime, format: .dateTime), forKey: ClientRuntime.Key("endTime"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, scheduledactionfilter0) in filters.enumerated() {
                try filtersContainer.encode(scheduledactionfilter0, forKey: ClientRuntime.Key("ScheduledActionFilter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let scheduledActionName = scheduledActionName {
            try container.encode(scheduledActionName, forKey: ClientRuntime.Key("ScheduledActionName"))
        }
        if let startTime = startTime {
            try container.encode(ClientRuntime.TimestampWrapper(startTime, format: .dateTime), forKey: ClientRuntime.Key("startTime"))
        }
        if let targetActionType = targetActionType {
            try container.encode(targetActionType, forKey: ClientRuntime.Key("TargetActionType"))
        }
        try container.encode("DescribeScheduledActions", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeScheduledActionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeScheduledActionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeScheduledActionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeScheduledActionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeScheduledActionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeScheduledActionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeScheduledActionsOutputError>
}

public struct DescribeScheduledActionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeScheduledActionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeScheduledActionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeScheduledActionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeScheduledActionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeScheduledActionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeScheduledActionsOutputError>
}

public struct DescribeScheduledActionsInput: Swift.Equatable {
    /// <p>If true, retrieve only active scheduled actions.
    ///            If false, retrieve only disabled scheduled actions. </p>
    public let active: Swift.Bool?
    /// <p>The end time in UTC of the scheduled action to retrieve.
    ///             Only active scheduled actions that have invocations before this time are retrieved.</p>
    public let endTime: ClientRuntime.Date?
    /// <p>List of scheduled action filters. </p>
    public let filters: [RedshiftClientTypes.ScheduledActionFilter]?
    /// <p>An optional parameter that specifies the starting point to return a set of response
    ///             records. When the results of a <a>DescribeScheduledActions</a> request
    ///             exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the
    ///             <code>Marker</code> field of the response. You can retrieve the next set of response
    ///             records by providing the returned marker value in the <code>Marker</code> parameter and
    ///             retrying the request. </p>
    public let marker: Swift.String?
    /// <p>The maximum number of response records to return in each call. If the number of
    ///             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
    ///             is returned in a <code>marker</code> field of the response. You can retrieve the next
    ///             set of records by retrying the command with the returned marker value. </p>
    ///             <p>Default: <code>100</code>
    ///             </p>
    ///             <p>Constraints: minimum 20, maximum 100.</p>
    public let maxRecords: Swift.Int?
    /// <p>The name of the scheduled action to retrieve. </p>
    public let scheduledActionName: Swift.String?
    /// <p>The start time in UTC of the scheduled actions to retrieve.
    ///             Only active scheduled actions that have invocations after this time are retrieved.</p>
    public let startTime: ClientRuntime.Date?
    /// <p>The type of the scheduled actions to retrieve. </p>
    public let targetActionType: RedshiftClientTypes.ScheduledActionTypeValues?

    public init (
        active: Swift.Bool? = nil,
        endTime: ClientRuntime.Date? = nil,
        filters: [RedshiftClientTypes.ScheduledActionFilter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        scheduledActionName: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        targetActionType: RedshiftClientTypes.ScheduledActionTypeValues? = nil
    )
    {
        self.active = active
        self.endTime = endTime
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.scheduledActionName = scheduledActionName
        self.startTime = startTime
        self.targetActionType = targetActionType
    }
}

extension DescribeScheduledActionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeScheduledActionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ScheduledActionNotFoundFault" : self = .scheduledActionNotFoundFault(try ScheduledActionNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeScheduledActionsOutputError: Swift.Error, Swift.Equatable {
    case scheduledActionNotFoundFault(ScheduledActionNotFoundFault)
    case unauthorizedOperation(UnauthorizedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeScheduledActionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeScheduledActionsOutputResponse(marker: \(Swift.String(describing: marker)), scheduledActions: \(Swift.String(describing: scheduledActions)))"}
}

extension DescribeScheduledActionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeScheduledActionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.scheduledActions = output.scheduledActions
        } else {
            self.marker = nil
            self.scheduledActions = nil
        }
    }
}

public struct DescribeScheduledActionsOutputResponse: Swift.Equatable {
    /// <p>An optional parameter that specifies the starting point to return a set of response
    ///             records. When the results of a <a>DescribeScheduledActions</a> request
    ///             exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the
    ///             <code>Marker</code> field of the response. You can retrieve the next set of response
    ///             records by providing the returned marker value in the <code>Marker</code> parameter and
    ///             retrying the request. </p>
    public let marker: Swift.String?
    /// <p>List of retrieved scheduled actions. </p>
    public let scheduledActions: [RedshiftClientTypes.ScheduledAction]?

    public init (
        marker: Swift.String? = nil,
        scheduledActions: [RedshiftClientTypes.ScheduledAction]? = nil
    )
    {
        self.marker = marker
        self.scheduledActions = scheduledActions
    }
}

struct DescribeScheduledActionsOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let scheduledActions: [RedshiftClientTypes.ScheduledAction]?
}

extension DescribeScheduledActionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case scheduledActions = "ScheduledActions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeScheduledActionsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.scheduledActions) {
            struct KeyVal0{struct ScheduledAction{}}
            let scheduledActionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ScheduledAction>.CodingKeys.self, forKey: .scheduledActions)
            if let scheduledActionsWrappedContainer = scheduledActionsWrappedContainer {
                let scheduledActionsContainer = try scheduledActionsWrappedContainer.decodeIfPresent([RedshiftClientTypes.ScheduledAction].self, forKey: .member)
                var scheduledActionsBuffer:[RedshiftClientTypes.ScheduledAction]? = nil
                if let scheduledActionsContainer = scheduledActionsContainer {
                    scheduledActionsBuffer = [RedshiftClientTypes.ScheduledAction]()
                    for structureContainer0 in scheduledActionsContainer {
                        scheduledActionsBuffer?.append(structureContainer0)
                    }
                }
                scheduledActions = scheduledActionsBuffer
            } else {
                scheduledActions = []
            }
        } else {
            scheduledActions = nil
        }
    }
}

public struct DescribeSnapshotCopyGrantsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSnapshotCopyGrantsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSnapshotCopyGrantsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSnapshotCopyGrantsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSnapshotCopyGrantsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSnapshotCopyGrantsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSnapshotCopyGrantsOutputError>
}

extension DescribeSnapshotCopyGrantsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSnapshotCopyGrantsInput(marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)), snapshotCopyGrantName: \(Swift.String(describing: snapshotCopyGrantName)), tagKeys: \(Swift.String(describing: tagKeys)), tagValues: \(Swift.String(describing: tagValues)))"}
}

extension DescribeSnapshotCopyGrantsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let snapshotCopyGrantName = snapshotCopyGrantName {
            try container.encode(snapshotCopyGrantName, forKey: ClientRuntime.Key("SnapshotCopyGrantName"))
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
            for (index0, string0) in tagKeys.enumerated() {
                try tagKeysContainer.encode(string0, forKey: ClientRuntime.Key("TagKey.\(index0.advanced(by: 1))"))
            }
        }
        if let tagValues = tagValues {
            var tagValuesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagValues"))
            for (index0, string0) in tagValues.enumerated() {
                try tagValuesContainer.encode(string0, forKey: ClientRuntime.Key("TagValue.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("DescribeSnapshotCopyGrants", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeSnapshotCopyGrantsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSnapshotCopyGrantsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSnapshotCopyGrantsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSnapshotCopyGrantsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSnapshotCopyGrantsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSnapshotCopyGrantsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSnapshotCopyGrantsOutputError>
}

public struct DescribeSnapshotCopyGrantsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSnapshotCopyGrantsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSnapshotCopyGrantsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSnapshotCopyGrantsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSnapshotCopyGrantsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSnapshotCopyGrantsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSnapshotCopyGrantsOutputError>
}

/// <p>The result of the <code>DescribeSnapshotCopyGrants</code> action.</p>
public struct DescribeSnapshotCopyGrantsInput: Swift.Equatable {
    /// <p>An optional parameter that specifies the starting point to return a set of response
    ///             records. When the results of a <code>DescribeSnapshotCopyGrant</code> request exceed the
    ///             value specified in <code>MaxRecords</code>, AWS returns a value in the
    ///                 <code>Marker</code> field of the response. You can retrieve the next set of response
    ///             records by providing the returned marker value in the <code>Marker</code> parameter and
    ///             retrying the request. </p>
    ///         <p>Constraints: You can specify either the <b>SnapshotCopyGrantName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
    public let marker: Swift.String?
    /// <p>The maximum number of response records to return in each call. If the number of
    ///             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
    ///             is returned in a <code>marker</code> field of the response. You can retrieve the next
    ///             set of records by retrying the command with the returned marker value. </p>
    ///         <p>Default: <code>100</code>
    ///         </p>
    ///         <p>Constraints: minimum 20, maximum 100.</p>
    public let maxRecords: Swift.Int?
    /// <p>The name of the snapshot copy grant.</p>
    public let snapshotCopyGrantName: Swift.String?
    /// <p>A tag key or keys for which you want to return all matching resources that are
    ///             associated with the specified key or keys. For example, suppose that you have resources
    ///             tagged with keys called <code>owner</code> and <code>environment</code>. If you specify
    ///             both of these tag keys in the request, Amazon Redshift returns a response with all resources
    ///             that have either or both of these tag keys associated with them.</p>
    public let tagKeys: [Swift.String]?
    /// <p>A tag value or values for which you want to return all matching resources that are
    ///             associated with the specified value or values. For example, suppose that you have
    ///             resources tagged with values called <code>admin</code> and <code>test</code>. If you
    ///             specify both of these tag values in the request, Amazon Redshift returns a response with all
    ///             resources that have either or both of these tag values associated with them.</p>
    public let tagValues: [Swift.String]?

    public init (
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        snapshotCopyGrantName: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil,
        tagValues: [Swift.String]? = nil
    )
    {
        self.marker = marker
        self.maxRecords = maxRecords
        self.snapshotCopyGrantName = snapshotCopyGrantName
        self.tagKeys = tagKeys
        self.tagValues = tagValues
    }
}

extension DescribeSnapshotCopyGrantsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeSnapshotCopyGrantsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidTagFault" : self = .invalidTagFault(try InvalidTagFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotCopyGrantNotFoundFault" : self = .snapshotCopyGrantNotFoundFault(try SnapshotCopyGrantNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSnapshotCopyGrantsOutputError: Swift.Error, Swift.Equatable {
    case invalidTagFault(InvalidTagFault)
    case snapshotCopyGrantNotFoundFault(SnapshotCopyGrantNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSnapshotCopyGrantsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSnapshotCopyGrantsOutputResponse(marker: \(Swift.String(describing: marker)), snapshotCopyGrants: \(Swift.String(describing: snapshotCopyGrants)))"}
}

extension DescribeSnapshotCopyGrantsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeSnapshotCopyGrantsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.snapshotCopyGrants = output.snapshotCopyGrants
        } else {
            self.marker = nil
            self.snapshotCopyGrants = nil
        }
    }
}

/// <p></p>
public struct DescribeSnapshotCopyGrantsOutputResponse: Swift.Equatable {
    /// <p>An optional parameter that specifies the starting point to return a set of response
    ///             records. When the results of a <code>DescribeSnapshotCopyGrant</code> request exceed the
    ///             value specified in <code>MaxRecords</code>, AWS returns a value in the
    ///                 <code>Marker</code> field of the response. You can retrieve the next set of response
    ///             records by providing the returned marker value in the <code>Marker</code> parameter and
    ///             retrying the request. </p>
    ///         <p>Constraints: You can specify either the <b>SnapshotCopyGrantName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
    public let marker: Swift.String?
    /// <p>The list of <code>SnapshotCopyGrant</code> objects.</p>
    public let snapshotCopyGrants: [RedshiftClientTypes.SnapshotCopyGrant]?

    public init (
        marker: Swift.String? = nil,
        snapshotCopyGrants: [RedshiftClientTypes.SnapshotCopyGrant]? = nil
    )
    {
        self.marker = marker
        self.snapshotCopyGrants = snapshotCopyGrants
    }
}

struct DescribeSnapshotCopyGrantsOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let snapshotCopyGrants: [RedshiftClientTypes.SnapshotCopyGrant]?
}

extension DescribeSnapshotCopyGrantsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case snapshotCopyGrants = "SnapshotCopyGrants"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeSnapshotCopyGrantsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.snapshotCopyGrants) {
            struct KeyVal0{struct SnapshotCopyGrant{}}
            let snapshotCopyGrantsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.SnapshotCopyGrant>.CodingKeys.self, forKey: .snapshotCopyGrants)
            if let snapshotCopyGrantsWrappedContainer = snapshotCopyGrantsWrappedContainer {
                let snapshotCopyGrantsContainer = try snapshotCopyGrantsWrappedContainer.decodeIfPresent([RedshiftClientTypes.SnapshotCopyGrant].self, forKey: .member)
                var snapshotCopyGrantsBuffer:[RedshiftClientTypes.SnapshotCopyGrant]? = nil
                if let snapshotCopyGrantsContainer = snapshotCopyGrantsContainer {
                    snapshotCopyGrantsBuffer = [RedshiftClientTypes.SnapshotCopyGrant]()
                    for structureContainer0 in snapshotCopyGrantsContainer {
                        snapshotCopyGrantsBuffer?.append(structureContainer0)
                    }
                }
                snapshotCopyGrants = snapshotCopyGrantsBuffer
            } else {
                snapshotCopyGrants = []
            }
        } else {
            snapshotCopyGrants = nil
        }
    }
}

public struct DescribeSnapshotSchedulesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSnapshotSchedulesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSnapshotSchedulesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSnapshotSchedulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSnapshotSchedulesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSnapshotSchedulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSnapshotSchedulesOutputError>
}

extension DescribeSnapshotSchedulesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSnapshotSchedulesInput(clusterIdentifier: \(Swift.String(describing: clusterIdentifier)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)), scheduleIdentifier: \(Swift.String(describing: scheduleIdentifier)), tagKeys: \(Swift.String(describing: tagKeys)), tagValues: \(Swift.String(describing: tagValues)))"}
}

extension DescribeSnapshotSchedulesInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: ClientRuntime.Key("ClusterIdentifier"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let scheduleIdentifier = scheduleIdentifier {
            try container.encode(scheduleIdentifier, forKey: ClientRuntime.Key("ScheduleIdentifier"))
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
            for (index0, string0) in tagKeys.enumerated() {
                try tagKeysContainer.encode(string0, forKey: ClientRuntime.Key("TagKey.\(index0.advanced(by: 1))"))
            }
        }
        if let tagValues = tagValues {
            var tagValuesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagValues"))
            for (index0, string0) in tagValues.enumerated() {
                try tagValuesContainer.encode(string0, forKey: ClientRuntime.Key("TagValue.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("DescribeSnapshotSchedules", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeSnapshotSchedulesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSnapshotSchedulesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSnapshotSchedulesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSnapshotSchedulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSnapshotSchedulesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSnapshotSchedulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSnapshotSchedulesOutputError>
}

public struct DescribeSnapshotSchedulesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSnapshotSchedulesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSnapshotSchedulesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSnapshotSchedulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSnapshotSchedulesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSnapshotSchedulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSnapshotSchedulesOutputError>
}

public struct DescribeSnapshotSchedulesInput: Swift.Equatable {
    /// <p>The unique identifier for the cluster whose snapshot schedules you want to
    ///             view.</p>
    public let clusterIdentifier: Swift.String?
    /// <p>A value that indicates the starting point for the next set of response records in a
    ///             subsequent request. If a value is returned in a response, you can retrieve the next set
    ///             of records by providing this returned marker value in the <code>marker</code> parameter
    ///             and retrying the command. If the <code>marker</code> field is empty, all response
    ///             records have been retrieved for the request.</p>
    public let marker: Swift.String?
    /// <p>The maximum number or response records to return in each call. If the number of
    ///             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
    ///             is returned in a <code>marker</code> field of the response. You can retrieve the next
    ///             set of records by retrying the command with the returned <code>marker</code>
    ///             value.</p>
    public let maxRecords: Swift.Int?
    /// <p>A unique identifier for a snapshot schedule.</p>
    public let scheduleIdentifier: Swift.String?
    /// <p>The key value for a snapshot schedule tag.</p>
    public let tagKeys: [Swift.String]?
    /// <p>The value corresponding to the key of the snapshot schedule tag.</p>
    public let tagValues: [Swift.String]?

    public init (
        clusterIdentifier: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        scheduleIdentifier: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil,
        tagValues: [Swift.String]? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
        self.marker = marker
        self.maxRecords = maxRecords
        self.scheduleIdentifier = scheduleIdentifier
        self.tagKeys = tagKeys
        self.tagValues = tagValues
    }
}

extension DescribeSnapshotSchedulesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeSnapshotSchedulesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSnapshotSchedulesOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSnapshotSchedulesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSnapshotSchedulesOutputResponse(marker: \(Swift.String(describing: marker)), snapshotSchedules: \(Swift.String(describing: snapshotSchedules)))"}
}

extension DescribeSnapshotSchedulesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeSnapshotSchedulesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.snapshotSchedules = output.snapshotSchedules
        } else {
            self.marker = nil
            self.snapshotSchedules = nil
        }
    }
}

public struct DescribeSnapshotSchedulesOutputResponse: Swift.Equatable {
    /// <p>A value that indicates the starting point for the next set of response records in a
    ///             subsequent request. If a value is returned in a response, you can retrieve the next set
    ///             of records by providing this returned marker value in the <code>marker</code> parameter
    ///             and retrying the command. If the <code>marker</code> field is empty, all response
    ///             records have been retrieved for the request.</p>
    public let marker: Swift.String?
    /// <p>A list of SnapshotSchedules.</p>
    public let snapshotSchedules: [RedshiftClientTypes.SnapshotSchedule]?

    public init (
        marker: Swift.String? = nil,
        snapshotSchedules: [RedshiftClientTypes.SnapshotSchedule]? = nil
    )
    {
        self.marker = marker
        self.snapshotSchedules = snapshotSchedules
    }
}

struct DescribeSnapshotSchedulesOutputResponseBody: Swift.Equatable {
    public let snapshotSchedules: [RedshiftClientTypes.SnapshotSchedule]?
    public let marker: Swift.String?
}

extension DescribeSnapshotSchedulesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case snapshotSchedules = "SnapshotSchedules"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeSnapshotSchedulesResult"))
        if containerValues.contains(.snapshotSchedules) {
            struct KeyVal0{struct SnapshotSchedule{}}
            let snapshotSchedulesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.SnapshotSchedule>.CodingKeys.self, forKey: .snapshotSchedules)
            if let snapshotSchedulesWrappedContainer = snapshotSchedulesWrappedContainer {
                let snapshotSchedulesContainer = try snapshotSchedulesWrappedContainer.decodeIfPresent([RedshiftClientTypes.SnapshotSchedule].self, forKey: .member)
                var snapshotSchedulesBuffer:[RedshiftClientTypes.SnapshotSchedule]? = nil
                if let snapshotSchedulesContainer = snapshotSchedulesContainer {
                    snapshotSchedulesBuffer = [RedshiftClientTypes.SnapshotSchedule]()
                    for structureContainer0 in snapshotSchedulesContainer {
                        snapshotSchedulesBuffer?.append(structureContainer0)
                    }
                }
                snapshotSchedules = snapshotSchedulesBuffer
            } else {
                snapshotSchedules = []
            }
        } else {
            snapshotSchedules = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribeStorageInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeStorageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeStorageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeStorageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeStorageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeStorageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeStorageOutputError>
}

extension DescribeStorageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeStorageInput()"}
}

extension DescribeStorageInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        try container.encode("DescribeStorage", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeStorageInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeStorageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeStorageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeStorageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeStorageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeStorageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeStorageOutputError>
}

public struct DescribeStorageInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeStorageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeStorageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeStorageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeStorageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeStorageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeStorageOutputError>
}

public struct DescribeStorageInput: Swift.Equatable {

    public init() {}
}

extension DescribeStorageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeStorageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeStorageOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeStorageOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeStorageOutputResponse(totalBackupSizeInMegaBytes: \(Swift.String(describing: totalBackupSizeInMegaBytes)), totalProvisionedStorageInMegaBytes: \(Swift.String(describing: totalProvisionedStorageInMegaBytes)))"}
}

extension DescribeStorageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeStorageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.totalBackupSizeInMegaBytes = output.totalBackupSizeInMegaBytes
            self.totalProvisionedStorageInMegaBytes = output.totalProvisionedStorageInMegaBytes
        } else {
            self.totalBackupSizeInMegaBytes = 0.0
            self.totalProvisionedStorageInMegaBytes = 0.0
        }
    }
}

public struct DescribeStorageOutputResponse: Swift.Equatable {
    /// <p>The total amount of storage currently used for snapshots.</p>
    public let totalBackupSizeInMegaBytes: Swift.Double
    /// <p>The total amount of storage currently provisioned.</p>
    public let totalProvisionedStorageInMegaBytes: Swift.Double

    public init (
        totalBackupSizeInMegaBytes: Swift.Double = 0.0,
        totalProvisionedStorageInMegaBytes: Swift.Double = 0.0
    )
    {
        self.totalBackupSizeInMegaBytes = totalBackupSizeInMegaBytes
        self.totalProvisionedStorageInMegaBytes = totalProvisionedStorageInMegaBytes
    }
}

struct DescribeStorageOutputResponseBody: Swift.Equatable {
    public let totalBackupSizeInMegaBytes: Swift.Double
    public let totalProvisionedStorageInMegaBytes: Swift.Double
}

extension DescribeStorageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case totalBackupSizeInMegaBytes = "TotalBackupSizeInMegaBytes"
        case totalProvisionedStorageInMegaBytes = "TotalProvisionedStorageInMegaBytes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeStorageResult"))
        let totalBackupSizeInMegaBytesDecoded = try containerValues.decode(Swift.Double.self, forKey: .totalBackupSizeInMegaBytes)
        totalBackupSizeInMegaBytes = totalBackupSizeInMegaBytesDecoded
        let totalProvisionedStorageInMegaBytesDecoded = try containerValues.decode(Swift.Double.self, forKey: .totalProvisionedStorageInMegaBytes)
        totalProvisionedStorageInMegaBytes = totalProvisionedStorageInMegaBytesDecoded
    }
}

public struct DescribeTableRestoreStatusInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTableRestoreStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTableRestoreStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTableRestoreStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTableRestoreStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTableRestoreStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTableRestoreStatusOutputError>
}

extension DescribeTableRestoreStatusInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeTableRestoreStatusInput(clusterIdentifier: \(Swift.String(describing: clusterIdentifier)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)), tableRestoreRequestId: \(Swift.String(describing: tableRestoreRequestId)))"}
}

extension DescribeTableRestoreStatusInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: ClientRuntime.Key("ClusterIdentifier"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let tableRestoreRequestId = tableRestoreRequestId {
            try container.encode(tableRestoreRequestId, forKey: ClientRuntime.Key("TableRestoreRequestId"))
        }
        try container.encode("DescribeTableRestoreStatus", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeTableRestoreStatusInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTableRestoreStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTableRestoreStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTableRestoreStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTableRestoreStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTableRestoreStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTableRestoreStatusOutputError>
}

public struct DescribeTableRestoreStatusInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTableRestoreStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTableRestoreStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTableRestoreStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTableRestoreStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTableRestoreStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTableRestoreStatusOutputError>
}

/// <p></p>
public struct DescribeTableRestoreStatusInput: Swift.Equatable {
    /// <p>The Amazon Redshift cluster that the table is being restored to.</p>
    public let clusterIdentifier: Swift.String?
    /// <p>An optional pagination token provided by a previous
    ///                 <code>DescribeTableRestoreStatus</code> request. If this parameter is specified, the
    ///             response includes only records beyond the marker, up to the value specified by the
    ///                 <code>MaxRecords</code> parameter.</p>
    public let marker: Swift.String?
    /// <p>The maximum number of records to include in the response. If more records exist
    ///             than the specified <code>MaxRecords</code> value, a pagination token called a marker is
    ///             included in the response so that the remaining results can be retrieved.</p>
    public let maxRecords: Swift.Int?
    /// <p>The identifier of the table restore request to return status for. If you don't
    ///             specify a <code>TableRestoreRequestId</code> value, then
    ///                 <code>DescribeTableRestoreStatus</code> returns the status of all in-progress table
    ///             restore requests.</p>
    public let tableRestoreRequestId: Swift.String?

    public init (
        clusterIdentifier: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        tableRestoreRequestId: Swift.String? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
        self.marker = marker
        self.maxRecords = maxRecords
        self.tableRestoreRequestId = tableRestoreRequestId
    }
}

extension DescribeTableRestoreStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeTableRestoreStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TableRestoreNotFoundFault" : self = .tableRestoreNotFoundFault(try TableRestoreNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTableRestoreStatusOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case tableRestoreNotFoundFault(TableRestoreNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTableRestoreStatusOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeTableRestoreStatusOutputResponse(marker: \(Swift.String(describing: marker)), tableRestoreStatusDetails: \(Swift.String(describing: tableRestoreStatusDetails)))"}
}

extension DescribeTableRestoreStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeTableRestoreStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.tableRestoreStatusDetails = output.tableRestoreStatusDetails
        } else {
            self.marker = nil
            self.tableRestoreStatusDetails = nil
        }
    }
}

/// <p></p>
public struct DescribeTableRestoreStatusOutputResponse: Swift.Equatable {
    /// <p>A pagination token that can be used in a subsequent <a>DescribeTableRestoreStatus</a> request.</p>
    public let marker: Swift.String?
    /// <p>A list of status details for one or more table restore requests.</p>
    public let tableRestoreStatusDetails: [RedshiftClientTypes.TableRestoreStatus]?

    public init (
        marker: Swift.String? = nil,
        tableRestoreStatusDetails: [RedshiftClientTypes.TableRestoreStatus]? = nil
    )
    {
        self.marker = marker
        self.tableRestoreStatusDetails = tableRestoreStatusDetails
    }
}

struct DescribeTableRestoreStatusOutputResponseBody: Swift.Equatable {
    public let tableRestoreStatusDetails: [RedshiftClientTypes.TableRestoreStatus]?
    public let marker: Swift.String?
}

extension DescribeTableRestoreStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case tableRestoreStatusDetails = "TableRestoreStatusDetails"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeTableRestoreStatusResult"))
        if containerValues.contains(.tableRestoreStatusDetails) {
            struct KeyVal0{struct TableRestoreStatus{}}
            let tableRestoreStatusDetailsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.TableRestoreStatus>.CodingKeys.self, forKey: .tableRestoreStatusDetails)
            if let tableRestoreStatusDetailsWrappedContainer = tableRestoreStatusDetailsWrappedContainer {
                let tableRestoreStatusDetailsContainer = try tableRestoreStatusDetailsWrappedContainer.decodeIfPresent([RedshiftClientTypes.TableRestoreStatus].self, forKey: .member)
                var tableRestoreStatusDetailsBuffer:[RedshiftClientTypes.TableRestoreStatus]? = nil
                if let tableRestoreStatusDetailsContainer = tableRestoreStatusDetailsContainer {
                    tableRestoreStatusDetailsBuffer = [RedshiftClientTypes.TableRestoreStatus]()
                    for structureContainer0 in tableRestoreStatusDetailsContainer {
                        tableRestoreStatusDetailsBuffer?.append(structureContainer0)
                    }
                }
                tableRestoreStatusDetails = tableRestoreStatusDetailsBuffer
            } else {
                tableRestoreStatusDetails = []
            }
        } else {
            tableRestoreStatusDetails = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribeTagsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTagsOutputError>
}

extension DescribeTagsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeTagsInput(marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)), resourceName: \(Swift.String(describing: resourceName)), resourceType: \(Swift.String(describing: resourceType)), tagKeys: \(Swift.String(describing: tagKeys)), tagValues: \(Swift.String(describing: tagValues)))"}
}

extension DescribeTagsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let resourceName = resourceName {
            try container.encode(resourceName, forKey: ClientRuntime.Key("ResourceName"))
        }
        if let resourceType = resourceType {
            try container.encode(resourceType, forKey: ClientRuntime.Key("ResourceType"))
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
            for (index0, string0) in tagKeys.enumerated() {
                try tagKeysContainer.encode(string0, forKey: ClientRuntime.Key("TagKey.\(index0.advanced(by: 1))"))
            }
        }
        if let tagValues = tagValues {
            var tagValuesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagValues"))
            for (index0, string0) in tagValues.enumerated() {
                try tagValuesContainer.encode(string0, forKey: ClientRuntime.Key("TagValue.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("DescribeTags", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeTagsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTagsOutputError>
}

public struct DescribeTagsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTagsOutputError>
}

/// <p></p>
public struct DescribeTagsInput: Swift.Equatable {
    /// <p>A value that indicates the starting point for the next set of response records in a
    ///             subsequent request. If a value is returned in a response, you can retrieve the next set
    ///             of records by providing this returned marker value in the <code>marker</code> parameter
    ///             and retrying the command. If the <code>marker</code> field is empty, all response
    ///             records have been retrieved for the request. </p>
    public let marker: Swift.String?
    /// <p>The maximum number or response records to return in each call. If the number of
    ///             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
    ///             is returned in a <code>marker</code> field of the response. You can retrieve the next
    ///             set of records by retrying the command with the returned <code>marker</code> value.
    ///         </p>
    public let maxRecords: Swift.Int?
    /// <p>The Amazon Resource Name (ARN) for which you want to describe the tag or tags. For
    ///             example, <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>. </p>
    public let resourceName: Swift.String?
    /// <p>The type of resource with which you want to view tags. Valid resource types are: </p>
    ///         <ul>
    ///             <li>
    ///                 <p>Cluster</p>
    ///             </li>
    ///             <li>
    ///                 <p>CIDR/IP</p>
    ///             </li>
    ///             <li>
    ///                 <p>EC2 security group</p>
    ///             </li>
    ///             <li>
    ///                 <p>Snapshot</p>
    ///             </li>
    ///             <li>
    ///                 <p>Cluster security group</p>
    ///             </li>
    ///             <li>
    ///                 <p>Subnet group</p>
    ///             </li>
    ///             <li>
    ///                 <p>HSM connection</p>
    ///             </li>
    ///             <li>
    ///                 <p>HSM certificate</p>
    ///             </li>
    ///             <li>
    ///                 <p>Parameter group</p>
    ///             </li>
    ///             <li>
    ///                 <p>Snapshot copy grant</p>
    ///             </li>
    ///          </ul>
    ///         <p>For more information about Amazon Redshift resource types and constructing ARNs, go to
    ///                 <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-overview.html#redshift-iam-access-control-specify-actions">Specifying Policy Elements: Actions, Effects, Resources, and Principals</a> in
    ///             the Amazon Redshift Cluster Management Guide. </p>
    public let resourceType: Swift.String?
    /// <p>A tag key or keys for which you want to return all matching resources that are
    ///             associated with the specified key or keys. For example, suppose that you have resources
    ///             tagged with keys called <code>owner</code> and <code>environment</code>. If you specify
    ///             both of these tag keys in the request, Amazon Redshift returns a response with all resources
    ///             that have either or both of these tag keys associated with them.</p>
    public let tagKeys: [Swift.String]?
    /// <p>A tag value or values for which you want to return all matching resources that are
    ///             associated with the specified value or values. For example, suppose that you have
    ///             resources tagged with values called <code>admin</code> and <code>test</code>. If you
    ///             specify both of these tag values in the request, Amazon Redshift returns a response with all
    ///             resources that have either or both of these tag values associated with them.</p>
    public let tagValues: [Swift.String]?

    public init (
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        resourceName: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil,
        tagValues: [Swift.String]? = nil
    )
    {
        self.marker = marker
        self.maxRecords = maxRecords
        self.resourceName = resourceName
        self.resourceType = resourceType
        self.tagKeys = tagKeys
        self.tagValues = tagValues
    }
}

extension DescribeTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidTagFault" : self = .invalidTagFault(try InvalidTagFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTagsOutputError: Swift.Error, Swift.Equatable {
    case invalidTagFault(InvalidTagFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTagsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeTagsOutputResponse(marker: \(Swift.String(describing: marker)), taggedResources: \(Swift.String(describing: taggedResources)))"}
}

extension DescribeTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeTagsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.taggedResources = output.taggedResources
        } else {
            self.marker = nil
            self.taggedResources = nil
        }
    }
}

/// <p></p>
public struct DescribeTagsOutputResponse: Swift.Equatable {
    /// <p>A value that indicates the starting point for the next set of response records in a
    ///             subsequent request. If a value is returned in a response, you can retrieve the next set
    ///             of records by providing this returned marker value in the <code>Marker</code> parameter
    ///             and retrying the command. If the <code>Marker</code> field is empty, all response
    ///             records have been retrieved for the request. </p>
    public let marker: Swift.String?
    /// <p>A list of tags with their associated resources.</p>
    public let taggedResources: [RedshiftClientTypes.TaggedResource]?

    public init (
        marker: Swift.String? = nil,
        taggedResources: [RedshiftClientTypes.TaggedResource]? = nil
    )
    {
        self.marker = marker
        self.taggedResources = taggedResources
    }
}

struct DescribeTagsOutputResponseBody: Swift.Equatable {
    public let taggedResources: [RedshiftClientTypes.TaggedResource]?
    public let marker: Swift.String?
}

extension DescribeTagsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case taggedResources = "TaggedResources"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeTagsResult"))
        if containerValues.contains(.taggedResources) {
            struct KeyVal0{struct TaggedResource{}}
            let taggedResourcesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.TaggedResource>.CodingKeys.self, forKey: .taggedResources)
            if let taggedResourcesWrappedContainer = taggedResourcesWrappedContainer {
                let taggedResourcesContainer = try taggedResourcesWrappedContainer.decodeIfPresent([RedshiftClientTypes.TaggedResource].self, forKey: .member)
                var taggedResourcesBuffer:[RedshiftClientTypes.TaggedResource]? = nil
                if let taggedResourcesContainer = taggedResourcesContainer {
                    taggedResourcesBuffer = [RedshiftClientTypes.TaggedResource]()
                    for structureContainer0 in taggedResourcesContainer {
                        taggedResourcesBuffer?.append(structureContainer0)
                    }
                }
                taggedResources = taggedResourcesBuffer
            } else {
                taggedResources = []
            }
        } else {
            taggedResources = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribeUsageLimitsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeUsageLimitsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeUsageLimitsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeUsageLimitsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeUsageLimitsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeUsageLimitsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeUsageLimitsOutputError>
}

extension DescribeUsageLimitsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeUsageLimitsInput(clusterIdentifier: \(Swift.String(describing: clusterIdentifier)), featureType: \(Swift.String(describing: featureType)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)), tagKeys: \(Swift.String(describing: tagKeys)), tagValues: \(Swift.String(describing: tagValues)), usageLimitId: \(Swift.String(describing: usageLimitId)))"}
}

extension DescribeUsageLimitsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: ClientRuntime.Key("ClusterIdentifier"))
        }
        if let featureType = featureType {
            try container.encode(featureType, forKey: ClientRuntime.Key("FeatureType"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
            for (index0, string0) in tagKeys.enumerated() {
                try tagKeysContainer.encode(string0, forKey: ClientRuntime.Key("TagKey.\(index0.advanced(by: 1))"))
            }
        }
        if let tagValues = tagValues {
            var tagValuesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagValues"))
            for (index0, string0) in tagValues.enumerated() {
                try tagValuesContainer.encode(string0, forKey: ClientRuntime.Key("TagValue.\(index0.advanced(by: 1))"))
            }
        }
        if let usageLimitId = usageLimitId {
            try container.encode(usageLimitId, forKey: ClientRuntime.Key("UsageLimitId"))
        }
        try container.encode("DescribeUsageLimits", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeUsageLimitsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeUsageLimitsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeUsageLimitsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeUsageLimitsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeUsageLimitsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeUsageLimitsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeUsageLimitsOutputError>
}

public struct DescribeUsageLimitsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeUsageLimitsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeUsageLimitsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeUsageLimitsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeUsageLimitsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeUsageLimitsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeUsageLimitsOutputError>
}

public struct DescribeUsageLimitsInput: Swift.Equatable {
    /// <p>The identifier of the cluster for which you want to describe usage limits.</p>
    public let clusterIdentifier: Swift.String?
    /// <p>The feature type for which you want to describe usage limits.</p>
    public let featureType: RedshiftClientTypes.UsageLimitFeatureType?
    /// <p>An optional parameter that specifies the starting point to return a set of response
    ///             records. When the results of a <a>DescribeUsageLimits</a> request
    ///             exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the
    ///             <code>Marker</code> field of the response. You can retrieve the next set of response
    ///             records by providing the returned marker value in the <code>Marker</code> parameter and
    ///             retrying the request. </p>
    public let marker: Swift.String?
    /// <p>The maximum number of response records to return in each call. If the number of
    ///             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
    ///             is returned in a <code>marker</code> field of the response. You can retrieve the next
    ///             set of records by retrying the command with the returned marker value. </p>
    ///         <p>Default: <code>100</code>
    ///         </p>
    ///         <p>Constraints: minimum 20, maximum 100.</p>
    public let maxRecords: Swift.Int?
    /// <p>A tag key or keys for which you want to return all matching usage limit objects
    ///             that are associated with the specified key or keys. For example, suppose that you
    ///             have parameter groups that are tagged with keys called <code>owner</code> and
    ///             <code>environment</code>. If you specify both of these tag keys in the request,
    ///             Amazon Redshift returns a response with the usage limit objects have either or both of these
    ///             tag keys associated with them.</p>
    public let tagKeys: [Swift.String]?
    /// <p>A tag value or values for which you want to return all matching usage limit objects
    ///             that are associated with the specified tag value or values. For example, suppose
    ///             that you have parameter groups that are tagged with values called <code>admin</code> and
    ///             <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift
    ///             returns a response with the usage limit objects that have either or both of these tag
    ///             values associated with them.</p>
    public let tagValues: [Swift.String]?
    /// <p>The identifier of the usage limit to describe.</p>
    public let usageLimitId: Swift.String?

    public init (
        clusterIdentifier: Swift.String? = nil,
        featureType: RedshiftClientTypes.UsageLimitFeatureType? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        tagKeys: [Swift.String]? = nil,
        tagValues: [Swift.String]? = nil,
        usageLimitId: Swift.String? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
        self.featureType = featureType
        self.marker = marker
        self.maxRecords = maxRecords
        self.tagKeys = tagKeys
        self.tagValues = tagValues
        self.usageLimitId = usageLimitId
    }
}

extension DescribeUsageLimitsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeUsageLimitsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationFault" : self = .unsupportedOperationFault(try UnsupportedOperationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeUsageLimitsOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case unsupportedOperationFault(UnsupportedOperationFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeUsageLimitsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeUsageLimitsOutputResponse(marker: \(Swift.String(describing: marker)), usageLimits: \(Swift.String(describing: usageLimits)))"}
}

extension DescribeUsageLimitsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeUsageLimitsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.usageLimits = output.usageLimits
        } else {
            self.marker = nil
            self.usageLimits = nil
        }
    }
}

public struct DescribeUsageLimitsOutputResponse: Swift.Equatable {
    /// <p>A value that indicates the starting point for the next set of response records in a
    ///             subsequent request. If a value is returned in a response, you can retrieve the next set
    ///             of records by providing this returned marker value in the <code>Marker</code> parameter
    ///             and retrying the command. If the <code>Marker</code> field is empty, all response
    ///             records have been retrieved for the request. </p>
    public let marker: Swift.String?
    /// <p>Contains the output from the <a>DescribeUsageLimits</a>
    ///             action. </p>
    public let usageLimits: [RedshiftClientTypes.UsageLimit]?

    public init (
        marker: Swift.String? = nil,
        usageLimits: [RedshiftClientTypes.UsageLimit]? = nil
    )
    {
        self.marker = marker
        self.usageLimits = usageLimits
    }
}

struct DescribeUsageLimitsOutputResponseBody: Swift.Equatable {
    public let usageLimits: [RedshiftClientTypes.UsageLimit]?
    public let marker: Swift.String?
}

extension DescribeUsageLimitsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case usageLimits = "UsageLimits"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeUsageLimitsResult"))
        if containerValues.contains(.usageLimits) {
            struct KeyVal0{struct member{}}
            let usageLimitsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .usageLimits)
            if let usageLimitsWrappedContainer = usageLimitsWrappedContainer {
                let usageLimitsContainer = try usageLimitsWrappedContainer.decodeIfPresent([RedshiftClientTypes.UsageLimit].self, forKey: .member)
                var usageLimitsBuffer:[RedshiftClientTypes.UsageLimit]? = nil
                if let usageLimitsContainer = usageLimitsContainer {
                    usageLimitsBuffer = [RedshiftClientTypes.UsageLimit]()
                    for structureContainer0 in usageLimitsContainer {
                        usageLimitsBuffer?.append(structureContainer0)
                    }
                }
                usageLimits = usageLimitsBuffer
            } else {
                usageLimits = []
            }
        } else {
            usageLimits = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DisableLoggingInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisableLoggingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisableLoggingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisableLoggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisableLoggingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisableLoggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisableLoggingOutputError>
}

extension DisableLoggingInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisableLoggingInput(clusterIdentifier: \(Swift.String(describing: clusterIdentifier)))"}
}

extension DisableLoggingInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: ClientRuntime.Key("ClusterIdentifier"))
        }
        try container.encode("DisableLogging", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DisableLoggingInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisableLoggingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisableLoggingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisableLoggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisableLoggingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisableLoggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisableLoggingOutputError>
}

public struct DisableLoggingInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisableLoggingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisableLoggingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisableLoggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisableLoggingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisableLoggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisableLoggingOutputError>
}

/// <p></p>
public struct DisableLoggingInput: Swift.Equatable {
    /// <p>The identifier of the cluster on which logging is to be stopped.</p>
    ///         <p>Example: <code>examplecluster</code>
    ///         </p>
    public let clusterIdentifier: Swift.String?

    public init (
        clusterIdentifier: Swift.String? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
    }
}

extension DisableLoggingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DisableLoggingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisableLoggingOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisableLoggingOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisableLoggingOutputResponse(bucketName: \(Swift.String(describing: bucketName)), lastFailureMessage: \(Swift.String(describing: lastFailureMessage)), lastFailureTime: \(Swift.String(describing: lastFailureTime)), lastSuccessfulDeliveryTime: \(Swift.String(describing: lastSuccessfulDeliveryTime)), loggingEnabled: \(Swift.String(describing: loggingEnabled)), s3KeyPrefix: \(Swift.String(describing: s3KeyPrefix)))"}
}

extension DisableLoggingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DisableLoggingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.bucketName = output.bucketName
            self.lastFailureMessage = output.lastFailureMessage
            self.lastFailureTime = output.lastFailureTime
            self.lastSuccessfulDeliveryTime = output.lastSuccessfulDeliveryTime
            self.loggingEnabled = output.loggingEnabled
            self.s3KeyPrefix = output.s3KeyPrefix
        } else {
            self.bucketName = nil
            self.lastFailureMessage = nil
            self.lastFailureTime = nil
            self.lastSuccessfulDeliveryTime = nil
            self.loggingEnabled = false
            self.s3KeyPrefix = nil
        }
    }
}

/// <p>Describes the status of logging for a cluster.</p>
public struct DisableLoggingOutputResponse: Swift.Equatable {
    /// <p>The name of the S3 bucket where the log files are stored.</p>
    public let bucketName: Swift.String?
    /// <p>The message indicating that logs failed to be delivered.</p>
    public let lastFailureMessage: Swift.String?
    /// <p>The last time when logs failed to be delivered.</p>
    public let lastFailureTime: ClientRuntime.Date?
    /// <p>The last time that logs were delivered.</p>
    public let lastSuccessfulDeliveryTime: ClientRuntime.Date?
    /// <p>
    ///             <code>true</code> if logging is on, <code>false</code> if logging is off.</p>
    public let loggingEnabled: Swift.Bool
    /// <p>The prefix applied to the log file names.</p>
    public let s3KeyPrefix: Swift.String?

    public init (
        bucketName: Swift.String? = nil,
        lastFailureMessage: Swift.String? = nil,
        lastFailureTime: ClientRuntime.Date? = nil,
        lastSuccessfulDeliveryTime: ClientRuntime.Date? = nil,
        loggingEnabled: Swift.Bool = false,
        s3KeyPrefix: Swift.String? = nil
    )
    {
        self.bucketName = bucketName
        self.lastFailureMessage = lastFailureMessage
        self.lastFailureTime = lastFailureTime
        self.lastSuccessfulDeliveryTime = lastSuccessfulDeliveryTime
        self.loggingEnabled = loggingEnabled
        self.s3KeyPrefix = s3KeyPrefix
    }
}

struct DisableLoggingOutputResponseBody: Swift.Equatable {
    public let loggingEnabled: Swift.Bool
    public let bucketName: Swift.String?
    public let s3KeyPrefix: Swift.String?
    public let lastSuccessfulDeliveryTime: ClientRuntime.Date?
    public let lastFailureTime: ClientRuntime.Date?
    public let lastFailureMessage: Swift.String?
}

extension DisableLoggingOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName = "BucketName"
        case lastFailureMessage = "LastFailureMessage"
        case lastFailureTime = "LastFailureTime"
        case lastSuccessfulDeliveryTime = "LastSuccessfulDeliveryTime"
        case loggingEnabled = "LoggingEnabled"
        case s3KeyPrefix = "S3KeyPrefix"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DisableLoggingResult"))
        let loggingEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .loggingEnabled)
        loggingEnabled = loggingEnabledDecoded
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let s3KeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3KeyPrefix)
        s3KeyPrefix = s3KeyPrefixDecoded
        let lastSuccessfulDeliveryTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastSuccessfulDeliveryTime)
        var lastSuccessfulDeliveryTimeBuffer:ClientRuntime.Date? = nil
        if let lastSuccessfulDeliveryTimeDecoded = lastSuccessfulDeliveryTimeDecoded {
            lastSuccessfulDeliveryTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(lastSuccessfulDeliveryTimeDecoded, format: .dateTime)
        }
        lastSuccessfulDeliveryTime = lastSuccessfulDeliveryTimeBuffer
        let lastFailureTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastFailureTime)
        var lastFailureTimeBuffer:ClientRuntime.Date? = nil
        if let lastFailureTimeDecoded = lastFailureTimeDecoded {
            lastFailureTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(lastFailureTimeDecoded, format: .dateTime)
        }
        lastFailureTime = lastFailureTimeBuffer
        let lastFailureMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastFailureMessage)
        lastFailureMessage = lastFailureMessageDecoded
    }
}

public struct DisableSnapshotCopyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisableSnapshotCopyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisableSnapshotCopyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisableSnapshotCopyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisableSnapshotCopyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisableSnapshotCopyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisableSnapshotCopyOutputError>
}

extension DisableSnapshotCopyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisableSnapshotCopyInput(clusterIdentifier: \(Swift.String(describing: clusterIdentifier)))"}
}

extension DisableSnapshotCopyInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: ClientRuntime.Key("ClusterIdentifier"))
        }
        try container.encode("DisableSnapshotCopy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DisableSnapshotCopyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisableSnapshotCopyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisableSnapshotCopyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisableSnapshotCopyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisableSnapshotCopyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisableSnapshotCopyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisableSnapshotCopyOutputError>
}

public struct DisableSnapshotCopyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisableSnapshotCopyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisableSnapshotCopyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisableSnapshotCopyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisableSnapshotCopyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisableSnapshotCopyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisableSnapshotCopyOutputError>
}

/// <p></p>
public struct DisableSnapshotCopyInput: Swift.Equatable {
    /// <p>The unique identifier of the source cluster that you want to disable copying of
    ///             snapshots to a destination region.</p>
    ///         <p>Constraints: Must be the valid name of an existing cluster that has cross-region
    ///             snapshot copy enabled.</p>
    public let clusterIdentifier: Swift.String?

    public init (
        clusterIdentifier: Swift.String? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
    }
}

extension DisableSnapshotCopyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DisableSnapshotCopyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotCopyAlreadyDisabledFault" : self = .snapshotCopyAlreadyDisabledFault(try SnapshotCopyAlreadyDisabledFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisableSnapshotCopyOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case snapshotCopyAlreadyDisabledFault(SnapshotCopyAlreadyDisabledFault)
    case unauthorizedOperation(UnauthorizedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisableSnapshotCopyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisableSnapshotCopyOutputResponse(cluster: \(Swift.String(describing: cluster)))"}
}

extension DisableSnapshotCopyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DisableSnapshotCopyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct DisableSnapshotCopyOutputResponse: Swift.Equatable {
    /// <p>Describes a cluster.</p>
    public let cluster: RedshiftClientTypes.Cluster?

    public init (
        cluster: RedshiftClientTypes.Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct DisableSnapshotCopyOutputResponseBody: Swift.Equatable {
    public let cluster: RedshiftClientTypes.Cluster?
}

extension DisableSnapshotCopyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cluster = "Cluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DisableSnapshotCopyResult"))
        let clusterDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

extension RedshiftClientTypes.EC2SecurityGroup: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eC2SecurityGroupName = "EC2SecurityGroupName"
        case eC2SecurityGroupOwnerId = "EC2SecurityGroupOwnerId"
        case status = "Status"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let eC2SecurityGroupName = eC2SecurityGroupName {
            try container.encode(eC2SecurityGroupName, forKey: ClientRuntime.Key("EC2SecurityGroupName"))
        }
        if let eC2SecurityGroupOwnerId = eC2SecurityGroupOwnerId {
            try container.encode(eC2SecurityGroupOwnerId, forKey: ClientRuntime.Key("EC2SecurityGroupOwnerId"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let eC2SecurityGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eC2SecurityGroupName)
        eC2SecurityGroupName = eC2SecurityGroupNameDecoded
        let eC2SecurityGroupOwnerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eC2SecurityGroupOwnerId)
        eC2SecurityGroupOwnerId = eC2SecurityGroupOwnerIdDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([RedshiftClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[RedshiftClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [RedshiftClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension RedshiftClientTypes.EC2SecurityGroup: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EC2SecurityGroup(eC2SecurityGroupName: \(Swift.String(describing: eC2SecurityGroupName)), eC2SecurityGroupOwnerId: \(Swift.String(describing: eC2SecurityGroupOwnerId)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)))"}
}

extension RedshiftClientTypes {
    /// <p>Describes an Amazon EC2 security group.</p>
    public struct EC2SecurityGroup: Swift.Equatable {
        /// <p>The name of the EC2 Security Group.</p>
        public let eC2SecurityGroupName: Swift.String?
        /// <p>The AWS ID of the owner of the EC2 security group specified in the
        ///                 <code>EC2SecurityGroupName</code> field. </p>
        public let eC2SecurityGroupOwnerId: Swift.String?
        /// <p>The status of the EC2 security group.</p>
        public let status: Swift.String?
        /// <p>The list of tags for the EC2 security group.</p>
        public let tags: [RedshiftClientTypes.Tag]?

        public init (
            eC2SecurityGroupName: Swift.String? = nil,
            eC2SecurityGroupOwnerId: Swift.String? = nil,
            status: Swift.String? = nil,
            tags: [RedshiftClientTypes.Tag]? = nil
        )
        {
            self.eC2SecurityGroupName = eC2SecurityGroupName
            self.eC2SecurityGroupOwnerId = eC2SecurityGroupOwnerId
            self.status = status
            self.tags = tags
        }
    }

}

extension RedshiftClientTypes.ElasticIpStatus: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case elasticIp = "ElasticIp"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let elasticIp = elasticIp {
            try container.encode(elasticIp, forKey: ClientRuntime.Key("ElasticIp"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let elasticIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .elasticIp)
        elasticIp = elasticIpDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension RedshiftClientTypes.ElasticIpStatus: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ElasticIpStatus(elasticIp: \(Swift.String(describing: elasticIp)), status: \(Swift.String(describing: status)))"}
}

extension RedshiftClientTypes {
    /// <p>Describes the status of the elastic IP (EIP) address.</p>
    public struct ElasticIpStatus: Swift.Equatable {
        /// <p>The elastic IP (EIP) address for the cluster.</p>
        public let elasticIp: Swift.String?
        /// <p>The status of the elastic IP (EIP) address.</p>
        public let status: Swift.String?

        public init (
            elasticIp: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.elasticIp = elasticIp
            self.status = status
        }
    }

}

public struct EnableLoggingInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "EnableLoggingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<EnableLoggingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<EnableLoggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<EnableLoggingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<EnableLoggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<EnableLoggingOutputError>
}

extension EnableLoggingInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnableLoggingInput(bucketName: \(Swift.String(describing: bucketName)), clusterIdentifier: \(Swift.String(describing: clusterIdentifier)), s3KeyPrefix: \(Swift.String(describing: s3KeyPrefix)))"}
}

extension EnableLoggingInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let bucketName = bucketName {
            try container.encode(bucketName, forKey: ClientRuntime.Key("BucketName"))
        }
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: ClientRuntime.Key("ClusterIdentifier"))
        }
        if let s3KeyPrefix = s3KeyPrefix {
            try container.encode(s3KeyPrefix, forKey: ClientRuntime.Key("S3KeyPrefix"))
        }
        try container.encode("EnableLogging", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct EnableLoggingInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "EnableLoggingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<EnableLoggingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<EnableLoggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<EnableLoggingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<EnableLoggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<EnableLoggingOutputError>
}

public struct EnableLoggingInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "EnableLoggingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<EnableLoggingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<EnableLoggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<EnableLoggingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<EnableLoggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<EnableLoggingOutputError>
}

/// <p></p>
public struct EnableLoggingInput: Swift.Equatable {
    /// <p>The name of an existing S3 bucket where the log files are to be stored.</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Must be in the same region as the cluster</p>
    ///             </li>
    ///             <li>
    ///                 <p>The cluster must have read bucket and put object permissions</p>
    ///             </li>
    ///          </ul>
    public let bucketName: Swift.String?
    /// <p>The identifier of the cluster on which logging is to be started.</p>
    ///         <p>Example: <code>examplecluster</code>
    ///         </p>
    public let clusterIdentifier: Swift.String?
    /// <p>The prefix applied to the log file names.</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Cannot exceed 512 characters</p>
    ///             </li>
    ///             <li>
    ///                 <p>Cannot contain spaces( ), double quotes ("), single quotes ('), a backslash
    ///                     (\), or control characters. The hexadecimal codes for invalid characters are: </p>
    ///                 <ul>
    ///                   <li>
    ///                         <p>x00 to x20</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>x22</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>x27</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>x5c</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>x7f or larger</p>
    ///                     </li>
    ///                </ul>
    ///             </li>
    ///          </ul>
    public let s3KeyPrefix: Swift.String?

    public init (
        bucketName: Swift.String? = nil,
        clusterIdentifier: Swift.String? = nil,
        s3KeyPrefix: Swift.String? = nil
    )
    {
        self.bucketName = bucketName
        self.clusterIdentifier = clusterIdentifier
        self.s3KeyPrefix = s3KeyPrefix
    }
}

extension EnableLoggingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension EnableLoggingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BucketNotFoundFault" : self = .bucketNotFoundFault(try BucketNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientS3BucketPolicyFault" : self = .insufficientS3BucketPolicyFault(try InsufficientS3BucketPolicyFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidS3BucketNameFault" : self = .invalidS3BucketNameFault(try InvalidS3BucketNameFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidS3KeyPrefixFault" : self = .invalidS3KeyPrefixFault(try InvalidS3KeyPrefixFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum EnableLoggingOutputError: Swift.Error, Swift.Equatable {
    case bucketNotFoundFault(BucketNotFoundFault)
    case clusterNotFoundFault(ClusterNotFoundFault)
    case insufficientS3BucketPolicyFault(InsufficientS3BucketPolicyFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidS3BucketNameFault(InvalidS3BucketNameFault)
    case invalidS3KeyPrefixFault(InvalidS3KeyPrefixFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableLoggingOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnableLoggingOutputResponse(bucketName: \(Swift.String(describing: bucketName)), lastFailureMessage: \(Swift.String(describing: lastFailureMessage)), lastFailureTime: \(Swift.String(describing: lastFailureTime)), lastSuccessfulDeliveryTime: \(Swift.String(describing: lastSuccessfulDeliveryTime)), loggingEnabled: \(Swift.String(describing: loggingEnabled)), s3KeyPrefix: \(Swift.String(describing: s3KeyPrefix)))"}
}

extension EnableLoggingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: EnableLoggingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.bucketName = output.bucketName
            self.lastFailureMessage = output.lastFailureMessage
            self.lastFailureTime = output.lastFailureTime
            self.lastSuccessfulDeliveryTime = output.lastSuccessfulDeliveryTime
            self.loggingEnabled = output.loggingEnabled
            self.s3KeyPrefix = output.s3KeyPrefix
        } else {
            self.bucketName = nil
            self.lastFailureMessage = nil
            self.lastFailureTime = nil
            self.lastSuccessfulDeliveryTime = nil
            self.loggingEnabled = false
            self.s3KeyPrefix = nil
        }
    }
}

/// <p>Describes the status of logging for a cluster.</p>
public struct EnableLoggingOutputResponse: Swift.Equatable {
    /// <p>The name of the S3 bucket where the log files are stored.</p>
    public let bucketName: Swift.String?
    /// <p>The message indicating that logs failed to be delivered.</p>
    public let lastFailureMessage: Swift.String?
    /// <p>The last time when logs failed to be delivered.</p>
    public let lastFailureTime: ClientRuntime.Date?
    /// <p>The last time that logs were delivered.</p>
    public let lastSuccessfulDeliveryTime: ClientRuntime.Date?
    /// <p>
    ///             <code>true</code> if logging is on, <code>false</code> if logging is off.</p>
    public let loggingEnabled: Swift.Bool
    /// <p>The prefix applied to the log file names.</p>
    public let s3KeyPrefix: Swift.String?

    public init (
        bucketName: Swift.String? = nil,
        lastFailureMessage: Swift.String? = nil,
        lastFailureTime: ClientRuntime.Date? = nil,
        lastSuccessfulDeliveryTime: ClientRuntime.Date? = nil,
        loggingEnabled: Swift.Bool = false,
        s3KeyPrefix: Swift.String? = nil
    )
    {
        self.bucketName = bucketName
        self.lastFailureMessage = lastFailureMessage
        self.lastFailureTime = lastFailureTime
        self.lastSuccessfulDeliveryTime = lastSuccessfulDeliveryTime
        self.loggingEnabled = loggingEnabled
        self.s3KeyPrefix = s3KeyPrefix
    }
}

struct EnableLoggingOutputResponseBody: Swift.Equatable {
    public let loggingEnabled: Swift.Bool
    public let bucketName: Swift.String?
    public let s3KeyPrefix: Swift.String?
    public let lastSuccessfulDeliveryTime: ClientRuntime.Date?
    public let lastFailureTime: ClientRuntime.Date?
    public let lastFailureMessage: Swift.String?
}

extension EnableLoggingOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName = "BucketName"
        case lastFailureMessage = "LastFailureMessage"
        case lastFailureTime = "LastFailureTime"
        case lastSuccessfulDeliveryTime = "LastSuccessfulDeliveryTime"
        case loggingEnabled = "LoggingEnabled"
        case s3KeyPrefix = "S3KeyPrefix"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("EnableLoggingResult"))
        let loggingEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .loggingEnabled)
        loggingEnabled = loggingEnabledDecoded
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let s3KeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3KeyPrefix)
        s3KeyPrefix = s3KeyPrefixDecoded
        let lastSuccessfulDeliveryTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastSuccessfulDeliveryTime)
        var lastSuccessfulDeliveryTimeBuffer:ClientRuntime.Date? = nil
        if let lastSuccessfulDeliveryTimeDecoded = lastSuccessfulDeliveryTimeDecoded {
            lastSuccessfulDeliveryTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(lastSuccessfulDeliveryTimeDecoded, format: .dateTime)
        }
        lastSuccessfulDeliveryTime = lastSuccessfulDeliveryTimeBuffer
        let lastFailureTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastFailureTime)
        var lastFailureTimeBuffer:ClientRuntime.Date? = nil
        if let lastFailureTimeDecoded = lastFailureTimeDecoded {
            lastFailureTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(lastFailureTimeDecoded, format: .dateTime)
        }
        lastFailureTime = lastFailureTimeBuffer
        let lastFailureMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastFailureMessage)
        lastFailureMessage = lastFailureMessageDecoded
    }
}

public struct EnableSnapshotCopyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "EnableSnapshotCopyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<EnableSnapshotCopyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<EnableSnapshotCopyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<EnableSnapshotCopyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<EnableSnapshotCopyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<EnableSnapshotCopyOutputError>
}

extension EnableSnapshotCopyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnableSnapshotCopyInput(clusterIdentifier: \(Swift.String(describing: clusterIdentifier)), destinationRegion: \(Swift.String(describing: destinationRegion)), manualSnapshotRetentionPeriod: \(Swift.String(describing: manualSnapshotRetentionPeriod)), retentionPeriod: \(Swift.String(describing: retentionPeriod)), snapshotCopyGrantName: \(Swift.String(describing: snapshotCopyGrantName)))"}
}

extension EnableSnapshotCopyInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: ClientRuntime.Key("ClusterIdentifier"))
        }
        if let destinationRegion = destinationRegion {
            try container.encode(destinationRegion, forKey: ClientRuntime.Key("DestinationRegion"))
        }
        if let manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriod {
            try container.encode(manualSnapshotRetentionPeriod, forKey: ClientRuntime.Key("ManualSnapshotRetentionPeriod"))
        }
        if let retentionPeriod = retentionPeriod {
            try container.encode(retentionPeriod, forKey: ClientRuntime.Key("RetentionPeriod"))
        }
        if let snapshotCopyGrantName = snapshotCopyGrantName {
            try container.encode(snapshotCopyGrantName, forKey: ClientRuntime.Key("SnapshotCopyGrantName"))
        }
        try container.encode("EnableSnapshotCopy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct EnableSnapshotCopyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "EnableSnapshotCopyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<EnableSnapshotCopyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<EnableSnapshotCopyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<EnableSnapshotCopyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<EnableSnapshotCopyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<EnableSnapshotCopyOutputError>
}

public struct EnableSnapshotCopyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "EnableSnapshotCopyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<EnableSnapshotCopyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<EnableSnapshotCopyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<EnableSnapshotCopyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<EnableSnapshotCopyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<EnableSnapshotCopyOutputError>
}

/// <p></p>
public struct EnableSnapshotCopyInput: Swift.Equatable {
    /// <p>The unique identifier of the source cluster to copy snapshots from.</p>
    ///         <p>Constraints: Must be the valid name of an existing cluster that does not already
    ///             have cross-region snapshot copy enabled.</p>
    public let clusterIdentifier: Swift.String?
    /// <p>The destination AWS Region that you want to copy snapshots to.</p>
    ///         <p>Constraints: Must be the name of a valid AWS Region. For more information, see
    ///                 <a href="https://docs.aws.amazon.com/general/latest/gr/rande.html#redshift_region">Regions and Endpoints</a> in the Amazon Web Services General Reference.
    ///         </p>
    public let destinationRegion: Swift.String?
    /// <p>The number of days to retain newly copied snapshots in the destination AWS Region
    ///             after they are copied from the source AWS Region. If the value is -1, the manual
    ///             snapshot is retained indefinitely. </p>
    ///         <p>The value must be either -1 or an integer between 1 and 3,653.</p>
    public let manualSnapshotRetentionPeriod: Swift.Int?
    /// <p>The number of days to retain automated snapshots in the destination region after
    ///             they are copied from the source region.</p>
    ///         <p>Default: 7.</p>
    ///         <p>Constraints: Must be at least 1 and no more than 35.</p>
    public let retentionPeriod: Swift.Int?
    /// <p>The name of the snapshot copy grant to use when snapshots of an AWS KMS-encrypted
    ///             cluster are copied to the destination region.</p>
    public let snapshotCopyGrantName: Swift.String?

    public init (
        clusterIdentifier: Swift.String? = nil,
        destinationRegion: Swift.String? = nil,
        manualSnapshotRetentionPeriod: Swift.Int? = nil,
        retentionPeriod: Swift.Int? = nil,
        snapshotCopyGrantName: Swift.String? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
        self.destinationRegion = destinationRegion
        self.manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriod
        self.retentionPeriod = retentionPeriod
        self.snapshotCopyGrantName = snapshotCopyGrantName
    }
}

extension EnableSnapshotCopyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension EnableSnapshotCopyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CopyToRegionDisabledFault" : self = .copyToRegionDisabledFault(try CopyToRegionDisabledFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependentServiceRequestThrottlingFault" : self = .dependentServiceRequestThrottlingFault(try DependentServiceRequestThrottlingFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleOrderableOptions" : self = .incompatibleOrderableOptions(try IncompatibleOrderableOptions(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRetentionPeriodFault" : self = .invalidRetentionPeriodFault(try InvalidRetentionPeriodFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededFault" : self = .limitExceededFault(try LimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotCopyAlreadyEnabledFault" : self = .snapshotCopyAlreadyEnabledFault(try SnapshotCopyAlreadyEnabledFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotCopyGrantNotFoundFault" : self = .snapshotCopyGrantNotFoundFault(try SnapshotCopyGrantNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnknownSnapshotCopyRegionFault" : self = .unknownSnapshotCopyRegionFault(try UnknownSnapshotCopyRegionFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum EnableSnapshotCopyOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case copyToRegionDisabledFault(CopyToRegionDisabledFault)
    case dependentServiceRequestThrottlingFault(DependentServiceRequestThrottlingFault)
    case incompatibleOrderableOptions(IncompatibleOrderableOptions)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidRetentionPeriodFault(InvalidRetentionPeriodFault)
    case limitExceededFault(LimitExceededFault)
    case snapshotCopyAlreadyEnabledFault(SnapshotCopyAlreadyEnabledFault)
    case snapshotCopyGrantNotFoundFault(SnapshotCopyGrantNotFoundFault)
    case unauthorizedOperation(UnauthorizedOperation)
    case unknownSnapshotCopyRegionFault(UnknownSnapshotCopyRegionFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableSnapshotCopyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnableSnapshotCopyOutputResponse(cluster: \(Swift.String(describing: cluster)))"}
}

extension EnableSnapshotCopyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: EnableSnapshotCopyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct EnableSnapshotCopyOutputResponse: Swift.Equatable {
    /// <p>Describes a cluster.</p>
    public let cluster: RedshiftClientTypes.Cluster?

    public init (
        cluster: RedshiftClientTypes.Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct EnableSnapshotCopyOutputResponseBody: Swift.Equatable {
    public let cluster: RedshiftClientTypes.Cluster?
}

extension EnableSnapshotCopyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cluster = "Cluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("EnableSnapshotCopyResult"))
        let clusterDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

extension RedshiftClientTypes.Endpoint: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
        case port = "Port"
        case vpcEndpoints = "VpcEndpoints"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let address = address {
            try container.encode(address, forKey: ClientRuntime.Key("Address"))
        }
        if port != 0 {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
        if let vpcEndpoints = vpcEndpoints {
            var vpcEndpointsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcEndpoints"))
            for (index0, vpcendpoint0) in vpcEndpoints.enumerated() {
                try vpcEndpointsContainer.encode(vpcendpoint0, forKey: ClientRuntime.Key("VpcEndpoint.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .address)
        address = addressDecoded
        let portDecoded = try containerValues.decode(Swift.Int.self, forKey: .port)
        port = portDecoded
        if containerValues.contains(.vpcEndpoints) {
            struct KeyVal0{struct VpcEndpoint{}}
            let vpcEndpointsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.VpcEndpoint>.CodingKeys.self, forKey: .vpcEndpoints)
            if let vpcEndpointsWrappedContainer = vpcEndpointsWrappedContainer {
                let vpcEndpointsContainer = try vpcEndpointsWrappedContainer.decodeIfPresent([RedshiftClientTypes.VpcEndpoint].self, forKey: .member)
                var vpcEndpointsBuffer:[RedshiftClientTypes.VpcEndpoint]? = nil
                if let vpcEndpointsContainer = vpcEndpointsContainer {
                    vpcEndpointsBuffer = [RedshiftClientTypes.VpcEndpoint]()
                    for structureContainer0 in vpcEndpointsContainer {
                        vpcEndpointsBuffer?.append(structureContainer0)
                    }
                }
                vpcEndpoints = vpcEndpointsBuffer
            } else {
                vpcEndpoints = []
            }
        } else {
            vpcEndpoints = nil
        }
    }
}

extension RedshiftClientTypes.Endpoint: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Endpoint(address: \(Swift.String(describing: address)), port: \(Swift.String(describing: port)), vpcEndpoints: \(Swift.String(describing: vpcEndpoints)))"}
}

extension RedshiftClientTypes {
    /// <p>Describes a connection endpoint.</p>
    public struct Endpoint: Swift.Equatable {
        /// <p>The DNS address of the Cluster.</p>
        public let address: Swift.String?
        /// <p>The port that the database engine is listening on.</p>
        public let port: Swift.Int
        /// <p>Describes a connection endpoint.</p>
        public let vpcEndpoints: [RedshiftClientTypes.VpcEndpoint]?

        public init (
            address: Swift.String? = nil,
            port: Swift.Int = 0,
            vpcEndpoints: [RedshiftClientTypes.VpcEndpoint]? = nil
        )
        {
            self.address = address
            self.port = port
            self.vpcEndpoints = vpcEndpoints
        }
    }

}

extension RedshiftClientTypes.EndpointAccess: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
        case clusterIdentifier = "ClusterIdentifier"
        case endpointCreateTime = "EndpointCreateTime"
        case endpointName = "EndpointName"
        case endpointStatus = "EndpointStatus"
        case port = "Port"
        case resourceOwner = "ResourceOwner"
        case subnetGroupName = "SubnetGroupName"
        case vpcEndpoint = "VpcEndpoint"
        case vpcSecurityGroups = "VpcSecurityGroups"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let address = address {
            try container.encode(address, forKey: ClientRuntime.Key("Address"))
        }
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: ClientRuntime.Key("ClusterIdentifier"))
        }
        if let endpointCreateTime = endpointCreateTime {
            try container.encode(ClientRuntime.TimestampWrapper(endpointCreateTime, format: .dateTime), forKey: ClientRuntime.Key("endpointCreateTime"))
        }
        if let endpointName = endpointName {
            try container.encode(endpointName, forKey: ClientRuntime.Key("EndpointName"))
        }
        if let endpointStatus = endpointStatus {
            try container.encode(endpointStatus, forKey: ClientRuntime.Key("EndpointStatus"))
        }
        if port != 0 {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
        if let resourceOwner = resourceOwner {
            try container.encode(resourceOwner, forKey: ClientRuntime.Key("ResourceOwner"))
        }
        if let subnetGroupName = subnetGroupName {
            try container.encode(subnetGroupName, forKey: ClientRuntime.Key("SubnetGroupName"))
        }
        if let vpcEndpoint = vpcEndpoint {
            try container.encode(vpcEndpoint, forKey: ClientRuntime.Key("VpcEndpoint"))
        }
        if let vpcSecurityGroups = vpcSecurityGroups {
            var vpcSecurityGroupsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSecurityGroups"))
            for (index0, vpcsecuritygroupmembership0) in vpcSecurityGroups.enumerated() {
                try vpcSecurityGroupsContainer.encode(vpcsecuritygroupmembership0, forKey: ClientRuntime.Key("VpcSecurityGroup.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let resourceOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceOwner)
        resourceOwner = resourceOwnerDecoded
        let subnetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetGroupName)
        subnetGroupName = subnetGroupNameDecoded
        let endpointStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointStatus)
        endpointStatus = endpointStatusDecoded
        let endpointNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointName)
        endpointName = endpointNameDecoded
        let endpointCreateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointCreateTime)
        var endpointCreateTimeBuffer:ClientRuntime.Date? = nil
        if let endpointCreateTimeDecoded = endpointCreateTimeDecoded {
            endpointCreateTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(endpointCreateTimeDecoded, format: .dateTime)
        }
        endpointCreateTime = endpointCreateTimeBuffer
        let portDecoded = try containerValues.decode(Swift.Int.self, forKey: .port)
        port = portDecoded
        let addressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .address)
        address = addressDecoded
        if containerValues.contains(.vpcSecurityGroups) {
            struct KeyVal0{struct VpcSecurityGroup{}}
            let vpcSecurityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.VpcSecurityGroup>.CodingKeys.self, forKey: .vpcSecurityGroups)
            if let vpcSecurityGroupsWrappedContainer = vpcSecurityGroupsWrappedContainer {
                let vpcSecurityGroupsContainer = try vpcSecurityGroupsWrappedContainer.decodeIfPresent([RedshiftClientTypes.VpcSecurityGroupMembership].self, forKey: .member)
                var vpcSecurityGroupsBuffer:[RedshiftClientTypes.VpcSecurityGroupMembership]? = nil
                if let vpcSecurityGroupsContainer = vpcSecurityGroupsContainer {
                    vpcSecurityGroupsBuffer = [RedshiftClientTypes.VpcSecurityGroupMembership]()
                    for structureContainer0 in vpcSecurityGroupsContainer {
                        vpcSecurityGroupsBuffer?.append(structureContainer0)
                    }
                }
                vpcSecurityGroups = vpcSecurityGroupsBuffer
            } else {
                vpcSecurityGroups = []
            }
        } else {
            vpcSecurityGroups = nil
        }
        let vpcEndpointDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.VpcEndpoint.self, forKey: .vpcEndpoint)
        vpcEndpoint = vpcEndpointDecoded
    }
}

extension RedshiftClientTypes.EndpointAccess: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EndpointAccess(address: \(Swift.String(describing: address)), clusterIdentifier: \(Swift.String(describing: clusterIdentifier)), endpointCreateTime: \(Swift.String(describing: endpointCreateTime)), endpointName: \(Swift.String(describing: endpointName)), endpointStatus: \(Swift.String(describing: endpointStatus)), port: \(Swift.String(describing: port)), resourceOwner: \(Swift.String(describing: resourceOwner)), subnetGroupName: \(Swift.String(describing: subnetGroupName)), vpcEndpoint: \(Swift.String(describing: vpcEndpoint)), vpcSecurityGroups: \(Swift.String(describing: vpcSecurityGroups)))"}
}

extension RedshiftClientTypes {
    /// <p>Describes a Redshift-managed VPC endpoint.</p>
    public struct EndpointAccess: Swift.Equatable {
        /// <p>The DNS address of the endpoint.</p>
        public let address: Swift.String?
        /// <p>The cluster identifier of the cluster associated with the endpoint.</p>
        public let clusterIdentifier: Swift.String?
        /// <p>The time (UTC) that the endpoint was created.</p>
        public let endpointCreateTime: ClientRuntime.Date?
        /// <p>The name of the endpoint.</p>
        public let endpointName: Swift.String?
        /// <p>The status of the endpoint.</p>
        public let endpointStatus: Swift.String?
        /// <p>The port number on which the cluster accepts incoming connections.</p>
        public let port: Swift.Int
        /// <p>The AWS account ID of the owner of the cluster.</p>
        public let resourceOwner: Swift.String?
        /// <p>The subnet group name where Amazon Redshift chooses to deploy the endpoint.</p>
        public let subnetGroupName: Swift.String?
        /// <p>The connection endpoint for connecting to an Amazon Redshift cluster through the proxy.</p>
        public let vpcEndpoint: RedshiftClientTypes.VpcEndpoint?
        /// <p>The security groups associated with the endpoint.</p>
        public let vpcSecurityGroups: [RedshiftClientTypes.VpcSecurityGroupMembership]?

        public init (
            address: Swift.String? = nil,
            clusterIdentifier: Swift.String? = nil,
            endpointCreateTime: ClientRuntime.Date? = nil,
            endpointName: Swift.String? = nil,
            endpointStatus: Swift.String? = nil,
            port: Swift.Int = 0,
            resourceOwner: Swift.String? = nil,
            subnetGroupName: Swift.String? = nil,
            vpcEndpoint: RedshiftClientTypes.VpcEndpoint? = nil,
            vpcSecurityGroups: [RedshiftClientTypes.VpcSecurityGroupMembership]? = nil
        )
        {
            self.address = address
            self.clusterIdentifier = clusterIdentifier
            self.endpointCreateTime = endpointCreateTime
            self.endpointName = endpointName
            self.endpointStatus = endpointStatus
            self.port = port
            self.resourceOwner = resourceOwner
            self.subnetGroupName = subnetGroupName
            self.vpcEndpoint = vpcEndpoint
            self.vpcSecurityGroups = vpcSecurityGroups
        }
    }

}

extension EndpointAlreadyExistsFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EndpointAlreadyExistsFault(message: \(Swift.String(describing: message)))"}
}

extension EndpointAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<EndpointAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The account already has a Redshift-managed VPC endpoint with the given identifier.</p>
public struct EndpointAlreadyExistsFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct EndpointAlreadyExistsFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension EndpointAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RedshiftClientTypes.EndpointAuthorization: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedAllVPCs = "AllowedAllVPCs"
        case allowedVPCs = "AllowedVPCs"
        case authorizeTime = "AuthorizeTime"
        case clusterIdentifier = "ClusterIdentifier"
        case clusterStatus = "ClusterStatus"
        case endpointCount = "EndpointCount"
        case grantee = "Grantee"
        case grantor = "Grantor"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if allowedAllVPCs != false {
            try container.encode(allowedAllVPCs, forKey: ClientRuntime.Key("AllowedAllVPCs"))
        }
        if let allowedVPCs = allowedVPCs {
            var allowedVPCsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AllowedVPCs"))
            for (index0, string0) in allowedVPCs.enumerated() {
                try allowedVPCsContainer.encode(string0, forKey: ClientRuntime.Key("VpcIdentifier.\(index0.advanced(by: 1))"))
            }
        }
        if let authorizeTime = authorizeTime {
            try container.encode(ClientRuntime.TimestampWrapper(authorizeTime, format: .dateTime), forKey: ClientRuntime.Key("authorizeTime"))
        }
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: ClientRuntime.Key("ClusterIdentifier"))
        }
        if let clusterStatus = clusterStatus {
            try container.encode(clusterStatus, forKey: ClientRuntime.Key("ClusterStatus"))
        }
        if endpointCount != 0 {
            try container.encode(endpointCount, forKey: ClientRuntime.Key("EndpointCount"))
        }
        if let grantee = grantee {
            try container.encode(grantee, forKey: ClientRuntime.Key("Grantee"))
        }
        if let grantor = grantor {
            try container.encode(grantor, forKey: ClientRuntime.Key("Grantor"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .grantor)
        grantor = grantorDecoded
        let granteeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .grantee)
        grantee = granteeDecoded
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let authorizeTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizeTime)
        var authorizeTimeBuffer:ClientRuntime.Date? = nil
        if let authorizeTimeDecoded = authorizeTimeDecoded {
            authorizeTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(authorizeTimeDecoded, format: .dateTime)
        }
        authorizeTime = authorizeTimeBuffer
        let clusterStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterStatus)
        clusterStatus = clusterStatusDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.AuthorizationStatus.self, forKey: .status)
        status = statusDecoded
        let allowedAllVPCsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .allowedAllVPCs)
        allowedAllVPCs = allowedAllVPCsDecoded
        if containerValues.contains(.allowedVPCs) {
            struct KeyVal0{struct VpcIdentifier{}}
            let allowedVPCsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.VpcIdentifier>.CodingKeys.self, forKey: .allowedVPCs)
            if let allowedVPCsWrappedContainer = allowedVPCsWrappedContainer {
                let allowedVPCsContainer = try allowedVPCsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var allowedVPCsBuffer:[Swift.String]? = nil
                if let allowedVPCsContainer = allowedVPCsContainer {
                    allowedVPCsBuffer = [Swift.String]()
                    for stringContainer0 in allowedVPCsContainer {
                        allowedVPCsBuffer?.append(stringContainer0)
                    }
                }
                allowedVPCs = allowedVPCsBuffer
            } else {
                allowedVPCs = []
            }
        } else {
            allowedVPCs = nil
        }
        let endpointCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .endpointCount)
        endpointCount = endpointCountDecoded
    }
}

extension RedshiftClientTypes.EndpointAuthorization: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EndpointAuthorization(allowedAllVPCs: \(Swift.String(describing: allowedAllVPCs)), allowedVPCs: \(Swift.String(describing: allowedVPCs)), authorizeTime: \(Swift.String(describing: authorizeTime)), clusterIdentifier: \(Swift.String(describing: clusterIdentifier)), clusterStatus: \(Swift.String(describing: clusterStatus)), endpointCount: \(Swift.String(describing: endpointCount)), grantee: \(Swift.String(describing: grantee)), grantor: \(Swift.String(describing: grantor)), status: \(Swift.String(describing: status)))"}
}

extension RedshiftClientTypes {
    /// <p>Describes an endpoint authorization for authorizing Redshift-managed VPC endpoint access to a cluster across AWS accounts.</p>
    public struct EndpointAuthorization: Swift.Equatable {
        /// <p>Indicates whether all VPCs in the grantee account are allowed access to the cluster.</p>
        public let allowedAllVPCs: Swift.Bool
        /// <p>The VPCs allowed access to the cluster.</p>
        public let allowedVPCs: [Swift.String]?
        /// <p>The time (UTC) when the authorization was created.</p>
        public let authorizeTime: ClientRuntime.Date?
        /// <p>The cluster identifier.</p>
        public let clusterIdentifier: Swift.String?
        /// <p>The status of the cluster.</p>
        public let clusterStatus: Swift.String?
        /// <p>The number of Redshift-managed VPC endpoints created for the authorization.</p>
        public let endpointCount: Swift.Int
        /// <p>The AWS account ID of the grantee of the cluster.</p>
        public let grantee: Swift.String?
        /// <p>The AWS account ID of the cluster owner.</p>
        public let grantor: Swift.String?
        /// <p>The status of the authorization action.</p>
        public let status: RedshiftClientTypes.AuthorizationStatus?

        public init (
            allowedAllVPCs: Swift.Bool = false,
            allowedVPCs: [Swift.String]? = nil,
            authorizeTime: ClientRuntime.Date? = nil,
            clusterIdentifier: Swift.String? = nil,
            clusterStatus: Swift.String? = nil,
            endpointCount: Swift.Int = 0,
            grantee: Swift.String? = nil,
            grantor: Swift.String? = nil,
            status: RedshiftClientTypes.AuthorizationStatus? = nil
        )
        {
            self.allowedAllVPCs = allowedAllVPCs
            self.allowedVPCs = allowedVPCs
            self.authorizeTime = authorizeTime
            self.clusterIdentifier = clusterIdentifier
            self.clusterStatus = clusterStatus
            self.endpointCount = endpointCount
            self.grantee = grantee
            self.grantor = grantor
            self.status = status
        }
    }

}

extension EndpointAuthorizationAlreadyExistsFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EndpointAuthorizationAlreadyExistsFault(message: \(Swift.String(describing: message)))"}
}

extension EndpointAuthorizationAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<EndpointAuthorizationAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The authorization already exists for this endpoint.</p>
public struct EndpointAuthorizationAlreadyExistsFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct EndpointAuthorizationAlreadyExistsFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension EndpointAuthorizationAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EndpointAuthorizationNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EndpointAuthorizationNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension EndpointAuthorizationNotFoundFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<EndpointAuthorizationNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The authorization for this endpoint can't be found.</p>
public struct EndpointAuthorizationNotFoundFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct EndpointAuthorizationNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension EndpointAuthorizationNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EndpointAuthorizationsPerClusterLimitExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EndpointAuthorizationsPerClusterLimitExceededFault(message: \(Swift.String(describing: message)))"}
}

extension EndpointAuthorizationsPerClusterLimitExceededFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<EndpointAuthorizationsPerClusterLimitExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of endpoint authorizations per cluster has exceeded its limit.</p>
public struct EndpointAuthorizationsPerClusterLimitExceededFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct EndpointAuthorizationsPerClusterLimitExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension EndpointAuthorizationsPerClusterLimitExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EndpointNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EndpointNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension EndpointNotFoundFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<EndpointNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The endpoint name doesn't refer to an existing endpoint.</p>
public struct EndpointNotFoundFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct EndpointNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension EndpointNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EndpointsPerAuthorizationLimitExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EndpointsPerAuthorizationLimitExceededFault(message: \(Swift.String(describing: message)))"}
}

extension EndpointsPerAuthorizationLimitExceededFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<EndpointsPerAuthorizationLimitExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of Redshift-managed VPC endpoints per authorization has exceeded its limit.</p>
public struct EndpointsPerAuthorizationLimitExceededFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct EndpointsPerAuthorizationLimitExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension EndpointsPerAuthorizationLimitExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EndpointsPerClusterLimitExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EndpointsPerClusterLimitExceededFault(message: \(Swift.String(describing: message)))"}
}

extension EndpointsPerClusterLimitExceededFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<EndpointsPerClusterLimitExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of Redshift-managed VPC endpoints per cluster has exceeded its limit.</p>
public struct EndpointsPerClusterLimitExceededFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct EndpointsPerClusterLimitExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension EndpointsPerClusterLimitExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RedshiftClientTypes.Event: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case date = "Date"
        case eventCategories = "EventCategories"
        case eventId = "EventId"
        case message = "Message"
        case severity = "Severity"
        case sourceIdentifier = "SourceIdentifier"
        case sourceType = "SourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let date = date {
            try container.encode(ClientRuntime.TimestampWrapper(date, format: .dateTime), forKey: ClientRuntime.Key("date"))
        }
        if let eventCategories = eventCategories {
            var eventCategoriesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EventCategories"))
            for (index0, string0) in eventCategories.enumerated() {
                try eventCategoriesContainer.encode(string0, forKey: ClientRuntime.Key("EventCategory.\(index0.advanced(by: 1))"))
            }
        }
        if let eventId = eventId {
            try container.encode(eventId, forKey: ClientRuntime.Key("EventId"))
        }
        if let message = message {
            try container.encode(message, forKey: ClientRuntime.Key("Message"))
        }
        if let severity = severity {
            try container.encode(severity, forKey: ClientRuntime.Key("Severity"))
        }
        if let sourceIdentifier = sourceIdentifier {
            try container.encode(sourceIdentifier, forKey: ClientRuntime.Key("SourceIdentifier"))
        }
        if let sourceType = sourceType {
            try container.encode(sourceType, forKey: ClientRuntime.Key("SourceType"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceIdentifier)
        sourceIdentifier = sourceIdentifierDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.SourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        if containerValues.contains(.eventCategories) {
            struct KeyVal0{struct EventCategory{}}
            let eventCategoriesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.EventCategory>.CodingKeys.self, forKey: .eventCategories)
            if let eventCategoriesWrappedContainer = eventCategoriesWrappedContainer {
                let eventCategoriesContainer = try eventCategoriesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var eventCategoriesBuffer:[Swift.String]? = nil
                if let eventCategoriesContainer = eventCategoriesContainer {
                    eventCategoriesBuffer = [Swift.String]()
                    for stringContainer0 in eventCategoriesContainer {
                        eventCategoriesBuffer?.append(stringContainer0)
                    }
                }
                eventCategories = eventCategoriesBuffer
            } else {
                eventCategories = []
            }
        } else {
            eventCategories = nil
        }
        let severityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .severity)
        severity = severityDecoded
        let dateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .date)
        var dateBuffer:ClientRuntime.Date? = nil
        if let dateDecoded = dateDecoded {
            dateBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(dateDecoded, format: .dateTime)
        }
        date = dateBuffer
        let eventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventId)
        eventId = eventIdDecoded
    }
}

extension RedshiftClientTypes.Event: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Event(date: \(Swift.String(describing: date)), eventCategories: \(Swift.String(describing: eventCategories)), eventId: \(Swift.String(describing: eventId)), message: \(Swift.String(describing: message)), severity: \(Swift.String(describing: severity)), sourceIdentifier: \(Swift.String(describing: sourceIdentifier)), sourceType: \(Swift.String(describing: sourceType)))"}
}

extension RedshiftClientTypes {
    /// <p>Describes an event.</p>
    public struct Event: Swift.Equatable {
        /// <p>The date and time of the event.</p>
        public let date: ClientRuntime.Date?
        /// <p>A list of the event categories.</p>
        ///         <p>Values: Configuration, Management, Monitoring, Security</p>
        public let eventCategories: [Swift.String]?
        /// <p>The identifier of the event.</p>
        public let eventId: Swift.String?
        /// <p>The text of this event.</p>
        public let message: Swift.String?
        /// <p>The severity of the event.</p>
        ///         <p>Values: ERROR, INFO</p>
        public let severity: Swift.String?
        /// <p>The identifier for the source of the event.</p>
        public let sourceIdentifier: Swift.String?
        /// <p>The source type for this event.</p>
        public let sourceType: RedshiftClientTypes.SourceType?

        public init (
            date: ClientRuntime.Date? = nil,
            eventCategories: [Swift.String]? = nil,
            eventId: Swift.String? = nil,
            message: Swift.String? = nil,
            severity: Swift.String? = nil,
            sourceIdentifier: Swift.String? = nil,
            sourceType: RedshiftClientTypes.SourceType? = nil
        )
        {
            self.date = date
            self.eventCategories = eventCategories
            self.eventId = eventId
            self.message = message
            self.severity = severity
            self.sourceIdentifier = sourceIdentifier
            self.sourceType = sourceType
        }
    }

}

extension RedshiftClientTypes.EventCategoriesMap: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events = "Events"
        case sourceType = "SourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let events = events {
            var eventsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Events"))
            for (index0, eventinfomap0) in events.enumerated() {
                try eventsContainer.encode(eventinfomap0, forKey: ClientRuntime.Key("EventInfoMap.\(index0.advanced(by: 1))"))
            }
        }
        if let sourceType = sourceType {
            try container.encode(sourceType, forKey: ClientRuntime.Key("SourceType"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        if containerValues.contains(.events) {
            struct KeyVal0{struct EventInfoMap{}}
            let eventsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.EventInfoMap>.CodingKeys.self, forKey: .events)
            if let eventsWrappedContainer = eventsWrappedContainer {
                let eventsContainer = try eventsWrappedContainer.decodeIfPresent([RedshiftClientTypes.EventInfoMap].self, forKey: .member)
                var eventsBuffer:[RedshiftClientTypes.EventInfoMap]? = nil
                if let eventsContainer = eventsContainer {
                    eventsBuffer = [RedshiftClientTypes.EventInfoMap]()
                    for structureContainer0 in eventsContainer {
                        eventsBuffer?.append(structureContainer0)
                    }
                }
                events = eventsBuffer
            } else {
                events = []
            }
        } else {
            events = nil
        }
    }
}

extension RedshiftClientTypes.EventCategoriesMap: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EventCategoriesMap(events: \(Swift.String(describing: events)), sourceType: \(Swift.String(describing: sourceType)))"}
}

extension RedshiftClientTypes {
    /// <p>Describes event categories.</p>
    public struct EventCategoriesMap: Swift.Equatable {
        /// <p>The events in the event category.</p>
        public let events: [RedshiftClientTypes.EventInfoMap]?
        /// <p>The source type, such as cluster or cluster-snapshot, that the returned categories
        ///             belong to.</p>
        public let sourceType: Swift.String?

        public init (
            events: [RedshiftClientTypes.EventInfoMap]? = nil,
            sourceType: Swift.String? = nil
        )
        {
            self.events = events
            self.sourceType = sourceType
        }
    }

}

extension RedshiftClientTypes.EventInfoMap: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventCategories = "EventCategories"
        case eventDescription = "EventDescription"
        case eventId = "EventId"
        case severity = "Severity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let eventCategories = eventCategories {
            var eventCategoriesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EventCategories"))
            for (index0, string0) in eventCategories.enumerated() {
                try eventCategoriesContainer.encode(string0, forKey: ClientRuntime.Key("EventCategory.\(index0.advanced(by: 1))"))
            }
        }
        if let eventDescription = eventDescription {
            try container.encode(eventDescription, forKey: ClientRuntime.Key("EventDescription"))
        }
        if let eventId = eventId {
            try container.encode(eventId, forKey: ClientRuntime.Key("EventId"))
        }
        if let severity = severity {
            try container.encode(severity, forKey: ClientRuntime.Key("Severity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventId)
        eventId = eventIdDecoded
        if containerValues.contains(.eventCategories) {
            struct KeyVal0{struct EventCategory{}}
            let eventCategoriesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.EventCategory>.CodingKeys.self, forKey: .eventCategories)
            if let eventCategoriesWrappedContainer = eventCategoriesWrappedContainer {
                let eventCategoriesContainer = try eventCategoriesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var eventCategoriesBuffer:[Swift.String]? = nil
                if let eventCategoriesContainer = eventCategoriesContainer {
                    eventCategoriesBuffer = [Swift.String]()
                    for stringContainer0 in eventCategoriesContainer {
                        eventCategoriesBuffer?.append(stringContainer0)
                    }
                }
                eventCategories = eventCategoriesBuffer
            } else {
                eventCategories = []
            }
        } else {
            eventCategories = nil
        }
        let eventDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventDescription)
        eventDescription = eventDescriptionDecoded
        let severityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .severity)
        severity = severityDecoded
    }
}

extension RedshiftClientTypes.EventInfoMap: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EventInfoMap(eventCategories: \(Swift.String(describing: eventCategories)), eventDescription: \(Swift.String(describing: eventDescription)), eventId: \(Swift.String(describing: eventId)), severity: \(Swift.String(describing: severity)))"}
}

extension RedshiftClientTypes {
    /// <p>Describes event information.</p>
    public struct EventInfoMap: Swift.Equatable {
        /// <p>The category of an Amazon Redshift event.</p>
        public let eventCategories: [Swift.String]?
        /// <p>The description of an Amazon Redshift event.</p>
        public let eventDescription: Swift.String?
        /// <p>The identifier of an Amazon Redshift event.</p>
        public let eventId: Swift.String?
        /// <p>The severity of the event.</p>
        ///         <p>Values: ERROR, INFO</p>
        public let severity: Swift.String?

        public init (
            eventCategories: [Swift.String]? = nil,
            eventDescription: Swift.String? = nil,
            eventId: Swift.String? = nil,
            severity: Swift.String? = nil
        )
        {
            self.eventCategories = eventCategories
            self.eventDescription = eventDescription
            self.eventId = eventId
            self.severity = severity
        }
    }

}

extension RedshiftClientTypes.EventSubscription: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case custSubscriptionId = "CustSubscriptionId"
        case customerAwsId = "CustomerAwsId"
        case enabled = "Enabled"
        case eventCategoriesList = "EventCategoriesList"
        case severity = "Severity"
        case snsTopicArn = "SnsTopicArn"
        case sourceIdsList = "SourceIdsList"
        case sourceType = "SourceType"
        case status = "Status"
        case subscriptionCreationTime = "SubscriptionCreationTime"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let custSubscriptionId = custSubscriptionId {
            try container.encode(custSubscriptionId, forKey: ClientRuntime.Key("CustSubscriptionId"))
        }
        if let customerAwsId = customerAwsId {
            try container.encode(customerAwsId, forKey: ClientRuntime.Key("CustomerAwsId"))
        }
        if enabled != false {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let eventCategoriesList = eventCategoriesList {
            var eventCategoriesListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EventCategoriesList"))
            for (index0, string0) in eventCategoriesList.enumerated() {
                try eventCategoriesListContainer.encode(string0, forKey: ClientRuntime.Key("EventCategory.\(index0.advanced(by: 1))"))
            }
        }
        if let severity = severity {
            try container.encode(severity, forKey: ClientRuntime.Key("Severity"))
        }
        if let snsTopicArn = snsTopicArn {
            try container.encode(snsTopicArn, forKey: ClientRuntime.Key("SnsTopicArn"))
        }
        if let sourceIdsList = sourceIdsList {
            var sourceIdsListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SourceIdsList"))
            for (index0, string0) in sourceIdsList.enumerated() {
                try sourceIdsListContainer.encode(string0, forKey: ClientRuntime.Key("SourceId.\(index0.advanced(by: 1))"))
            }
        }
        if let sourceType = sourceType {
            try container.encode(sourceType, forKey: ClientRuntime.Key("SourceType"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let subscriptionCreationTime = subscriptionCreationTime {
            try container.encode(ClientRuntime.TimestampWrapper(subscriptionCreationTime, format: .dateTime), forKey: ClientRuntime.Key("subscriptionCreationTime"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customerAwsIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerAwsId)
        customerAwsId = customerAwsIdDecoded
        let custSubscriptionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .custSubscriptionId)
        custSubscriptionId = custSubscriptionIdDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let subscriptionCreationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionCreationTime)
        var subscriptionCreationTimeBuffer:ClientRuntime.Date? = nil
        if let subscriptionCreationTimeDecoded = subscriptionCreationTimeDecoded {
            subscriptionCreationTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(subscriptionCreationTimeDecoded, format: .dateTime)
        }
        subscriptionCreationTime = subscriptionCreationTimeBuffer
        let sourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        if containerValues.contains(.sourceIdsList) {
            struct KeyVal0{struct SourceId{}}
            let sourceIdsListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.SourceId>.CodingKeys.self, forKey: .sourceIdsList)
            if let sourceIdsListWrappedContainer = sourceIdsListWrappedContainer {
                let sourceIdsListContainer = try sourceIdsListWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var sourceIdsListBuffer:[Swift.String]? = nil
                if let sourceIdsListContainer = sourceIdsListContainer {
                    sourceIdsListBuffer = [Swift.String]()
                    for stringContainer0 in sourceIdsListContainer {
                        sourceIdsListBuffer?.append(stringContainer0)
                    }
                }
                sourceIdsList = sourceIdsListBuffer
            } else {
                sourceIdsList = []
            }
        } else {
            sourceIdsList = nil
        }
        if containerValues.contains(.eventCategoriesList) {
            struct KeyVal0{struct EventCategory{}}
            let eventCategoriesListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.EventCategory>.CodingKeys.self, forKey: .eventCategoriesList)
            if let eventCategoriesListWrappedContainer = eventCategoriesListWrappedContainer {
                let eventCategoriesListContainer = try eventCategoriesListWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var eventCategoriesListBuffer:[Swift.String]? = nil
                if let eventCategoriesListContainer = eventCategoriesListContainer {
                    eventCategoriesListBuffer = [Swift.String]()
                    for stringContainer0 in eventCategoriesListContainer {
                        eventCategoriesListBuffer?.append(stringContainer0)
                    }
                }
                eventCategoriesList = eventCategoriesListBuffer
            } else {
                eventCategoriesList = []
            }
        } else {
            eventCategoriesList = nil
        }
        let severityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .severity)
        severity = severityDecoded
        let enabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([RedshiftClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[RedshiftClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [RedshiftClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension RedshiftClientTypes.EventSubscription: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EventSubscription(custSubscriptionId: \(Swift.String(describing: custSubscriptionId)), customerAwsId: \(Swift.String(describing: customerAwsId)), enabled: \(Swift.String(describing: enabled)), eventCategoriesList: \(Swift.String(describing: eventCategoriesList)), severity: \(Swift.String(describing: severity)), snsTopicArn: \(Swift.String(describing: snsTopicArn)), sourceIdsList: \(Swift.String(describing: sourceIdsList)), sourceType: \(Swift.String(describing: sourceType)), status: \(Swift.String(describing: status)), subscriptionCreationTime: \(Swift.String(describing: subscriptionCreationTime)), tags: \(Swift.String(describing: tags)))"}
}

extension RedshiftClientTypes {
    /// <p>Describes event subscriptions.</p>
    public struct EventSubscription: Swift.Equatable {
        /// <p>The name of the Amazon Redshift event notification subscription.</p>
        public let custSubscriptionId: Swift.String?
        /// <p>The AWS customer account associated with the Amazon Redshift event notification
        ///             subscription.</p>
        public let customerAwsId: Swift.String?
        /// <p>A boolean value indicating whether the subscription is enabled; <code>true</code>
        ///             indicates that the subscription is enabled.</p>
        public let enabled: Swift.Bool
        /// <p>The list of Amazon Redshift event categories specified in the event notification
        ///             subscription.</p>
        ///         <p>Values: Configuration, Management, Monitoring, Security</p>
        public let eventCategoriesList: [Swift.String]?
        /// <p>The event severity specified in the Amazon Redshift event notification
        ///             subscription.</p>
        ///         <p>Values: ERROR, INFO</p>
        public let severity: Swift.String?
        /// <p>The Amazon Resource Name (ARN) of the Amazon SNS topic used by the event
        ///             notification subscription.</p>
        public let snsTopicArn: Swift.String?
        /// <p>A list of the sources that publish events to the Amazon Redshift event notification
        ///             subscription.</p>
        public let sourceIdsList: [Swift.String]?
        /// <p>The source type of the events returned by the Amazon Redshift event notification, such as
        ///             cluster, cluster-snapshot, cluster-parameter-group, cluster-security-group, or scheduled-action. </p>
        public let sourceType: Swift.String?
        /// <p>The status of the Amazon Redshift event notification subscription.</p>
        ///         <p>Constraints:</p>
        ///         <ul>
        ///             <li>
        ///                 <p>Can be one of the following: active | no-permission |
        ///                     topic-not-exist</p>
        ///             </li>
        ///             <li>
        ///                 <p>The status "no-permission" indicates that Amazon Redshift no longer has
        ///                     permission to post to the Amazon SNS topic. The status "topic-not-exist"
        ///                     indicates that the topic was deleted after the subscription was
        ///                     created.</p>
        ///             </li>
        ///          </ul>
        public let status: Swift.String?
        /// <p>The date and time the Amazon Redshift event notification subscription was
        ///             created.</p>
        public let subscriptionCreationTime: ClientRuntime.Date?
        /// <p>The list of tags for the event subscription.</p>
        public let tags: [RedshiftClientTypes.Tag]?

        public init (
            custSubscriptionId: Swift.String? = nil,
            customerAwsId: Swift.String? = nil,
            enabled: Swift.Bool = false,
            eventCategoriesList: [Swift.String]? = nil,
            severity: Swift.String? = nil,
            snsTopicArn: Swift.String? = nil,
            sourceIdsList: [Swift.String]? = nil,
            sourceType: Swift.String? = nil,
            status: Swift.String? = nil,
            subscriptionCreationTime: ClientRuntime.Date? = nil,
            tags: [RedshiftClientTypes.Tag]? = nil
        )
        {
            self.custSubscriptionId = custSubscriptionId
            self.customerAwsId = customerAwsId
            self.enabled = enabled
            self.eventCategoriesList = eventCategoriesList
            self.severity = severity
            self.snsTopicArn = snsTopicArn
            self.sourceIdsList = sourceIdsList
            self.sourceType = sourceType
            self.status = status
            self.subscriptionCreationTime = subscriptionCreationTime
            self.tags = tags
        }
    }

}

extension EventSubscriptionQuotaExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EventSubscriptionQuotaExceededFault(message: \(Swift.String(describing: message)))"}
}

extension EventSubscriptionQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<EventSubscriptionQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request would exceed the allowed number of event subscriptions for this
///             account.
/// For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a>
/// in the <i>Amazon Redshift Cluster Management Guide</i>.
/// </p>
public struct EventSubscriptionQuotaExceededFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct EventSubscriptionQuotaExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension EventSubscriptionQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct GetClusterCredentialsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetClusterCredentialsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetClusterCredentialsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetClusterCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetClusterCredentialsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetClusterCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetClusterCredentialsOutputError>
}

extension GetClusterCredentialsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetClusterCredentialsInput(autoCreate: \(Swift.String(describing: autoCreate)), clusterIdentifier: \(Swift.String(describing: clusterIdentifier)), dbGroups: \(Swift.String(describing: dbGroups)), dbName: \(Swift.String(describing: dbName)), dbUser: \(Swift.String(describing: dbUser)), durationSeconds: \(Swift.String(describing: durationSeconds)))"}
}

extension GetClusterCredentialsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let autoCreate = autoCreate {
            try container.encode(autoCreate, forKey: ClientRuntime.Key("AutoCreate"))
        }
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: ClientRuntime.Key("ClusterIdentifier"))
        }
        if let dbGroups = dbGroups {
            var dbGroupsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DbGroups"))
            for (index0, string0) in dbGroups.enumerated() {
                try dbGroupsContainer.encode(string0, forKey: ClientRuntime.Key("DbGroup.\(index0.advanced(by: 1))"))
            }
        }
        if let dbName = dbName {
            try container.encode(dbName, forKey: ClientRuntime.Key("DbName"))
        }
        if let dbUser = dbUser {
            try container.encode(dbUser, forKey: ClientRuntime.Key("DbUser"))
        }
        if let durationSeconds = durationSeconds {
            try container.encode(durationSeconds, forKey: ClientRuntime.Key("DurationSeconds"))
        }
        try container.encode("GetClusterCredentials", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct GetClusterCredentialsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetClusterCredentialsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetClusterCredentialsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetClusterCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetClusterCredentialsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetClusterCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetClusterCredentialsOutputError>
}

public struct GetClusterCredentialsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetClusterCredentialsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetClusterCredentialsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetClusterCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetClusterCredentialsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetClusterCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetClusterCredentialsOutputError>
}

/// <p>The request parameters to get cluster credentials.</p>
public struct GetClusterCredentialsInput: Swift.Equatable {
    /// <p>Create a database user with the name specified for the user named in
    ///                 <code>DbUser</code> if one does not exist.</p>
    public let autoCreate: Swift.Bool?
    /// <p>The unique identifier of the cluster that contains the database for which your are
    ///             requesting credentials. This parameter is case sensitive.</p>
    public let clusterIdentifier: Swift.String?
    /// <p>A list of the names of existing database groups that the user named in
    ///                 <code>DbUser</code> will join for the current session, in addition to any group
    ///             memberships for an existing user. If not specified, a new user is added only to
    ///             PUBLIC.</p>
    ///         <p>Database group name constraints</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Must be 1 to 64 alphanumeric characters or hyphens</p>
    ///             </li>
    ///             <li>
    ///                 <p>Must contain only lowercase letters, numbers, underscore, plus sign, period
    ///                     (dot), at symbol (@), or hyphen.</p>
    ///             </li>
    ///             <li>
    ///                 <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Must not contain a colon ( : ) or slash ( / ). </p>
    ///             </li>
    ///             <li>
    ///                 <p>Cannot be a reserved word. A list of reserved words can be found in <a href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon
    ///                     Redshift Database Developer Guide.</p>
    ///             </li>
    ///          </ul>
    public let dbGroups: [Swift.String]?
    /// <p>The name of a database that <code>DbUser</code> is authorized to log on to. If
    ///                 <code>DbName</code> is not specified, <code>DbUser</code> can log on to any existing
    ///             database.</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Must be 1 to 64 alphanumeric characters or hyphens</p>
    ///             </li>
    ///             <li>
    ///                 <p>Must contain only lowercase letters, numbers, underscore, plus sign, period
    ///                     (dot), at symbol (@), or hyphen.</p>
    ///             </li>
    ///             <li>
    ///                 <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Must not contain a colon ( : ) or slash ( / ). </p>
    ///             </li>
    ///             <li>
    ///                 <p>Cannot be a reserved word. A list of reserved words can be found in <a href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon
    ///                     Redshift Database Developer Guide.</p>
    ///             </li>
    ///          </ul>
    public let dbName: Swift.String?
    /// <p>The name of a database user. If a user name matching <code>DbUser</code> exists in
    ///             the database, the temporary user credentials have the same permissions as the existing
    ///             user. If <code>DbUser</code> doesn't exist in the database and <code>Autocreate</code>
    ///             is <code>True</code>, a new user is created using the value for <code>DbUser</code> with
    ///             PUBLIC permissions. If a database user matching the value for <code>DbUser</code>
    ///             doesn't exist and <code>Autocreate</code> is <code>False</code>, then the command
    ///             succeeds but the connection attempt will fail because the user doesn't exist in the
    ///             database.</p>
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_USER.html">CREATE USER</a> in the Amazon
    ///             Redshift Database Developer Guide. </p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Must be 1 to 64 alphanumeric characters or hyphens. The user name can't be
    ///                         <code>PUBLIC</code>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Must contain only lowercase letters, numbers, underscore, plus sign, period
    ///                     (dot), at symbol (@), or hyphen.</p>
    ///             </li>
    ///             <li>
    ///                 <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Must not contain a colon ( : ) or slash ( / ). </p>
    ///             </li>
    ///             <li>
    ///                 <p>Cannot be a reserved word. A list of reserved words can be found in <a href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon
    ///                     Redshift Database Developer Guide.</p>
    ///             </li>
    ///          </ul>
    public let dbUser: Swift.String?
    /// <p>The number of seconds until the returned temporary password expires.</p>
    ///         <p>Constraint: minimum 900, maximum 3600.</p>
    ///         <p>Default: 900</p>
    public let durationSeconds: Swift.Int?

    public init (
        autoCreate: Swift.Bool? = nil,
        clusterIdentifier: Swift.String? = nil,
        dbGroups: [Swift.String]? = nil,
        dbName: Swift.String? = nil,
        dbUser: Swift.String? = nil,
        durationSeconds: Swift.Int? = nil
    )
    {
        self.autoCreate = autoCreate
        self.clusterIdentifier = clusterIdentifier
        self.dbGroups = dbGroups
        self.dbName = dbName
        self.dbUser = dbUser
        self.durationSeconds = durationSeconds
    }
}

extension GetClusterCredentialsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetClusterCredentialsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationFault" : self = .unsupportedOperationFault(try UnsupportedOperationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetClusterCredentialsOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case unsupportedOperationFault(UnsupportedOperationFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetClusterCredentialsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetClusterCredentialsOutputResponse(dbPassword: \(Swift.String(describing: dbPassword)), dbUser: \(Swift.String(describing: dbUser)), expiration: \(Swift.String(describing: expiration)))"}
}

extension GetClusterCredentialsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetClusterCredentialsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dbPassword = output.dbPassword
            self.dbUser = output.dbUser
            self.expiration = output.expiration
        } else {
            self.dbPassword = nil
            self.dbUser = nil
            self.expiration = nil
        }
    }
}

/// <p>Temporary credentials with authorization to log on to an Amazon Redshift database.
///         </p>
public struct GetClusterCredentialsOutputResponse: Swift.Equatable {
    /// <p>A temporary password that authorizes the user name returned by <code>DbUser</code>
    ///             to log on to the database <code>DbName</code>. </p>
    public let dbPassword: Swift.String?
    /// <p>A database user name that is authorized to log on to the database
    ///                 <code>DbName</code> using the password <code>DbPassword</code>. If the specified
    ///             DbUser exists in the database, the new user name has the same database privileges as the
    ///             the user named in DbUser. By default, the user is added to PUBLIC. If the
    ///                 <code>DbGroups</code> parameter is specifed, <code>DbUser</code> is added to the
    ///             listed groups for any sessions created using these credentials.</p>
    public let dbUser: Swift.String?
    /// <p>The date and time the password in <code>DbPassword</code> expires.</p>
    public let expiration: ClientRuntime.Date?

    public init (
        dbPassword: Swift.String? = nil,
        dbUser: Swift.String? = nil,
        expiration: ClientRuntime.Date? = nil
    )
    {
        self.dbPassword = dbPassword
        self.dbUser = dbUser
        self.expiration = expiration
    }
}

struct GetClusterCredentialsOutputResponseBody: Swift.Equatable {
    public let dbUser: Swift.String?
    public let dbPassword: Swift.String?
    public let expiration: ClientRuntime.Date?
}

extension GetClusterCredentialsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dbPassword = "DbPassword"
        case dbUser = "DbUser"
        case expiration = "Expiration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetClusterCredentialsResult"))
        let dbUserDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbUser)
        dbUser = dbUserDecoded
        let dbPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbPassword)
        dbPassword = dbPasswordDecoded
        let expirationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expiration)
        var expirationBuffer:ClientRuntime.Date? = nil
        if let expirationDecoded = expirationDecoded {
            expirationBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(expirationDecoded, format: .dateTime)
        }
        expiration = expirationBuffer
    }
}

public struct GetReservedNodeExchangeOfferingsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetReservedNodeExchangeOfferingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetReservedNodeExchangeOfferingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetReservedNodeExchangeOfferingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetReservedNodeExchangeOfferingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetReservedNodeExchangeOfferingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetReservedNodeExchangeOfferingsOutputError>
}

extension GetReservedNodeExchangeOfferingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetReservedNodeExchangeOfferingsInput(marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)), reservedNodeId: \(Swift.String(describing: reservedNodeId)))"}
}

extension GetReservedNodeExchangeOfferingsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let reservedNodeId = reservedNodeId {
            try container.encode(reservedNodeId, forKey: ClientRuntime.Key("ReservedNodeId"))
        }
        try container.encode("GetReservedNodeExchangeOfferings", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct GetReservedNodeExchangeOfferingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetReservedNodeExchangeOfferingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetReservedNodeExchangeOfferingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetReservedNodeExchangeOfferingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetReservedNodeExchangeOfferingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetReservedNodeExchangeOfferingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetReservedNodeExchangeOfferingsOutputError>
}

public struct GetReservedNodeExchangeOfferingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetReservedNodeExchangeOfferingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetReservedNodeExchangeOfferingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetReservedNodeExchangeOfferingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetReservedNodeExchangeOfferingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetReservedNodeExchangeOfferingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetReservedNodeExchangeOfferingsOutputError>
}

/// <p></p>
public struct GetReservedNodeExchangeOfferingsInput: Swift.Equatable {
    /// <p>A value that indicates the starting point for the next set of
    ///             ReservedNodeOfferings.</p>
    public let marker: Swift.String?
    /// <p>An integer setting the maximum number of ReservedNodeOfferings to
    ///             retrieve.</p>
    public let maxRecords: Swift.Int?
    /// <p>A string representing the node identifier for the DC1 Reserved Node to be
    ///             exchanged.</p>
    public let reservedNodeId: Swift.String?

    public init (
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        reservedNodeId: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxRecords = maxRecords
        self.reservedNodeId = reservedNodeId
    }
}

extension GetReservedNodeExchangeOfferingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetReservedNodeExchangeOfferingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependentServiceUnavailableFault" : self = .dependentServiceUnavailableFault(try DependentServiceUnavailableFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidReservedNodeStateFault" : self = .invalidReservedNodeStateFault(try InvalidReservedNodeStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReservedNodeAlreadyMigratedFault" : self = .reservedNodeAlreadyMigratedFault(try ReservedNodeAlreadyMigratedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReservedNodeNotFoundFault" : self = .reservedNodeNotFoundFault(try ReservedNodeNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReservedNodeOfferingNotFoundFault" : self = .reservedNodeOfferingNotFoundFault(try ReservedNodeOfferingNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationFault" : self = .unsupportedOperationFault(try UnsupportedOperationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetReservedNodeExchangeOfferingsOutputError: Swift.Error, Swift.Equatable {
    case dependentServiceUnavailableFault(DependentServiceUnavailableFault)
    case invalidReservedNodeStateFault(InvalidReservedNodeStateFault)
    case reservedNodeAlreadyMigratedFault(ReservedNodeAlreadyMigratedFault)
    case reservedNodeNotFoundFault(ReservedNodeNotFoundFault)
    case reservedNodeOfferingNotFoundFault(ReservedNodeOfferingNotFoundFault)
    case unsupportedOperationFault(UnsupportedOperationFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetReservedNodeExchangeOfferingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetReservedNodeExchangeOfferingsOutputResponse(marker: \(Swift.String(describing: marker)), reservedNodeOfferings: \(Swift.String(describing: reservedNodeOfferings)))"}
}

extension GetReservedNodeExchangeOfferingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetReservedNodeExchangeOfferingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.reservedNodeOfferings = output.reservedNodeOfferings
        } else {
            self.marker = nil
            self.reservedNodeOfferings = nil
        }
    }
}

public struct GetReservedNodeExchangeOfferingsOutputResponse: Swift.Equatable {
    /// <p>An optional parameter that specifies the starting point for returning a set of
    ///             response records. When the results of a <code>GetReservedNodeExchangeOfferings</code>
    ///             request exceed the value specified in MaxRecords, Amazon Redshift returns a value in the
    ///             marker field of the response. You can retrieve the next set of response records by
    ///             providing the returned marker value in the marker parameter and retrying the request.
    ///         </p>
    public let marker: Swift.String?
    /// <p>Returns an array of <a>ReservedNodeOffering</a> objects.</p>
    public let reservedNodeOfferings: [RedshiftClientTypes.ReservedNodeOffering]?

    public init (
        marker: Swift.String? = nil,
        reservedNodeOfferings: [RedshiftClientTypes.ReservedNodeOffering]? = nil
    )
    {
        self.marker = marker
        self.reservedNodeOfferings = reservedNodeOfferings
    }
}

struct GetReservedNodeExchangeOfferingsOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let reservedNodeOfferings: [RedshiftClientTypes.ReservedNodeOffering]?
}

extension GetReservedNodeExchangeOfferingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case reservedNodeOfferings = "ReservedNodeOfferings"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetReservedNodeExchangeOfferingsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.reservedNodeOfferings) {
            struct KeyVal0{struct ReservedNodeOffering{}}
            let reservedNodeOfferingsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ReservedNodeOffering>.CodingKeys.self, forKey: .reservedNodeOfferings)
            if let reservedNodeOfferingsWrappedContainer = reservedNodeOfferingsWrappedContainer {
                let reservedNodeOfferingsContainer = try reservedNodeOfferingsWrappedContainer.decodeIfPresent([RedshiftClientTypes.ReservedNodeOffering].self, forKey: .member)
                var reservedNodeOfferingsBuffer:[RedshiftClientTypes.ReservedNodeOffering]? = nil
                if let reservedNodeOfferingsContainer = reservedNodeOfferingsContainer {
                    reservedNodeOfferingsBuffer = [RedshiftClientTypes.ReservedNodeOffering]()
                    for structureContainer0 in reservedNodeOfferingsContainer {
                        reservedNodeOfferingsBuffer?.append(structureContainer0)
                    }
                }
                reservedNodeOfferings = reservedNodeOfferingsBuffer
            } else {
                reservedNodeOfferings = []
            }
        } else {
            reservedNodeOfferings = nil
        }
    }
}

extension RedshiftClientTypes.HsmClientCertificate: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hsmClientCertificateIdentifier = "HsmClientCertificateIdentifier"
        case hsmClientCertificatePublicKey = "HsmClientCertificatePublicKey"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let hsmClientCertificateIdentifier = hsmClientCertificateIdentifier {
            try container.encode(hsmClientCertificateIdentifier, forKey: ClientRuntime.Key("HsmClientCertificateIdentifier"))
        }
        if let hsmClientCertificatePublicKey = hsmClientCertificatePublicKey {
            try container.encode(hsmClientCertificatePublicKey, forKey: ClientRuntime.Key("HsmClientCertificatePublicKey"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hsmClientCertificateIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hsmClientCertificateIdentifier)
        hsmClientCertificateIdentifier = hsmClientCertificateIdentifierDecoded
        let hsmClientCertificatePublicKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hsmClientCertificatePublicKey)
        hsmClientCertificatePublicKey = hsmClientCertificatePublicKeyDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([RedshiftClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[RedshiftClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [RedshiftClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension RedshiftClientTypes.HsmClientCertificate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HsmClientCertificate(hsmClientCertificateIdentifier: \(Swift.String(describing: hsmClientCertificateIdentifier)), hsmClientCertificatePublicKey: \(Swift.String(describing: hsmClientCertificatePublicKey)), tags: \(Swift.String(describing: tags)))"}
}

extension RedshiftClientTypes {
    /// <p>Returns information about an HSM client certificate. The certificate is stored in a
    ///             secure Hardware Storage Module (HSM), and used by the Amazon Redshift cluster to encrypt data
    ///             files.</p>
    public struct HsmClientCertificate: Swift.Equatable {
        /// <p>The identifier of the HSM client certificate.</p>
        public let hsmClientCertificateIdentifier: Swift.String?
        /// <p>The public key that the Amazon Redshift cluster will use to connect to the HSM. You must
        ///             register the public key in the HSM.</p>
        public let hsmClientCertificatePublicKey: Swift.String?
        /// <p>The list of tags for the HSM client certificate.</p>
        public let tags: [RedshiftClientTypes.Tag]?

        public init (
            hsmClientCertificateIdentifier: Swift.String? = nil,
            hsmClientCertificatePublicKey: Swift.String? = nil,
            tags: [RedshiftClientTypes.Tag]? = nil
        )
        {
            self.hsmClientCertificateIdentifier = hsmClientCertificateIdentifier
            self.hsmClientCertificatePublicKey = hsmClientCertificatePublicKey
            self.tags = tags
        }
    }

}

extension HsmClientCertificateAlreadyExistsFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HsmClientCertificateAlreadyExistsFault(message: \(Swift.String(describing: message)))"}
}

extension HsmClientCertificateAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<HsmClientCertificateAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There is already an existing Amazon Redshift HSM client certificate with the specified
///             identifier.</p>
public struct HsmClientCertificateAlreadyExistsFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct HsmClientCertificateAlreadyExistsFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension HsmClientCertificateAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension HsmClientCertificateNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HsmClientCertificateNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension HsmClientCertificateNotFoundFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<HsmClientCertificateNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There is no Amazon Redshift HSM client certificate with the specified
///             identifier.</p>
public struct HsmClientCertificateNotFoundFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct HsmClientCertificateNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension HsmClientCertificateNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension HsmClientCertificateQuotaExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HsmClientCertificateQuotaExceededFault(message: \(Swift.String(describing: message)))"}
}

extension HsmClientCertificateQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<HsmClientCertificateQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The quota for HSM client certificates has been reached.
/// For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a>
/// in the <i>Amazon Redshift Cluster Management Guide</i>.
/// </p>
public struct HsmClientCertificateQuotaExceededFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct HsmClientCertificateQuotaExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension HsmClientCertificateQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RedshiftClientTypes.HsmConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case hsmConfigurationIdentifier = "HsmConfigurationIdentifier"
        case hsmIpAddress = "HsmIpAddress"
        case hsmPartitionName = "HsmPartitionName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let hsmConfigurationIdentifier = hsmConfigurationIdentifier {
            try container.encode(hsmConfigurationIdentifier, forKey: ClientRuntime.Key("HsmConfigurationIdentifier"))
        }
        if let hsmIpAddress = hsmIpAddress {
            try container.encode(hsmIpAddress, forKey: ClientRuntime.Key("HsmIpAddress"))
        }
        if let hsmPartitionName = hsmPartitionName {
            try container.encode(hsmPartitionName, forKey: ClientRuntime.Key("HsmPartitionName"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hsmConfigurationIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hsmConfigurationIdentifier)
        hsmConfigurationIdentifier = hsmConfigurationIdentifierDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let hsmIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hsmIpAddress)
        hsmIpAddress = hsmIpAddressDecoded
        let hsmPartitionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hsmPartitionName)
        hsmPartitionName = hsmPartitionNameDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([RedshiftClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[RedshiftClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [RedshiftClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension RedshiftClientTypes.HsmConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HsmConfiguration(description: \(Swift.String(describing: description)), hsmConfigurationIdentifier: \(Swift.String(describing: hsmConfigurationIdentifier)), hsmIpAddress: \(Swift.String(describing: hsmIpAddress)), hsmPartitionName: \(Swift.String(describing: hsmPartitionName)), tags: \(Swift.String(describing: tags)))"}
}

extension RedshiftClientTypes {
    /// <p>Returns information about an HSM configuration, which is an object that describes
    ///             to Amazon Redshift clusters the information they require to connect to an HSM where they can
    ///             store database encryption keys.</p>
    public struct HsmConfiguration: Swift.Equatable {
        /// <p>A text description of the HSM configuration.</p>
        public let description: Swift.String?
        /// <p>The name of the Amazon Redshift HSM configuration.</p>
        public let hsmConfigurationIdentifier: Swift.String?
        /// <p>The IP address that the Amazon Redshift cluster must use to access the HSM.</p>
        public let hsmIpAddress: Swift.String?
        /// <p>The name of the partition in the HSM where the Amazon Redshift clusters will store their
        ///             database encryption keys.</p>
        public let hsmPartitionName: Swift.String?
        /// <p>The list of tags for the HSM configuration.</p>
        public let tags: [RedshiftClientTypes.Tag]?

        public init (
            description: Swift.String? = nil,
            hsmConfigurationIdentifier: Swift.String? = nil,
            hsmIpAddress: Swift.String? = nil,
            hsmPartitionName: Swift.String? = nil,
            tags: [RedshiftClientTypes.Tag]? = nil
        )
        {
            self.description = description
            self.hsmConfigurationIdentifier = hsmConfigurationIdentifier
            self.hsmIpAddress = hsmIpAddress
            self.hsmPartitionName = hsmPartitionName
            self.tags = tags
        }
    }

}

extension HsmConfigurationAlreadyExistsFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HsmConfigurationAlreadyExistsFault(message: \(Swift.String(describing: message)))"}
}

extension HsmConfigurationAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<HsmConfigurationAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There is already an existing Amazon Redshift HSM configuration with the specified
///             identifier.</p>
public struct HsmConfigurationAlreadyExistsFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct HsmConfigurationAlreadyExistsFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension HsmConfigurationAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension HsmConfigurationNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HsmConfigurationNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension HsmConfigurationNotFoundFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<HsmConfigurationNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There is no Amazon Redshift HSM configuration with the specified identifier.</p>
public struct HsmConfigurationNotFoundFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct HsmConfigurationNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension HsmConfigurationNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension HsmConfigurationQuotaExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HsmConfigurationQuotaExceededFault(message: \(Swift.String(describing: message)))"}
}

extension HsmConfigurationQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<HsmConfigurationQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The quota for HSM configurations has been reached.
/// For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a>
/// in the <i>Amazon Redshift Cluster Management Guide</i>.
/// </p>
public struct HsmConfigurationQuotaExceededFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct HsmConfigurationQuotaExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension HsmConfigurationQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RedshiftClientTypes.HsmStatus: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hsmClientCertificateIdentifier = "HsmClientCertificateIdentifier"
        case hsmConfigurationIdentifier = "HsmConfigurationIdentifier"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let hsmClientCertificateIdentifier = hsmClientCertificateIdentifier {
            try container.encode(hsmClientCertificateIdentifier, forKey: ClientRuntime.Key("HsmClientCertificateIdentifier"))
        }
        if let hsmConfigurationIdentifier = hsmConfigurationIdentifier {
            try container.encode(hsmConfigurationIdentifier, forKey: ClientRuntime.Key("HsmConfigurationIdentifier"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hsmClientCertificateIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hsmClientCertificateIdentifier)
        hsmClientCertificateIdentifier = hsmClientCertificateIdentifierDecoded
        let hsmConfigurationIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hsmConfigurationIdentifier)
        hsmConfigurationIdentifier = hsmConfigurationIdentifierDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension RedshiftClientTypes.HsmStatus: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HsmStatus(hsmClientCertificateIdentifier: \(Swift.String(describing: hsmClientCertificateIdentifier)), hsmConfigurationIdentifier: \(Swift.String(describing: hsmConfigurationIdentifier)), status: \(Swift.String(describing: status)))"}
}

extension RedshiftClientTypes {
    /// <p>Describes the status of changes to HSM settings.</p>
    public struct HsmStatus: Swift.Equatable {
        /// <p>Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to
        ///             retrieve the data encryption keys stored in an HSM.</p>
        public let hsmClientCertificateIdentifier: Swift.String?
        /// <p>Specifies the name of the HSM configuration that contains the information the
        ///             Amazon Redshift cluster can use to retrieve and store keys in an HSM.</p>
        public let hsmConfigurationIdentifier: Swift.String?
        /// <p>Reports whether the Amazon Redshift cluster has finished applying any HSM settings
        ///             changes specified in a modify cluster command.</p>
        ///         <p>Values: active, applying</p>
        public let status: Swift.String?

        public init (
            hsmClientCertificateIdentifier: Swift.String? = nil,
            hsmConfigurationIdentifier: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.hsmClientCertificateIdentifier = hsmClientCertificateIdentifier
            self.hsmConfigurationIdentifier = hsmConfigurationIdentifier
            self.status = status
        }
    }

}

extension RedshiftClientTypes.IPRange: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cIDRIP = "CIDRIP"
        case status = "Status"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let cIDRIP = cIDRIP {
            try container.encode(cIDRIP, forKey: ClientRuntime.Key("CIDRIP"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let cIDRIPDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cIDRIP)
        cIDRIP = cIDRIPDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([RedshiftClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[RedshiftClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [RedshiftClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension RedshiftClientTypes.IPRange: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IPRange(cIDRIP: \(Swift.String(describing: cIDRIP)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)))"}
}

extension RedshiftClientTypes {
    /// <p>Describes an IP range used in a security group.</p>
    public struct IPRange: Swift.Equatable {
        /// <p>The IP range in Classless Inter-Domain Routing (CIDR) notation.</p>
        public let cIDRIP: Swift.String?
        /// <p>The status of the IP range, for example, "authorized".</p>
        public let status: Swift.String?
        /// <p>The list of tags for the IP range.</p>
        public let tags: [RedshiftClientTypes.Tag]?

        public init (
            cIDRIP: Swift.String? = nil,
            status: Swift.String? = nil,
            tags: [RedshiftClientTypes.Tag]? = nil
        )
        {
            self.cIDRIP = cIDRIP
            self.status = status
            self.tags = tags
        }
    }

}

extension InProgressTableRestoreQuotaExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InProgressTableRestoreQuotaExceededFault(message: \(Swift.String(describing: message)))"}
}

extension InProgressTableRestoreQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InProgressTableRestoreQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have exceeded the allowed number of table restore requests. Wait for your
///             current table restore requests to complete before making a new request.</p>
public struct InProgressTableRestoreQuotaExceededFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InProgressTableRestoreQuotaExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InProgressTableRestoreQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IncompatibleOrderableOptions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IncompatibleOrderableOptions(message: \(Swift.String(describing: message)))"}
}

extension IncompatibleOrderableOptions: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<IncompatibleOrderableOptionsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified options are incompatible.</p>
public struct IncompatibleOrderableOptions: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct IncompatibleOrderableOptionsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension IncompatibleOrderableOptionsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InsufficientClusterCapacityFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InsufficientClusterCapacityFault(message: \(Swift.String(describing: message)))"}
}

extension InsufficientClusterCapacityFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InsufficientClusterCapacityFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of nodes specified exceeds the allotted capacity of the
///             cluster.</p>
public struct InsufficientClusterCapacityFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InsufficientClusterCapacityFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InsufficientClusterCapacityFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InsufficientS3BucketPolicyFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InsufficientS3BucketPolicyFault(message: \(Swift.String(describing: message)))"}
}

extension InsufficientS3BucketPolicyFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InsufficientS3BucketPolicyFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The cluster does not have read bucket or put object permissions on the S3 bucket
///             specified when enabling logging.</p>
public struct InsufficientS3BucketPolicyFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InsufficientS3BucketPolicyFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InsufficientS3BucketPolicyFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidAuthorizationStateFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidAuthorizationStateFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidAuthorizationStateFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidAuthorizationStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The status of the authorization is not valid.</p>
public struct InvalidAuthorizationStateFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidAuthorizationStateFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidAuthorizationStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidClusterParameterGroupStateFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidClusterParameterGroupStateFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidClusterParameterGroupStateFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidClusterParameterGroupStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The cluster parameter group action can not be completed because another task is in
///             progress that involves the parameter group. Wait a few moments and try the operation
///             again.</p>
public struct InvalidClusterParameterGroupStateFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidClusterParameterGroupStateFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidClusterParameterGroupStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidClusterSecurityGroupStateFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidClusterSecurityGroupStateFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidClusterSecurityGroupStateFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidClusterSecurityGroupStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The state of the cluster security group is not <code>available</code>. </p>
public struct InvalidClusterSecurityGroupStateFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidClusterSecurityGroupStateFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidClusterSecurityGroupStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidClusterSnapshotScheduleStateFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidClusterSnapshotScheduleStateFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidClusterSnapshotScheduleStateFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidClusterSnapshotScheduleStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The cluster snapshot schedule state is not valid.</p>
public struct InvalidClusterSnapshotScheduleStateFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidClusterSnapshotScheduleStateFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidClusterSnapshotScheduleStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidClusterSnapshotStateFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidClusterSnapshotStateFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidClusterSnapshotStateFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidClusterSnapshotStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified cluster snapshot is not in the <code>available</code> state, or other
///             accounts are authorized to access the snapshot. </p>
public struct InvalidClusterSnapshotStateFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidClusterSnapshotStateFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidClusterSnapshotStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidClusterStateFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidClusterStateFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidClusterStateFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidClusterStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified cluster is not in the <code>available</code> state. </p>
public struct InvalidClusterStateFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidClusterStateFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidClusterStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidClusterSubnetGroupStateFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidClusterSubnetGroupStateFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidClusterSubnetGroupStateFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidClusterSubnetGroupStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The cluster subnet group cannot be deleted because it is in use.</p>
public struct InvalidClusterSubnetGroupStateFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidClusterSubnetGroupStateFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidClusterSubnetGroupStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidClusterSubnetStateFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidClusterSubnetStateFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidClusterSubnetStateFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidClusterSubnetStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The state of the subnet is invalid.</p>
public struct InvalidClusterSubnetStateFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidClusterSubnetStateFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidClusterSubnetStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidClusterTrackFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidClusterTrackFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidClusterTrackFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidClusterTrackFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The provided cluster track name is not valid.</p>
public struct InvalidClusterTrackFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidClusterTrackFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidClusterTrackFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidElasticIpFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidElasticIpFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidElasticIpFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidElasticIpFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The Elastic IP (EIP) is invalid or cannot be found.</p>
public struct InvalidElasticIpFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidElasticIpFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidElasticIpFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidEndpointStateFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidEndpointStateFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidEndpointStateFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidEndpointStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The status of the endpoint is not valid.</p>
public struct InvalidEndpointStateFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidEndpointStateFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidEndpointStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidHsmClientCertificateStateFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidHsmClientCertificateStateFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidHsmClientCertificateStateFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidHsmClientCertificateStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified HSM client certificate is not in the <code>available</code> state, or
///             it is still in use by one or more Amazon Redshift clusters.</p>
public struct InvalidHsmClientCertificateStateFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidHsmClientCertificateStateFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidHsmClientCertificateStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidHsmConfigurationStateFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidHsmConfigurationStateFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidHsmConfigurationStateFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidHsmConfigurationStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified HSM configuration is not in the <code>available</code> state, or it
///             is still in use by one or more Amazon Redshift clusters.</p>
public struct InvalidHsmConfigurationStateFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidHsmConfigurationStateFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidHsmConfigurationStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidReservedNodeStateFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidReservedNodeStateFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidReservedNodeStateFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidReservedNodeStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the Reserved Node being exchanged is not in an active state.</p>
public struct InvalidReservedNodeStateFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidReservedNodeStateFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidReservedNodeStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRestoreFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidRestoreFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidRestoreFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidRestoreFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The restore is invalid.</p>
public struct InvalidRestoreFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRestoreFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidRestoreFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRetentionPeriodFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidRetentionPeriodFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidRetentionPeriodFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidRetentionPeriodFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The retention period specified is either in the past or is not a valid value.</p>
///         <p>The value must be either -1 or an integer between 1 and 3,653.</p>
public struct InvalidRetentionPeriodFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRetentionPeriodFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidRetentionPeriodFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidS3BucketNameFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidS3BucketNameFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidS3BucketNameFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidS3BucketNameFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The S3 bucket name is invalid. For more information about naming rules, go to
///                 <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/BucketRestrictions.html">Bucket
///                 Restrictions and Limitations</a> in the Amazon Simple Storage Service (S3)
///             Developer Guide.</p>
public struct InvalidS3BucketNameFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidS3BucketNameFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidS3BucketNameFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidS3KeyPrefixFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidS3KeyPrefixFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidS3KeyPrefixFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidS3KeyPrefixFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The string specified for the logging S3 key prefix does not comply with the
///             documented constraints.</p>
public struct InvalidS3KeyPrefixFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidS3KeyPrefixFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidS3KeyPrefixFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidScheduleFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidScheduleFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidScheduleFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidScheduleFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The schedule you submitted isn't valid.</p>
public struct InvalidScheduleFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidScheduleFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidScheduleFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidScheduledActionFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidScheduledActionFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidScheduledActionFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidScheduledActionFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The scheduled action is not valid. </p>
public struct InvalidScheduledActionFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidScheduledActionFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidScheduledActionFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSnapshotCopyGrantStateFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidSnapshotCopyGrantStateFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidSnapshotCopyGrantStateFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidSnapshotCopyGrantStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The snapshot copy grant can't be deleted because it is used by one or more
///             clusters.</p>
public struct InvalidSnapshotCopyGrantStateFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidSnapshotCopyGrantStateFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidSnapshotCopyGrantStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSubnet: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidSubnet(message: \(Swift.String(describing: message)))"}
}

extension InvalidSubnet: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidSubnetBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested subnet is not valid, or not all of the subnets are in the same
///             VPC.</p>
public struct InvalidSubnet: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidSubnetBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidSubnetBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSubscriptionStateFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidSubscriptionStateFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidSubscriptionStateFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidSubscriptionStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The subscription request is invalid because it is a duplicate request. This
///             subscription request is already in progress.</p>
public struct InvalidSubscriptionStateFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidSubscriptionStateFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidSubscriptionStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTableRestoreArgumentFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidTableRestoreArgumentFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidTableRestoreArgumentFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidTableRestoreArgumentFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The value specified for the <code>sourceDatabaseName</code>,
///                 <code>sourceSchemaName</code>, or <code>sourceTableName</code> parameter, or a
///             combination of these, doesn't exist in the snapshot.</p>
public struct InvalidTableRestoreArgumentFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTableRestoreArgumentFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidTableRestoreArgumentFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTagFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidTagFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidTagFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidTagFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The tag is invalid.</p>
public struct InvalidTagFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTagFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidTagFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidUsageLimitFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidUsageLimitFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidUsageLimitFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidUsageLimitFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The usage limit is not valid.</p>
public struct InvalidUsageLimitFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidUsageLimitFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidUsageLimitFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidVPCNetworkStateFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidVPCNetworkStateFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidVPCNetworkStateFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidVPCNetworkStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The cluster subnet group does not cover all Availability Zones.</p>
public struct InvalidVPCNetworkStateFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidVPCNetworkStateFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidVPCNetworkStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LimitExceededFault(message: \(Swift.String(describing: message)))"}
}

extension LimitExceededFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<LimitExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The encryption key has exceeded its grant limit in AWS KMS.</p>
public struct LimitExceededFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension LimitExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RedshiftClientTypes.MaintenanceTrack: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseVersion = "DatabaseVersion"
        case maintenanceTrackName = "MaintenanceTrackName"
        case updateTargets = "UpdateTargets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let databaseVersion = databaseVersion {
            try container.encode(databaseVersion, forKey: ClientRuntime.Key("DatabaseVersion"))
        }
        if let maintenanceTrackName = maintenanceTrackName {
            try container.encode(maintenanceTrackName, forKey: ClientRuntime.Key("MaintenanceTrackName"))
        }
        if let updateTargets = updateTargets {
            var updateTargetsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("UpdateTargets"))
            for (index0, updatetarget0) in updateTargets.enumerated() {
                try updateTargetsContainer.encode(updatetarget0, forKey: ClientRuntime.Key("UpdateTarget.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maintenanceTrackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maintenanceTrackName)
        maintenanceTrackName = maintenanceTrackNameDecoded
        let databaseVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseVersion)
        databaseVersion = databaseVersionDecoded
        if containerValues.contains(.updateTargets) {
            struct KeyVal0{struct UpdateTarget{}}
            let updateTargetsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.UpdateTarget>.CodingKeys.self, forKey: .updateTargets)
            if let updateTargetsWrappedContainer = updateTargetsWrappedContainer {
                let updateTargetsContainer = try updateTargetsWrappedContainer.decodeIfPresent([RedshiftClientTypes.UpdateTarget].self, forKey: .member)
                var updateTargetsBuffer:[RedshiftClientTypes.UpdateTarget]? = nil
                if let updateTargetsContainer = updateTargetsContainer {
                    updateTargetsBuffer = [RedshiftClientTypes.UpdateTarget]()
                    for structureContainer0 in updateTargetsContainer {
                        updateTargetsBuffer?.append(structureContainer0)
                    }
                }
                updateTargets = updateTargetsBuffer
            } else {
                updateTargets = []
            }
        } else {
            updateTargets = nil
        }
    }
}

extension RedshiftClientTypes.MaintenanceTrack: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MaintenanceTrack(databaseVersion: \(Swift.String(describing: databaseVersion)), maintenanceTrackName: \(Swift.String(describing: maintenanceTrackName)), updateTargets: \(Swift.String(describing: updateTargets)))"}
}

extension RedshiftClientTypes {
    /// <p>Defines a maintenance track that determines which Amazon Redshift version to apply
    ///             during a maintenance window. If the value for <code>MaintenanceTrack</code> is
    ///                 <code>current</code>, the cluster is updated to the most recently certified
    ///             maintenance release. If the value is <code>trailing</code>, the cluster is updated to
    ///             the previously certified maintenance release. </p>
    public struct MaintenanceTrack: Swift.Equatable {
        /// <p>The version number for the cluster release.</p>
        public let databaseVersion: Swift.String?
        /// <p>The name of the maintenance track. Possible values are <code>current</code> and
        ///                 <code>trailing</code>.</p>
        public let maintenanceTrackName: Swift.String?
        /// <p>An array of <a>UpdateTarget</a> objects to update with the maintenance
        ///             track. </p>
        public let updateTargets: [RedshiftClientTypes.UpdateTarget]?

        public init (
            databaseVersion: Swift.String? = nil,
            maintenanceTrackName: Swift.String? = nil,
            updateTargets: [RedshiftClientTypes.UpdateTarget]? = nil
        )
        {
            self.databaseVersion = databaseVersion
            self.maintenanceTrackName = maintenanceTrackName
            self.updateTargets = updateTargets
        }
    }

}

extension RedshiftClientTypes {
    public enum Mode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case highPerformance
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [Mode] {
            return [
                .highPerformance,
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .highPerformance: return "high-performance"
            case .standard: return "standard"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Mode(rawValue: rawValue) ?? Mode.sdkUnknown(rawValue)
        }
    }
}

public struct ModifyAquaConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyAquaConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyAquaConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyAquaConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyAquaConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyAquaConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyAquaConfigurationOutputError>
}

extension ModifyAquaConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyAquaConfigurationInput(aquaConfigurationStatus: \(Swift.String(describing: aquaConfigurationStatus)), clusterIdentifier: \(Swift.String(describing: clusterIdentifier)))"}
}

extension ModifyAquaConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let aquaConfigurationStatus = aquaConfigurationStatus {
            try container.encode(aquaConfigurationStatus, forKey: ClientRuntime.Key("AquaConfigurationStatus"))
        }
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: ClientRuntime.Key("ClusterIdentifier"))
        }
        try container.encode("ModifyAquaConfiguration", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ModifyAquaConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyAquaConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyAquaConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyAquaConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyAquaConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyAquaConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyAquaConfigurationOutputError>
}

public struct ModifyAquaConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyAquaConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyAquaConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyAquaConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyAquaConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyAquaConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyAquaConfigurationOutputError>
}

public struct ModifyAquaConfigurationInput: Swift.Equatable {
    /// <p>The new value of AQUA configuration status. Possible values include the following.</p>
    ///         <ul>
    ///             <li>
    ///                <p>enabled - Use AQUA if it is available for the current AWS Region and Amazon Redshift node type.</p>
    ///             </li>
    ///             <li>
    ///                <p>disabled - Don't use AQUA. </p>
    ///             </li>
    ///             <li>
    ///                <p>auto - Amazon Redshift determines whether to use AQUA.</p>
    ///             </li>
    ///          </ul>
    public let aquaConfigurationStatus: RedshiftClientTypes.AquaConfigurationStatus?
    /// <p>The identifier of the cluster to be modified.</p>
    public let clusterIdentifier: Swift.String?

    public init (
        aquaConfigurationStatus: RedshiftClientTypes.AquaConfigurationStatus? = nil,
        clusterIdentifier: Swift.String? = nil
    )
    {
        self.aquaConfigurationStatus = aquaConfigurationStatus
        self.clusterIdentifier = clusterIdentifier
    }
}

extension ModifyAquaConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyAquaConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationFault" : self = .unsupportedOperationFault(try UnsupportedOperationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyAquaConfigurationOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case unsupportedOperationFault(UnsupportedOperationFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyAquaConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyAquaConfigurationOutputResponse(aquaConfiguration: \(Swift.String(describing: aquaConfiguration)))"}
}

extension ModifyAquaConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyAquaConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aquaConfiguration = output.aquaConfiguration
        } else {
            self.aquaConfiguration = nil
        }
    }
}

public struct ModifyAquaConfigurationOutputResponse: Swift.Equatable {
    /// <p>The updated AQUA configuration of the cluster. </p>
    public let aquaConfiguration: RedshiftClientTypes.AquaConfiguration?

    public init (
        aquaConfiguration: RedshiftClientTypes.AquaConfiguration? = nil
    )
    {
        self.aquaConfiguration = aquaConfiguration
    }
}

struct ModifyAquaConfigurationOutputResponseBody: Swift.Equatable {
    public let aquaConfiguration: RedshiftClientTypes.AquaConfiguration?
}

extension ModifyAquaConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aquaConfiguration = "AquaConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyAquaConfigurationResult"))
        let aquaConfigurationDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.AquaConfiguration.self, forKey: .aquaConfiguration)
        aquaConfiguration = aquaConfigurationDecoded
    }
}

public struct ModifyClusterDbRevisionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyClusterDbRevisionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyClusterDbRevisionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyClusterDbRevisionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyClusterDbRevisionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyClusterDbRevisionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyClusterDbRevisionOutputError>
}

extension ModifyClusterDbRevisionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyClusterDbRevisionInput(clusterIdentifier: \(Swift.String(describing: clusterIdentifier)), revisionTarget: \(Swift.String(describing: revisionTarget)))"}
}

extension ModifyClusterDbRevisionInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: ClientRuntime.Key("ClusterIdentifier"))
        }
        if let revisionTarget = revisionTarget {
            try container.encode(revisionTarget, forKey: ClientRuntime.Key("RevisionTarget"))
        }
        try container.encode("ModifyClusterDbRevision", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ModifyClusterDbRevisionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyClusterDbRevisionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyClusterDbRevisionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyClusterDbRevisionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyClusterDbRevisionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyClusterDbRevisionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyClusterDbRevisionOutputError>
}

public struct ModifyClusterDbRevisionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyClusterDbRevisionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyClusterDbRevisionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyClusterDbRevisionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyClusterDbRevisionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyClusterDbRevisionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyClusterDbRevisionOutputError>
}

public struct ModifyClusterDbRevisionInput: Swift.Equatable {
    /// <p>The unique identifier of a cluster whose database revision you want to modify. </p>
    ///         <p>Example: <code>examplecluster</code>
    ///         </p>
    public let clusterIdentifier: Swift.String?
    /// <p>The identifier of the database revision. You can retrieve this value from the
    ///             response to the <a>DescribeClusterDbRevisions</a> request.</p>
    public let revisionTarget: Swift.String?

    public init (
        clusterIdentifier: Swift.String? = nil,
        revisionTarget: Swift.String? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
        self.revisionTarget = revisionTarget
    }
}

extension ModifyClusterDbRevisionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyClusterDbRevisionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterOnLatestRevisionFault" : self = .clusterOnLatestRevisionFault(try ClusterOnLatestRevisionFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyClusterDbRevisionOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case clusterOnLatestRevisionFault(ClusterOnLatestRevisionFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyClusterDbRevisionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyClusterDbRevisionOutputResponse(cluster: \(Swift.String(describing: cluster)))"}
}

extension ModifyClusterDbRevisionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyClusterDbRevisionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct ModifyClusterDbRevisionOutputResponse: Swift.Equatable {
    /// <p>Describes a cluster.</p>
    public let cluster: RedshiftClientTypes.Cluster?

    public init (
        cluster: RedshiftClientTypes.Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct ModifyClusterDbRevisionOutputResponseBody: Swift.Equatable {
    public let cluster: RedshiftClientTypes.Cluster?
}

extension ModifyClusterDbRevisionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cluster = "Cluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyClusterDbRevisionResult"))
        let clusterDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

public struct ModifyClusterIamRolesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyClusterIamRolesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyClusterIamRolesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyClusterIamRolesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyClusterIamRolesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyClusterIamRolesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyClusterIamRolesOutputError>
}

extension ModifyClusterIamRolesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyClusterIamRolesInput(addIamRoles: \(Swift.String(describing: addIamRoles)), clusterIdentifier: \(Swift.String(describing: clusterIdentifier)), removeIamRoles: \(Swift.String(describing: removeIamRoles)))"}
}

extension ModifyClusterIamRolesInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let addIamRoles = addIamRoles {
            var addIamRolesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AddIamRoles"))
            for (index0, string0) in addIamRoles.enumerated() {
                try addIamRolesContainer.encode(string0, forKey: ClientRuntime.Key("IamRoleArn.\(index0.advanced(by: 1))"))
            }
        }
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: ClientRuntime.Key("ClusterIdentifier"))
        }
        if let removeIamRoles = removeIamRoles {
            var removeIamRolesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("RemoveIamRoles"))
            for (index0, string0) in removeIamRoles.enumerated() {
                try removeIamRolesContainer.encode(string0, forKey: ClientRuntime.Key("IamRoleArn.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ModifyClusterIamRoles", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ModifyClusterIamRolesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyClusterIamRolesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyClusterIamRolesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyClusterIamRolesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyClusterIamRolesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyClusterIamRolesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyClusterIamRolesOutputError>
}

public struct ModifyClusterIamRolesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyClusterIamRolesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyClusterIamRolesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyClusterIamRolesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyClusterIamRolesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyClusterIamRolesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyClusterIamRolesOutputError>
}

/// <p></p>
public struct ModifyClusterIamRolesInput: Swift.Equatable {
    /// <p>Zero or more IAM roles to associate with the cluster. The roles must be in their
    ///             Amazon Resource Name (ARN) format. You can associate up to 10 IAM roles with a single
    ///             cluster in a single request.</p>
    public let addIamRoles: [Swift.String]?
    /// <p>The unique identifier of the cluster for which you want to associate or
    ///             disassociate IAM roles.</p>
    public let clusterIdentifier: Swift.String?
    /// <p>Zero or more IAM roles in ARN format to disassociate from the cluster. You can
    ///             disassociate up to 10 IAM roles from a single cluster in a single request.</p>
    public let removeIamRoles: [Swift.String]?

    public init (
        addIamRoles: [Swift.String]? = nil,
        clusterIdentifier: Swift.String? = nil,
        removeIamRoles: [Swift.String]? = nil
    )
    {
        self.addIamRoles = addIamRoles
        self.clusterIdentifier = clusterIdentifier
        self.removeIamRoles = removeIamRoles
    }
}

extension ModifyClusterIamRolesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyClusterIamRolesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyClusterIamRolesOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyClusterIamRolesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyClusterIamRolesOutputResponse(cluster: \(Swift.String(describing: cluster)))"}
}

extension ModifyClusterIamRolesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyClusterIamRolesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct ModifyClusterIamRolesOutputResponse: Swift.Equatable {
    /// <p>Describes a cluster.</p>
    public let cluster: RedshiftClientTypes.Cluster?

    public init (
        cluster: RedshiftClientTypes.Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct ModifyClusterIamRolesOutputResponseBody: Swift.Equatable {
    public let cluster: RedshiftClientTypes.Cluster?
}

extension ModifyClusterIamRolesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cluster = "Cluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyClusterIamRolesResult"))
        let clusterDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

public struct ModifyClusterInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyClusterOutputError>
}

extension ModifyClusterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyClusterInput(allowVersionUpgrade: \(Swift.String(describing: allowVersionUpgrade)), automatedSnapshotRetentionPeriod: \(Swift.String(describing: automatedSnapshotRetentionPeriod)), availabilityZone: \(Swift.String(describing: availabilityZone)), availabilityZoneRelocation: \(Swift.String(describing: availabilityZoneRelocation)), clusterIdentifier: \(Swift.String(describing: clusterIdentifier)), clusterParameterGroupName: \(Swift.String(describing: clusterParameterGroupName)), clusterSecurityGroups: \(Swift.String(describing: clusterSecurityGroups)), clusterType: \(Swift.String(describing: clusterType)), clusterVersion: \(Swift.String(describing: clusterVersion)), elasticIp: \(Swift.String(describing: elasticIp)), encrypted: \(Swift.String(describing: encrypted)), enhancedVpcRouting: \(Swift.String(describing: enhancedVpcRouting)), hsmClientCertificateIdentifier: \(Swift.String(describing: hsmClientCertificateIdentifier)), hsmConfigurationIdentifier: \(Swift.String(describing: hsmConfigurationIdentifier)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), maintenanceTrackName: \(Swift.String(describing: maintenanceTrackName)), manualSnapshotRetentionPeriod: \(Swift.String(describing: manualSnapshotRetentionPeriod)), masterUserPassword: \(Swift.String(describing: masterUserPassword)), newClusterIdentifier: \(Swift.String(describing: newClusterIdentifier)), nodeType: \(Swift.String(describing: nodeType)), numberOfNodes: \(Swift.String(describing: numberOfNodes)), port: \(Swift.String(describing: port)), preferredMaintenanceWindow: \(Swift.String(describing: preferredMaintenanceWindow)), publiclyAccessible: \(Swift.String(describing: publiclyAccessible)), vpcSecurityGroupIds: \(Swift.String(describing: vpcSecurityGroupIds)))"}
}

extension ModifyClusterInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let allowVersionUpgrade = allowVersionUpgrade {
            try container.encode(allowVersionUpgrade, forKey: ClientRuntime.Key("AllowVersionUpgrade"))
        }
        if let automatedSnapshotRetentionPeriod = automatedSnapshotRetentionPeriod {
            try container.encode(automatedSnapshotRetentionPeriod, forKey: ClientRuntime.Key("AutomatedSnapshotRetentionPeriod"))
        }
        if let availabilityZone = availabilityZone {
            try container.encode(availabilityZone, forKey: ClientRuntime.Key("AvailabilityZone"))
        }
        if let availabilityZoneRelocation = availabilityZoneRelocation {
            try container.encode(availabilityZoneRelocation, forKey: ClientRuntime.Key("AvailabilityZoneRelocation"))
        }
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: ClientRuntime.Key("ClusterIdentifier"))
        }
        if let clusterParameterGroupName = clusterParameterGroupName {
            try container.encode(clusterParameterGroupName, forKey: ClientRuntime.Key("ClusterParameterGroupName"))
        }
        if let clusterSecurityGroups = clusterSecurityGroups {
            var clusterSecurityGroupsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ClusterSecurityGroups"))
            for (index0, string0) in clusterSecurityGroups.enumerated() {
                try clusterSecurityGroupsContainer.encode(string0, forKey: ClientRuntime.Key("ClusterSecurityGroupName.\(index0.advanced(by: 1))"))
            }
        }
        if let clusterType = clusterType {
            try container.encode(clusterType, forKey: ClientRuntime.Key("ClusterType"))
        }
        if let clusterVersion = clusterVersion {
            try container.encode(clusterVersion, forKey: ClientRuntime.Key("ClusterVersion"))
        }
        if let elasticIp = elasticIp {
            try container.encode(elasticIp, forKey: ClientRuntime.Key("ElasticIp"))
        }
        if let encrypted = encrypted {
            try container.encode(encrypted, forKey: ClientRuntime.Key("Encrypted"))
        }
        if let enhancedVpcRouting = enhancedVpcRouting {
            try container.encode(enhancedVpcRouting, forKey: ClientRuntime.Key("EnhancedVpcRouting"))
        }
        if let hsmClientCertificateIdentifier = hsmClientCertificateIdentifier {
            try container.encode(hsmClientCertificateIdentifier, forKey: ClientRuntime.Key("HsmClientCertificateIdentifier"))
        }
        if let hsmConfigurationIdentifier = hsmConfigurationIdentifier {
            try container.encode(hsmConfigurationIdentifier, forKey: ClientRuntime.Key("HsmConfigurationIdentifier"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: ClientRuntime.Key("KmsKeyId"))
        }
        if let maintenanceTrackName = maintenanceTrackName {
            try container.encode(maintenanceTrackName, forKey: ClientRuntime.Key("MaintenanceTrackName"))
        }
        if let manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriod {
            try container.encode(manualSnapshotRetentionPeriod, forKey: ClientRuntime.Key("ManualSnapshotRetentionPeriod"))
        }
        if let masterUserPassword = masterUserPassword {
            try container.encode(masterUserPassword, forKey: ClientRuntime.Key("MasterUserPassword"))
        }
        if let newClusterIdentifier = newClusterIdentifier {
            try container.encode(newClusterIdentifier, forKey: ClientRuntime.Key("NewClusterIdentifier"))
        }
        if let nodeType = nodeType {
            try container.encode(nodeType, forKey: ClientRuntime.Key("NodeType"))
        }
        if let numberOfNodes = numberOfNodes {
            try container.encode(numberOfNodes, forKey: ClientRuntime.Key("NumberOfNodes"))
        }
        if let port = port {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try container.encode(preferredMaintenanceWindow, forKey: ClientRuntime.Key("PreferredMaintenanceWindow"))
        }
        if let publiclyAccessible = publiclyAccessible {
            try container.encode(publiclyAccessible, forKey: ClientRuntime.Key("PubliclyAccessible"))
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: ClientRuntime.Key("VpcSecurityGroupId.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ModifyCluster", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ModifyClusterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyClusterOutputError>
}

public struct ModifyClusterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyClusterOutputError>
}

/// <p></p>
public struct ModifyClusterInput: Swift.Equatable {
    /// <p>If <code>true</code>, major version upgrades will be applied automatically to the
    ///             cluster during the maintenance window. </p>
    ///         <p>Default: <code>false</code>
    ///         </p>
    public let allowVersionUpgrade: Swift.Bool?
    /// <p>The number of days that automated snapshots are retained. If the value is 0,
    ///             automated snapshots are disabled. Even if automated snapshots are disabled, you can
    ///             still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p>
    ///         <p>If you decrease the automated snapshot retention period from its current value,
    ///             existing automated snapshots that fall outside of the new retention period will be
    ///             immediately deleted.</p>
    ///
    ///         <p>You can't disable automated snapshots for RA3 node types. Set the automated retention period from 1-35 days.</p>
    ///         <p>Default: Uses existing setting.</p>
    ///         <p>Constraints: Must be a value from 0 to 35.</p>
    public let automatedSnapshotRetentionPeriod: Swift.Int?
    /// <p>The option to initiate relocation for an Amazon Redshift cluster to the target Availability Zone.</p>
    public let availabilityZone: Swift.String?
    /// <p>The option to enable relocation for an Amazon Redshift cluster between Availability Zones after the cluster modification is complete.</p>
    public let availabilityZoneRelocation: Swift.Bool?
    /// <p>The unique identifier of the cluster to be modified.</p>
    ///         <p>Example: <code>examplecluster</code>
    ///         </p>
    public let clusterIdentifier: Swift.String?
    /// <p>The name of the cluster parameter group to apply to this cluster. This change is
    ///             applied only after the cluster is rebooted. To reboot a cluster use <a>RebootCluster</a>. </p>
    ///         <p>Default: Uses existing setting.</p>
    ///         <p>Constraints: The cluster parameter group must be in the same parameter group family
    ///             that matches the cluster version.</p>
    public let clusterParameterGroupName: Swift.String?
    /// <p>A list of cluster security groups to be authorized on this cluster. This change is
    ///             asynchronously applied as soon as possible.</p>
    ///         <p>Security groups currently associated with the cluster, and not in the list of
    ///             groups to apply, will be revoked from the cluster.</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Must be 1 to 255 alphanumeric characters or hyphens</p>
    ///             </li>
    ///             <li>
    ///                 <p>First character must be a letter</p>
    ///             </li>
    ///             <li>
    ///                 <p>Cannot end with a hyphen or contain two consecutive hyphens</p>
    ///             </li>
    ///          </ul>
    public let clusterSecurityGroups: [Swift.String]?
    /// <p>The new cluster type.</p>
    ///         <p>When you submit your cluster resize request, your existing cluster goes into a
    ///             read-only mode. After Amazon Redshift provisions a new cluster based on your resize
    ///             requirements, there will be outage for a period while the old cluster is deleted and
    ///             your connection is switched to the new cluster. You can use <a>DescribeResize</a> to track the progress of the resize request. </p>
    ///         <p>Valid Values: <code> multi-node | single-node </code>
    ///         </p>
    public let clusterType: Swift.String?
    /// <p>The new version number of the Amazon Redshift engine to upgrade to.</p>
    ///         <p>For major version upgrades, if a non-default cluster parameter group is currently
    ///             in use, a new cluster parameter group in the cluster parameter group family for the new
    ///             version must be specified. The new cluster parameter group can be the default for that
    ///             cluster parameter group family.
    /// For more information about parameters and parameter groups, go to
    /// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a>
    /// in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
    ///         <p>Example: <code>1.0</code>
    ///         </p>
    public let clusterVersion: Swift.String?
    /// <p>The Elastic IP (EIP) address for the cluster.</p>
    ///         <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible
    ///             through an Internet gateway. For more information about provisioning clusters in
    ///             EC2-VPC, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported
    ///                 Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
    public let elasticIp: Swift.String?
    /// <p>Indicates whether the cluster is encrypted. If the value is encrypted (true) and you
    ///             provide a value for the <code>KmsKeyId</code> parameter, we encrypt the cluster
    ///             with the provided <code>KmsKeyId</code>. If you don't provide a <code>KmsKeyId</code>,
    ///             we encrypt with the default key. </p>
    ///             <p>If the value is not encrypted (false), then the cluster is decrypted. </p>
    public let encrypted: Swift.Bool?
    /// <p>An option that specifies whether to create the cluster with enhanced VPC routing
    ///             enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a
    ///             VPC. For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in
    ///             the Amazon Redshift Cluster Management Guide.</p>
    ///         <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p>
    ///         <p>Default: false</p>
    public let enhancedVpcRouting: Swift.Bool?
    /// <p>Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to
    ///             retrieve the data encryption keys stored in an HSM.</p>
    public let hsmClientCertificateIdentifier: Swift.String?
    /// <p>Specifies the name of the HSM configuration that contains the information the
    ///             Amazon Redshift cluster can use to retrieve and store keys in an HSM.</p>
    public let hsmConfigurationIdentifier: Swift.String?
    /// <p>The AWS Key Management Service (KMS) key ID of the encryption key that you want to use
    ///             to encrypt data in the cluster.</p>
    public let kmsKeyId: Swift.String?
    /// <p>The name for the maintenance track that you want to assign for the cluster. This name
    ///             change is asynchronous. The new track name stays in the
    ///                 <code>PendingModifiedValues</code> for the cluster until the next maintenance
    ///             window. When the maintenance track changes, the cluster is switched to the latest
    ///             cluster release available for the maintenance track. At this point, the maintenance
    ///             track name is applied.</p>
    public let maintenanceTrackName: Swift.String?
    /// <p>The default for number of days that a newly created manual snapshot is retained. If
    ///             the value is -1, the manual snapshot is retained indefinitely. This value doesn't
    ///             retroactively change the retention periods of existing manual snapshots.</p>
    ///         <p>The value must be either -1 or an integer between 1 and 3,653.</p>
    ///         <p>The default value is -1.</p>
    public let manualSnapshotRetentionPeriod: Swift.Int?
    /// <p>The new password for the cluster master user. This change is asynchronously applied
    ///             as soon as possible. Between the time of the request and the completion of the request,
    ///             the <code>MasterUserPassword</code> element exists in the
    ///                 <code>PendingModifiedValues</code> element of the operation response. </p>
    ///         <note>
    ///             <p>Operations never return the password, so this operation provides a way to
    ///                 regain access to the master user account for a cluster if the password is
    ///                 lost.</p>
    ///         </note>
    ///         <p>Default: Uses existing setting.</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Must be between 8 and 64 characters in length.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Must contain at least one uppercase letter.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Must contain at least one lowercase letter.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Must contain one number.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Can be any printable ASCII character (ASCII code 33 to 126) except '
    ///                     (single quote), " (double quote), \, /, @, or space.</p>
    ///             </li>
    ///          </ul>
    public let masterUserPassword: Swift.String?
    /// <p>The new identifier for the cluster.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>Alphabetic characters must be lowercase.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>Must be unique for all clusters within an AWS account.</p>
    ///             </li>
    ///          </ul>
    ///
    ///             <p>Example: <code>examplecluster</code>
    ///         </p>
    public let newClusterIdentifier: Swift.String?
    /// <p>The new node type of the cluster. If you specify a new node type, you must also
    ///             specify the number of nodes parameter.</p>
    ///         <p>
    /// For more information about resizing clusters, go to
    /// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/rs-resize-tutorial.html">Resizing Clusters in Amazon Redshift</a>
    /// in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
    ///
    ///         <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> |
    ///             <code>dc1.large</code> | <code>dc1.8xlarge</code> |
    ///             <code>dc2.large</code> | <code>dc2.8xlarge</code> |
    ///             <code>ra3.xlplus</code> |  <code>ra3.4xlarge</code> | <code>ra3.16xlarge</code>
    ///          </p>
    public let nodeType: Swift.String?
    /// <p>The new number of nodes of the cluster. If you specify a new number of nodes, you
    ///             must also specify the node type parameter.</p>
    ///         <p>
    /// For more information about resizing clusters, go to
    /// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/rs-resize-tutorial.html">Resizing Clusters in Amazon Redshift</a>
    /// in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
    ///
    ///         <p>Valid Values: Integer greater than <code>0</code>.</p>
    public let numberOfNodes: Swift.Int?
    /// <p>The option to change the port of an Amazon Redshift cluster.</p>
    public let port: Swift.Int?
    /// <p>The weekly time range (in UTC) during which system maintenance can occur, if
    ///             necessary. If system maintenance is necessary during the window, it may result in an
    ///             outage.</p>
    ///         <p>This maintenance window change is made immediately. If the new maintenance window
    ///             indicates the current time, there must be at least 120 minutes between the current time
    ///             and end of the window in order to ensure that pending changes are applied.</p>
    ///         <p>Default: Uses existing setting.</p>
    ///         <p>Format: ddd:hh24:mi-ddd:hh24:mi, for example
    ///             <code>wed:07:30-wed:08:00</code>.</p>
    ///         <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p>
    ///         <p>Constraints: Must be at least 30 minutes.</p>
    public let preferredMaintenanceWindow: Swift.String?
    /// <p>If <code>true</code>, the cluster can be accessed from a public network. Only
    ///             clusters in VPCs can be set to be publicly available.</p>
    public let publiclyAccessible: Swift.Bool?
    /// <p>A list of virtual private cloud (VPC) security groups to be associated with the
    ///             cluster. This change is asynchronously applied as soon as possible.</p>
    public let vpcSecurityGroupIds: [Swift.String]?

    public init (
        allowVersionUpgrade: Swift.Bool? = nil,
        automatedSnapshotRetentionPeriod: Swift.Int? = nil,
        availabilityZone: Swift.String? = nil,
        availabilityZoneRelocation: Swift.Bool? = nil,
        clusterIdentifier: Swift.String? = nil,
        clusterParameterGroupName: Swift.String? = nil,
        clusterSecurityGroups: [Swift.String]? = nil,
        clusterType: Swift.String? = nil,
        clusterVersion: Swift.String? = nil,
        elasticIp: Swift.String? = nil,
        encrypted: Swift.Bool? = nil,
        enhancedVpcRouting: Swift.Bool? = nil,
        hsmClientCertificateIdentifier: Swift.String? = nil,
        hsmConfigurationIdentifier: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        maintenanceTrackName: Swift.String? = nil,
        manualSnapshotRetentionPeriod: Swift.Int? = nil,
        masterUserPassword: Swift.String? = nil,
        newClusterIdentifier: Swift.String? = nil,
        nodeType: Swift.String? = nil,
        numberOfNodes: Swift.Int? = nil,
        port: Swift.Int? = nil,
        preferredMaintenanceWindow: Swift.String? = nil,
        publiclyAccessible: Swift.Bool? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil
    )
    {
        self.allowVersionUpgrade = allowVersionUpgrade
        self.automatedSnapshotRetentionPeriod = automatedSnapshotRetentionPeriod
        self.availabilityZone = availabilityZone
        self.availabilityZoneRelocation = availabilityZoneRelocation
        self.clusterIdentifier = clusterIdentifier
        self.clusterParameterGroupName = clusterParameterGroupName
        self.clusterSecurityGroups = clusterSecurityGroups
        self.clusterType = clusterType
        self.clusterVersion = clusterVersion
        self.elasticIp = elasticIp
        self.encrypted = encrypted
        self.enhancedVpcRouting = enhancedVpcRouting
        self.hsmClientCertificateIdentifier = hsmClientCertificateIdentifier
        self.hsmConfigurationIdentifier = hsmConfigurationIdentifier
        self.kmsKeyId = kmsKeyId
        self.maintenanceTrackName = maintenanceTrackName
        self.manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriod
        self.masterUserPassword = masterUserPassword
        self.newClusterIdentifier = newClusterIdentifier
        self.nodeType = nodeType
        self.numberOfNodes = numberOfNodes
        self.port = port
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.publiclyAccessible = publiclyAccessible
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

public struct ModifyClusterMaintenanceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyClusterMaintenanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyClusterMaintenanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyClusterMaintenanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyClusterMaintenanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyClusterMaintenanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyClusterMaintenanceOutputError>
}

extension ModifyClusterMaintenanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyClusterMaintenanceInput(clusterIdentifier: \(Swift.String(describing: clusterIdentifier)), deferMaintenance: \(Swift.String(describing: deferMaintenance)), deferMaintenanceDuration: \(Swift.String(describing: deferMaintenanceDuration)), deferMaintenanceEndTime: \(Swift.String(describing: deferMaintenanceEndTime)), deferMaintenanceIdentifier: \(Swift.String(describing: deferMaintenanceIdentifier)), deferMaintenanceStartTime: \(Swift.String(describing: deferMaintenanceStartTime)))"}
}

extension ModifyClusterMaintenanceInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: ClientRuntime.Key("ClusterIdentifier"))
        }
        if let deferMaintenance = deferMaintenance {
            try container.encode(deferMaintenance, forKey: ClientRuntime.Key("DeferMaintenance"))
        }
        if let deferMaintenanceDuration = deferMaintenanceDuration {
            try container.encode(deferMaintenanceDuration, forKey: ClientRuntime.Key("DeferMaintenanceDuration"))
        }
        if let deferMaintenanceEndTime = deferMaintenanceEndTime {
            try container.encode(ClientRuntime.TimestampWrapper(deferMaintenanceEndTime, format: .dateTime), forKey: ClientRuntime.Key("deferMaintenanceEndTime"))
        }
        if let deferMaintenanceIdentifier = deferMaintenanceIdentifier {
            try container.encode(deferMaintenanceIdentifier, forKey: ClientRuntime.Key("DeferMaintenanceIdentifier"))
        }
        if let deferMaintenanceStartTime = deferMaintenanceStartTime {
            try container.encode(ClientRuntime.TimestampWrapper(deferMaintenanceStartTime, format: .dateTime), forKey: ClientRuntime.Key("deferMaintenanceStartTime"))
        }
        try container.encode("ModifyClusterMaintenance", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ModifyClusterMaintenanceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyClusterMaintenanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyClusterMaintenanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyClusterMaintenanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyClusterMaintenanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyClusterMaintenanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyClusterMaintenanceOutputError>
}

public struct ModifyClusterMaintenanceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyClusterMaintenanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyClusterMaintenanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyClusterMaintenanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyClusterMaintenanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyClusterMaintenanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyClusterMaintenanceOutputError>
}

public struct ModifyClusterMaintenanceInput: Swift.Equatable {
    /// <p>A unique identifier for the cluster.</p>
    public let clusterIdentifier: Swift.String?
    /// <p>A boolean indicating whether to enable the deferred maintenance window. </p>
    public let deferMaintenance: Swift.Bool?
    /// <p>An integer indicating the duration of the maintenance window in days. If you specify a
    ///             duration, you can't specify an end time. The duration must be 45 days or less.</p>
    public let deferMaintenanceDuration: Swift.Int?
    /// <p>A timestamp indicating end time for the deferred maintenance window. If you specify an
    ///             end time, you can't specify a duration.</p>
    public let deferMaintenanceEndTime: ClientRuntime.Date?
    /// <p>A unique identifier for the deferred maintenance window.</p>
    public let deferMaintenanceIdentifier: Swift.String?
    /// <p>A timestamp indicating the start time for the deferred maintenance window.</p>
    public let deferMaintenanceStartTime: ClientRuntime.Date?

    public init (
        clusterIdentifier: Swift.String? = nil,
        deferMaintenance: Swift.Bool? = nil,
        deferMaintenanceDuration: Swift.Int? = nil,
        deferMaintenanceEndTime: ClientRuntime.Date? = nil,
        deferMaintenanceIdentifier: Swift.String? = nil,
        deferMaintenanceStartTime: ClientRuntime.Date? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
        self.deferMaintenance = deferMaintenance
        self.deferMaintenanceDuration = deferMaintenanceDuration
        self.deferMaintenanceEndTime = deferMaintenanceEndTime
        self.deferMaintenanceIdentifier = deferMaintenanceIdentifier
        self.deferMaintenanceStartTime = deferMaintenanceStartTime
    }
}

extension ModifyClusterMaintenanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyClusterMaintenanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyClusterMaintenanceOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyClusterMaintenanceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyClusterMaintenanceOutputResponse(cluster: \(Swift.String(describing: cluster)))"}
}

extension ModifyClusterMaintenanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyClusterMaintenanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct ModifyClusterMaintenanceOutputResponse: Swift.Equatable {
    /// <p>Describes a cluster.</p>
    public let cluster: RedshiftClientTypes.Cluster?

    public init (
        cluster: RedshiftClientTypes.Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct ModifyClusterMaintenanceOutputResponseBody: Swift.Equatable {
    public let cluster: RedshiftClientTypes.Cluster?
}

extension ModifyClusterMaintenanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cluster = "Cluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyClusterMaintenanceResult"))
        let clusterDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

extension ModifyClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterAlreadyExistsFault" : self = .clusterAlreadyExistsFault(try ClusterAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterParameterGroupNotFoundFault" : self = .clusterParameterGroupNotFoundFault(try ClusterParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterSecurityGroupNotFoundFault" : self = .clusterSecurityGroupNotFoundFault(try ClusterSecurityGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependentServiceRequestThrottlingFault" : self = .dependentServiceRequestThrottlingFault(try DependentServiceRequestThrottlingFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HsmClientCertificateNotFoundFault" : self = .hsmClientCertificateNotFoundFault(try HsmClientCertificateNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HsmConfigurationNotFoundFault" : self = .hsmConfigurationNotFoundFault(try HsmConfigurationNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientClusterCapacityFault" : self = .insufficientClusterCapacityFault(try InsufficientClusterCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterSecurityGroupStateFault" : self = .invalidClusterSecurityGroupStateFault(try InvalidClusterSecurityGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterTrackFault" : self = .invalidClusterTrackFault(try InvalidClusterTrackFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidElasticIpFault" : self = .invalidElasticIpFault(try InvalidElasticIpFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRetentionPeriodFault" : self = .invalidRetentionPeriodFault(try InvalidRetentionPeriodFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededFault" : self = .limitExceededFault(try LimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NumberOfNodesPerClusterLimitExceededFault" : self = .numberOfNodesPerClusterLimitExceededFault(try NumberOfNodesPerClusterLimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NumberOfNodesQuotaExceededFault" : self = .numberOfNodesQuotaExceededFault(try NumberOfNodesQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TableLimitExceededFault" : self = .tableLimitExceededFault(try TableLimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOptionFault" : self = .unsupportedOptionFault(try UnsupportedOptionFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyClusterOutputError: Swift.Error, Swift.Equatable {
    case clusterAlreadyExistsFault(ClusterAlreadyExistsFault)
    case clusterNotFoundFault(ClusterNotFoundFault)
    case clusterParameterGroupNotFoundFault(ClusterParameterGroupNotFoundFault)
    case clusterSecurityGroupNotFoundFault(ClusterSecurityGroupNotFoundFault)
    case dependentServiceRequestThrottlingFault(DependentServiceRequestThrottlingFault)
    case hsmClientCertificateNotFoundFault(HsmClientCertificateNotFoundFault)
    case hsmConfigurationNotFoundFault(HsmConfigurationNotFoundFault)
    case insufficientClusterCapacityFault(InsufficientClusterCapacityFault)
    case invalidClusterSecurityGroupStateFault(InvalidClusterSecurityGroupStateFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidClusterTrackFault(InvalidClusterTrackFault)
    case invalidElasticIpFault(InvalidElasticIpFault)
    case invalidRetentionPeriodFault(InvalidRetentionPeriodFault)
    case limitExceededFault(LimitExceededFault)
    case numberOfNodesPerClusterLimitExceededFault(NumberOfNodesPerClusterLimitExceededFault)
    case numberOfNodesQuotaExceededFault(NumberOfNodesQuotaExceededFault)
    case tableLimitExceededFault(TableLimitExceededFault)
    case unauthorizedOperation(UnauthorizedOperation)
    case unsupportedOptionFault(UnsupportedOptionFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyClusterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyClusterOutputResponse(cluster: \(Swift.String(describing: cluster)))"}
}

extension ModifyClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct ModifyClusterOutputResponse: Swift.Equatable {
    /// <p>Describes a cluster.</p>
    public let cluster: RedshiftClientTypes.Cluster?

    public init (
        cluster: RedshiftClientTypes.Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct ModifyClusterOutputResponseBody: Swift.Equatable {
    public let cluster: RedshiftClientTypes.Cluster?
}

extension ModifyClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cluster = "Cluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyClusterResult"))
        let clusterDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

public struct ModifyClusterParameterGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyClusterParameterGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyClusterParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyClusterParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyClusterParameterGroupOutputError>
}

extension ModifyClusterParameterGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyClusterParameterGroupInput(parameterGroupName: \(Swift.String(describing: parameterGroupName)), parameters: \(Swift.String(describing: parameters)))"}
}

extension ModifyClusterParameterGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let parameterGroupName = parameterGroupName {
            try container.encode(parameterGroupName, forKey: ClientRuntime.Key("ParameterGroupName"))
        }
        if let parameters = parameters {
            var parametersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Parameters"))
            for (index0, parameter0) in parameters.enumerated() {
                try parametersContainer.encode(parameter0, forKey: ClientRuntime.Key("Parameter.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ModifyClusterParameterGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ModifyClusterParameterGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyClusterParameterGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyClusterParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyClusterParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyClusterParameterGroupOutputError>
}

public struct ModifyClusterParameterGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyClusterParameterGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyClusterParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyClusterParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyClusterParameterGroupOutputError>
}

/// <p>Describes a modify cluster parameter group operation. </p>
public struct ModifyClusterParameterGroupInput: Swift.Equatable {
    /// <p>The name of the parameter group to be modified.</p>
    public let parameterGroupName: Swift.String?
    /// <p>An array of parameters to be modified. A maximum of 20 parameters can be modified
    ///             in a single request.</p>
    ///         <p>For each parameter to be modified, you must supply at least the parameter name and
    ///             parameter value; other name-value pairs of the parameter are optional.</p>
    ///         <p>For the workload management (WLM) configuration, you must supply all the name-value
    ///             pairs in the wlm_json_configuration parameter.</p>
    public let parameters: [RedshiftClientTypes.Parameter]?

    public init (
        parameterGroupName: Swift.String? = nil,
        parameters: [RedshiftClientTypes.Parameter]? = nil
    )
    {
        self.parameterGroupName = parameterGroupName
        self.parameters = parameters
    }
}

extension ModifyClusterParameterGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyClusterParameterGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterParameterGroupNotFoundFault" : self = .clusterParameterGroupNotFoundFault(try ClusterParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterParameterGroupStateFault" : self = .invalidClusterParameterGroupStateFault(try InvalidClusterParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyClusterParameterGroupOutputError: Swift.Error, Swift.Equatable {
    case clusterParameterGroupNotFoundFault(ClusterParameterGroupNotFoundFault)
    case invalidClusterParameterGroupStateFault(InvalidClusterParameterGroupStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyClusterParameterGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyClusterParameterGroupOutputResponse(parameterGroupName: \(Swift.String(describing: parameterGroupName)), parameterGroupStatus: \(Swift.String(describing: parameterGroupStatus)))"}
}

extension ModifyClusterParameterGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyClusterParameterGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.parameterGroupName = output.parameterGroupName
            self.parameterGroupStatus = output.parameterGroupStatus
        } else {
            self.parameterGroupName = nil
            self.parameterGroupStatus = nil
        }
    }
}

/// <p></p>
public struct ModifyClusterParameterGroupOutputResponse: Swift.Equatable {
    /// <p>The name of the cluster parameter group.</p>
    public let parameterGroupName: Swift.String?
    /// <p>The status of the parameter group. For example, if you made a change to a parameter
    ///             group name-value pair, then the change could be pending a reboot of an associated
    ///             cluster.</p>
    public let parameterGroupStatus: Swift.String?

    public init (
        parameterGroupName: Swift.String? = nil,
        parameterGroupStatus: Swift.String? = nil
    )
    {
        self.parameterGroupName = parameterGroupName
        self.parameterGroupStatus = parameterGroupStatus
    }
}

struct ModifyClusterParameterGroupOutputResponseBody: Swift.Equatable {
    public let parameterGroupName: Swift.String?
    public let parameterGroupStatus: Swift.String?
}

extension ModifyClusterParameterGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterGroupName = "ParameterGroupName"
        case parameterGroupStatus = "ParameterGroupStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyClusterParameterGroupResult"))
        let parameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterGroupName)
        parameterGroupName = parameterGroupNameDecoded
        let parameterGroupStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterGroupStatus)
        parameterGroupStatus = parameterGroupStatusDecoded
    }
}

public struct ModifyClusterSnapshotInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyClusterSnapshotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyClusterSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyClusterSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyClusterSnapshotOutputError>
}

extension ModifyClusterSnapshotInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyClusterSnapshotInput(force: \(Swift.String(describing: force)), manualSnapshotRetentionPeriod: \(Swift.String(describing: manualSnapshotRetentionPeriod)), snapshotIdentifier: \(Swift.String(describing: snapshotIdentifier)))"}
}

extension ModifyClusterSnapshotInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if force != false {
            try container.encode(force, forKey: ClientRuntime.Key("Force"))
        }
        if let manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriod {
            try container.encode(manualSnapshotRetentionPeriod, forKey: ClientRuntime.Key("ManualSnapshotRetentionPeriod"))
        }
        if let snapshotIdentifier = snapshotIdentifier {
            try container.encode(snapshotIdentifier, forKey: ClientRuntime.Key("SnapshotIdentifier"))
        }
        try container.encode("ModifyClusterSnapshot", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ModifyClusterSnapshotInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyClusterSnapshotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyClusterSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyClusterSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyClusterSnapshotOutputError>
}

public struct ModifyClusterSnapshotInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyClusterSnapshotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyClusterSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyClusterSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyClusterSnapshotOutputError>
}

public struct ModifyClusterSnapshotInput: Swift.Equatable {
    /// <p>A Boolean option to override an exception if the retention period has already
    ///             passed.</p>
    public let force: Swift.Bool
    /// <p>The number of days that a manual snapshot is retained. If the value is -1, the manual
    ///             snapshot is retained indefinitely.</p>
    ///         <p>If the manual snapshot falls outside of the new retention period, you can specify the
    ///             force option to immediately delete the snapshot.</p>
    ///         <p>The value must be either -1 or an integer between 1 and 3,653.</p>
    public let manualSnapshotRetentionPeriod: Swift.Int?
    /// <p>The identifier of the snapshot whose setting you want to modify.</p>
    public let snapshotIdentifier: Swift.String?

    public init (
        force: Swift.Bool = false,
        manualSnapshotRetentionPeriod: Swift.Int? = nil,
        snapshotIdentifier: Swift.String? = nil
    )
    {
        self.force = force
        self.manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriod
        self.snapshotIdentifier = snapshotIdentifier
    }
}

extension ModifyClusterSnapshotOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyClusterSnapshotOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterSnapshotNotFoundFault" : self = .clusterSnapshotNotFoundFault(try ClusterSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterSnapshotStateFault" : self = .invalidClusterSnapshotStateFault(try InvalidClusterSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRetentionPeriodFault" : self = .invalidRetentionPeriodFault(try InvalidRetentionPeriodFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyClusterSnapshotOutputError: Swift.Error, Swift.Equatable {
    case clusterSnapshotNotFoundFault(ClusterSnapshotNotFoundFault)
    case invalidClusterSnapshotStateFault(InvalidClusterSnapshotStateFault)
    case invalidRetentionPeriodFault(InvalidRetentionPeriodFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyClusterSnapshotOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyClusterSnapshotOutputResponse(snapshot: \(Swift.String(describing: snapshot)))"}
}

extension ModifyClusterSnapshotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyClusterSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.snapshot = output.snapshot
        } else {
            self.snapshot = nil
        }
    }
}

public struct ModifyClusterSnapshotOutputResponse: Swift.Equatable {
    /// <p>Describes a snapshot.</p>
    public let snapshot: RedshiftClientTypes.Snapshot?

    public init (
        snapshot: RedshiftClientTypes.Snapshot? = nil
    )
    {
        self.snapshot = snapshot
    }
}

struct ModifyClusterSnapshotOutputResponseBody: Swift.Equatable {
    public let snapshot: RedshiftClientTypes.Snapshot?
}

extension ModifyClusterSnapshotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshot = "Snapshot"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyClusterSnapshotResult"))
        let snapshotDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.Snapshot.self, forKey: .snapshot)
        snapshot = snapshotDecoded
    }
}

public struct ModifyClusterSnapshotScheduleInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyClusterSnapshotScheduleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyClusterSnapshotScheduleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyClusterSnapshotScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyClusterSnapshotScheduleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyClusterSnapshotScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyClusterSnapshotScheduleOutputError>
}

extension ModifyClusterSnapshotScheduleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyClusterSnapshotScheduleInput(clusterIdentifier: \(Swift.String(describing: clusterIdentifier)), disassociateSchedule: \(Swift.String(describing: disassociateSchedule)), scheduleIdentifier: \(Swift.String(describing: scheduleIdentifier)))"}
}

extension ModifyClusterSnapshotScheduleInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: ClientRuntime.Key("ClusterIdentifier"))
        }
        if let disassociateSchedule = disassociateSchedule {
            try container.encode(disassociateSchedule, forKey: ClientRuntime.Key("DisassociateSchedule"))
        }
        if let scheduleIdentifier = scheduleIdentifier {
            try container.encode(scheduleIdentifier, forKey: ClientRuntime.Key("ScheduleIdentifier"))
        }
        try container.encode("ModifyClusterSnapshotSchedule", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ModifyClusterSnapshotScheduleInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyClusterSnapshotScheduleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyClusterSnapshotScheduleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyClusterSnapshotScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyClusterSnapshotScheduleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyClusterSnapshotScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyClusterSnapshotScheduleOutputError>
}

public struct ModifyClusterSnapshotScheduleInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyClusterSnapshotScheduleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyClusterSnapshotScheduleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyClusterSnapshotScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyClusterSnapshotScheduleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyClusterSnapshotScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyClusterSnapshotScheduleOutputError>
}

public struct ModifyClusterSnapshotScheduleInput: Swift.Equatable {
    /// <p>A unique identifier for the cluster whose snapshot schedule you want to modify.
    ///         </p>
    public let clusterIdentifier: Swift.String?
    /// <p>A boolean to indicate whether to remove the assoiciation between the cluster and the
    ///             schedule.</p>
    public let disassociateSchedule: Swift.Bool?
    /// <p>A unique alphanumeric identifier for the schedule that you want to associate with the
    ///             cluster.</p>
    public let scheduleIdentifier: Swift.String?

    public init (
        clusterIdentifier: Swift.String? = nil,
        disassociateSchedule: Swift.Bool? = nil,
        scheduleIdentifier: Swift.String? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
        self.disassociateSchedule = disassociateSchedule
        self.scheduleIdentifier = scheduleIdentifier
    }
}

extension ModifyClusterSnapshotScheduleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyClusterSnapshotScheduleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterSnapshotScheduleStateFault" : self = .invalidClusterSnapshotScheduleStateFault(try InvalidClusterSnapshotScheduleStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotScheduleNotFoundFault" : self = .snapshotScheduleNotFoundFault(try SnapshotScheduleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyClusterSnapshotScheduleOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case invalidClusterSnapshotScheduleStateFault(InvalidClusterSnapshotScheduleStateFault)
    case snapshotScheduleNotFoundFault(SnapshotScheduleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyClusterSnapshotScheduleOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyClusterSnapshotScheduleOutputResponse()"}
}

extension ModifyClusterSnapshotScheduleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ModifyClusterSnapshotScheduleOutputResponse: Swift.Equatable {

    public init() {}
}

struct ModifyClusterSnapshotScheduleOutputResponseBody: Swift.Equatable {
}

extension ModifyClusterSnapshotScheduleOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct ModifyClusterSubnetGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyClusterSubnetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyClusterSubnetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyClusterSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyClusterSubnetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyClusterSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyClusterSubnetGroupOutputError>
}

extension ModifyClusterSubnetGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyClusterSubnetGroupInput(clusterSubnetGroupName: \(Swift.String(describing: clusterSubnetGroupName)), description: \(Swift.String(describing: description)), subnetIds: \(Swift.String(describing: subnetIds)))"}
}

extension ModifyClusterSubnetGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let clusterSubnetGroupName = clusterSubnetGroupName {
            try container.encode(clusterSubnetGroupName, forKey: ClientRuntime.Key("ClusterSubnetGroupName"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SubnetIds"))
            for (index0, string0) in subnetIds.enumerated() {
                try subnetIdsContainer.encode(string0, forKey: ClientRuntime.Key("SubnetIdentifier.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ModifyClusterSubnetGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ModifyClusterSubnetGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyClusterSubnetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyClusterSubnetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyClusterSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyClusterSubnetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyClusterSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyClusterSubnetGroupOutputError>
}

public struct ModifyClusterSubnetGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyClusterSubnetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyClusterSubnetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyClusterSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyClusterSubnetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyClusterSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyClusterSubnetGroupOutputError>
}

/// <p></p>
public struct ModifyClusterSubnetGroupInput: Swift.Equatable {
    /// <p>The name of the subnet group to be modified.</p>
    public let clusterSubnetGroupName: Swift.String?
    /// <p>A text description of the subnet group to be modified.</p>
    public let description: Swift.String?
    /// <p>An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single
    ///             request.</p>
    public let subnetIds: [Swift.String]?

    public init (
        clusterSubnetGroupName: Swift.String? = nil,
        description: Swift.String? = nil,
        subnetIds: [Swift.String]? = nil
    )
    {
        self.clusterSubnetGroupName = clusterSubnetGroupName
        self.description = description
        self.subnetIds = subnetIds
    }
}

extension ModifyClusterSubnetGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyClusterSubnetGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterSubnetGroupNotFoundFault" : self = .clusterSubnetGroupNotFoundFault(try ClusterSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterSubnetQuotaExceededFault" : self = .clusterSubnetQuotaExceededFault(try ClusterSubnetQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependentServiceRequestThrottlingFault" : self = .dependentServiceRequestThrottlingFault(try DependentServiceRequestThrottlingFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetAlreadyInUse" : self = .subnetAlreadyInUse(try SubnetAlreadyInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyClusterSubnetGroupOutputError: Swift.Error, Swift.Equatable {
    case clusterSubnetGroupNotFoundFault(ClusterSubnetGroupNotFoundFault)
    case clusterSubnetQuotaExceededFault(ClusterSubnetQuotaExceededFault)
    case dependentServiceRequestThrottlingFault(DependentServiceRequestThrottlingFault)
    case invalidSubnet(InvalidSubnet)
    case subnetAlreadyInUse(SubnetAlreadyInUse)
    case unauthorizedOperation(UnauthorizedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyClusterSubnetGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyClusterSubnetGroupOutputResponse(clusterSubnetGroup: \(Swift.String(describing: clusterSubnetGroup)))"}
}

extension ModifyClusterSubnetGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyClusterSubnetGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clusterSubnetGroup = output.clusterSubnetGroup
        } else {
            self.clusterSubnetGroup = nil
        }
    }
}

public struct ModifyClusterSubnetGroupOutputResponse: Swift.Equatable {
    /// <p>Describes a subnet group.</p>
    public let clusterSubnetGroup: RedshiftClientTypes.ClusterSubnetGroup?

    public init (
        clusterSubnetGroup: RedshiftClientTypes.ClusterSubnetGroup? = nil
    )
    {
        self.clusterSubnetGroup = clusterSubnetGroup
    }
}

struct ModifyClusterSubnetGroupOutputResponseBody: Swift.Equatable {
    public let clusterSubnetGroup: RedshiftClientTypes.ClusterSubnetGroup?
}

extension ModifyClusterSubnetGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterSubnetGroup = "ClusterSubnetGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyClusterSubnetGroupResult"))
        let clusterSubnetGroupDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.ClusterSubnetGroup.self, forKey: .clusterSubnetGroup)
        clusterSubnetGroup = clusterSubnetGroupDecoded
    }
}

public struct ModifyEndpointAccessInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyEndpointAccessInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyEndpointAccessInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyEndpointAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyEndpointAccessInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyEndpointAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyEndpointAccessOutputError>
}

extension ModifyEndpointAccessInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyEndpointAccessInput(endpointName: \(Swift.String(describing: endpointName)), vpcSecurityGroupIds: \(Swift.String(describing: vpcSecurityGroupIds)))"}
}

extension ModifyEndpointAccessInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let endpointName = endpointName {
            try container.encode(endpointName, forKey: ClientRuntime.Key("EndpointName"))
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: ClientRuntime.Key("VpcSecurityGroupId.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ModifyEndpointAccess", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ModifyEndpointAccessInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyEndpointAccessInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyEndpointAccessInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyEndpointAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyEndpointAccessInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyEndpointAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyEndpointAccessOutputError>
}

public struct ModifyEndpointAccessInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyEndpointAccessInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyEndpointAccessInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyEndpointAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyEndpointAccessInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyEndpointAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyEndpointAccessOutputError>
}

public struct ModifyEndpointAccessInput: Swift.Equatable {
    /// <p>The endpoint to be modified.</p>
    public let endpointName: Swift.String?
    /// <p>The complete list of VPC security groups associated with the endpoint after the endpoint is modified.</p>
    public let vpcSecurityGroupIds: [Swift.String]?

    public init (
        endpointName: Swift.String? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil
    )
    {
        self.endpointName = endpointName
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

extension ModifyEndpointAccessOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyEndpointAccessOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EndpointNotFoundFault" : self = .endpointNotFoundFault(try EndpointNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterSecurityGroupStateFault" : self = .invalidClusterSecurityGroupStateFault(try InvalidClusterSecurityGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointStateFault" : self = .invalidEndpointStateFault(try InvalidEndpointStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyEndpointAccessOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case endpointNotFoundFault(EndpointNotFoundFault)
    case invalidClusterSecurityGroupStateFault(InvalidClusterSecurityGroupStateFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidEndpointStateFault(InvalidEndpointStateFault)
    case unauthorizedOperation(UnauthorizedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyEndpointAccessOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyEndpointAccessOutputResponse(address: \(Swift.String(describing: address)), clusterIdentifier: \(Swift.String(describing: clusterIdentifier)), endpointCreateTime: \(Swift.String(describing: endpointCreateTime)), endpointName: \(Swift.String(describing: endpointName)), endpointStatus: \(Swift.String(describing: endpointStatus)), port: \(Swift.String(describing: port)), resourceOwner: \(Swift.String(describing: resourceOwner)), subnetGroupName: \(Swift.String(describing: subnetGroupName)), vpcEndpoint: \(Swift.String(describing: vpcEndpoint)), vpcSecurityGroups: \(Swift.String(describing: vpcSecurityGroups)))"}
}

extension ModifyEndpointAccessOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyEndpointAccessOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.address = output.address
            self.clusterIdentifier = output.clusterIdentifier
            self.endpointCreateTime = output.endpointCreateTime
            self.endpointName = output.endpointName
            self.endpointStatus = output.endpointStatus
            self.port = output.port
            self.resourceOwner = output.resourceOwner
            self.subnetGroupName = output.subnetGroupName
            self.vpcEndpoint = output.vpcEndpoint
            self.vpcSecurityGroups = output.vpcSecurityGroups
        } else {
            self.address = nil
            self.clusterIdentifier = nil
            self.endpointCreateTime = nil
            self.endpointName = nil
            self.endpointStatus = nil
            self.port = 0
            self.resourceOwner = nil
            self.subnetGroupName = nil
            self.vpcEndpoint = nil
            self.vpcSecurityGroups = nil
        }
    }
}

/// <p>Describes a Redshift-managed VPC endpoint.</p>
public struct ModifyEndpointAccessOutputResponse: Swift.Equatable {
    /// <p>The DNS address of the endpoint.</p>
    public let address: Swift.String?
    /// <p>The cluster identifier of the cluster associated with the endpoint.</p>
    public let clusterIdentifier: Swift.String?
    /// <p>The time (UTC) that the endpoint was created.</p>
    public let endpointCreateTime: ClientRuntime.Date?
    /// <p>The name of the endpoint.</p>
    public let endpointName: Swift.String?
    /// <p>The status of the endpoint.</p>
    public let endpointStatus: Swift.String?
    /// <p>The port number on which the cluster accepts incoming connections.</p>
    public let port: Swift.Int
    /// <p>The AWS account ID of the owner of the cluster.</p>
    public let resourceOwner: Swift.String?
    /// <p>The subnet group name where Amazon Redshift chooses to deploy the endpoint.</p>
    public let subnetGroupName: Swift.String?
    /// <p>The connection endpoint for connecting to an Amazon Redshift cluster through the proxy.</p>
    public let vpcEndpoint: RedshiftClientTypes.VpcEndpoint?
    /// <p>The security groups associated with the endpoint.</p>
    public let vpcSecurityGroups: [RedshiftClientTypes.VpcSecurityGroupMembership]?

    public init (
        address: Swift.String? = nil,
        clusterIdentifier: Swift.String? = nil,
        endpointCreateTime: ClientRuntime.Date? = nil,
        endpointName: Swift.String? = nil,
        endpointStatus: Swift.String? = nil,
        port: Swift.Int = 0,
        resourceOwner: Swift.String? = nil,
        subnetGroupName: Swift.String? = nil,
        vpcEndpoint: RedshiftClientTypes.VpcEndpoint? = nil,
        vpcSecurityGroups: [RedshiftClientTypes.VpcSecurityGroupMembership]? = nil
    )
    {
        self.address = address
        self.clusterIdentifier = clusterIdentifier
        self.endpointCreateTime = endpointCreateTime
        self.endpointName = endpointName
        self.endpointStatus = endpointStatus
        self.port = port
        self.resourceOwner = resourceOwner
        self.subnetGroupName = subnetGroupName
        self.vpcEndpoint = vpcEndpoint
        self.vpcSecurityGroups = vpcSecurityGroups
    }
}

struct ModifyEndpointAccessOutputResponseBody: Swift.Equatable {
    public let clusterIdentifier: Swift.String?
    public let resourceOwner: Swift.String?
    public let subnetGroupName: Swift.String?
    public let endpointStatus: Swift.String?
    public let endpointName: Swift.String?
    public let endpointCreateTime: ClientRuntime.Date?
    public let port: Swift.Int
    public let address: Swift.String?
    public let vpcSecurityGroups: [RedshiftClientTypes.VpcSecurityGroupMembership]?
    public let vpcEndpoint: RedshiftClientTypes.VpcEndpoint?
}

extension ModifyEndpointAccessOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
        case clusterIdentifier = "ClusterIdentifier"
        case endpointCreateTime = "EndpointCreateTime"
        case endpointName = "EndpointName"
        case endpointStatus = "EndpointStatus"
        case port = "Port"
        case resourceOwner = "ResourceOwner"
        case subnetGroupName = "SubnetGroupName"
        case vpcEndpoint = "VpcEndpoint"
        case vpcSecurityGroups = "VpcSecurityGroups"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyEndpointAccessResult"))
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let resourceOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceOwner)
        resourceOwner = resourceOwnerDecoded
        let subnetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetGroupName)
        subnetGroupName = subnetGroupNameDecoded
        let endpointStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointStatus)
        endpointStatus = endpointStatusDecoded
        let endpointNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointName)
        endpointName = endpointNameDecoded
        let endpointCreateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointCreateTime)
        var endpointCreateTimeBuffer:ClientRuntime.Date? = nil
        if let endpointCreateTimeDecoded = endpointCreateTimeDecoded {
            endpointCreateTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(endpointCreateTimeDecoded, format: .dateTime)
        }
        endpointCreateTime = endpointCreateTimeBuffer
        let portDecoded = try containerValues.decode(Swift.Int.self, forKey: .port)
        port = portDecoded
        let addressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .address)
        address = addressDecoded
        if containerValues.contains(.vpcSecurityGroups) {
            struct KeyVal0{struct VpcSecurityGroup{}}
            let vpcSecurityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.VpcSecurityGroup>.CodingKeys.self, forKey: .vpcSecurityGroups)
            if let vpcSecurityGroupsWrappedContainer = vpcSecurityGroupsWrappedContainer {
                let vpcSecurityGroupsContainer = try vpcSecurityGroupsWrappedContainer.decodeIfPresent([RedshiftClientTypes.VpcSecurityGroupMembership].self, forKey: .member)
                var vpcSecurityGroupsBuffer:[RedshiftClientTypes.VpcSecurityGroupMembership]? = nil
                if let vpcSecurityGroupsContainer = vpcSecurityGroupsContainer {
                    vpcSecurityGroupsBuffer = [RedshiftClientTypes.VpcSecurityGroupMembership]()
                    for structureContainer0 in vpcSecurityGroupsContainer {
                        vpcSecurityGroupsBuffer?.append(structureContainer0)
                    }
                }
                vpcSecurityGroups = vpcSecurityGroupsBuffer
            } else {
                vpcSecurityGroups = []
            }
        } else {
            vpcSecurityGroups = nil
        }
        let vpcEndpointDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.VpcEndpoint.self, forKey: .vpcEndpoint)
        vpcEndpoint = vpcEndpointDecoded
    }
}

public struct ModifyEventSubscriptionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyEventSubscriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyEventSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyEventSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyEventSubscriptionOutputError>
}

extension ModifyEventSubscriptionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyEventSubscriptionInput(enabled: \(Swift.String(describing: enabled)), eventCategories: \(Swift.String(describing: eventCategories)), severity: \(Swift.String(describing: severity)), snsTopicArn: \(Swift.String(describing: snsTopicArn)), sourceIds: \(Swift.String(describing: sourceIds)), sourceType: \(Swift.String(describing: sourceType)), subscriptionName: \(Swift.String(describing: subscriptionName)))"}
}

extension ModifyEventSubscriptionInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let enabled = enabled {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let eventCategories = eventCategories {
            var eventCategoriesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EventCategories"))
            for (index0, string0) in eventCategories.enumerated() {
                try eventCategoriesContainer.encode(string0, forKey: ClientRuntime.Key("EventCategory.\(index0.advanced(by: 1))"))
            }
        }
        if let severity = severity {
            try container.encode(severity, forKey: ClientRuntime.Key("Severity"))
        }
        if let snsTopicArn = snsTopicArn {
            try container.encode(snsTopicArn, forKey: ClientRuntime.Key("SnsTopicArn"))
        }
        if let sourceIds = sourceIds {
            var sourceIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SourceIds"))
            for (index0, string0) in sourceIds.enumerated() {
                try sourceIdsContainer.encode(string0, forKey: ClientRuntime.Key("SourceId.\(index0.advanced(by: 1))"))
            }
        }
        if let sourceType = sourceType {
            try container.encode(sourceType, forKey: ClientRuntime.Key("SourceType"))
        }
        if let subscriptionName = subscriptionName {
            try container.encode(subscriptionName, forKey: ClientRuntime.Key("SubscriptionName"))
        }
        try container.encode("ModifyEventSubscription", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ModifyEventSubscriptionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyEventSubscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyEventSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyEventSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyEventSubscriptionOutputError>
}

public struct ModifyEventSubscriptionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyEventSubscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyEventSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyEventSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyEventSubscriptionOutputError>
}

/// <p></p>
public struct ModifyEventSubscriptionInput: Swift.Equatable {
    /// <p>A Boolean value indicating if the subscription is enabled. <code>true</code>
    ///             indicates the subscription is enabled </p>
    public let enabled: Swift.Bool?
    /// <p>Specifies the Amazon Redshift event categories to be published by the event notification
    ///             subscription.</p>
    ///         <p>Values: configuration, management, monitoring, security</p>
    public let eventCategories: [Swift.String]?
    /// <p>Specifies the Amazon Redshift event severity to be published by the event notification
    ///             subscription.</p>
    ///         <p>Values: ERROR, INFO</p>
    public let severity: Swift.String?
    /// <p>The Amazon Resource Name (ARN) of the SNS topic to be used by the event
    ///             notification subscription.</p>
    public let snsTopicArn: Swift.String?
    /// <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects
    ///             must be of the same type as was specified in the source type parameter. The event
    ///             subscription will return only events generated by the specified objects. If not
    ///             specified, then events are returned for all objects within the source type
    ///             specified.</p>
    ///         <p>Example: my-cluster-1, my-cluster-2</p>
    ///         <p>Example: my-snapshot-20131010</p>
    public let sourceIds: [Swift.String]?
    /// <p>The type of source that will be generating the events. For example, if you want to
    ///             be notified of events generated by a cluster, you would set this parameter to cluster.
    ///             If this value is not specified, events are returned for all Amazon Redshift objects in your
    ///             AWS account. You must specify a source type in order to specify source IDs.</p>
    ///         <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, cluster-snapshot, and scheduled-action.</p>
    public let sourceType: Swift.String?
    /// <p>The name of the modified Amazon Redshift event notification subscription.</p>
    public let subscriptionName: Swift.String?

    public init (
        enabled: Swift.Bool? = nil,
        eventCategories: [Swift.String]? = nil,
        severity: Swift.String? = nil,
        snsTopicArn: Swift.String? = nil,
        sourceIds: [Swift.String]? = nil,
        sourceType: Swift.String? = nil,
        subscriptionName: Swift.String? = nil
    )
    {
        self.enabled = enabled
        self.eventCategories = eventCategories
        self.severity = severity
        self.snsTopicArn = snsTopicArn
        self.sourceIds = sourceIds
        self.sourceType = sourceType
        self.subscriptionName = subscriptionName
    }
}

extension ModifyEventSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyEventSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidSubscriptionStateFault" : self = .invalidSubscriptionStateFault(try InvalidSubscriptionStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SNSInvalidTopicFault" : self = .sNSInvalidTopicFault(try SNSInvalidTopicFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SNSNoAuthorizationFault" : self = .sNSNoAuthorizationFault(try SNSNoAuthorizationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SNSTopicArnNotFoundFault" : self = .sNSTopicArnNotFoundFault(try SNSTopicArnNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SourceNotFoundFault" : self = .sourceNotFoundFault(try SourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionCategoryNotFoundFault" : self = .subscriptionCategoryNotFoundFault(try SubscriptionCategoryNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionEventIdNotFoundFault" : self = .subscriptionEventIdNotFoundFault(try SubscriptionEventIdNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionNotFoundFault" : self = .subscriptionNotFoundFault(try SubscriptionNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionSeverityNotFoundFault" : self = .subscriptionSeverityNotFoundFault(try SubscriptionSeverityNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyEventSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case invalidSubscriptionStateFault(InvalidSubscriptionStateFault)
    case sNSInvalidTopicFault(SNSInvalidTopicFault)
    case sNSNoAuthorizationFault(SNSNoAuthorizationFault)
    case sNSTopicArnNotFoundFault(SNSTopicArnNotFoundFault)
    case sourceNotFoundFault(SourceNotFoundFault)
    case subscriptionCategoryNotFoundFault(SubscriptionCategoryNotFoundFault)
    case subscriptionEventIdNotFoundFault(SubscriptionEventIdNotFoundFault)
    case subscriptionNotFoundFault(SubscriptionNotFoundFault)
    case subscriptionSeverityNotFoundFault(SubscriptionSeverityNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyEventSubscriptionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyEventSubscriptionOutputResponse(eventSubscription: \(Swift.String(describing: eventSubscription)))"}
}

extension ModifyEventSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyEventSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventSubscription = output.eventSubscription
        } else {
            self.eventSubscription = nil
        }
    }
}

public struct ModifyEventSubscriptionOutputResponse: Swift.Equatable {
    /// <p>Describes event subscriptions.</p>
    public let eventSubscription: RedshiftClientTypes.EventSubscription?

    public init (
        eventSubscription: RedshiftClientTypes.EventSubscription? = nil
    )
    {
        self.eventSubscription = eventSubscription
    }
}

struct ModifyEventSubscriptionOutputResponseBody: Swift.Equatable {
    public let eventSubscription: RedshiftClientTypes.EventSubscription?
}

extension ModifyEventSubscriptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSubscription = "EventSubscription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyEventSubscriptionResult"))
        let eventSubscriptionDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.EventSubscription.self, forKey: .eventSubscription)
        eventSubscription = eventSubscriptionDecoded
    }
}

public struct ModifyScheduledActionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyScheduledActionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyScheduledActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyScheduledActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyScheduledActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyScheduledActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyScheduledActionOutputError>
}

extension ModifyScheduledActionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyScheduledActionInput(enable: \(Swift.String(describing: enable)), endTime: \(Swift.String(describing: endTime)), iamRole: \(Swift.String(describing: iamRole)), schedule: \(Swift.String(describing: schedule)), scheduledActionDescription: \(Swift.String(describing: scheduledActionDescription)), scheduledActionName: \(Swift.String(describing: scheduledActionName)), startTime: \(Swift.String(describing: startTime)), targetAction: \(Swift.String(describing: targetAction)))"}
}

extension ModifyScheduledActionInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let enable = enable {
            try container.encode(enable, forKey: ClientRuntime.Key("Enable"))
        }
        if let endTime = endTime {
            try container.encode(ClientRuntime.TimestampWrapper(endTime, format: .dateTime), forKey: ClientRuntime.Key("endTime"))
        }
        if let iamRole = iamRole {
            try container.encode(iamRole, forKey: ClientRuntime.Key("IamRole"))
        }
        if let schedule = schedule {
            try container.encode(schedule, forKey: ClientRuntime.Key("Schedule"))
        }
        if let scheduledActionDescription = scheduledActionDescription {
            try container.encode(scheduledActionDescription, forKey: ClientRuntime.Key("ScheduledActionDescription"))
        }
        if let scheduledActionName = scheduledActionName {
            try container.encode(scheduledActionName, forKey: ClientRuntime.Key("ScheduledActionName"))
        }
        if let startTime = startTime {
            try container.encode(ClientRuntime.TimestampWrapper(startTime, format: .dateTime), forKey: ClientRuntime.Key("startTime"))
        }
        if let targetAction = targetAction {
            try container.encode(targetAction, forKey: ClientRuntime.Key("TargetAction"))
        }
        try container.encode("ModifyScheduledAction", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ModifyScheduledActionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyScheduledActionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyScheduledActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyScheduledActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyScheduledActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyScheduledActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyScheduledActionOutputError>
}

public struct ModifyScheduledActionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyScheduledActionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyScheduledActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyScheduledActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyScheduledActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyScheduledActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyScheduledActionOutputError>
}

public struct ModifyScheduledActionInput: Swift.Equatable {
    /// <p>A modified enable flag of the scheduled action. If true, the scheduled action is active. If false, the scheduled action is disabled. </p>
    public let enable: Swift.Bool?
    /// <p>A modified end time of the scheduled action.
    ///             For more information about this parameter, see <a>ScheduledAction</a>. </p>
    public let endTime: ClientRuntime.Date?
    /// <p>A different IAM role to assume to run the target action.
    ///             For more information about this parameter, see <a>ScheduledAction</a>.</p>
    public let iamRole: Swift.String?
    /// <p>A modified schedule in either <code>at( )</code> or <code>cron( )</code> format.
    ///             For more information about this parameter, see <a>ScheduledAction</a>.</p>
    public let schedule: Swift.String?
    /// <p>A modified description of the scheduled action. </p>
    public let scheduledActionDescription: Swift.String?
    /// <p>The name of the scheduled action to modify. </p>
    public let scheduledActionName: Swift.String?
    /// <p>A modified start time of the scheduled action.
    ///             For more information about this parameter, see <a>ScheduledAction</a>. </p>
    public let startTime: ClientRuntime.Date?
    /// <p>A modified JSON format of the scheduled action.
    ///             For more information about this parameter, see <a>ScheduledAction</a>. </p>
    public let targetAction: RedshiftClientTypes.ScheduledActionType?

    public init (
        enable: Swift.Bool? = nil,
        endTime: ClientRuntime.Date? = nil,
        iamRole: Swift.String? = nil,
        schedule: Swift.String? = nil,
        scheduledActionDescription: Swift.String? = nil,
        scheduledActionName: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        targetAction: RedshiftClientTypes.ScheduledActionType? = nil
    )
    {
        self.enable = enable
        self.endTime = endTime
        self.iamRole = iamRole
        self.schedule = schedule
        self.scheduledActionDescription = scheduledActionDescription
        self.scheduledActionName = scheduledActionName
        self.startTime = startTime
        self.targetAction = targetAction
    }
}

extension ModifyScheduledActionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyScheduledActionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidScheduledActionFault" : self = .invalidScheduledActionFault(try InvalidScheduledActionFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidScheduleFault" : self = .invalidScheduleFault(try InvalidScheduleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ScheduledActionNotFoundFault" : self = .scheduledActionNotFoundFault(try ScheduledActionNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ScheduledActionTypeUnsupportedFault" : self = .scheduledActionTypeUnsupportedFault(try ScheduledActionTypeUnsupportedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyScheduledActionOutputError: Swift.Error, Swift.Equatable {
    case invalidScheduledActionFault(InvalidScheduledActionFault)
    case invalidScheduleFault(InvalidScheduleFault)
    case scheduledActionNotFoundFault(ScheduledActionNotFoundFault)
    case scheduledActionTypeUnsupportedFault(ScheduledActionTypeUnsupportedFault)
    case unauthorizedOperation(UnauthorizedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyScheduledActionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyScheduledActionOutputResponse(endTime: \(Swift.String(describing: endTime)), iamRole: \(Swift.String(describing: iamRole)), nextInvocations: \(Swift.String(describing: nextInvocations)), schedule: \(Swift.String(describing: schedule)), scheduledActionDescription: \(Swift.String(describing: scheduledActionDescription)), scheduledActionName: \(Swift.String(describing: scheduledActionName)), startTime: \(Swift.String(describing: startTime)), state: \(Swift.String(describing: state)), targetAction: \(Swift.String(describing: targetAction)))"}
}

extension ModifyScheduledActionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyScheduledActionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endTime = output.endTime
            self.iamRole = output.iamRole
            self.nextInvocations = output.nextInvocations
            self.schedule = output.schedule
            self.scheduledActionDescription = output.scheduledActionDescription
            self.scheduledActionName = output.scheduledActionName
            self.startTime = output.startTime
            self.state = output.state
            self.targetAction = output.targetAction
        } else {
            self.endTime = nil
            self.iamRole = nil
            self.nextInvocations = nil
            self.schedule = nil
            self.scheduledActionDescription = nil
            self.scheduledActionName = nil
            self.startTime = nil
            self.state = nil
            self.targetAction = nil
        }
    }
}

/// <p>Describes a scheduled action. You can use a scheduled action to trigger some Amazon Redshift API operations on a schedule.
///             For information about which API operations can be scheduled, see  <a>ScheduledActionType</a>. </p>
public struct ModifyScheduledActionOutputResponse: Swift.Equatable {
    /// <p>The end time in UTC when the schedule is no longer active. After this time, the scheduled action does not trigger. </p>
    public let endTime: ClientRuntime.Date?
    /// <p>The IAM role to assume to run the scheduled action.
    ///             This IAM role must have permission to run the Amazon Redshift API operation in the scheduled action.
    ///             This IAM role must allow the Amazon Redshift scheduler (Principal scheduler.redshift.amazonaws.com) to assume permissions on your behalf.
    ///
    /// For more information about the IAM role to use with the Amazon Redshift scheduler, see
    /// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html">Using Identity-Based Policies for Amazon Redshift</a>
    /// in the <i>Amazon Redshift Cluster Management Guide</i>.
    /// </p>
    public let iamRole: Swift.String?
    /// <p>List of times when the scheduled action will run. </p>
    public let nextInvocations: [ClientRuntime.Date]?
    /// <p>The schedule for a one-time (at format) or recurring (cron format) scheduled action.
    ///             Schedule invocations must be separated by at least one hour.</p>
    ///         <p>Format of at expressions is "<code>at(yyyy-mm-ddThh:mm:ss)</code>". For example, "<code>at(2016-03-04T17:27:00)</code>".</p>
    ///         <p>Format of cron expressions is "<code>cron(Minutes Hours Day-of-month Month Day-of-week Year)</code>".
    ///             For example, "<code>cron(0 10 ? * MON *)</code>". For more information, see
    ///             <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/events/ScheduledEvents.html#CronExpressions">Cron Expressions</a>
    ///             in the <i>Amazon CloudWatch Events User Guide</i>.</p>
    public let schedule: Swift.String?
    /// <p>The description of the scheduled action. </p>
    public let scheduledActionDescription: Swift.String?
    /// <p>The name of the scheduled action. </p>
    public let scheduledActionName: Swift.String?
    /// <p>The start time in UTC when the schedule is active. Before this time, the scheduled action does not trigger. </p>
    public let startTime: ClientRuntime.Date?
    /// <p>The state of the scheduled action. For example, <code>DISABLED</code>. </p>
    public let state: RedshiftClientTypes.ScheduledActionState?
    /// <p>A JSON format string of the Amazon Redshift API operation with input parameters. </p>
    ///         <p>"<code>{\"ResizeCluster\":{\"NodeType\":\"ds2.8xlarge\",\"ClusterIdentifier\":\"my-test-cluster\",\"NumberOfNodes\":3}}</code>". </p>
    public let targetAction: RedshiftClientTypes.ScheduledActionType?

    public init (
        endTime: ClientRuntime.Date? = nil,
        iamRole: Swift.String? = nil,
        nextInvocations: [ClientRuntime.Date]? = nil,
        schedule: Swift.String? = nil,
        scheduledActionDescription: Swift.String? = nil,
        scheduledActionName: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        state: RedshiftClientTypes.ScheduledActionState? = nil,
        targetAction: RedshiftClientTypes.ScheduledActionType? = nil
    )
    {
        self.endTime = endTime
        self.iamRole = iamRole
        self.nextInvocations = nextInvocations
        self.schedule = schedule
        self.scheduledActionDescription = scheduledActionDescription
        self.scheduledActionName = scheduledActionName
        self.startTime = startTime
        self.state = state
        self.targetAction = targetAction
    }
}

struct ModifyScheduledActionOutputResponseBody: Swift.Equatable {
    public let scheduledActionName: Swift.String?
    public let targetAction: RedshiftClientTypes.ScheduledActionType?
    public let schedule: Swift.String?
    public let iamRole: Swift.String?
    public let scheduledActionDescription: Swift.String?
    public let state: RedshiftClientTypes.ScheduledActionState?
    public let nextInvocations: [ClientRuntime.Date]?
    public let startTime: ClientRuntime.Date?
    public let endTime: ClientRuntime.Date?
}

extension ModifyScheduledActionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case iamRole = "IamRole"
        case nextInvocations = "NextInvocations"
        case schedule = "Schedule"
        case scheduledActionDescription = "ScheduledActionDescription"
        case scheduledActionName = "ScheduledActionName"
        case startTime = "StartTime"
        case state = "State"
        case targetAction = "TargetAction"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyScheduledActionResult"))
        let scheduledActionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduledActionName)
        scheduledActionName = scheduledActionNameDecoded
        let targetActionDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.ScheduledActionType.self, forKey: .targetAction)
        targetAction = targetActionDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schedule)
        schedule = scheduleDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
        let scheduledActionDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduledActionDescription)
        scheduledActionDescription = scheduledActionDescriptionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.ScheduledActionState.self, forKey: .state)
        state = stateDecoded
        if containerValues.contains(.nextInvocations) {
            struct KeyVal0{struct ScheduledActionTime{}}
            let nextInvocationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ScheduledActionTime>.CodingKeys.self, forKey: .nextInvocations)
            if let nextInvocationsWrappedContainer = nextInvocationsWrappedContainer {
                let nextInvocationsContainer = try nextInvocationsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var nextInvocationsBuffer:[ClientRuntime.Date]? = nil
                if let nextInvocationsContainer = nextInvocationsContainer {
                    nextInvocationsBuffer = [ClientRuntime.Date]()
                    for timestampContainer0 in nextInvocationsContainer {
                        try nextInvocationsBuffer?.append(ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(timestampContainer0, format: .dateTime))
                    }
                }
                nextInvocations = nextInvocationsBuffer
            } else {
                nextInvocations = []
            }
        } else {
            nextInvocations = nil
        }
        let startTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startTime)
        var startTimeBuffer:ClientRuntime.Date? = nil
        if let startTimeDecoded = startTimeDecoded {
            startTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(startTimeDecoded, format: .dateTime)
        }
        startTime = startTimeBuffer
        let endTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endTime)
        var endTimeBuffer:ClientRuntime.Date? = nil
        if let endTimeDecoded = endTimeDecoded {
            endTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(endTimeDecoded, format: .dateTime)
        }
        endTime = endTimeBuffer
    }
}

public struct ModifySnapshotCopyRetentionPeriodInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifySnapshotCopyRetentionPeriodInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifySnapshotCopyRetentionPeriodInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifySnapshotCopyRetentionPeriodOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifySnapshotCopyRetentionPeriodInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifySnapshotCopyRetentionPeriodOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifySnapshotCopyRetentionPeriodOutputError>
}

extension ModifySnapshotCopyRetentionPeriodInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifySnapshotCopyRetentionPeriodInput(clusterIdentifier: \(Swift.String(describing: clusterIdentifier)), manual: \(Swift.String(describing: manual)), retentionPeriod: \(Swift.String(describing: retentionPeriod)))"}
}

extension ModifySnapshotCopyRetentionPeriodInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: ClientRuntime.Key("ClusterIdentifier"))
        }
        if manual != false {
            try container.encode(manual, forKey: ClientRuntime.Key("Manual"))
        }
        if retentionPeriod != 0 {
            try container.encode(retentionPeriod, forKey: ClientRuntime.Key("RetentionPeriod"))
        }
        try container.encode("ModifySnapshotCopyRetentionPeriod", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ModifySnapshotCopyRetentionPeriodInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifySnapshotCopyRetentionPeriodInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifySnapshotCopyRetentionPeriodInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifySnapshotCopyRetentionPeriodOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifySnapshotCopyRetentionPeriodInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifySnapshotCopyRetentionPeriodOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifySnapshotCopyRetentionPeriodOutputError>
}

public struct ModifySnapshotCopyRetentionPeriodInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifySnapshotCopyRetentionPeriodInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifySnapshotCopyRetentionPeriodInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifySnapshotCopyRetentionPeriodOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifySnapshotCopyRetentionPeriodInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifySnapshotCopyRetentionPeriodOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifySnapshotCopyRetentionPeriodOutputError>
}

/// <p></p>
public struct ModifySnapshotCopyRetentionPeriodInput: Swift.Equatable {
    /// <p>The unique identifier of the cluster for which you want to change the retention
    ///             period for either automated or manual snapshots that are copied to a destination AWS
    ///             Region.</p>
    ///         <p>Constraints: Must be the valid name of an existing cluster that has cross-region
    ///             snapshot copy enabled.</p>
    public let clusterIdentifier: Swift.String?
    /// <p>Indicates whether to apply the snapshot retention period to newly copied manual
    ///             snapshots instead of automated snapshots.</p>
    public let manual: Swift.Bool
    /// <p>The number of days to retain automated snapshots in the destination AWS Region
    ///             after they are copied from the source AWS Region.</p>
    ///         <p>By default, this only changes the retention period of copied automated snapshots. </p>
    ///         <p>If you decrease the retention period for automated snapshots that are copied to a
    ///             destination AWS Region, Amazon Redshift deletes any existing automated snapshots that were
    ///             copied to the destination AWS Region and that fall outside of the new retention
    ///             period.</p>
    ///         <p>Constraints: Must be at least 1 and no more than 35 for automated snapshots. </p>
    ///         <p>If you specify the <code>manual</code> option, only newly copied manual snapshots will
    ///             have the new retention period. </p>
    ///         <p>If you specify the value of -1 newly copied manual snapshots are retained
    ///             indefinitely.</p>
    ///         <p>Constraints: The number of days must be either -1 or an integer between 1 and 3,653
    ///             for manual snapshots.</p>
    public let retentionPeriod: Swift.Int

    public init (
        clusterIdentifier: Swift.String? = nil,
        manual: Swift.Bool = false,
        retentionPeriod: Swift.Int = 0
    )
    {
        self.clusterIdentifier = clusterIdentifier
        self.manual = manual
        self.retentionPeriod = retentionPeriod
    }
}

extension ModifySnapshotCopyRetentionPeriodOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifySnapshotCopyRetentionPeriodOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRetentionPeriodFault" : self = .invalidRetentionPeriodFault(try InvalidRetentionPeriodFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotCopyDisabledFault" : self = .snapshotCopyDisabledFault(try SnapshotCopyDisabledFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifySnapshotCopyRetentionPeriodOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidRetentionPeriodFault(InvalidRetentionPeriodFault)
    case snapshotCopyDisabledFault(SnapshotCopyDisabledFault)
    case unauthorizedOperation(UnauthorizedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifySnapshotCopyRetentionPeriodOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifySnapshotCopyRetentionPeriodOutputResponse(cluster: \(Swift.String(describing: cluster)))"}
}

extension ModifySnapshotCopyRetentionPeriodOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifySnapshotCopyRetentionPeriodOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct ModifySnapshotCopyRetentionPeriodOutputResponse: Swift.Equatable {
    /// <p>Describes a cluster.</p>
    public let cluster: RedshiftClientTypes.Cluster?

    public init (
        cluster: RedshiftClientTypes.Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct ModifySnapshotCopyRetentionPeriodOutputResponseBody: Swift.Equatable {
    public let cluster: RedshiftClientTypes.Cluster?
}

extension ModifySnapshotCopyRetentionPeriodOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cluster = "Cluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifySnapshotCopyRetentionPeriodResult"))
        let clusterDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

public struct ModifySnapshotScheduleInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifySnapshotScheduleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifySnapshotScheduleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifySnapshotScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifySnapshotScheduleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifySnapshotScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifySnapshotScheduleOutputError>
}

extension ModifySnapshotScheduleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifySnapshotScheduleInput(scheduleDefinitions: \(Swift.String(describing: scheduleDefinitions)), scheduleIdentifier: \(Swift.String(describing: scheduleIdentifier)))"}
}

extension ModifySnapshotScheduleInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let scheduleDefinitions = scheduleDefinitions {
            var scheduleDefinitionsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ScheduleDefinitions"))
            for (index0, string0) in scheduleDefinitions.enumerated() {
                try scheduleDefinitionsContainer.encode(string0, forKey: ClientRuntime.Key("ScheduleDefinition.\(index0.advanced(by: 1))"))
            }
        }
        if let scheduleIdentifier = scheduleIdentifier {
            try container.encode(scheduleIdentifier, forKey: ClientRuntime.Key("ScheduleIdentifier"))
        }
        try container.encode("ModifySnapshotSchedule", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ModifySnapshotScheduleInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifySnapshotScheduleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifySnapshotScheduleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifySnapshotScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifySnapshotScheduleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifySnapshotScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifySnapshotScheduleOutputError>
}

public struct ModifySnapshotScheduleInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifySnapshotScheduleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifySnapshotScheduleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifySnapshotScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifySnapshotScheduleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifySnapshotScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifySnapshotScheduleOutputError>
}

public struct ModifySnapshotScheduleInput: Swift.Equatable {
    /// <p>An updated list of schedule definitions. A schedule definition is made up of schedule
    ///             expressions, for example, "cron(30 12 *)" or "rate(12 hours)".</p>
    public let scheduleDefinitions: [Swift.String]?
    /// <p>A unique alphanumeric identifier of the schedule to modify.</p>
    public let scheduleIdentifier: Swift.String?

    public init (
        scheduleDefinitions: [Swift.String]? = nil,
        scheduleIdentifier: Swift.String? = nil
    )
    {
        self.scheduleDefinitions = scheduleDefinitions
        self.scheduleIdentifier = scheduleIdentifier
    }
}

extension ModifySnapshotScheduleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifySnapshotScheduleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidScheduleFault" : self = .invalidScheduleFault(try InvalidScheduleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotScheduleNotFoundFault" : self = .snapshotScheduleNotFoundFault(try SnapshotScheduleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotScheduleUpdateInProgressFault" : self = .snapshotScheduleUpdateInProgressFault(try SnapshotScheduleUpdateInProgressFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifySnapshotScheduleOutputError: Swift.Error, Swift.Equatable {
    case invalidScheduleFault(InvalidScheduleFault)
    case snapshotScheduleNotFoundFault(SnapshotScheduleNotFoundFault)
    case snapshotScheduleUpdateInProgressFault(SnapshotScheduleUpdateInProgressFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifySnapshotScheduleOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifySnapshotScheduleOutputResponse(associatedClusterCount: \(Swift.String(describing: associatedClusterCount)), associatedClusters: \(Swift.String(describing: associatedClusters)), nextInvocations: \(Swift.String(describing: nextInvocations)), scheduleDefinitions: \(Swift.String(describing: scheduleDefinitions)), scheduleDescription: \(Swift.String(describing: scheduleDescription)), scheduleIdentifier: \(Swift.String(describing: scheduleIdentifier)), tags: \(Swift.String(describing: tags)))"}
}

extension ModifySnapshotScheduleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifySnapshotScheduleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.associatedClusterCount = output.associatedClusterCount
            self.associatedClusters = output.associatedClusters
            self.nextInvocations = output.nextInvocations
            self.scheduleDefinitions = output.scheduleDefinitions
            self.scheduleDescription = output.scheduleDescription
            self.scheduleIdentifier = output.scheduleIdentifier
            self.tags = output.tags
        } else {
            self.associatedClusterCount = nil
            self.associatedClusters = nil
            self.nextInvocations = nil
            self.scheduleDefinitions = nil
            self.scheduleDescription = nil
            self.scheduleIdentifier = nil
            self.tags = nil
        }
    }
}

/// <p>Describes a snapshot schedule. You can set a regular interval for creating
///             snapshots of a cluster. You can also schedule snapshots for specific dates. </p>
public struct ModifySnapshotScheduleOutputResponse: Swift.Equatable {
    /// <p>The number of clusters associated with the schedule.</p>
    public let associatedClusterCount: Swift.Int?
    /// <p>A list of clusters associated with the schedule. A maximum of 100 clusters is returned.</p>
    public let associatedClusters: [RedshiftClientTypes.ClusterAssociatedToSchedule]?
    /// <p></p>
    public let nextInvocations: [ClientRuntime.Date]?
    /// <p>A list of ScheduleDefinitions.</p>
    public let scheduleDefinitions: [Swift.String]?
    /// <p>The description of the schedule.</p>
    public let scheduleDescription: Swift.String?
    /// <p>A unique identifier for the schedule.</p>
    public let scheduleIdentifier: Swift.String?
    /// <p>An optional set of tags describing the schedule.</p>
    public let tags: [RedshiftClientTypes.Tag]?

    public init (
        associatedClusterCount: Swift.Int? = nil,
        associatedClusters: [RedshiftClientTypes.ClusterAssociatedToSchedule]? = nil,
        nextInvocations: [ClientRuntime.Date]? = nil,
        scheduleDefinitions: [Swift.String]? = nil,
        scheduleDescription: Swift.String? = nil,
        scheduleIdentifier: Swift.String? = nil,
        tags: [RedshiftClientTypes.Tag]? = nil
    )
    {
        self.associatedClusterCount = associatedClusterCount
        self.associatedClusters = associatedClusters
        self.nextInvocations = nextInvocations
        self.scheduleDefinitions = scheduleDefinitions
        self.scheduleDescription = scheduleDescription
        self.scheduleIdentifier = scheduleIdentifier
        self.tags = tags
    }
}

struct ModifySnapshotScheduleOutputResponseBody: Swift.Equatable {
    public let scheduleDefinitions: [Swift.String]?
    public let scheduleIdentifier: Swift.String?
    public let scheduleDescription: Swift.String?
    public let tags: [RedshiftClientTypes.Tag]?
    public let nextInvocations: [ClientRuntime.Date]?
    public let associatedClusterCount: Swift.Int?
    public let associatedClusters: [RedshiftClientTypes.ClusterAssociatedToSchedule]?
}

extension ModifySnapshotScheduleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedClusterCount = "AssociatedClusterCount"
        case associatedClusters = "AssociatedClusters"
        case nextInvocations = "NextInvocations"
        case scheduleDefinitions = "ScheduleDefinitions"
        case scheduleDescription = "ScheduleDescription"
        case scheduleIdentifier = "ScheduleIdentifier"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifySnapshotScheduleResult"))
        if containerValues.contains(.scheduleDefinitions) {
            struct KeyVal0{struct ScheduleDefinition{}}
            let scheduleDefinitionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ScheduleDefinition>.CodingKeys.self, forKey: .scheduleDefinitions)
            if let scheduleDefinitionsWrappedContainer = scheduleDefinitionsWrappedContainer {
                let scheduleDefinitionsContainer = try scheduleDefinitionsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var scheduleDefinitionsBuffer:[Swift.String]? = nil
                if let scheduleDefinitionsContainer = scheduleDefinitionsContainer {
                    scheduleDefinitionsBuffer = [Swift.String]()
                    for stringContainer0 in scheduleDefinitionsContainer {
                        scheduleDefinitionsBuffer?.append(stringContainer0)
                    }
                }
                scheduleDefinitions = scheduleDefinitionsBuffer
            } else {
                scheduleDefinitions = []
            }
        } else {
            scheduleDefinitions = nil
        }
        let scheduleIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleIdentifier)
        scheduleIdentifier = scheduleIdentifierDecoded
        let scheduleDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleDescription)
        scheduleDescription = scheduleDescriptionDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([RedshiftClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[RedshiftClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [RedshiftClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        if containerValues.contains(.nextInvocations) {
            struct KeyVal0{struct SnapshotTime{}}
            let nextInvocationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.SnapshotTime>.CodingKeys.self, forKey: .nextInvocations)
            if let nextInvocationsWrappedContainer = nextInvocationsWrappedContainer {
                let nextInvocationsContainer = try nextInvocationsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var nextInvocationsBuffer:[ClientRuntime.Date]? = nil
                if let nextInvocationsContainer = nextInvocationsContainer {
                    nextInvocationsBuffer = [ClientRuntime.Date]()
                    for timestampContainer0 in nextInvocationsContainer {
                        try nextInvocationsBuffer?.append(ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(timestampContainer0, format: .dateTime))
                    }
                }
                nextInvocations = nextInvocationsBuffer
            } else {
                nextInvocations = []
            }
        } else {
            nextInvocations = nil
        }
        let associatedClusterCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .associatedClusterCount)
        associatedClusterCount = associatedClusterCountDecoded
        if containerValues.contains(.associatedClusters) {
            struct KeyVal0{struct ClusterAssociatedToSchedule{}}
            let associatedClustersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ClusterAssociatedToSchedule>.CodingKeys.self, forKey: .associatedClusters)
            if let associatedClustersWrappedContainer = associatedClustersWrappedContainer {
                let associatedClustersContainer = try associatedClustersWrappedContainer.decodeIfPresent([RedshiftClientTypes.ClusterAssociatedToSchedule].self, forKey: .member)
                var associatedClustersBuffer:[RedshiftClientTypes.ClusterAssociatedToSchedule]? = nil
                if let associatedClustersContainer = associatedClustersContainer {
                    associatedClustersBuffer = [RedshiftClientTypes.ClusterAssociatedToSchedule]()
                    for structureContainer0 in associatedClustersContainer {
                        associatedClustersBuffer?.append(structureContainer0)
                    }
                }
                associatedClusters = associatedClustersBuffer
            } else {
                associatedClusters = []
            }
        } else {
            associatedClusters = nil
        }
    }
}

public struct ModifyUsageLimitInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyUsageLimitInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyUsageLimitInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyUsageLimitOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyUsageLimitInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyUsageLimitOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyUsageLimitOutputError>
}

extension ModifyUsageLimitInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyUsageLimitInput(amount: \(Swift.String(describing: amount)), breachAction: \(Swift.String(describing: breachAction)), usageLimitId: \(Swift.String(describing: usageLimitId)))"}
}

extension ModifyUsageLimitInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let amount = amount {
            try container.encode(amount, forKey: ClientRuntime.Key("Amount"))
        }
        if let breachAction = breachAction {
            try container.encode(breachAction, forKey: ClientRuntime.Key("BreachAction"))
        }
        if let usageLimitId = usageLimitId {
            try container.encode(usageLimitId, forKey: ClientRuntime.Key("UsageLimitId"))
        }
        try container.encode("ModifyUsageLimit", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ModifyUsageLimitInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyUsageLimitInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyUsageLimitInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyUsageLimitOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyUsageLimitInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyUsageLimitOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyUsageLimitOutputError>
}

public struct ModifyUsageLimitInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyUsageLimitInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyUsageLimitInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyUsageLimitOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyUsageLimitInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyUsageLimitOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyUsageLimitOutputError>
}

public struct ModifyUsageLimitInput: Swift.Equatable {
    /// <p>The new limit amount.
    ///             For more information about this parameter, see <a>UsageLimit</a>. </p>
    public let amount: Swift.Int?
    /// <p>The new action that Amazon Redshift takes when the limit is reached.
    ///             For more information about this parameter, see <a>UsageLimit</a>. </p>
    public let breachAction: RedshiftClientTypes.UsageLimitBreachAction?
    /// <p>The identifier of the usage limit to modify.</p>
    public let usageLimitId: Swift.String?

    public init (
        amount: Swift.Int? = nil,
        breachAction: RedshiftClientTypes.UsageLimitBreachAction? = nil,
        usageLimitId: Swift.String? = nil
    )
    {
        self.amount = amount
        self.breachAction = breachAction
        self.usageLimitId = usageLimitId
    }
}

extension ModifyUsageLimitOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyUsageLimitOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidUsageLimitFault" : self = .invalidUsageLimitFault(try InvalidUsageLimitFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationFault" : self = .unsupportedOperationFault(try UnsupportedOperationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UsageLimitNotFoundFault" : self = .usageLimitNotFoundFault(try UsageLimitNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyUsageLimitOutputError: Swift.Error, Swift.Equatable {
    case invalidUsageLimitFault(InvalidUsageLimitFault)
    case unsupportedOperationFault(UnsupportedOperationFault)
    case usageLimitNotFoundFault(UsageLimitNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyUsageLimitOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyUsageLimitOutputResponse(amount: \(Swift.String(describing: amount)), breachAction: \(Swift.String(describing: breachAction)), clusterIdentifier: \(Swift.String(describing: clusterIdentifier)), featureType: \(Swift.String(describing: featureType)), limitType: \(Swift.String(describing: limitType)), period: \(Swift.String(describing: period)), tags: \(Swift.String(describing: tags)), usageLimitId: \(Swift.String(describing: usageLimitId)))"}
}

extension ModifyUsageLimitOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyUsageLimitOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.amount = output.amount
            self.breachAction = output.breachAction
            self.clusterIdentifier = output.clusterIdentifier
            self.featureType = output.featureType
            self.limitType = output.limitType
            self.period = output.period
            self.tags = output.tags
            self.usageLimitId = output.usageLimitId
        } else {
            self.amount = 0
            self.breachAction = nil
            self.clusterIdentifier = nil
            self.featureType = nil
            self.limitType = nil
            self.period = nil
            self.tags = nil
            self.usageLimitId = nil
        }
    }
}

/// <p>Describes a usage limit object for a cluster. </p>
public struct ModifyUsageLimitOutputResponse: Swift.Equatable {
    /// <p>The limit amount. If time-based, this amount is in minutes. If data-based, this amount is in terabytes (TB).</p>
    public let amount: Swift.Int
    /// <p>The action that Amazon Redshift takes when the limit is reached. Possible values are: </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>log</b> - To log an event in a system table. The default is log.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>emit-metric</b> - To emit CloudWatch metrics.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>disable</b> - To disable the feature until the next usage period begins.</p>
    ///             </li>
    ///          </ul>
    public let breachAction: RedshiftClientTypes.UsageLimitBreachAction?
    /// <p>The identifier of the cluster with a usage limit.</p>
    public let clusterIdentifier: Swift.String?
    /// <p>The Amazon Redshift feature to which the limit applies.</p>
    public let featureType: RedshiftClientTypes.UsageLimitFeatureType?
    /// <p>The type of limit. Depending on the feature type, this can be based on a time duration or data size.</p>
    public let limitType: RedshiftClientTypes.UsageLimitLimitType?
    /// <p>The time period that the amount applies to. A <code>weekly</code> period begins on Sunday. The default is <code>monthly</code>. </p>
    public let period: RedshiftClientTypes.UsageLimitPeriod?
    /// <p>A list of tag instances.</p>
    public let tags: [RedshiftClientTypes.Tag]?
    /// <p>The identifier of the usage limit.</p>
    public let usageLimitId: Swift.String?

    public init (
        amount: Swift.Int = 0,
        breachAction: RedshiftClientTypes.UsageLimitBreachAction? = nil,
        clusterIdentifier: Swift.String? = nil,
        featureType: RedshiftClientTypes.UsageLimitFeatureType? = nil,
        limitType: RedshiftClientTypes.UsageLimitLimitType? = nil,
        period: RedshiftClientTypes.UsageLimitPeriod? = nil,
        tags: [RedshiftClientTypes.Tag]? = nil,
        usageLimitId: Swift.String? = nil
    )
    {
        self.amount = amount
        self.breachAction = breachAction
        self.clusterIdentifier = clusterIdentifier
        self.featureType = featureType
        self.limitType = limitType
        self.period = period
        self.tags = tags
        self.usageLimitId = usageLimitId
    }
}

struct ModifyUsageLimitOutputResponseBody: Swift.Equatable {
    public let usageLimitId: Swift.String?
    public let clusterIdentifier: Swift.String?
    public let featureType: RedshiftClientTypes.UsageLimitFeatureType?
    public let limitType: RedshiftClientTypes.UsageLimitLimitType?
    public let amount: Swift.Int
    public let period: RedshiftClientTypes.UsageLimitPeriod?
    public let breachAction: RedshiftClientTypes.UsageLimitBreachAction?
    public let tags: [RedshiftClientTypes.Tag]?
}

extension ModifyUsageLimitOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amount = "Amount"
        case breachAction = "BreachAction"
        case clusterIdentifier = "ClusterIdentifier"
        case featureType = "FeatureType"
        case limitType = "LimitType"
        case period = "Period"
        case tags = "Tags"
        case usageLimitId = "UsageLimitId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyUsageLimitResult"))
        let usageLimitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .usageLimitId)
        usageLimitId = usageLimitIdDecoded
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let featureTypeDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.UsageLimitFeatureType.self, forKey: .featureType)
        featureType = featureTypeDecoded
        let limitTypeDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.UsageLimitLimitType.self, forKey: .limitType)
        limitType = limitTypeDecoded
        let amountDecoded = try containerValues.decode(Swift.Int.self, forKey: .amount)
        amount = amountDecoded
        let periodDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.UsageLimitPeriod.self, forKey: .period)
        period = periodDecoded
        let breachActionDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.UsageLimitBreachAction.self, forKey: .breachAction)
        breachAction = breachActionDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([RedshiftClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[RedshiftClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [RedshiftClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension RedshiftClientTypes.NetworkInterface: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone = "AvailabilityZone"
        case networkInterfaceId = "NetworkInterfaceId"
        case privateIpAddress = "PrivateIpAddress"
        case subnetId = "SubnetId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let availabilityZone = availabilityZone {
            try container.encode(availabilityZone, forKey: ClientRuntime.Key("AvailabilityZone"))
        }
        if let networkInterfaceId = networkInterfaceId {
            try container.encode(networkInterfaceId, forKey: ClientRuntime.Key("NetworkInterfaceId"))
        }
        if let privateIpAddress = privateIpAddress {
            try container.encode(privateIpAddress, forKey: ClientRuntime.Key("PrivateIpAddress"))
        }
        if let subnetId = subnetId {
            try container.encode(subnetId, forKey: ClientRuntime.Key("SubnetId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkInterfaceId)
        networkInterfaceId = networkInterfaceIdDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let privateIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateIpAddress)
        privateIpAddress = privateIpAddressDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
    }
}

extension RedshiftClientTypes.NetworkInterface: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NetworkInterface(availabilityZone: \(Swift.String(describing: availabilityZone)), networkInterfaceId: \(Swift.String(describing: networkInterfaceId)), privateIpAddress: \(Swift.String(describing: privateIpAddress)), subnetId: \(Swift.String(describing: subnetId)))"}
}

extension RedshiftClientTypes {
    /// <p>Describes a network interface. </p>
    public struct NetworkInterface: Swift.Equatable {
        /// <p>The Availability Zone. </p>
        public let availabilityZone: Swift.String?
        /// <p>The network interface identifier. </p>
        public let networkInterfaceId: Swift.String?
        /// <p>The IPv4 address of the network interface within the subnet. </p>
        public let privateIpAddress: Swift.String?
        /// <p>The subnet identifier. </p>
        public let subnetId: Swift.String?

        public init (
            availabilityZone: Swift.String? = nil,
            networkInterfaceId: Swift.String? = nil,
            privateIpAddress: Swift.String? = nil,
            subnetId: Swift.String? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.networkInterfaceId = networkInterfaceId
            self.privateIpAddress = privateIpAddress
            self.subnetId = subnetId
        }
    }

}

extension RedshiftClientTypes.NodeConfigurationOption: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case estimatedDiskUtilizationPercent = "EstimatedDiskUtilizationPercent"
        case mode = "Mode"
        case nodeType = "NodeType"
        case numberOfNodes = "NumberOfNodes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let estimatedDiskUtilizationPercent = estimatedDiskUtilizationPercent {
            try container.encode(estimatedDiskUtilizationPercent, forKey: ClientRuntime.Key("EstimatedDiskUtilizationPercent"))
        }
        if let mode = mode {
            try container.encode(mode, forKey: ClientRuntime.Key("Mode"))
        }
        if let nodeType = nodeType {
            try container.encode(nodeType, forKey: ClientRuntime.Key("NodeType"))
        }
        if numberOfNodes != 0 {
            try container.encode(numberOfNodes, forKey: ClientRuntime.Key("NumberOfNodes"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nodeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeType)
        nodeType = nodeTypeDecoded
        let numberOfNodesDecoded = try containerValues.decode(Swift.Int.self, forKey: .numberOfNodes)
        numberOfNodes = numberOfNodesDecoded
        let estimatedDiskUtilizationPercentDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .estimatedDiskUtilizationPercent)
        estimatedDiskUtilizationPercent = estimatedDiskUtilizationPercentDecoded
        let modeDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.Mode.self, forKey: .mode)
        mode = modeDecoded
    }
}

extension RedshiftClientTypes.NodeConfigurationOption: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NodeConfigurationOption(estimatedDiskUtilizationPercent: \(Swift.String(describing: estimatedDiskUtilizationPercent)), mode: \(Swift.String(describing: mode)), nodeType: \(Swift.String(describing: nodeType)), numberOfNodes: \(Swift.String(describing: numberOfNodes)))"}
}

extension RedshiftClientTypes {
    /// <p>A list of node configurations.</p>
    public struct NodeConfigurationOption: Swift.Equatable {
        /// <p>The estimated disk utilizaton percentage.</p>
        public let estimatedDiskUtilizationPercent: Swift.Double?
        /// <p>The category of the node configuration recommendation.</p>
        public let mode: RedshiftClientTypes.Mode?
        /// <p>The node type, such as, "ds2.8xlarge".</p>
        public let nodeType: Swift.String?
        /// <p>The number of nodes.</p>
        public let numberOfNodes: Swift.Int

        public init (
            estimatedDiskUtilizationPercent: Swift.Double? = nil,
            mode: RedshiftClientTypes.Mode? = nil,
            nodeType: Swift.String? = nil,
            numberOfNodes: Swift.Int = 0
        )
        {
            self.estimatedDiskUtilizationPercent = estimatedDiskUtilizationPercent
            self.mode = mode
            self.nodeType = nodeType
            self.numberOfNodes = numberOfNodes
        }
    }

}

extension RedshiftClientTypes.NodeConfigurationOptionsFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case `operator` = "Operator"
        case values = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let `operator` = `operator` {
            try container.encode(`operator`, forKey: ClientRuntime.Key("Operator"))
        }
        if let values = values {
            var valuesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Value"))
            for (index0, string0) in values.enumerated() {
                try valuesContainer.encode(string0, forKey: ClientRuntime.Key("item.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.NodeConfigurationOptionsFilterName.self, forKey: .name)
        name = nameDecoded
        let operatorDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.OperatorType.self, forKey: .operator)
        `operator` = operatorDecoded
        if containerValues.contains(.values) {
            struct KeyVal0{struct item{}}
            let valuesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .values)
            if let valuesWrappedContainer = valuesWrappedContainer {
                let valuesContainer = try valuesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var valuesBuffer:[Swift.String]? = nil
                if let valuesContainer = valuesContainer {
                    valuesBuffer = [Swift.String]()
                    for stringContainer0 in valuesContainer {
                        valuesBuffer?.append(stringContainer0)
                    }
                }
                values = valuesBuffer
            } else {
                values = []
            }
        } else {
            values = nil
        }
    }
}

extension RedshiftClientTypes.NodeConfigurationOptionsFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NodeConfigurationOptionsFilter(name: \(Swift.String(describing: name)), operator: \(Swift.String(describing: `operator`)), values: \(Swift.String(describing: values)))"}
}

extension RedshiftClientTypes {
    /// <p>A set of elements to filter the returned node configurations.</p>
    public struct NodeConfigurationOptionsFilter: Swift.Equatable {
        /// <p>The filter operator.
        ///             If filter Name is NodeType only the 'in' operator is supported.
        ///             Provide one value to evaluate for 'eq', 'lt', 'le', 'gt', and 'ge'.
        ///             Provide two values to evaluate for 'between'.
        ///             Provide a list of values for 'in'.</p>
        public let `operator`: RedshiftClientTypes.OperatorType?
        /// <p>The name of the element to filter.</p>
        public let name: RedshiftClientTypes.NodeConfigurationOptionsFilterName?
        /// <p>List of values. Compare Name using Operator to Values.
        ///             If filter Name is NumberOfNodes, then values can range from 0 to 200.
        ///             If filter Name is EstimatedDiskUtilizationPercent, then values can range from 0 to 100.
        ///             For example, filter NumberOfNodes (name) GT (operator) 3 (values).</p>
        public let values: [Swift.String]?

        public init (
            `operator`: RedshiftClientTypes.OperatorType? = nil,
            name: RedshiftClientTypes.NodeConfigurationOptionsFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.`operator` = `operator`
            self.name = name
            self.values = values
        }
    }

}

extension RedshiftClientTypes {
    public enum NodeConfigurationOptionsFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case estimatedDiskUtilizationPercent
        case mode
        case nodeType
        case numNodes
        case sdkUnknown(Swift.String)

        public static var allCases: [NodeConfigurationOptionsFilterName] {
            return [
                .estimatedDiskUtilizationPercent,
                .mode,
                .nodeType,
                .numNodes,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .estimatedDiskUtilizationPercent: return "EstimatedDiskUtilizationPercent"
            case .mode: return "Mode"
            case .nodeType: return "NodeType"
            case .numNodes: return "NumberOfNodes"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NodeConfigurationOptionsFilterName(rawValue: rawValue) ?? NodeConfigurationOptionsFilterName.sdkUnknown(rawValue)
        }
    }
}

extension NumberOfNodesPerClusterLimitExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NumberOfNodesPerClusterLimitExceededFault(message: \(Swift.String(describing: message)))"}
}

extension NumberOfNodesPerClusterLimitExceededFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<NumberOfNodesPerClusterLimitExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The operation would exceed the number of nodes allowed for a cluster.</p>
public struct NumberOfNodesPerClusterLimitExceededFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NumberOfNodesPerClusterLimitExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NumberOfNodesPerClusterLimitExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NumberOfNodesQuotaExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NumberOfNodesQuotaExceededFault(message: \(Swift.String(describing: message)))"}
}

extension NumberOfNodesQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<NumberOfNodesQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The operation would exceed the number of nodes allotted to the account.
///
/// For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a>
/// in the <i>Amazon Redshift Cluster Management Guide</i>.
/// </p>
public struct NumberOfNodesQuotaExceededFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NumberOfNodesQuotaExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NumberOfNodesQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RedshiftClientTypes {
    public enum OperatorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case between
        case eq
        case ge
        case gt
        case `in`
        case le
        case lt
        case sdkUnknown(Swift.String)

        public static var allCases: [OperatorType] {
            return [
                .between,
                .eq,
                .ge,
                .gt,
                .in,
                .le,
                .lt,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .between: return "between"
            case .eq: return "eq"
            case .ge: return "ge"
            case .gt: return "gt"
            case .in: return "in"
            case .le: return "le"
            case .lt: return "lt"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OperatorType(rawValue: rawValue) ?? OperatorType.sdkUnknown(rawValue)
        }
    }
}

extension RedshiftClientTypes.OrderableClusterOption: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZones = "AvailabilityZones"
        case clusterType = "ClusterType"
        case clusterVersion = "ClusterVersion"
        case nodeType = "NodeType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AvailabilityZones"))
            for (index0, availabilityzone0) in availabilityZones.enumerated() {
                try availabilityZonesContainer.encode(availabilityzone0, forKey: ClientRuntime.Key("AvailabilityZone.\(index0.advanced(by: 1))"))
            }
        }
        if let clusterType = clusterType {
            try container.encode(clusterType, forKey: ClientRuntime.Key("ClusterType"))
        }
        if let clusterVersion = clusterVersion {
            try container.encode(clusterVersion, forKey: ClientRuntime.Key("ClusterVersion"))
        }
        if let nodeType = nodeType {
            try container.encode(nodeType, forKey: ClientRuntime.Key("NodeType"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterVersion)
        clusterVersion = clusterVersionDecoded
        let clusterTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterType)
        clusterType = clusterTypeDecoded
        let nodeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeType)
        nodeType = nodeTypeDecoded
        if containerValues.contains(.availabilityZones) {
            struct KeyVal0{struct AvailabilityZone{}}
            let availabilityZonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AvailabilityZone>.CodingKeys.self, forKey: .availabilityZones)
            if let availabilityZonesWrappedContainer = availabilityZonesWrappedContainer {
                let availabilityZonesContainer = try availabilityZonesWrappedContainer.decodeIfPresent([RedshiftClientTypes.AvailabilityZone].self, forKey: .member)
                var availabilityZonesBuffer:[RedshiftClientTypes.AvailabilityZone]? = nil
                if let availabilityZonesContainer = availabilityZonesContainer {
                    availabilityZonesBuffer = [RedshiftClientTypes.AvailabilityZone]()
                    for structureContainer0 in availabilityZonesContainer {
                        availabilityZonesBuffer?.append(structureContainer0)
                    }
                }
                availabilityZones = availabilityZonesBuffer
            } else {
                availabilityZones = []
            }
        } else {
            availabilityZones = nil
        }
    }
}

extension RedshiftClientTypes.OrderableClusterOption: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OrderableClusterOption(availabilityZones: \(Swift.String(describing: availabilityZones)), clusterType: \(Swift.String(describing: clusterType)), clusterVersion: \(Swift.String(describing: clusterVersion)), nodeType: \(Swift.String(describing: nodeType)))"}
}

extension RedshiftClientTypes {
    /// <p>Describes an orderable cluster option.</p>
    public struct OrderableClusterOption: Swift.Equatable {
        /// <p>A list of availability zones for the orderable cluster.</p>
        public let availabilityZones: [RedshiftClientTypes.AvailabilityZone]?
        /// <p>The cluster type, for example <code>multi-node</code>. </p>
        public let clusterType: Swift.String?
        /// <p>The version of the orderable cluster.</p>
        public let clusterVersion: Swift.String?
        /// <p>The node type for the orderable cluster.</p>
        public let nodeType: Swift.String?

        public init (
            availabilityZones: [RedshiftClientTypes.AvailabilityZone]? = nil,
            clusterType: Swift.String? = nil,
            clusterVersion: Swift.String? = nil,
            nodeType: Swift.String? = nil
        )
        {
            self.availabilityZones = availabilityZones
            self.clusterType = clusterType
            self.clusterVersion = clusterVersion
            self.nodeType = nodeType
        }
    }

}

extension RedshiftClientTypes.Parameter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedValues = "AllowedValues"
        case applyType = "ApplyType"
        case dataType = "DataType"
        case description = "Description"
        case isModifiable = "IsModifiable"
        case minimumEngineVersion = "MinimumEngineVersion"
        case parameterName = "ParameterName"
        case parameterValue = "ParameterValue"
        case source = "Source"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let allowedValues = allowedValues {
            try container.encode(allowedValues, forKey: ClientRuntime.Key("AllowedValues"))
        }
        if let applyType = applyType {
            try container.encode(applyType, forKey: ClientRuntime.Key("ApplyType"))
        }
        if let dataType = dataType {
            try container.encode(dataType, forKey: ClientRuntime.Key("DataType"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if isModifiable != false {
            try container.encode(isModifiable, forKey: ClientRuntime.Key("IsModifiable"))
        }
        if let minimumEngineVersion = minimumEngineVersion {
            try container.encode(minimumEngineVersion, forKey: ClientRuntime.Key("MinimumEngineVersion"))
        }
        if let parameterName = parameterName {
            try container.encode(parameterName, forKey: ClientRuntime.Key("ParameterName"))
        }
        if let parameterValue = parameterValue {
            try container.encode(parameterValue, forKey: ClientRuntime.Key("ParameterValue"))
        }
        if let source = source {
            try container.encode(source, forKey: ClientRuntime.Key("Source"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterName)
        parameterName = parameterNameDecoded
        let parameterValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterValue)
        parameterValue = parameterValueDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let allowedValuesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .allowedValues)
        allowedValues = allowedValuesDecoded
        let applyTypeDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.ParameterApplyType.self, forKey: .applyType)
        applyType = applyTypeDecoded
        let isModifiableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isModifiable)
        isModifiable = isModifiableDecoded
        let minimumEngineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .minimumEngineVersion)
        minimumEngineVersion = minimumEngineVersionDecoded
    }
}

extension RedshiftClientTypes.Parameter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Parameter(allowedValues: \(Swift.String(describing: allowedValues)), applyType: \(Swift.String(describing: applyType)), dataType: \(Swift.String(describing: dataType)), description: \(Swift.String(describing: description)), isModifiable: \(Swift.String(describing: isModifiable)), minimumEngineVersion: \(Swift.String(describing: minimumEngineVersion)), parameterName: \(Swift.String(describing: parameterName)), parameterValue: \(Swift.String(describing: parameterValue)), source: \(Swift.String(describing: source)))"}
}

extension RedshiftClientTypes {
    /// <p>Describes a parameter in a cluster parameter group.</p>
    public struct Parameter: Swift.Equatable {
        /// <p>The valid range of values for the parameter.</p>
        public let allowedValues: Swift.String?
        /// <p>Specifies how to apply the WLM configuration parameter. Some properties can be
        ///             applied dynamically, while other properties require that any associated clusters be
        ///             rebooted for the configuration changes to be applied.
        /// For more information about parameters and parameter groups, go to
        /// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a>
        /// in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
        public let applyType: RedshiftClientTypes.ParameterApplyType?
        /// <p>The data type of the parameter.</p>
        public let dataType: Swift.String?
        /// <p>A description of the parameter.</p>
        public let description: Swift.String?
        /// <p>If <code>true</code>, the parameter can be modified. Some parameters have security
        ///             or operational implications that prevent them from being changed. </p>
        public let isModifiable: Swift.Bool
        /// <p>The earliest engine version to which the parameter can apply.</p>
        public let minimumEngineVersion: Swift.String?
        /// <p>The name of the parameter.</p>
        public let parameterName: Swift.String?
        /// <p>The value of the parameter. If <code>ParameterName</code> is <code>wlm_json_configuration</code>,
        ///             then the maximum size of <code>ParameterValue</code> is 8000 characters.</p>
        public let parameterValue: Swift.String?
        /// <p>The source of the parameter value, such as "engine-default" or "user".</p>
        public let source: Swift.String?

        public init (
            allowedValues: Swift.String? = nil,
            applyType: RedshiftClientTypes.ParameterApplyType? = nil,
            dataType: Swift.String? = nil,
            description: Swift.String? = nil,
            isModifiable: Swift.Bool = false,
            minimumEngineVersion: Swift.String? = nil,
            parameterName: Swift.String? = nil,
            parameterValue: Swift.String? = nil,
            source: Swift.String? = nil
        )
        {
            self.allowedValues = allowedValues
            self.applyType = applyType
            self.dataType = dataType
            self.description = description
            self.isModifiable = isModifiable
            self.minimumEngineVersion = minimumEngineVersion
            self.parameterName = parameterName
            self.parameterValue = parameterValue
            self.source = source
        }
    }

}

extension RedshiftClientTypes {
    public enum ParameterApplyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `dynamic`
        case `static`
        case sdkUnknown(Swift.String)

        public static var allCases: [ParameterApplyType] {
            return [
                .dynamic,
                .static,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dynamic: return "dynamic"
            case .static: return "static"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ParameterApplyType(rawValue: rawValue) ?? ParameterApplyType.sdkUnknown(rawValue)
        }
    }
}

extension RedshiftClientTypes.PartnerIntegrationInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case databaseName = "DatabaseName"
        case partnerName = "PartnerName"
        case status = "Status"
        case statusMessage = "StatusMessage"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let createdAt = createdAt {
            try container.encode(ClientRuntime.TimestampWrapper(createdAt, format: .dateTime), forKey: ClientRuntime.Key("createdAt"))
        }
        if let databaseName = databaseName {
            try container.encode(databaseName, forKey: ClientRuntime.Key("DatabaseName"))
        }
        if let partnerName = partnerName {
            try container.encode(partnerName, forKey: ClientRuntime.Key("PartnerName"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let statusMessage = statusMessage {
            try container.encode(statusMessage, forKey: ClientRuntime.Key("StatusMessage"))
        }
        if let updatedAt = updatedAt {
            try container.encode(ClientRuntime.TimestampWrapper(updatedAt, format: .dateTime), forKey: ClientRuntime.Key("updatedAt"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let partnerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .partnerName)
        partnerName = partnerNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.PartnerIntegrationStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        var createdAtBuffer:ClientRuntime.Date? = nil
        if let createdAtDecoded = createdAtDecoded {
            createdAtBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(createdAtDecoded, format: .dateTime)
        }
        createdAt = createdAtBuffer
        let updatedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedAt)
        var updatedAtBuffer:ClientRuntime.Date? = nil
        if let updatedAtDecoded = updatedAtDecoded {
            updatedAtBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(updatedAtDecoded, format: .dateTime)
        }
        updatedAt = updatedAtBuffer
    }
}

extension RedshiftClientTypes.PartnerIntegrationInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PartnerIntegrationInfo(createdAt: \(Swift.String(describing: createdAt)), databaseName: \(Swift.String(describing: databaseName)), partnerName: \(Swift.String(describing: partnerName)), status: \(Swift.String(describing: status)), statusMessage: \(Swift.String(describing: statusMessage)), updatedAt: \(Swift.String(describing: updatedAt)))"}
}

extension RedshiftClientTypes {
    /// <p>Describes a partner integration.</p>
    public struct PartnerIntegrationInfo: Swift.Equatable {
        /// <p>The date (UTC) that the partner integration was created.</p>
        public let createdAt: ClientRuntime.Date?
        /// <p>The name of the database that receives data from a partner.</p>
        public let databaseName: Swift.String?
        /// <p>The name of the partner.</p>
        public let partnerName: Swift.String?
        /// <p>The partner integration status.</p>
        public let status: RedshiftClientTypes.PartnerIntegrationStatus?
        /// <p>The status message provided by the partner.</p>
        public let statusMessage: Swift.String?
        /// <p>The date (UTC) that the partner integration status was last updated by the partner.</p>
        public let updatedAt: ClientRuntime.Date?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            databaseName: Swift.String? = nil,
            partnerName: Swift.String? = nil,
            status: RedshiftClientTypes.PartnerIntegrationStatus? = nil,
            statusMessage: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.databaseName = databaseName
            self.partnerName = partnerName
            self.status = status
            self.statusMessage = statusMessage
            self.updatedAt = updatedAt
        }
    }

}

extension RedshiftClientTypes {
    public enum PartnerIntegrationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case connectionfailure
        case inactive
        case runtimefailure
        case sdkUnknown(Swift.String)

        public static var allCases: [PartnerIntegrationStatus] {
            return [
                .active,
                .connectionfailure,
                .inactive,
                .runtimefailure,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .connectionfailure: return "ConnectionFailure"
            case .inactive: return "Inactive"
            case .runtimefailure: return "RuntimeFailure"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PartnerIntegrationStatus(rawValue: rawValue) ?? PartnerIntegrationStatus.sdkUnknown(rawValue)
        }
    }
}

extension PartnerNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PartnerNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension PartnerNotFoundFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<PartnerNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The name of the partner was not found.</p>
public struct PartnerNotFoundFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct PartnerNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension PartnerNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct PauseClusterInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PauseClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PauseClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PauseClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PauseClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PauseClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PauseClusterOutputError>
}

extension PauseClusterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PauseClusterInput(clusterIdentifier: \(Swift.String(describing: clusterIdentifier)))"}
}

extension PauseClusterInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: ClientRuntime.Key("ClusterIdentifier"))
        }
        try container.encode("PauseCluster", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct PauseClusterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PauseClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PauseClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PauseClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PauseClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PauseClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PauseClusterOutputError>
}

public struct PauseClusterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PauseClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PauseClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PauseClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PauseClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PauseClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PauseClusterOutputError>
}

/// <p>Describes a pause cluster operation. For example, a scheduled action to run the <code>PauseCluster</code> API operation. </p>
public struct PauseClusterInput: Swift.Equatable {
    /// <p>The identifier of the cluster to be paused.</p>
    public let clusterIdentifier: Swift.String?

    public init (
        clusterIdentifier: Swift.String? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
    }
}

extension RedshiftClientTypes.PauseClusterMessage: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterIdentifier = "ClusterIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: ClientRuntime.Key("ClusterIdentifier"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
    }
}

extension RedshiftClientTypes.PauseClusterMessage: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PauseClusterMessage(clusterIdentifier: \(Swift.String(describing: clusterIdentifier)))"}
}

extension RedshiftClientTypes {
    /// <p>Describes a pause cluster operation. For example, a scheduled action to run the <code>PauseCluster</code> API operation. </p>
    public struct PauseClusterMessage: Swift.Equatable {
        /// <p>The identifier of the cluster to be paused.</p>
        public let clusterIdentifier: Swift.String?

        public init (
            clusterIdentifier: Swift.String? = nil
        )
        {
            self.clusterIdentifier = clusterIdentifier
        }
    }

}

extension PauseClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PauseClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PauseClusterOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension PauseClusterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PauseClusterOutputResponse(cluster: \(Swift.String(describing: cluster)))"}
}

extension PauseClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PauseClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct PauseClusterOutputResponse: Swift.Equatable {
    /// <p>Describes a cluster.</p>
    public let cluster: RedshiftClientTypes.Cluster?

    public init (
        cluster: RedshiftClientTypes.Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct PauseClusterOutputResponseBody: Swift.Equatable {
    public let cluster: RedshiftClientTypes.Cluster?
}

extension PauseClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cluster = "Cluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("PauseClusterResult"))
        let clusterDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

extension RedshiftClientTypes.PendingModifiedValues: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automatedSnapshotRetentionPeriod = "AutomatedSnapshotRetentionPeriod"
        case clusterIdentifier = "ClusterIdentifier"
        case clusterType = "ClusterType"
        case clusterVersion = "ClusterVersion"
        case encryptionType = "EncryptionType"
        case enhancedVpcRouting = "EnhancedVpcRouting"
        case maintenanceTrackName = "MaintenanceTrackName"
        case masterUserPassword = "MasterUserPassword"
        case nodeType = "NodeType"
        case numberOfNodes = "NumberOfNodes"
        case publiclyAccessible = "PubliclyAccessible"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let automatedSnapshotRetentionPeriod = automatedSnapshotRetentionPeriod {
            try container.encode(automatedSnapshotRetentionPeriod, forKey: ClientRuntime.Key("AutomatedSnapshotRetentionPeriod"))
        }
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: ClientRuntime.Key("ClusterIdentifier"))
        }
        if let clusterType = clusterType {
            try container.encode(clusterType, forKey: ClientRuntime.Key("ClusterType"))
        }
        if let clusterVersion = clusterVersion {
            try container.encode(clusterVersion, forKey: ClientRuntime.Key("ClusterVersion"))
        }
        if let encryptionType = encryptionType {
            try container.encode(encryptionType, forKey: ClientRuntime.Key("EncryptionType"))
        }
        if let enhancedVpcRouting = enhancedVpcRouting {
            try container.encode(enhancedVpcRouting, forKey: ClientRuntime.Key("EnhancedVpcRouting"))
        }
        if let maintenanceTrackName = maintenanceTrackName {
            try container.encode(maintenanceTrackName, forKey: ClientRuntime.Key("MaintenanceTrackName"))
        }
        if let masterUserPassword = masterUserPassword {
            try container.encode(masterUserPassword, forKey: ClientRuntime.Key("MasterUserPassword"))
        }
        if let nodeType = nodeType {
            try container.encode(nodeType, forKey: ClientRuntime.Key("NodeType"))
        }
        if let numberOfNodes = numberOfNodes {
            try container.encode(numberOfNodes, forKey: ClientRuntime.Key("NumberOfNodes"))
        }
        if let publiclyAccessible = publiclyAccessible {
            try container.encode(publiclyAccessible, forKey: ClientRuntime.Key("PubliclyAccessible"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let masterUserPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterUserPassword)
        masterUserPassword = masterUserPasswordDecoded
        let nodeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeType)
        nodeType = nodeTypeDecoded
        let numberOfNodesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfNodes)
        numberOfNodes = numberOfNodesDecoded
        let clusterTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterType)
        clusterType = clusterTypeDecoded
        let clusterVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterVersion)
        clusterVersion = clusterVersionDecoded
        let automatedSnapshotRetentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .automatedSnapshotRetentionPeriod)
        automatedSnapshotRetentionPeriod = automatedSnapshotRetentionPeriodDecoded
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let publiclyAccessibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publiclyAccessible)
        publiclyAccessible = publiclyAccessibleDecoded
        let enhancedVpcRoutingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enhancedVpcRouting)
        enhancedVpcRouting = enhancedVpcRoutingDecoded
        let maintenanceTrackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maintenanceTrackName)
        maintenanceTrackName = maintenanceTrackNameDecoded
        let encryptionTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionType)
        encryptionType = encryptionTypeDecoded
    }
}

extension RedshiftClientTypes.PendingModifiedValues: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PendingModifiedValues(automatedSnapshotRetentionPeriod: \(Swift.String(describing: automatedSnapshotRetentionPeriod)), clusterIdentifier: \(Swift.String(describing: clusterIdentifier)), clusterType: \(Swift.String(describing: clusterType)), clusterVersion: \(Swift.String(describing: clusterVersion)), encryptionType: \(Swift.String(describing: encryptionType)), enhancedVpcRouting: \(Swift.String(describing: enhancedVpcRouting)), maintenanceTrackName: \(Swift.String(describing: maintenanceTrackName)), masterUserPassword: \(Swift.String(describing: masterUserPassword)), nodeType: \(Swift.String(describing: nodeType)), numberOfNodes: \(Swift.String(describing: numberOfNodes)), publiclyAccessible: \(Swift.String(describing: publiclyAccessible)))"}
}

extension RedshiftClientTypes {
    /// <p>Describes cluster attributes that are in a pending state. A change to one or more
    ///             the attributes was requested and is in progress or will be applied.</p>
    public struct PendingModifiedValues: Swift.Equatable {
        /// <p>The pending or in-progress change of the automated snapshot retention
        ///             period.</p>
        public let automatedSnapshotRetentionPeriod: Swift.Int?
        /// <p>The pending or in-progress change of the new identifier for the cluster.</p>
        public let clusterIdentifier: Swift.String?
        /// <p>The pending or in-progress change of the cluster type.</p>
        public let clusterType: Swift.String?
        /// <p>The pending or in-progress change of the service version.</p>
        public let clusterVersion: Swift.String?
        /// <p>The encryption type for a cluster. Possible values are: KMS and None. </p>
        public let encryptionType: Swift.String?
        /// <p>An option that specifies whether to create the cluster with enhanced VPC routing
        ///             enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a
        ///             VPC. For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in
        ///             the Amazon Redshift Cluster Management Guide.</p>
        ///         <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p>
        ///         <p>Default: false</p>
        public let enhancedVpcRouting: Swift.Bool?
        /// <p>The name of the maintenance track that the cluster will change to during the next
        ///             maintenance window.</p>
        public let maintenanceTrackName: Swift.String?
        /// <p>The pending or in-progress change of the master user password for the
        ///             cluster.</p>
        public let masterUserPassword: Swift.String?
        /// <p>The pending or in-progress change of the cluster's node type.</p>
        public let nodeType: Swift.String?
        /// <p>The pending or in-progress change of the number of nodes in the cluster.</p>
        public let numberOfNodes: Swift.Int?
        /// <p>The pending or in-progress change of the ability to connect to the cluster from the
        ///             public network.</p>
        public let publiclyAccessible: Swift.Bool?

        public init (
            automatedSnapshotRetentionPeriod: Swift.Int? = nil,
            clusterIdentifier: Swift.String? = nil,
            clusterType: Swift.String? = nil,
            clusterVersion: Swift.String? = nil,
            encryptionType: Swift.String? = nil,
            enhancedVpcRouting: Swift.Bool? = nil,
            maintenanceTrackName: Swift.String? = nil,
            masterUserPassword: Swift.String? = nil,
            nodeType: Swift.String? = nil,
            numberOfNodes: Swift.Int? = nil,
            publiclyAccessible: Swift.Bool? = nil
        )
        {
            self.automatedSnapshotRetentionPeriod = automatedSnapshotRetentionPeriod
            self.clusterIdentifier = clusterIdentifier
            self.clusterType = clusterType
            self.clusterVersion = clusterVersion
            self.encryptionType = encryptionType
            self.enhancedVpcRouting = enhancedVpcRouting
            self.maintenanceTrackName = maintenanceTrackName
            self.masterUserPassword = masterUserPassword
            self.nodeType = nodeType
            self.numberOfNodes = numberOfNodes
            self.publiclyAccessible = publiclyAccessible
        }
    }

}

public struct PurchaseReservedNodeOfferingInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PurchaseReservedNodeOfferingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PurchaseReservedNodeOfferingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PurchaseReservedNodeOfferingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PurchaseReservedNodeOfferingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PurchaseReservedNodeOfferingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PurchaseReservedNodeOfferingOutputError>
}

extension PurchaseReservedNodeOfferingInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PurchaseReservedNodeOfferingInput(nodeCount: \(Swift.String(describing: nodeCount)), reservedNodeOfferingId: \(Swift.String(describing: reservedNodeOfferingId)))"}
}

extension PurchaseReservedNodeOfferingInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let nodeCount = nodeCount {
            try container.encode(nodeCount, forKey: ClientRuntime.Key("NodeCount"))
        }
        if let reservedNodeOfferingId = reservedNodeOfferingId {
            try container.encode(reservedNodeOfferingId, forKey: ClientRuntime.Key("ReservedNodeOfferingId"))
        }
        try container.encode("PurchaseReservedNodeOffering", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct PurchaseReservedNodeOfferingInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PurchaseReservedNodeOfferingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PurchaseReservedNodeOfferingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PurchaseReservedNodeOfferingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PurchaseReservedNodeOfferingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PurchaseReservedNodeOfferingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PurchaseReservedNodeOfferingOutputError>
}

public struct PurchaseReservedNodeOfferingInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PurchaseReservedNodeOfferingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PurchaseReservedNodeOfferingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PurchaseReservedNodeOfferingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PurchaseReservedNodeOfferingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PurchaseReservedNodeOfferingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PurchaseReservedNodeOfferingOutputError>
}

/// <p></p>
public struct PurchaseReservedNodeOfferingInput: Swift.Equatable {
    /// <p>The number of reserved nodes that you want to purchase.</p>
    ///         <p>Default: <code>1</code>
    ///         </p>
    public let nodeCount: Swift.Int?
    /// <p>The unique identifier of the reserved node offering you want to purchase.</p>
    public let reservedNodeOfferingId: Swift.String?

    public init (
        nodeCount: Swift.Int? = nil,
        reservedNodeOfferingId: Swift.String? = nil
    )
    {
        self.nodeCount = nodeCount
        self.reservedNodeOfferingId = reservedNodeOfferingId
    }
}

extension PurchaseReservedNodeOfferingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PurchaseReservedNodeOfferingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ReservedNodeAlreadyExistsFault" : self = .reservedNodeAlreadyExistsFault(try ReservedNodeAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReservedNodeOfferingNotFoundFault" : self = .reservedNodeOfferingNotFoundFault(try ReservedNodeOfferingNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReservedNodeQuotaExceededFault" : self = .reservedNodeQuotaExceededFault(try ReservedNodeQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationFault" : self = .unsupportedOperationFault(try UnsupportedOperationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PurchaseReservedNodeOfferingOutputError: Swift.Error, Swift.Equatable {
    case reservedNodeAlreadyExistsFault(ReservedNodeAlreadyExistsFault)
    case reservedNodeOfferingNotFoundFault(ReservedNodeOfferingNotFoundFault)
    case reservedNodeQuotaExceededFault(ReservedNodeQuotaExceededFault)
    case unsupportedOperationFault(UnsupportedOperationFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension PurchaseReservedNodeOfferingOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PurchaseReservedNodeOfferingOutputResponse(reservedNode: \(Swift.String(describing: reservedNode)))"}
}

extension PurchaseReservedNodeOfferingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PurchaseReservedNodeOfferingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.reservedNode = output.reservedNode
        } else {
            self.reservedNode = nil
        }
    }
}

public struct PurchaseReservedNodeOfferingOutputResponse: Swift.Equatable {
    /// <p>Describes a reserved node. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node
    ///             offerings. </p>
    public let reservedNode: RedshiftClientTypes.ReservedNode?

    public init (
        reservedNode: RedshiftClientTypes.ReservedNode? = nil
    )
    {
        self.reservedNode = reservedNode
    }
}

struct PurchaseReservedNodeOfferingOutputResponseBody: Swift.Equatable {
    public let reservedNode: RedshiftClientTypes.ReservedNode?
}

extension PurchaseReservedNodeOfferingOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reservedNode = "ReservedNode"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("PurchaseReservedNodeOfferingResult"))
        let reservedNodeDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.ReservedNode.self, forKey: .reservedNode)
        reservedNode = reservedNodeDecoded
    }
}

public struct RebootClusterInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RebootClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RebootClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RebootClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RebootClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RebootClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RebootClusterOutputError>
}

extension RebootClusterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RebootClusterInput(clusterIdentifier: \(Swift.String(describing: clusterIdentifier)))"}
}

extension RebootClusterInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: ClientRuntime.Key("ClusterIdentifier"))
        }
        try container.encode("RebootCluster", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct RebootClusterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RebootClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RebootClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RebootClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RebootClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RebootClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RebootClusterOutputError>
}

public struct RebootClusterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RebootClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RebootClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RebootClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RebootClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RebootClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RebootClusterOutputError>
}

/// <p></p>
public struct RebootClusterInput: Swift.Equatable {
    /// <p>The cluster identifier.</p>
    public let clusterIdentifier: Swift.String?

    public init (
        clusterIdentifier: Swift.String? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
    }
}

extension RebootClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RebootClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RebootClusterOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RebootClusterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RebootClusterOutputResponse(cluster: \(Swift.String(describing: cluster)))"}
}

extension RebootClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RebootClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct RebootClusterOutputResponse: Swift.Equatable {
    /// <p>Describes a cluster.</p>
    public let cluster: RedshiftClientTypes.Cluster?

    public init (
        cluster: RedshiftClientTypes.Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct RebootClusterOutputResponseBody: Swift.Equatable {
    public let cluster: RedshiftClientTypes.Cluster?
}

extension RebootClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cluster = "Cluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("RebootClusterResult"))
        let clusterDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

extension RedshiftClientTypes.RecurringCharge: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recurringChargeAmount = "RecurringChargeAmount"
        case recurringChargeFrequency = "RecurringChargeFrequency"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if recurringChargeAmount != 0.0 {
            try container.encode(Swift.String(recurringChargeAmount), forKey: ClientRuntime.Key("RecurringChargeAmount"))
        }
        if let recurringChargeFrequency = recurringChargeFrequency {
            try container.encode(recurringChargeFrequency, forKey: ClientRuntime.Key("RecurringChargeFrequency"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recurringChargeAmountDecoded = try containerValues.decode(Swift.Double.self, forKey: .recurringChargeAmount)
        recurringChargeAmount = recurringChargeAmountDecoded
        let recurringChargeFrequencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recurringChargeFrequency)
        recurringChargeFrequency = recurringChargeFrequencyDecoded
    }
}

extension RedshiftClientTypes.RecurringCharge: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RecurringCharge(recurringChargeAmount: \(Swift.String(describing: recurringChargeAmount)), recurringChargeFrequency: \(Swift.String(describing: recurringChargeFrequency)))"}
}

extension RedshiftClientTypes {
    /// <p>Describes a recurring charge.</p>
    public struct RecurringCharge: Swift.Equatable {
        /// <p>The amount charged per the period of time specified by the recurring charge
        ///             frequency.</p>
        public let recurringChargeAmount: Swift.Double
        /// <p>The frequency at which the recurring charge amount is applied.</p>
        public let recurringChargeFrequency: Swift.String?

        public init (
            recurringChargeAmount: Swift.Double = 0.0,
            recurringChargeFrequency: Swift.String? = nil
        )
        {
            self.recurringChargeAmount = recurringChargeAmount
            self.recurringChargeFrequency = recurringChargeFrequency
        }
    }

}

extension RedshiftClientTypes.ReservedNode: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currencyCode = "CurrencyCode"
        case duration = "Duration"
        case fixedPrice = "FixedPrice"
        case nodeCount = "NodeCount"
        case nodeType = "NodeType"
        case offeringType = "OfferingType"
        case recurringCharges = "RecurringCharges"
        case reservedNodeId = "ReservedNodeId"
        case reservedNodeOfferingId = "ReservedNodeOfferingId"
        case reservedNodeOfferingType = "ReservedNodeOfferingType"
        case startTime = "StartTime"
        case state = "State"
        case usagePrice = "UsagePrice"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let currencyCode = currencyCode {
            try container.encode(currencyCode, forKey: ClientRuntime.Key("CurrencyCode"))
        }
        if duration != 0 {
            try container.encode(duration, forKey: ClientRuntime.Key("Duration"))
        }
        if fixedPrice != 0.0 {
            try container.encode(Swift.String(fixedPrice), forKey: ClientRuntime.Key("FixedPrice"))
        }
        if nodeCount != 0 {
            try container.encode(nodeCount, forKey: ClientRuntime.Key("NodeCount"))
        }
        if let nodeType = nodeType {
            try container.encode(nodeType, forKey: ClientRuntime.Key("NodeType"))
        }
        if let offeringType = offeringType {
            try container.encode(offeringType, forKey: ClientRuntime.Key("OfferingType"))
        }
        if let recurringCharges = recurringCharges {
            var recurringChargesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("RecurringCharges"))
            for (index0, recurringcharge0) in recurringCharges.enumerated() {
                try recurringChargesContainer.encode(recurringcharge0, forKey: ClientRuntime.Key("RecurringCharge.\(index0.advanced(by: 1))"))
            }
        }
        if let reservedNodeId = reservedNodeId {
            try container.encode(reservedNodeId, forKey: ClientRuntime.Key("ReservedNodeId"))
        }
        if let reservedNodeOfferingId = reservedNodeOfferingId {
            try container.encode(reservedNodeOfferingId, forKey: ClientRuntime.Key("ReservedNodeOfferingId"))
        }
        if let reservedNodeOfferingType = reservedNodeOfferingType {
            try container.encode(reservedNodeOfferingType, forKey: ClientRuntime.Key("ReservedNodeOfferingType"))
        }
        if let startTime = startTime {
            try container.encode(ClientRuntime.TimestampWrapper(startTime, format: .dateTime), forKey: ClientRuntime.Key("startTime"))
        }
        if let state = state {
            try container.encode(state, forKey: ClientRuntime.Key("State"))
        }
        if usagePrice != 0.0 {
            try container.encode(Swift.String(usagePrice), forKey: ClientRuntime.Key("UsagePrice"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reservedNodeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reservedNodeId)
        reservedNodeId = reservedNodeIdDecoded
        let reservedNodeOfferingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reservedNodeOfferingId)
        reservedNodeOfferingId = reservedNodeOfferingIdDecoded
        let nodeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeType)
        nodeType = nodeTypeDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startTime)
        var startTimeBuffer:ClientRuntime.Date? = nil
        if let startTimeDecoded = startTimeDecoded {
            startTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(startTimeDecoded, format: .dateTime)
        }
        startTime = startTimeBuffer
        let durationDecoded = try containerValues.decode(Swift.Int.self, forKey: .duration)
        duration = durationDecoded
        let fixedPriceDecoded = try containerValues.decode(Swift.Double.self, forKey: .fixedPrice)
        fixedPrice = fixedPriceDecoded
        let usagePriceDecoded = try containerValues.decode(Swift.Double.self, forKey: .usagePrice)
        usagePrice = usagePriceDecoded
        let currencyCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
        let nodeCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .nodeCount)
        nodeCount = nodeCountDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
        let offeringTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .offeringType)
        offeringType = offeringTypeDecoded
        if containerValues.contains(.recurringCharges) {
            struct KeyVal0{struct RecurringCharge{}}
            let recurringChargesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.RecurringCharge>.CodingKeys.self, forKey: .recurringCharges)
            if let recurringChargesWrappedContainer = recurringChargesWrappedContainer {
                let recurringChargesContainer = try recurringChargesWrappedContainer.decodeIfPresent([RedshiftClientTypes.RecurringCharge].self, forKey: .member)
                var recurringChargesBuffer:[RedshiftClientTypes.RecurringCharge]? = nil
                if let recurringChargesContainer = recurringChargesContainer {
                    recurringChargesBuffer = [RedshiftClientTypes.RecurringCharge]()
                    for structureContainer0 in recurringChargesContainer {
                        recurringChargesBuffer?.append(structureContainer0)
                    }
                }
                recurringCharges = recurringChargesBuffer
            } else {
                recurringCharges = []
            }
        } else {
            recurringCharges = nil
        }
        let reservedNodeOfferingTypeDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.ReservedNodeOfferingType.self, forKey: .reservedNodeOfferingType)
        reservedNodeOfferingType = reservedNodeOfferingTypeDecoded
    }
}

extension RedshiftClientTypes.ReservedNode: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReservedNode(currencyCode: \(Swift.String(describing: currencyCode)), duration: \(Swift.String(describing: duration)), fixedPrice: \(Swift.String(describing: fixedPrice)), nodeCount: \(Swift.String(describing: nodeCount)), nodeType: \(Swift.String(describing: nodeType)), offeringType: \(Swift.String(describing: offeringType)), recurringCharges: \(Swift.String(describing: recurringCharges)), reservedNodeId: \(Swift.String(describing: reservedNodeId)), reservedNodeOfferingId: \(Swift.String(describing: reservedNodeOfferingId)), reservedNodeOfferingType: \(Swift.String(describing: reservedNodeOfferingType)), startTime: \(Swift.String(describing: startTime)), state: \(Swift.String(describing: state)), usagePrice: \(Swift.String(describing: usagePrice)))"}
}

extension RedshiftClientTypes {
    /// <p>Describes a reserved node. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node
    ///             offerings. </p>
    public struct ReservedNode: Swift.Equatable {
        /// <p>The currency code for the reserved cluster.</p>
        public let currencyCode: Swift.String?
        /// <p>The duration of the node reservation in seconds.</p>
        public let duration: Swift.Int
        /// <p>The fixed cost Amazon Redshift charges you for this reserved node.</p>
        public let fixedPrice: Swift.Double
        /// <p>The number of reserved compute nodes.</p>
        public let nodeCount: Swift.Int
        /// <p>The node type of the reserved node.</p>
        public let nodeType: Swift.String?
        /// <p>The anticipated utilization of the reserved node, as defined in the reserved node
        ///             offering.</p>
        public let offeringType: Swift.String?
        /// <p>The recurring charges for the reserved node.</p>
        public let recurringCharges: [RedshiftClientTypes.RecurringCharge]?
        /// <p>The unique identifier for the reservation.</p>
        public let reservedNodeId: Swift.String?
        /// <p>The identifier for the reserved node offering.</p>
        public let reservedNodeOfferingId: Swift.String?
        /// <p></p>
        public let reservedNodeOfferingType: RedshiftClientTypes.ReservedNodeOfferingType?
        /// <p>The time the reservation started. You purchase a reserved node offering for a
        ///             duration. This is the start time of that duration.</p>
        public let startTime: ClientRuntime.Date?
        /// <p>The state of the reserved compute node.</p>
        ///         <p>Possible Values:</p>
        ///         <ul>
        ///             <li>
        ///                 <p>pending-payment-This reserved node has recently been purchased, and the
        ///                     sale has been approved, but payment has not yet been confirmed.</p>
        ///             </li>
        ///             <li>
        ///                 <p>active-This reserved node is owned by the caller and is available for
        ///                     use.</p>
        ///             </li>
        ///             <li>
        ///                 <p>payment-failed-Payment failed for the purchase attempt.</p>
        ///             </li>
        ///             <li>
        ///                 <p>retired-The reserved node is no longer available. </p>
        ///             </li>
        ///             <li>
        ///                 <p>exchanging-The owner is exchanging the reserved node for another reserved
        ///                     node.</p>
        ///             </li>
        ///          </ul>
        public let state: Swift.String?
        /// <p>The hourly rate Amazon Redshift charges you for this reserved node.</p>
        public let usagePrice: Swift.Double

        public init (
            currencyCode: Swift.String? = nil,
            duration: Swift.Int = 0,
            fixedPrice: Swift.Double = 0.0,
            nodeCount: Swift.Int = 0,
            nodeType: Swift.String? = nil,
            offeringType: Swift.String? = nil,
            recurringCharges: [RedshiftClientTypes.RecurringCharge]? = nil,
            reservedNodeId: Swift.String? = nil,
            reservedNodeOfferingId: Swift.String? = nil,
            reservedNodeOfferingType: RedshiftClientTypes.ReservedNodeOfferingType? = nil,
            startTime: ClientRuntime.Date? = nil,
            state: Swift.String? = nil,
            usagePrice: Swift.Double = 0.0
        )
        {
            self.currencyCode = currencyCode
            self.duration = duration
            self.fixedPrice = fixedPrice
            self.nodeCount = nodeCount
            self.nodeType = nodeType
            self.offeringType = offeringType
            self.recurringCharges = recurringCharges
            self.reservedNodeId = reservedNodeId
            self.reservedNodeOfferingId = reservedNodeOfferingId
            self.reservedNodeOfferingType = reservedNodeOfferingType
            self.startTime = startTime
            self.state = state
            self.usagePrice = usagePrice
        }
    }

}

extension ReservedNodeAlreadyExistsFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReservedNodeAlreadyExistsFault(message: \(Swift.String(describing: message)))"}
}

extension ReservedNodeAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<ReservedNodeAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>User already has a reservation with the given identifier.</p>
public struct ReservedNodeAlreadyExistsFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ReservedNodeAlreadyExistsFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ReservedNodeAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ReservedNodeAlreadyMigratedFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReservedNodeAlreadyMigratedFault(message: \(Swift.String(describing: message)))"}
}

extension ReservedNodeAlreadyMigratedFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<ReservedNodeAlreadyMigratedFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the reserved node has already been exchanged.</p>
public struct ReservedNodeAlreadyMigratedFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ReservedNodeAlreadyMigratedFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ReservedNodeAlreadyMigratedFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ReservedNodeNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReservedNodeNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension ReservedNodeNotFoundFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<ReservedNodeNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified reserved compute node not found.</p>
public struct ReservedNodeNotFoundFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ReservedNodeNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ReservedNodeNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RedshiftClientTypes.ReservedNodeOffering: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currencyCode = "CurrencyCode"
        case duration = "Duration"
        case fixedPrice = "FixedPrice"
        case nodeType = "NodeType"
        case offeringType = "OfferingType"
        case recurringCharges = "RecurringCharges"
        case reservedNodeOfferingId = "ReservedNodeOfferingId"
        case reservedNodeOfferingType = "ReservedNodeOfferingType"
        case usagePrice = "UsagePrice"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let currencyCode = currencyCode {
            try container.encode(currencyCode, forKey: ClientRuntime.Key("CurrencyCode"))
        }
        if duration != 0 {
            try container.encode(duration, forKey: ClientRuntime.Key("Duration"))
        }
        if fixedPrice != 0.0 {
            try container.encode(Swift.String(fixedPrice), forKey: ClientRuntime.Key("FixedPrice"))
        }
        if let nodeType = nodeType {
            try container.encode(nodeType, forKey: ClientRuntime.Key("NodeType"))
        }
        if let offeringType = offeringType {
            try container.encode(offeringType, forKey: ClientRuntime.Key("OfferingType"))
        }
        if let recurringCharges = recurringCharges {
            var recurringChargesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("RecurringCharges"))
            for (index0, recurringcharge0) in recurringCharges.enumerated() {
                try recurringChargesContainer.encode(recurringcharge0, forKey: ClientRuntime.Key("RecurringCharge.\(index0.advanced(by: 1))"))
            }
        }
        if let reservedNodeOfferingId = reservedNodeOfferingId {
            try container.encode(reservedNodeOfferingId, forKey: ClientRuntime.Key("ReservedNodeOfferingId"))
        }
        if let reservedNodeOfferingType = reservedNodeOfferingType {
            try container.encode(reservedNodeOfferingType, forKey: ClientRuntime.Key("ReservedNodeOfferingType"))
        }
        if usagePrice != 0.0 {
            try container.encode(Swift.String(usagePrice), forKey: ClientRuntime.Key("UsagePrice"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reservedNodeOfferingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reservedNodeOfferingId)
        reservedNodeOfferingId = reservedNodeOfferingIdDecoded
        let nodeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeType)
        nodeType = nodeTypeDecoded
        let durationDecoded = try containerValues.decode(Swift.Int.self, forKey: .duration)
        duration = durationDecoded
        let fixedPriceDecoded = try containerValues.decode(Swift.Double.self, forKey: .fixedPrice)
        fixedPrice = fixedPriceDecoded
        let usagePriceDecoded = try containerValues.decode(Swift.Double.self, forKey: .usagePrice)
        usagePrice = usagePriceDecoded
        let currencyCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
        let offeringTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .offeringType)
        offeringType = offeringTypeDecoded
        if containerValues.contains(.recurringCharges) {
            struct KeyVal0{struct RecurringCharge{}}
            let recurringChargesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.RecurringCharge>.CodingKeys.self, forKey: .recurringCharges)
            if let recurringChargesWrappedContainer = recurringChargesWrappedContainer {
                let recurringChargesContainer = try recurringChargesWrappedContainer.decodeIfPresent([RedshiftClientTypes.RecurringCharge].self, forKey: .member)
                var recurringChargesBuffer:[RedshiftClientTypes.RecurringCharge]? = nil
                if let recurringChargesContainer = recurringChargesContainer {
                    recurringChargesBuffer = [RedshiftClientTypes.RecurringCharge]()
                    for structureContainer0 in recurringChargesContainer {
                        recurringChargesBuffer?.append(structureContainer0)
                    }
                }
                recurringCharges = recurringChargesBuffer
            } else {
                recurringCharges = []
            }
        } else {
            recurringCharges = nil
        }
        let reservedNodeOfferingTypeDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.ReservedNodeOfferingType.self, forKey: .reservedNodeOfferingType)
        reservedNodeOfferingType = reservedNodeOfferingTypeDecoded
    }
}

extension RedshiftClientTypes.ReservedNodeOffering: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReservedNodeOffering(currencyCode: \(Swift.String(describing: currencyCode)), duration: \(Swift.String(describing: duration)), fixedPrice: \(Swift.String(describing: fixedPrice)), nodeType: \(Swift.String(describing: nodeType)), offeringType: \(Swift.String(describing: offeringType)), recurringCharges: \(Swift.String(describing: recurringCharges)), reservedNodeOfferingId: \(Swift.String(describing: reservedNodeOfferingId)), reservedNodeOfferingType: \(Swift.String(describing: reservedNodeOfferingType)), usagePrice: \(Swift.String(describing: usagePrice)))"}
}

extension RedshiftClientTypes {
    /// <p>Describes a reserved node offering.</p>
    public struct ReservedNodeOffering: Swift.Equatable {
        /// <p>The currency code for the compute nodes offering.</p>
        public let currencyCode: Swift.String?
        /// <p>The duration, in seconds, for which the offering will reserve the node.</p>
        public let duration: Swift.Int
        /// <p>The upfront fixed charge you will pay to purchase the specific reserved node
        ///             offering.</p>
        public let fixedPrice: Swift.Double
        /// <p>The node type offered by the reserved node offering.</p>
        public let nodeType: Swift.String?
        /// <p>The anticipated utilization of the reserved node, as defined in the reserved node
        ///             offering.</p>
        public let offeringType: Swift.String?
        /// <p>The charge to your account regardless of whether you are creating any clusters
        ///             using the node offering. Recurring charges are only in effect for heavy-utilization
        ///             reserved nodes.</p>
        public let recurringCharges: [RedshiftClientTypes.RecurringCharge]?
        /// <p>The offering identifier.</p>
        public let reservedNodeOfferingId: Swift.String?
        /// <p></p>
        public let reservedNodeOfferingType: RedshiftClientTypes.ReservedNodeOfferingType?
        /// <p>The rate you are charged for each hour the cluster that is using the offering is
        ///             running.</p>
        public let usagePrice: Swift.Double

        public init (
            currencyCode: Swift.String? = nil,
            duration: Swift.Int = 0,
            fixedPrice: Swift.Double = 0.0,
            nodeType: Swift.String? = nil,
            offeringType: Swift.String? = nil,
            recurringCharges: [RedshiftClientTypes.RecurringCharge]? = nil,
            reservedNodeOfferingId: Swift.String? = nil,
            reservedNodeOfferingType: RedshiftClientTypes.ReservedNodeOfferingType? = nil,
            usagePrice: Swift.Double = 0.0
        )
        {
            self.currencyCode = currencyCode
            self.duration = duration
            self.fixedPrice = fixedPrice
            self.nodeType = nodeType
            self.offeringType = offeringType
            self.recurringCharges = recurringCharges
            self.reservedNodeOfferingId = reservedNodeOfferingId
            self.reservedNodeOfferingType = reservedNodeOfferingType
            self.usagePrice = usagePrice
        }
    }

}

extension ReservedNodeOfferingNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReservedNodeOfferingNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension ReservedNodeOfferingNotFoundFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<ReservedNodeOfferingNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Specified offering does not exist.</p>
public struct ReservedNodeOfferingNotFoundFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ReservedNodeOfferingNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ReservedNodeOfferingNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RedshiftClientTypes {
    public enum ReservedNodeOfferingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case regular
        case upgradable
        case sdkUnknown(Swift.String)

        public static var allCases: [ReservedNodeOfferingType] {
            return [
                .regular,
                .upgradable,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .regular: return "Regular"
            case .upgradable: return "Upgradable"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReservedNodeOfferingType(rawValue: rawValue) ?? ReservedNodeOfferingType.sdkUnknown(rawValue)
        }
    }
}

extension ReservedNodeQuotaExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReservedNodeQuotaExceededFault(message: \(Swift.String(describing: message)))"}
}

extension ReservedNodeQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<ReservedNodeQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Request would exceed the user's compute node quota.
/// For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a>
/// in the <i>Amazon Redshift Cluster Management Guide</i>.
/// </p>
public struct ReservedNodeQuotaExceededFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ReservedNodeQuotaExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ReservedNodeQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ResetClusterParameterGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResetClusterParameterGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ResetClusterParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResetClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ResetClusterParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ResetClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResetClusterParameterGroupOutputError>
}

extension ResetClusterParameterGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResetClusterParameterGroupInput(parameterGroupName: \(Swift.String(describing: parameterGroupName)), parameters: \(Swift.String(describing: parameters)), resetAllParameters: \(Swift.String(describing: resetAllParameters)))"}
}

extension ResetClusterParameterGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let parameterGroupName = parameterGroupName {
            try container.encode(parameterGroupName, forKey: ClientRuntime.Key("ParameterGroupName"))
        }
        if let parameters = parameters {
            var parametersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Parameters"))
            for (index0, parameter0) in parameters.enumerated() {
                try parametersContainer.encode(parameter0, forKey: ClientRuntime.Key("Parameter.\(index0.advanced(by: 1))"))
            }
        }
        if resetAllParameters != false {
            try container.encode(resetAllParameters, forKey: ClientRuntime.Key("ResetAllParameters"))
        }
        try container.encode("ResetClusterParameterGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ResetClusterParameterGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResetClusterParameterGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ResetClusterParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResetClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ResetClusterParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ResetClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResetClusterParameterGroupOutputError>
}

public struct ResetClusterParameterGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResetClusterParameterGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ResetClusterParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResetClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ResetClusterParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ResetClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResetClusterParameterGroupOutputError>
}

/// <p></p>
public struct ResetClusterParameterGroupInput: Swift.Equatable {
    /// <p>The name of the cluster parameter group to be reset.</p>
    public let parameterGroupName: Swift.String?
    /// <p>An array of names of parameters to be reset. If
    ///                 <i>ResetAllParameters</i> option is not used, then at least one
    ///             parameter name must be supplied. </p>
    ///         <p>Constraints: A maximum of 20 parameters can be reset in a single request.</p>
    public let parameters: [RedshiftClientTypes.Parameter]?
    /// <p>If <code>true</code>, all parameters in the specified parameter group will be reset
    ///             to their default values. </p>
    ///         <p>Default: <code>true</code>
    ///         </p>
    public let resetAllParameters: Swift.Bool

    public init (
        parameterGroupName: Swift.String? = nil,
        parameters: [RedshiftClientTypes.Parameter]? = nil,
        resetAllParameters: Swift.Bool = false
    )
    {
        self.parameterGroupName = parameterGroupName
        self.parameters = parameters
        self.resetAllParameters = resetAllParameters
    }
}

extension ResetClusterParameterGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ResetClusterParameterGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterParameterGroupNotFoundFault" : self = .clusterParameterGroupNotFoundFault(try ClusterParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterParameterGroupStateFault" : self = .invalidClusterParameterGroupStateFault(try InvalidClusterParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ResetClusterParameterGroupOutputError: Swift.Error, Swift.Equatable {
    case clusterParameterGroupNotFoundFault(ClusterParameterGroupNotFoundFault)
    case invalidClusterParameterGroupStateFault(InvalidClusterParameterGroupStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResetClusterParameterGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResetClusterParameterGroupOutputResponse(parameterGroupName: \(Swift.String(describing: parameterGroupName)), parameterGroupStatus: \(Swift.String(describing: parameterGroupStatus)))"}
}

extension ResetClusterParameterGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResetClusterParameterGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.parameterGroupName = output.parameterGroupName
            self.parameterGroupStatus = output.parameterGroupStatus
        } else {
            self.parameterGroupName = nil
            self.parameterGroupStatus = nil
        }
    }
}

/// <p></p>
public struct ResetClusterParameterGroupOutputResponse: Swift.Equatable {
    /// <p>The name of the cluster parameter group.</p>
    public let parameterGroupName: Swift.String?
    /// <p>The status of the parameter group. For example, if you made a change to a parameter
    ///             group name-value pair, then the change could be pending a reboot of an associated
    ///             cluster.</p>
    public let parameterGroupStatus: Swift.String?

    public init (
        parameterGroupName: Swift.String? = nil,
        parameterGroupStatus: Swift.String? = nil
    )
    {
        self.parameterGroupName = parameterGroupName
        self.parameterGroupStatus = parameterGroupStatus
    }
}

struct ResetClusterParameterGroupOutputResponseBody: Swift.Equatable {
    public let parameterGroupName: Swift.String?
    public let parameterGroupStatus: Swift.String?
}

extension ResetClusterParameterGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterGroupName = "ParameterGroupName"
        case parameterGroupStatus = "ParameterGroupStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ResetClusterParameterGroupResult"))
        let parameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterGroupName)
        parameterGroupName = parameterGroupNameDecoded
        let parameterGroupStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterGroupStatus)
        parameterGroupStatus = parameterGroupStatusDecoded
    }
}

public struct ResizeClusterInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResizeClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ResizeClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResizeClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ResizeClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ResizeClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResizeClusterOutputError>
}

extension ResizeClusterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResizeClusterInput(classic: \(Swift.String(describing: classic)), clusterIdentifier: \(Swift.String(describing: clusterIdentifier)), clusterType: \(Swift.String(describing: clusterType)), nodeType: \(Swift.String(describing: nodeType)), numberOfNodes: \(Swift.String(describing: numberOfNodes)))"}
}

extension ResizeClusterInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let classic = classic {
            try container.encode(classic, forKey: ClientRuntime.Key("Classic"))
        }
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: ClientRuntime.Key("ClusterIdentifier"))
        }
        if let clusterType = clusterType {
            try container.encode(clusterType, forKey: ClientRuntime.Key("ClusterType"))
        }
        if let nodeType = nodeType {
            try container.encode(nodeType, forKey: ClientRuntime.Key("NodeType"))
        }
        if let numberOfNodes = numberOfNodes {
            try container.encode(numberOfNodes, forKey: ClientRuntime.Key("NumberOfNodes"))
        }
        try container.encode("ResizeCluster", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ResizeClusterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResizeClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ResizeClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResizeClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ResizeClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ResizeClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResizeClusterOutputError>
}

public struct ResizeClusterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResizeClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ResizeClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResizeClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ResizeClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ResizeClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResizeClusterOutputError>
}

/// <p>Describes a resize cluster operation. For example, a scheduled action to run the <code>ResizeCluster</code> API operation. </p>
public struct ResizeClusterInput: Swift.Equatable {
    /// <p>A boolean value indicating whether the resize operation is using the classic resize
    ///             process. If you don't provide this parameter or set the value to
    ///             <code>false</code>, the resize type is elastic. </p>
    public let classic: Swift.Bool?
    /// <p>The unique identifier for the cluster to resize.</p>
    public let clusterIdentifier: Swift.String?
    /// <p>The new cluster type for the specified cluster.</p>
    public let clusterType: Swift.String?
    /// <p>The new node type for the nodes you are adding. If not specified, the cluster's current node type is used.</p>
    public let nodeType: Swift.String?
    /// <p>The new number of nodes for the cluster. If not specified, the cluster's current number of nodes is used.</p>
    public let numberOfNodes: Swift.Int?

    public init (
        classic: Swift.Bool? = nil,
        clusterIdentifier: Swift.String? = nil,
        clusterType: Swift.String? = nil,
        nodeType: Swift.String? = nil,
        numberOfNodes: Swift.Int? = nil
    )
    {
        self.classic = classic
        self.clusterIdentifier = clusterIdentifier
        self.clusterType = clusterType
        self.nodeType = nodeType
        self.numberOfNodes = numberOfNodes
    }
}

extension RedshiftClientTypes.ResizeClusterMessage: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case classic = "Classic"
        case clusterIdentifier = "ClusterIdentifier"
        case clusterType = "ClusterType"
        case nodeType = "NodeType"
        case numberOfNodes = "NumberOfNodes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let classic = classic {
            try container.encode(classic, forKey: ClientRuntime.Key("Classic"))
        }
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: ClientRuntime.Key("ClusterIdentifier"))
        }
        if let clusterType = clusterType {
            try container.encode(clusterType, forKey: ClientRuntime.Key("ClusterType"))
        }
        if let nodeType = nodeType {
            try container.encode(nodeType, forKey: ClientRuntime.Key("NodeType"))
        }
        if let numberOfNodes = numberOfNodes {
            try container.encode(numberOfNodes, forKey: ClientRuntime.Key("NumberOfNodes"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let clusterTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterType)
        clusterType = clusterTypeDecoded
        let nodeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeType)
        nodeType = nodeTypeDecoded
        let numberOfNodesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfNodes)
        numberOfNodes = numberOfNodesDecoded
        let classicDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .classic)
        classic = classicDecoded
    }
}

extension RedshiftClientTypes.ResizeClusterMessage: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResizeClusterMessage(classic: \(Swift.String(describing: classic)), clusterIdentifier: \(Swift.String(describing: clusterIdentifier)), clusterType: \(Swift.String(describing: clusterType)), nodeType: \(Swift.String(describing: nodeType)), numberOfNodes: \(Swift.String(describing: numberOfNodes)))"}
}

extension RedshiftClientTypes {
    /// <p>Describes a resize cluster operation. For example, a scheduled action to run the <code>ResizeCluster</code> API operation. </p>
    public struct ResizeClusterMessage: Swift.Equatable {
        /// <p>A boolean value indicating whether the resize operation is using the classic resize
        ///             process. If you don't provide this parameter or set the value to
        ///             <code>false</code>, the resize type is elastic. </p>
        public let classic: Swift.Bool?
        /// <p>The unique identifier for the cluster to resize.</p>
        public let clusterIdentifier: Swift.String?
        /// <p>The new cluster type for the specified cluster.</p>
        public let clusterType: Swift.String?
        /// <p>The new node type for the nodes you are adding. If not specified, the cluster's current node type is used.</p>
        public let nodeType: Swift.String?
        /// <p>The new number of nodes for the cluster. If not specified, the cluster's current number of nodes is used.</p>
        public let numberOfNodes: Swift.Int?

        public init (
            classic: Swift.Bool? = nil,
            clusterIdentifier: Swift.String? = nil,
            clusterType: Swift.String? = nil,
            nodeType: Swift.String? = nil,
            numberOfNodes: Swift.Int? = nil
        )
        {
            self.classic = classic
            self.clusterIdentifier = clusterIdentifier
            self.clusterType = clusterType
            self.nodeType = nodeType
            self.numberOfNodes = numberOfNodes
        }
    }

}

extension ResizeClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ResizeClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientClusterCapacityFault" : self = .insufficientClusterCapacityFault(try InsufficientClusterCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededFault" : self = .limitExceededFault(try LimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NumberOfNodesPerClusterLimitExceededFault" : self = .numberOfNodesPerClusterLimitExceededFault(try NumberOfNodesPerClusterLimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NumberOfNodesQuotaExceededFault" : self = .numberOfNodesQuotaExceededFault(try NumberOfNodesQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationFault" : self = .unsupportedOperationFault(try UnsupportedOperationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOptionFault" : self = .unsupportedOptionFault(try UnsupportedOptionFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ResizeClusterOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case insufficientClusterCapacityFault(InsufficientClusterCapacityFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case limitExceededFault(LimitExceededFault)
    case numberOfNodesPerClusterLimitExceededFault(NumberOfNodesPerClusterLimitExceededFault)
    case numberOfNodesQuotaExceededFault(NumberOfNodesQuotaExceededFault)
    case unauthorizedOperation(UnauthorizedOperation)
    case unsupportedOperationFault(UnsupportedOperationFault)
    case unsupportedOptionFault(UnsupportedOptionFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResizeClusterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResizeClusterOutputResponse(cluster: \(Swift.String(describing: cluster)))"}
}

extension ResizeClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResizeClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct ResizeClusterOutputResponse: Swift.Equatable {
    /// <p>Describes a cluster.</p>
    public let cluster: RedshiftClientTypes.Cluster?

    public init (
        cluster: RedshiftClientTypes.Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct ResizeClusterOutputResponseBody: Swift.Equatable {
    public let cluster: RedshiftClientTypes.Cluster?
}

extension ResizeClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cluster = "Cluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ResizeClusterResult"))
        let clusterDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

extension RedshiftClientTypes.ResizeInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowCancelResize = "AllowCancelResize"
        case resizeType = "ResizeType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if allowCancelResize != false {
            try container.encode(allowCancelResize, forKey: ClientRuntime.Key("AllowCancelResize"))
        }
        if let resizeType = resizeType {
            try container.encode(resizeType, forKey: ClientRuntime.Key("ResizeType"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resizeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resizeType)
        resizeType = resizeTypeDecoded
        let allowCancelResizeDecoded = try containerValues.decode(Swift.Bool.self, forKey: .allowCancelResize)
        allowCancelResize = allowCancelResizeDecoded
    }
}

extension RedshiftClientTypes.ResizeInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResizeInfo(allowCancelResize: \(Swift.String(describing: allowCancelResize)), resizeType: \(Swift.String(describing: resizeType)))"}
}

extension RedshiftClientTypes {
    /// <p>Describes a resize operation.</p>
    public struct ResizeInfo: Swift.Equatable {
        /// <p>A boolean value indicating if the resize operation can be cancelled.</p>
        public let allowCancelResize: Swift.Bool
        /// <p>Returns the value <code>ClassicResize</code>.</p>
        public let resizeType: Swift.String?

        public init (
            allowCancelResize: Swift.Bool = false,
            resizeType: Swift.String? = nil
        )
        {
            self.allowCancelResize = allowCancelResize
            self.resizeType = resizeType
        }
    }

}

extension ResizeNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResizeNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension ResizeNotFoundFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<ResizeNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A resize operation for the specified cluster is not found.</p>
public struct ResizeNotFoundFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResizeNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResizeNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<ResourceNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource could not be found.</p>
public struct ResourceNotFoundFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct RestoreFromClusterSnapshotInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreFromClusterSnapshotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RestoreFromClusterSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestoreFromClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RestoreFromClusterSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreFromClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestoreFromClusterSnapshotOutputError>
}

extension RestoreFromClusterSnapshotInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RestoreFromClusterSnapshotInput(additionalInfo: \(Swift.String(describing: additionalInfo)), allowVersionUpgrade: \(Swift.String(describing: allowVersionUpgrade)), aquaConfigurationStatus: \(Swift.String(describing: aquaConfigurationStatus)), automatedSnapshotRetentionPeriod: \(Swift.String(describing: automatedSnapshotRetentionPeriod)), availabilityZone: \(Swift.String(describing: availabilityZone)), availabilityZoneRelocation: \(Swift.String(describing: availabilityZoneRelocation)), clusterIdentifier: \(Swift.String(describing: clusterIdentifier)), clusterParameterGroupName: \(Swift.String(describing: clusterParameterGroupName)), clusterSecurityGroups: \(Swift.String(describing: clusterSecurityGroups)), clusterSubnetGroupName: \(Swift.String(describing: clusterSubnetGroupName)), elasticIp: \(Swift.String(describing: elasticIp)), enhancedVpcRouting: \(Swift.String(describing: enhancedVpcRouting)), hsmClientCertificateIdentifier: \(Swift.String(describing: hsmClientCertificateIdentifier)), hsmConfigurationIdentifier: \(Swift.String(describing: hsmConfigurationIdentifier)), iamRoles: \(Swift.String(describing: iamRoles)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), maintenanceTrackName: \(Swift.String(describing: maintenanceTrackName)), manualSnapshotRetentionPeriod: \(Swift.String(describing: manualSnapshotRetentionPeriod)), nodeType: \(Swift.String(describing: nodeType)), numberOfNodes: \(Swift.String(describing: numberOfNodes)), ownerAccount: \(Swift.String(describing: ownerAccount)), port: \(Swift.String(describing: port)), preferredMaintenanceWindow: \(Swift.String(describing: preferredMaintenanceWindow)), publiclyAccessible: \(Swift.String(describing: publiclyAccessible)), snapshotClusterIdentifier: \(Swift.String(describing: snapshotClusterIdentifier)), snapshotIdentifier: \(Swift.String(describing: snapshotIdentifier)), snapshotScheduleIdentifier: \(Swift.String(describing: snapshotScheduleIdentifier)), vpcSecurityGroupIds: \(Swift.String(describing: vpcSecurityGroupIds)))"}
}

extension RestoreFromClusterSnapshotInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let additionalInfo = additionalInfo {
            try container.encode(additionalInfo, forKey: ClientRuntime.Key("AdditionalInfo"))
        }
        if let allowVersionUpgrade = allowVersionUpgrade {
            try container.encode(allowVersionUpgrade, forKey: ClientRuntime.Key("AllowVersionUpgrade"))
        }
        if let aquaConfigurationStatus = aquaConfigurationStatus {
            try container.encode(aquaConfigurationStatus, forKey: ClientRuntime.Key("AquaConfigurationStatus"))
        }
        if let automatedSnapshotRetentionPeriod = automatedSnapshotRetentionPeriod {
            try container.encode(automatedSnapshotRetentionPeriod, forKey: ClientRuntime.Key("AutomatedSnapshotRetentionPeriod"))
        }
        if let availabilityZone = availabilityZone {
            try container.encode(availabilityZone, forKey: ClientRuntime.Key("AvailabilityZone"))
        }
        if let availabilityZoneRelocation = availabilityZoneRelocation {
            try container.encode(availabilityZoneRelocation, forKey: ClientRuntime.Key("AvailabilityZoneRelocation"))
        }
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: ClientRuntime.Key("ClusterIdentifier"))
        }
        if let clusterParameterGroupName = clusterParameterGroupName {
            try container.encode(clusterParameterGroupName, forKey: ClientRuntime.Key("ClusterParameterGroupName"))
        }
        if let clusterSecurityGroups = clusterSecurityGroups {
            var clusterSecurityGroupsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ClusterSecurityGroups"))
            for (index0, string0) in clusterSecurityGroups.enumerated() {
                try clusterSecurityGroupsContainer.encode(string0, forKey: ClientRuntime.Key("ClusterSecurityGroupName.\(index0.advanced(by: 1))"))
            }
        }
        if let clusterSubnetGroupName = clusterSubnetGroupName {
            try container.encode(clusterSubnetGroupName, forKey: ClientRuntime.Key("ClusterSubnetGroupName"))
        }
        if let elasticIp = elasticIp {
            try container.encode(elasticIp, forKey: ClientRuntime.Key("ElasticIp"))
        }
        if let enhancedVpcRouting = enhancedVpcRouting {
            try container.encode(enhancedVpcRouting, forKey: ClientRuntime.Key("EnhancedVpcRouting"))
        }
        if let hsmClientCertificateIdentifier = hsmClientCertificateIdentifier {
            try container.encode(hsmClientCertificateIdentifier, forKey: ClientRuntime.Key("HsmClientCertificateIdentifier"))
        }
        if let hsmConfigurationIdentifier = hsmConfigurationIdentifier {
            try container.encode(hsmConfigurationIdentifier, forKey: ClientRuntime.Key("HsmConfigurationIdentifier"))
        }
        if let iamRoles = iamRoles {
            var iamRolesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("IamRoles"))
            for (index0, string0) in iamRoles.enumerated() {
                try iamRolesContainer.encode(string0, forKey: ClientRuntime.Key("IamRoleArn.\(index0.advanced(by: 1))"))
            }
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: ClientRuntime.Key("KmsKeyId"))
        }
        if let maintenanceTrackName = maintenanceTrackName {
            try container.encode(maintenanceTrackName, forKey: ClientRuntime.Key("MaintenanceTrackName"))
        }
        if let manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriod {
            try container.encode(manualSnapshotRetentionPeriod, forKey: ClientRuntime.Key("ManualSnapshotRetentionPeriod"))
        }
        if let nodeType = nodeType {
            try container.encode(nodeType, forKey: ClientRuntime.Key("NodeType"))
        }
        if let numberOfNodes = numberOfNodes {
            try container.encode(numberOfNodes, forKey: ClientRuntime.Key("NumberOfNodes"))
        }
        if let ownerAccount = ownerAccount {
            try container.encode(ownerAccount, forKey: ClientRuntime.Key("OwnerAccount"))
        }
        if let port = port {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try container.encode(preferredMaintenanceWindow, forKey: ClientRuntime.Key("PreferredMaintenanceWindow"))
        }
        if let publiclyAccessible = publiclyAccessible {
            try container.encode(publiclyAccessible, forKey: ClientRuntime.Key("PubliclyAccessible"))
        }
        if let snapshotClusterIdentifier = snapshotClusterIdentifier {
            try container.encode(snapshotClusterIdentifier, forKey: ClientRuntime.Key("SnapshotClusterIdentifier"))
        }
        if let snapshotIdentifier = snapshotIdentifier {
            try container.encode(snapshotIdentifier, forKey: ClientRuntime.Key("SnapshotIdentifier"))
        }
        if let snapshotScheduleIdentifier = snapshotScheduleIdentifier {
            try container.encode(snapshotScheduleIdentifier, forKey: ClientRuntime.Key("SnapshotScheduleIdentifier"))
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: ClientRuntime.Key("VpcSecurityGroupId.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("RestoreFromClusterSnapshot", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct RestoreFromClusterSnapshotInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreFromClusterSnapshotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RestoreFromClusterSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestoreFromClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RestoreFromClusterSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreFromClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestoreFromClusterSnapshotOutputError>
}

public struct RestoreFromClusterSnapshotInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreFromClusterSnapshotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RestoreFromClusterSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestoreFromClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RestoreFromClusterSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreFromClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestoreFromClusterSnapshotOutputError>
}

/// <p></p>
public struct RestoreFromClusterSnapshotInput: Swift.Equatable {
    /// <p>Reserved.</p>
    public let additionalInfo: Swift.String?
    /// <p>If <code>true</code>, major version upgrades can be applied during the maintenance
    ///             window to the Amazon Redshift engine that is running on the cluster. </p>
    ///         <p>Default: <code>true</code>
    ///         </p>
    public let allowVersionUpgrade: Swift.Bool?
    /// <p>The value represents how the cluster is configured to use AQUA (Advanced Query Accelerator) after the cluster is restored. Possible values include the following.</p>
    ///         <ul>
    ///             <li>
    ///                <p>enabled - Use AQUA if it is available for the current AWS Region and Amazon Redshift node type.</p>
    ///             </li>
    ///             <li>
    ///                <p>disabled - Don't use AQUA. </p>
    ///             </li>
    ///             <li>
    ///                <p>auto - Amazon Redshift determines whether to use AQUA.</p>
    ///             </li>
    ///          </ul>
    public let aquaConfigurationStatus: RedshiftClientTypes.AquaConfigurationStatus?
    /// <p>The number of days that automated snapshots are retained. If the value is 0,
    ///             automated snapshots are disabled. Even if automated snapshots are disabled, you can
    ///             still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p>
    ///
    ///         <p>You can't disable automated snapshots for RA3 node types. Set the automated retention period from 1-35 days.</p>
    ///         <p>Default: The value selected for the cluster from which the snapshot was
    ///             taken.</p>
    ///         <p>Constraints: Must be a value from 0 to 35.</p>
    public let automatedSnapshotRetentionPeriod: Swift.Int?
    /// <p>The Amazon EC2 Availability Zone in which to restore the cluster.</p>
    ///         <p>Default: A random, system-chosen Availability Zone.</p>
    ///         <p>Example: <code>us-east-2a</code>
    ///         </p>
    public let availabilityZone: Swift.String?
    /// <p>The option to enable relocation for an Amazon Redshift cluster between Availability Zones after the cluster is restored.</p>
    public let availabilityZoneRelocation: Swift.Bool?
    /// <p>The identifier of the cluster that will be created from restoring the
    ///             snapshot.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>Alphabetic characters must be lowercase.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>Must be unique for all clusters within an AWS account.</p>
    ///             </li>
    ///          </ul>
    public let clusterIdentifier: Swift.String?
    /// <p>The name of the parameter group to be associated with this cluster.</p>
    ///         <p>Default: The default Amazon Redshift cluster parameter group. For information about the
    ///             default parameter group, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon
    ///                 Redshift Parameter Groups</a>.</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Must be 1 to 255 alphanumeric characters or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                 <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Cannot end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///          </ul>
    public let clusterParameterGroupName: Swift.String?
    /// <p>A list of security groups to be associated with this cluster.</p>
    ///         <p>Default: The default cluster security group for Amazon Redshift.</p>
    ///         <p>Cluster security groups only apply to clusters outside of VPCs.</p>
    public let clusterSecurityGroups: [Swift.String]?
    /// <p>The name of the subnet group where you want to cluster restored.</p>
    ///         <p>A snapshot of cluster in VPC can be restored only in VPC. Therefore, you must
    ///             provide subnet group name where you want the cluster restored.</p>
    public let clusterSubnetGroupName: Swift.String?
    /// <p>The elastic IP (EIP) address for the cluster.</p>
    public let elasticIp: Swift.String?
    /// <p>An option that specifies whether to create the cluster with enhanced VPC routing
    ///             enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a
    ///             VPC. For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in
    ///             the Amazon Redshift Cluster Management Guide.</p>
    ///         <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p>
    ///         <p>Default: false</p>
    public let enhancedVpcRouting: Swift.Bool?
    /// <p>Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to
    ///             retrieve the data encryption keys stored in an HSM.</p>
    public let hsmClientCertificateIdentifier: Swift.String?
    /// <p>Specifies the name of the HSM configuration that contains the information the
    ///             Amazon Redshift cluster can use to retrieve and store keys in an HSM.</p>
    public let hsmConfigurationIdentifier: Swift.String?
    /// <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the
    ///             cluster to access other AWS services. You must supply the IAM roles in their Amazon
    ///             Resource Name (ARN) format. You can supply up to 10 IAM roles in a single
    ///             request.</p>
    ///         <p>A cluster can have up to 10 IAM roles associated at any time.</p>
    public let iamRoles: [Swift.String]?
    /// <p>The AWS Key Management Service (KMS) key ID of the encryption key that you want to
    ///             use to encrypt data in the cluster that you restore from a shared snapshot.</p>
    public let kmsKeyId: Swift.String?
    /// <p>The name of the maintenance track for the restored cluster. When you take a snapshot,
    ///             the snapshot inherits the <code>MaintenanceTrack</code> value from the cluster. The
    ///             snapshot might be on a different track than the cluster that was the source for the
    ///             snapshot. For example, suppose that you take a snapshot of a cluster that is on the
    ///             current track and then change the cluster to be on the trailing track. In this case, the
    ///             snapshot and the source cluster are on different tracks.</p>
    public let maintenanceTrackName: Swift.String?
    /// <p>The default number of days to retain a manual snapshot. If the value is -1, the
    ///             snapshot is retained indefinitely. This setting doesn't change the retention period
    ///             of existing snapshots.</p>
    ///         <p>The value must be either -1 or an integer between 1 and 3,653.</p>
    public let manualSnapshotRetentionPeriod: Swift.Int?
    /// <p>The node type that the restored cluster will be provisioned with.</p>
    ///         <p>Default: The node type of the cluster from which the snapshot was taken. You can
    ///             modify this if you are using any DS node type. In that case, you can choose to restore
    ///             into another DS node type of the same size. For example, you can restore ds1.8xlarge
    ///             into ds2.8xlarge, or ds1.xlarge into ds2.xlarge. If you have a DC instance type, you
    ///             must restore into that same instance type and size. In other words, you can only restore
    ///             a dc1.large instance type into another dc1.large instance type or dc2.large instance
    ///             type. You can't restore dc1.8xlarge to dc2.8xlarge. First restore to a dc1.8xlarge
    ///             cluster, then resize to a dc2.8large cluster. For more information about node types, see
    ///                 <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-about-clusters-and-nodes">
    ///                 About Clusters and Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
    public let nodeType: Swift.String?
    /// <p>The number of nodes specified when provisioning the restored cluster.</p>
    public let numberOfNodes: Swift.Int?
    /// <p>The AWS customer account used to create or copy the snapshot. Required if you are
    ///             restoring a snapshot you do not own, optional if you own the snapshot.</p>
    public let ownerAccount: Swift.String?
    /// <p>The port number on which the cluster accepts connections.</p>
    ///         <p>Default: The same port as the original cluster.</p>
    ///         <p>Constraints: Must be between <code>1115</code> and <code>65535</code>.</p>
    public let port: Swift.Int?
    /// <p>The weekly time range (in UTC) during which automated cluster maintenance can
    ///             occur.</p>
    ///         <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code>
    ///         </p>
    ///         <p> Default: The value selected for the cluster from which the snapshot was taken. For
    ///             more information about the time blocks for each region, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide. </p>
    ///         <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p>
    ///         <p>Constraints: Minimum 30-minute window.</p>
    public let preferredMaintenanceWindow: Swift.String?
    /// <p>If <code>true</code>, the cluster can be accessed from a public network. </p>
    public let publiclyAccessible: Swift.Bool?
    /// <p>The name of the cluster the source snapshot was created from. This parameter is
    ///             required if your IAM user has a policy containing a snapshot resource element that
    ///             specifies anything other than * for the cluster name.</p>
    public let snapshotClusterIdentifier: Swift.String?
    /// <p>The name of the snapshot from which to create the new cluster. This parameter isn't
    ///             case sensitive.</p>
    ///         <p>Example: <code>my-snapshot-id</code>
    ///         </p>
    public let snapshotIdentifier: Swift.String?
    /// <p>A unique identifier for the snapshot schedule.</p>
    public let snapshotScheduleIdentifier: Swift.String?
    /// <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the
    ///             cluster.</p>
    ///         <p>Default: The default VPC security group is associated with the cluster.</p>
    ///         <p>VPC security groups only apply to clusters in VPCs.</p>
    public let vpcSecurityGroupIds: [Swift.String]?

    public init (
        additionalInfo: Swift.String? = nil,
        allowVersionUpgrade: Swift.Bool? = nil,
        aquaConfigurationStatus: RedshiftClientTypes.AquaConfigurationStatus? = nil,
        automatedSnapshotRetentionPeriod: Swift.Int? = nil,
        availabilityZone: Swift.String? = nil,
        availabilityZoneRelocation: Swift.Bool? = nil,
        clusterIdentifier: Swift.String? = nil,
        clusterParameterGroupName: Swift.String? = nil,
        clusterSecurityGroups: [Swift.String]? = nil,
        clusterSubnetGroupName: Swift.String? = nil,
        elasticIp: Swift.String? = nil,
        enhancedVpcRouting: Swift.Bool? = nil,
        hsmClientCertificateIdentifier: Swift.String? = nil,
        hsmConfigurationIdentifier: Swift.String? = nil,
        iamRoles: [Swift.String]? = nil,
        kmsKeyId: Swift.String? = nil,
        maintenanceTrackName: Swift.String? = nil,
        manualSnapshotRetentionPeriod: Swift.Int? = nil,
        nodeType: Swift.String? = nil,
        numberOfNodes: Swift.Int? = nil,
        ownerAccount: Swift.String? = nil,
        port: Swift.Int? = nil,
        preferredMaintenanceWindow: Swift.String? = nil,
        publiclyAccessible: Swift.Bool? = nil,
        snapshotClusterIdentifier: Swift.String? = nil,
        snapshotIdentifier: Swift.String? = nil,
        snapshotScheduleIdentifier: Swift.String? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil
    )
    {
        self.additionalInfo = additionalInfo
        self.allowVersionUpgrade = allowVersionUpgrade
        self.aquaConfigurationStatus = aquaConfigurationStatus
        self.automatedSnapshotRetentionPeriod = automatedSnapshotRetentionPeriod
        self.availabilityZone = availabilityZone
        self.availabilityZoneRelocation = availabilityZoneRelocation
        self.clusterIdentifier = clusterIdentifier
        self.clusterParameterGroupName = clusterParameterGroupName
        self.clusterSecurityGroups = clusterSecurityGroups
        self.clusterSubnetGroupName = clusterSubnetGroupName
        self.elasticIp = elasticIp
        self.enhancedVpcRouting = enhancedVpcRouting
        self.hsmClientCertificateIdentifier = hsmClientCertificateIdentifier
        self.hsmConfigurationIdentifier = hsmConfigurationIdentifier
        self.iamRoles = iamRoles
        self.kmsKeyId = kmsKeyId
        self.maintenanceTrackName = maintenanceTrackName
        self.manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriod
        self.nodeType = nodeType
        self.numberOfNodes = numberOfNodes
        self.ownerAccount = ownerAccount
        self.port = port
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.publiclyAccessible = publiclyAccessible
        self.snapshotClusterIdentifier = snapshotClusterIdentifier
        self.snapshotIdentifier = snapshotIdentifier
        self.snapshotScheduleIdentifier = snapshotScheduleIdentifier
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

extension RestoreFromClusterSnapshotOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RestoreFromClusterSnapshotOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessToSnapshotDeniedFault" : self = .accessToSnapshotDeniedFault(try AccessToSnapshotDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterAlreadyExistsFault" : self = .clusterAlreadyExistsFault(try ClusterAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterParameterGroupNotFoundFault" : self = .clusterParameterGroupNotFoundFault(try ClusterParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterQuotaExceededFault" : self = .clusterQuotaExceededFault(try ClusterQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterSecurityGroupNotFoundFault" : self = .clusterSecurityGroupNotFoundFault(try ClusterSecurityGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterSnapshotNotFoundFault" : self = .clusterSnapshotNotFoundFault(try ClusterSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterSubnetGroupNotFoundFault" : self = .clusterSubnetGroupNotFoundFault(try ClusterSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependentServiceRequestThrottlingFault" : self = .dependentServiceRequestThrottlingFault(try DependentServiceRequestThrottlingFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HsmClientCertificateNotFoundFault" : self = .hsmClientCertificateNotFoundFault(try HsmClientCertificateNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HsmConfigurationNotFoundFault" : self = .hsmConfigurationNotFoundFault(try HsmConfigurationNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientClusterCapacityFault" : self = .insufficientClusterCapacityFault(try InsufficientClusterCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterSnapshotStateFault" : self = .invalidClusterSnapshotStateFault(try InvalidClusterSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterSubnetGroupStateFault" : self = .invalidClusterSubnetGroupStateFault(try InvalidClusterSubnetGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterTrackFault" : self = .invalidClusterTrackFault(try InvalidClusterTrackFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidElasticIpFault" : self = .invalidElasticIpFault(try InvalidElasticIpFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRestoreFault" : self = .invalidRestoreFault(try InvalidRestoreFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagFault" : self = .invalidTagFault(try InvalidTagFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededFault" : self = .limitExceededFault(try LimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NumberOfNodesPerClusterLimitExceededFault" : self = .numberOfNodesPerClusterLimitExceededFault(try NumberOfNodesPerClusterLimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NumberOfNodesQuotaExceededFault" : self = .numberOfNodesQuotaExceededFault(try NumberOfNodesQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotScheduleNotFoundFault" : self = .snapshotScheduleNotFoundFault(try SnapshotScheduleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagLimitExceededFault" : self = .tagLimitExceededFault(try TagLimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RestoreFromClusterSnapshotOutputError: Swift.Error, Swift.Equatable {
    case accessToSnapshotDeniedFault(AccessToSnapshotDeniedFault)
    case clusterAlreadyExistsFault(ClusterAlreadyExistsFault)
    case clusterParameterGroupNotFoundFault(ClusterParameterGroupNotFoundFault)
    case clusterQuotaExceededFault(ClusterQuotaExceededFault)
    case clusterSecurityGroupNotFoundFault(ClusterSecurityGroupNotFoundFault)
    case clusterSnapshotNotFoundFault(ClusterSnapshotNotFoundFault)
    case clusterSubnetGroupNotFoundFault(ClusterSubnetGroupNotFoundFault)
    case dependentServiceRequestThrottlingFault(DependentServiceRequestThrottlingFault)
    case hsmClientCertificateNotFoundFault(HsmClientCertificateNotFoundFault)
    case hsmConfigurationNotFoundFault(HsmConfigurationNotFoundFault)
    case insufficientClusterCapacityFault(InsufficientClusterCapacityFault)
    case invalidClusterSnapshotStateFault(InvalidClusterSnapshotStateFault)
    case invalidClusterSubnetGroupStateFault(InvalidClusterSubnetGroupStateFault)
    case invalidClusterTrackFault(InvalidClusterTrackFault)
    case invalidElasticIpFault(InvalidElasticIpFault)
    case invalidRestoreFault(InvalidRestoreFault)
    case invalidSubnet(InvalidSubnet)
    case invalidTagFault(InvalidTagFault)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case limitExceededFault(LimitExceededFault)
    case numberOfNodesPerClusterLimitExceededFault(NumberOfNodesPerClusterLimitExceededFault)
    case numberOfNodesQuotaExceededFault(NumberOfNodesQuotaExceededFault)
    case snapshotScheduleNotFoundFault(SnapshotScheduleNotFoundFault)
    case tagLimitExceededFault(TagLimitExceededFault)
    case unauthorizedOperation(UnauthorizedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension RestoreFromClusterSnapshotOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RestoreFromClusterSnapshotOutputResponse(cluster: \(Swift.String(describing: cluster)))"}
}

extension RestoreFromClusterSnapshotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RestoreFromClusterSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct RestoreFromClusterSnapshotOutputResponse: Swift.Equatable {
    /// <p>Describes a cluster.</p>
    public let cluster: RedshiftClientTypes.Cluster?

    public init (
        cluster: RedshiftClientTypes.Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct RestoreFromClusterSnapshotOutputResponseBody: Swift.Equatable {
    public let cluster: RedshiftClientTypes.Cluster?
}

extension RestoreFromClusterSnapshotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cluster = "Cluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("RestoreFromClusterSnapshotResult"))
        let clusterDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

extension RedshiftClientTypes.RestoreStatus: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentRestoreRateInMegaBytesPerSecond = "CurrentRestoreRateInMegaBytesPerSecond"
        case elapsedTimeInSeconds = "ElapsedTimeInSeconds"
        case estimatedTimeToCompletionInSeconds = "EstimatedTimeToCompletionInSeconds"
        case progressInMegaBytes = "ProgressInMegaBytes"
        case snapshotSizeInMegaBytes = "SnapshotSizeInMegaBytes"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if currentRestoreRateInMegaBytesPerSecond != 0.0 {
            try container.encode(Swift.String(currentRestoreRateInMegaBytesPerSecond), forKey: ClientRuntime.Key("CurrentRestoreRateInMegaBytesPerSecond"))
        }
        if elapsedTimeInSeconds != 0 {
            try container.encode(elapsedTimeInSeconds, forKey: ClientRuntime.Key("ElapsedTimeInSeconds"))
        }
        if estimatedTimeToCompletionInSeconds != 0 {
            try container.encode(estimatedTimeToCompletionInSeconds, forKey: ClientRuntime.Key("EstimatedTimeToCompletionInSeconds"))
        }
        if progressInMegaBytes != 0 {
            try container.encode(progressInMegaBytes, forKey: ClientRuntime.Key("ProgressInMegaBytes"))
        }
        if snapshotSizeInMegaBytes != 0 {
            try container.encode(snapshotSizeInMegaBytes, forKey: ClientRuntime.Key("SnapshotSizeInMegaBytes"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let currentRestoreRateInMegaBytesPerSecondDecoded = try containerValues.decode(Swift.Double.self, forKey: .currentRestoreRateInMegaBytesPerSecond)
        currentRestoreRateInMegaBytesPerSecond = currentRestoreRateInMegaBytesPerSecondDecoded
        let snapshotSizeInMegaBytesDecoded = try containerValues.decode(Swift.Int.self, forKey: .snapshotSizeInMegaBytes)
        snapshotSizeInMegaBytes = snapshotSizeInMegaBytesDecoded
        let progressInMegaBytesDecoded = try containerValues.decode(Swift.Int.self, forKey: .progressInMegaBytes)
        progressInMegaBytes = progressInMegaBytesDecoded
        let elapsedTimeInSecondsDecoded = try containerValues.decode(Swift.Int.self, forKey: .elapsedTimeInSeconds)
        elapsedTimeInSeconds = elapsedTimeInSecondsDecoded
        let estimatedTimeToCompletionInSecondsDecoded = try containerValues.decode(Swift.Int.self, forKey: .estimatedTimeToCompletionInSeconds)
        estimatedTimeToCompletionInSeconds = estimatedTimeToCompletionInSecondsDecoded
    }
}

extension RedshiftClientTypes.RestoreStatus: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RestoreStatus(currentRestoreRateInMegaBytesPerSecond: \(Swift.String(describing: currentRestoreRateInMegaBytesPerSecond)), elapsedTimeInSeconds: \(Swift.String(describing: elapsedTimeInSeconds)), estimatedTimeToCompletionInSeconds: \(Swift.String(describing: estimatedTimeToCompletionInSeconds)), progressInMegaBytes: \(Swift.String(describing: progressInMegaBytes)), snapshotSizeInMegaBytes: \(Swift.String(describing: snapshotSizeInMegaBytes)), status: \(Swift.String(describing: status)))"}
}

extension RedshiftClientTypes {
    /// <p>Describes the status of a cluster restore action. Returns null if the cluster was
    ///             not created by restoring a snapshot.</p>
    public struct RestoreStatus: Swift.Equatable {
        /// <p>The number of megabytes per second being transferred from the backup storage.
        ///             Returns the average rate for a completed backup.
        ///             This field is only updated when you restore to DC2 and DS2 node types. </p>
        public let currentRestoreRateInMegaBytesPerSecond: Swift.Double
        /// <p>The amount of time an in-progress restore has been running, or the amount of time
        ///             it took a completed restore to finish.
        ///             This field is only updated when you restore to DC2 and DS2 node types. </p>
        public let elapsedTimeInSeconds: Swift.Int
        /// <p>The estimate of the time remaining before the restore will complete. Returns 0 for
        ///             a completed restore.
        ///             This field is only updated when you restore to DC2 and DS2 node types. </p>
        public let estimatedTimeToCompletionInSeconds: Swift.Int
        /// <p>The number of megabytes that have been transferred from snapshot storage.
        ///             This field is only updated when you restore to DC2 and DS2 node types. </p>
        public let progressInMegaBytes: Swift.Int
        /// <p>The size of the set of snapshot data used to restore the cluster.
        ///             This field is only updated when you restore to DC2 and DS2 node types. </p>
        public let snapshotSizeInMegaBytes: Swift.Int
        /// <p>The status of the restore action. Returns starting, restoring, completed, or
        ///             failed.</p>
        public let status: Swift.String?

        public init (
            currentRestoreRateInMegaBytesPerSecond: Swift.Double = 0.0,
            elapsedTimeInSeconds: Swift.Int = 0,
            estimatedTimeToCompletionInSeconds: Swift.Int = 0,
            progressInMegaBytes: Swift.Int = 0,
            snapshotSizeInMegaBytes: Swift.Int = 0,
            status: Swift.String? = nil
        )
        {
            self.currentRestoreRateInMegaBytesPerSecond = currentRestoreRateInMegaBytesPerSecond
            self.elapsedTimeInSeconds = elapsedTimeInSeconds
            self.estimatedTimeToCompletionInSeconds = estimatedTimeToCompletionInSeconds
            self.progressInMegaBytes = progressInMegaBytes
            self.snapshotSizeInMegaBytes = snapshotSizeInMegaBytes
            self.status = status
        }
    }

}

public struct RestoreTableFromClusterSnapshotInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreTableFromClusterSnapshotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RestoreTableFromClusterSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestoreTableFromClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RestoreTableFromClusterSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreTableFromClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestoreTableFromClusterSnapshotOutputError>
}

extension RestoreTableFromClusterSnapshotInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RestoreTableFromClusterSnapshotInput(clusterIdentifier: \(Swift.String(describing: clusterIdentifier)), enableCaseSensitiveIdentifier: \(Swift.String(describing: enableCaseSensitiveIdentifier)), newTableName: \(Swift.String(describing: newTableName)), snapshotIdentifier: \(Swift.String(describing: snapshotIdentifier)), sourceDatabaseName: \(Swift.String(describing: sourceDatabaseName)), sourceSchemaName: \(Swift.String(describing: sourceSchemaName)), sourceTableName: \(Swift.String(describing: sourceTableName)), targetDatabaseName: \(Swift.String(describing: targetDatabaseName)), targetSchemaName: \(Swift.String(describing: targetSchemaName)))"}
}

extension RestoreTableFromClusterSnapshotInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: ClientRuntime.Key("ClusterIdentifier"))
        }
        if let enableCaseSensitiveIdentifier = enableCaseSensitiveIdentifier {
            try container.encode(enableCaseSensitiveIdentifier, forKey: ClientRuntime.Key("EnableCaseSensitiveIdentifier"))
        }
        if let newTableName = newTableName {
            try container.encode(newTableName, forKey: ClientRuntime.Key("NewTableName"))
        }
        if let snapshotIdentifier = snapshotIdentifier {
            try container.encode(snapshotIdentifier, forKey: ClientRuntime.Key("SnapshotIdentifier"))
        }
        if let sourceDatabaseName = sourceDatabaseName {
            try container.encode(sourceDatabaseName, forKey: ClientRuntime.Key("SourceDatabaseName"))
        }
        if let sourceSchemaName = sourceSchemaName {
            try container.encode(sourceSchemaName, forKey: ClientRuntime.Key("SourceSchemaName"))
        }
        if let sourceTableName = sourceTableName {
            try container.encode(sourceTableName, forKey: ClientRuntime.Key("SourceTableName"))
        }
        if let targetDatabaseName = targetDatabaseName {
            try container.encode(targetDatabaseName, forKey: ClientRuntime.Key("TargetDatabaseName"))
        }
        if let targetSchemaName = targetSchemaName {
            try container.encode(targetSchemaName, forKey: ClientRuntime.Key("TargetSchemaName"))
        }
        try container.encode("RestoreTableFromClusterSnapshot", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct RestoreTableFromClusterSnapshotInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreTableFromClusterSnapshotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RestoreTableFromClusterSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestoreTableFromClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RestoreTableFromClusterSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreTableFromClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestoreTableFromClusterSnapshotOutputError>
}

public struct RestoreTableFromClusterSnapshotInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreTableFromClusterSnapshotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RestoreTableFromClusterSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestoreTableFromClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RestoreTableFromClusterSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreTableFromClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestoreTableFromClusterSnapshotOutputError>
}

/// <p></p>
public struct RestoreTableFromClusterSnapshotInput: Swift.Equatable {
    /// <p>The identifier of the Amazon Redshift cluster to restore the table to.</p>
    public let clusterIdentifier: Swift.String?
    /// <p>Indicates whether name identifiers for database, schema, and table are case sensitive.
    ///             If <code>true</code>, the names are case sensitive.
    ///             If <code>false</code> (default), the names are not case sensitive.</p>
    public let enableCaseSensitiveIdentifier: Swift.Bool?
    /// <p>The name of the table to create as a result of the current request.</p>
    public let newTableName: Swift.String?
    /// <p>The identifier of the snapshot to restore the table from. This snapshot must have
    ///             been created from the Amazon Redshift cluster specified by the
    ///                 <code>ClusterIdentifier</code> parameter.</p>
    public let snapshotIdentifier: Swift.String?
    /// <p>The name of the source database that contains the table to restore from.</p>
    public let sourceDatabaseName: Swift.String?
    /// <p>The name of the source schema that contains the table to restore from. If you do
    ///             not specify a <code>SourceSchemaName</code> value, the default is
    ///             <code>public</code>.</p>
    public let sourceSchemaName: Swift.String?
    /// <p>The name of the source table to restore from.</p>
    public let sourceTableName: Swift.String?
    /// <p>The name of the database to restore the table to.</p>
    public let targetDatabaseName: Swift.String?
    /// <p>The name of the schema to restore the table to.</p>
    public let targetSchemaName: Swift.String?

    public init (
        clusterIdentifier: Swift.String? = nil,
        enableCaseSensitiveIdentifier: Swift.Bool? = nil,
        newTableName: Swift.String? = nil,
        snapshotIdentifier: Swift.String? = nil,
        sourceDatabaseName: Swift.String? = nil,
        sourceSchemaName: Swift.String? = nil,
        sourceTableName: Swift.String? = nil,
        targetDatabaseName: Swift.String? = nil,
        targetSchemaName: Swift.String? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
        self.enableCaseSensitiveIdentifier = enableCaseSensitiveIdentifier
        self.newTableName = newTableName
        self.snapshotIdentifier = snapshotIdentifier
        self.sourceDatabaseName = sourceDatabaseName
        self.sourceSchemaName = sourceSchemaName
        self.sourceTableName = sourceTableName
        self.targetDatabaseName = targetDatabaseName
        self.targetSchemaName = targetSchemaName
    }
}

extension RestoreTableFromClusterSnapshotOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RestoreTableFromClusterSnapshotOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterSnapshotNotFoundFault" : self = .clusterSnapshotNotFoundFault(try ClusterSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InProgressTableRestoreQuotaExceededFault" : self = .inProgressTableRestoreQuotaExceededFault(try InProgressTableRestoreQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterSnapshotStateFault" : self = .invalidClusterSnapshotStateFault(try InvalidClusterSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTableRestoreArgumentFault" : self = .invalidTableRestoreArgumentFault(try InvalidTableRestoreArgumentFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationFault" : self = .unsupportedOperationFault(try UnsupportedOperationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RestoreTableFromClusterSnapshotOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case clusterSnapshotNotFoundFault(ClusterSnapshotNotFoundFault)
    case inProgressTableRestoreQuotaExceededFault(InProgressTableRestoreQuotaExceededFault)
    case invalidClusterSnapshotStateFault(InvalidClusterSnapshotStateFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidTableRestoreArgumentFault(InvalidTableRestoreArgumentFault)
    case unsupportedOperationFault(UnsupportedOperationFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RestoreTableFromClusterSnapshotOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RestoreTableFromClusterSnapshotOutputResponse(tableRestoreStatus: \(Swift.String(describing: tableRestoreStatus)))"}
}

extension RestoreTableFromClusterSnapshotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RestoreTableFromClusterSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tableRestoreStatus = output.tableRestoreStatus
        } else {
            self.tableRestoreStatus = nil
        }
    }
}

public struct RestoreTableFromClusterSnapshotOutputResponse: Swift.Equatable {
    /// <p>Describes the status of a <a>RestoreTableFromClusterSnapshot</a>
    ///             operation.</p>
    public let tableRestoreStatus: RedshiftClientTypes.TableRestoreStatus?

    public init (
        tableRestoreStatus: RedshiftClientTypes.TableRestoreStatus? = nil
    )
    {
        self.tableRestoreStatus = tableRestoreStatus
    }
}

struct RestoreTableFromClusterSnapshotOutputResponseBody: Swift.Equatable {
    public let tableRestoreStatus: RedshiftClientTypes.TableRestoreStatus?
}

extension RestoreTableFromClusterSnapshotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tableRestoreStatus = "TableRestoreStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("RestoreTableFromClusterSnapshotResult"))
        let tableRestoreStatusDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.TableRestoreStatus.self, forKey: .tableRestoreStatus)
        tableRestoreStatus = tableRestoreStatusDecoded
    }
}

public struct ResumeClusterInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResumeClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ResumeClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResumeClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ResumeClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ResumeClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResumeClusterOutputError>
}

extension ResumeClusterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResumeClusterInput(clusterIdentifier: \(Swift.String(describing: clusterIdentifier)))"}
}

extension ResumeClusterInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: ClientRuntime.Key("ClusterIdentifier"))
        }
        try container.encode("ResumeCluster", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ResumeClusterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResumeClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ResumeClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResumeClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ResumeClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ResumeClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResumeClusterOutputError>
}

public struct ResumeClusterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResumeClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ResumeClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResumeClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ResumeClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ResumeClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResumeClusterOutputError>
}

/// <p>Describes a resume cluster operation. For example, a scheduled action to run the <code>ResumeCluster</code> API operation. </p>
public struct ResumeClusterInput: Swift.Equatable {
    /// <p>The identifier of the cluster to be resumed.</p>
    public let clusterIdentifier: Swift.String?

    public init (
        clusterIdentifier: Swift.String? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
    }
}

extension RedshiftClientTypes.ResumeClusterMessage: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterIdentifier = "ClusterIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: ClientRuntime.Key("ClusterIdentifier"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
    }
}

extension RedshiftClientTypes.ResumeClusterMessage: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResumeClusterMessage(clusterIdentifier: \(Swift.String(describing: clusterIdentifier)))"}
}

extension RedshiftClientTypes {
    /// <p>Describes a resume cluster operation. For example, a scheduled action to run the <code>ResumeCluster</code> API operation. </p>
    public struct ResumeClusterMessage: Swift.Equatable {
        /// <p>The identifier of the cluster to be resumed.</p>
        public let clusterIdentifier: Swift.String?

        public init (
            clusterIdentifier: Swift.String? = nil
        )
        {
            self.clusterIdentifier = clusterIdentifier
        }
    }

}

extension ResumeClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ResumeClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientClusterCapacityFault" : self = .insufficientClusterCapacityFault(try InsufficientClusterCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ResumeClusterOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case insufficientClusterCapacityFault(InsufficientClusterCapacityFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResumeClusterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResumeClusterOutputResponse(cluster: \(Swift.String(describing: cluster)))"}
}

extension ResumeClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResumeClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct ResumeClusterOutputResponse: Swift.Equatable {
    /// <p>Describes a cluster.</p>
    public let cluster: RedshiftClientTypes.Cluster?

    public init (
        cluster: RedshiftClientTypes.Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct ResumeClusterOutputResponseBody: Swift.Equatable {
    public let cluster: RedshiftClientTypes.Cluster?
}

extension ResumeClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cluster = "Cluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ResumeClusterResult"))
        let clusterDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

extension RedshiftClientTypes.RevisionTarget: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseRevision = "DatabaseRevision"
        case databaseRevisionReleaseDate = "DatabaseRevisionReleaseDate"
        case description = "Description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let databaseRevision = databaseRevision {
            try container.encode(databaseRevision, forKey: ClientRuntime.Key("DatabaseRevision"))
        }
        if let databaseRevisionReleaseDate = databaseRevisionReleaseDate {
            try container.encode(ClientRuntime.TimestampWrapper(databaseRevisionReleaseDate, format: .dateTime), forKey: ClientRuntime.Key("databaseRevisionReleaseDate"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseRevisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseRevision)
        databaseRevision = databaseRevisionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let databaseRevisionReleaseDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseRevisionReleaseDate)
        var databaseRevisionReleaseDateBuffer:ClientRuntime.Date? = nil
        if let databaseRevisionReleaseDateDecoded = databaseRevisionReleaseDateDecoded {
            databaseRevisionReleaseDateBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(databaseRevisionReleaseDateDecoded, format: .dateTime)
        }
        databaseRevisionReleaseDate = databaseRevisionReleaseDateBuffer
    }
}

extension RedshiftClientTypes.RevisionTarget: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RevisionTarget(databaseRevision: \(Swift.String(describing: databaseRevision)), databaseRevisionReleaseDate: \(Swift.String(describing: databaseRevisionReleaseDate)), description: \(Swift.String(describing: description)))"}
}

extension RedshiftClientTypes {
    /// <p>Describes a <code>RevisionTarget</code>.</p>
    public struct RevisionTarget: Swift.Equatable {
        /// <p>A unique string that identifies the version to update the cluster to. You can use this
        ///             value in <a>ModifyClusterDbRevision</a>.</p>
        public let databaseRevision: Swift.String?
        /// <p>The date on which the database revision was released.</p>
        public let databaseRevisionReleaseDate: ClientRuntime.Date?
        /// <p>A string that describes the changes and features that will be applied to the cluster
        ///             when it is updated to the corresponding <a>ClusterDbRevision</a>.</p>
        public let description: Swift.String?

        public init (
            databaseRevision: Swift.String? = nil,
            databaseRevisionReleaseDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil
        )
        {
            self.databaseRevision = databaseRevision
            self.databaseRevisionReleaseDate = databaseRevisionReleaseDate
            self.description = description
        }
    }

}

public struct RevokeClusterSecurityGroupIngressInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RevokeClusterSecurityGroupIngressInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RevokeClusterSecurityGroupIngressInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RevokeClusterSecurityGroupIngressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RevokeClusterSecurityGroupIngressInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RevokeClusterSecurityGroupIngressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RevokeClusterSecurityGroupIngressOutputError>
}

extension RevokeClusterSecurityGroupIngressInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RevokeClusterSecurityGroupIngressInput(cIDRIP: \(Swift.String(describing: cIDRIP)), clusterSecurityGroupName: \(Swift.String(describing: clusterSecurityGroupName)), eC2SecurityGroupName: \(Swift.String(describing: eC2SecurityGroupName)), eC2SecurityGroupOwnerId: \(Swift.String(describing: eC2SecurityGroupOwnerId)))"}
}

extension RevokeClusterSecurityGroupIngressInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let cIDRIP = cIDRIP {
            try container.encode(cIDRIP, forKey: ClientRuntime.Key("CIDRIP"))
        }
        if let clusterSecurityGroupName = clusterSecurityGroupName {
            try container.encode(clusterSecurityGroupName, forKey: ClientRuntime.Key("ClusterSecurityGroupName"))
        }
        if let eC2SecurityGroupName = eC2SecurityGroupName {
            try container.encode(eC2SecurityGroupName, forKey: ClientRuntime.Key("EC2SecurityGroupName"))
        }
        if let eC2SecurityGroupOwnerId = eC2SecurityGroupOwnerId {
            try container.encode(eC2SecurityGroupOwnerId, forKey: ClientRuntime.Key("EC2SecurityGroupOwnerId"))
        }
        try container.encode("RevokeClusterSecurityGroupIngress", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct RevokeClusterSecurityGroupIngressInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RevokeClusterSecurityGroupIngressInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RevokeClusterSecurityGroupIngressInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RevokeClusterSecurityGroupIngressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RevokeClusterSecurityGroupIngressInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RevokeClusterSecurityGroupIngressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RevokeClusterSecurityGroupIngressOutputError>
}

public struct RevokeClusterSecurityGroupIngressInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RevokeClusterSecurityGroupIngressInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RevokeClusterSecurityGroupIngressInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RevokeClusterSecurityGroupIngressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RevokeClusterSecurityGroupIngressInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RevokeClusterSecurityGroupIngressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RevokeClusterSecurityGroupIngressOutputError>
}

/// <p></p>
public struct RevokeClusterSecurityGroupIngressInput: Swift.Equatable {
    /// <p>The IP range for which to revoke access. This range must be a valid Classless
    ///             Inter-Domain Routing (CIDR) block of IP addresses. If <code>CIDRIP</code> is specified,
    ///                 <code>EC2SecurityGroupName</code> and <code>EC2SecurityGroupOwnerId</code> cannot be
    ///             provided. </p>
    public let cIDRIP: Swift.String?
    /// <p>The name of the security Group from which to revoke the ingress rule.</p>
    public let clusterSecurityGroupName: Swift.String?
    /// <p>The name of the EC2 Security Group whose access is to be revoked. If
    ///                 <code>EC2SecurityGroupName</code> is specified, <code>EC2SecurityGroupOwnerId</code>
    ///             must also be provided and <code>CIDRIP</code> cannot be provided. </p>
    public let eC2SecurityGroupName: Swift.String?
    /// <p>The AWS account number of the owner of the security group specified in the
    ///                 <code>EC2SecurityGroupName</code> parameter. The AWS access key ID is not an
    ///             acceptable value. If <code>EC2SecurityGroupOwnerId</code> is specified,
    ///                 <code>EC2SecurityGroupName</code> must also be provided. and <code>CIDRIP</code>
    ///             cannot be provided. </p>
    ///         <p>Example: <code>111122223333</code>
    ///         </p>
    public let eC2SecurityGroupOwnerId: Swift.String?

    public init (
        cIDRIP: Swift.String? = nil,
        clusterSecurityGroupName: Swift.String? = nil,
        eC2SecurityGroupName: Swift.String? = nil,
        eC2SecurityGroupOwnerId: Swift.String? = nil
    )
    {
        self.cIDRIP = cIDRIP
        self.clusterSecurityGroupName = clusterSecurityGroupName
        self.eC2SecurityGroupName = eC2SecurityGroupName
        self.eC2SecurityGroupOwnerId = eC2SecurityGroupOwnerId
    }
}

extension RevokeClusterSecurityGroupIngressOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RevokeClusterSecurityGroupIngressOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationNotFoundFault" : self = .authorizationNotFoundFault(try AuthorizationNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterSecurityGroupNotFoundFault" : self = .clusterSecurityGroupNotFoundFault(try ClusterSecurityGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterSecurityGroupStateFault" : self = .invalidClusterSecurityGroupStateFault(try InvalidClusterSecurityGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RevokeClusterSecurityGroupIngressOutputError: Swift.Error, Swift.Equatable {
    case authorizationNotFoundFault(AuthorizationNotFoundFault)
    case clusterSecurityGroupNotFoundFault(ClusterSecurityGroupNotFoundFault)
    case invalidClusterSecurityGroupStateFault(InvalidClusterSecurityGroupStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RevokeClusterSecurityGroupIngressOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RevokeClusterSecurityGroupIngressOutputResponse(clusterSecurityGroup: \(Swift.String(describing: clusterSecurityGroup)))"}
}

extension RevokeClusterSecurityGroupIngressOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RevokeClusterSecurityGroupIngressOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clusterSecurityGroup = output.clusterSecurityGroup
        } else {
            self.clusterSecurityGroup = nil
        }
    }
}

public struct RevokeClusterSecurityGroupIngressOutputResponse: Swift.Equatable {
    /// <p>Describes a security group.</p>
    public let clusterSecurityGroup: RedshiftClientTypes.ClusterSecurityGroup?

    public init (
        clusterSecurityGroup: RedshiftClientTypes.ClusterSecurityGroup? = nil
    )
    {
        self.clusterSecurityGroup = clusterSecurityGroup
    }
}

struct RevokeClusterSecurityGroupIngressOutputResponseBody: Swift.Equatable {
    public let clusterSecurityGroup: RedshiftClientTypes.ClusterSecurityGroup?
}

extension RevokeClusterSecurityGroupIngressOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterSecurityGroup = "ClusterSecurityGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("RevokeClusterSecurityGroupIngressResult"))
        let clusterSecurityGroupDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.ClusterSecurityGroup.self, forKey: .clusterSecurityGroup)
        clusterSecurityGroup = clusterSecurityGroupDecoded
    }
}

public struct RevokeEndpointAccessInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RevokeEndpointAccessInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RevokeEndpointAccessInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RevokeEndpointAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RevokeEndpointAccessInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RevokeEndpointAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RevokeEndpointAccessOutputError>
}

extension RevokeEndpointAccessInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RevokeEndpointAccessInput(account: \(Swift.String(describing: account)), clusterIdentifier: \(Swift.String(describing: clusterIdentifier)), force: \(Swift.String(describing: force)), vpcIds: \(Swift.String(describing: vpcIds)))"}
}

extension RevokeEndpointAccessInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let account = account {
            try container.encode(account, forKey: ClientRuntime.Key("Account"))
        }
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: ClientRuntime.Key("ClusterIdentifier"))
        }
        if force != false {
            try container.encode(force, forKey: ClientRuntime.Key("Force"))
        }
        if let vpcIds = vpcIds {
            var vpcIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcIds"))
            for (index0, string0) in vpcIds.enumerated() {
                try vpcIdsContainer.encode(string0, forKey: ClientRuntime.Key("VpcIdentifier.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("RevokeEndpointAccess", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct RevokeEndpointAccessInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RevokeEndpointAccessInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RevokeEndpointAccessInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RevokeEndpointAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RevokeEndpointAccessInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RevokeEndpointAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RevokeEndpointAccessOutputError>
}

public struct RevokeEndpointAccessInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RevokeEndpointAccessInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RevokeEndpointAccessInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RevokeEndpointAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RevokeEndpointAccessInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RevokeEndpointAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RevokeEndpointAccessOutputError>
}

public struct RevokeEndpointAccessInput: Swift.Equatable {
    /// <p>The AWS account ID whose access is to be revoked.</p>
    public let account: Swift.String?
    /// <p>The cluster to revoke access from.</p>
    public let clusterIdentifier: Swift.String?
    /// <p>Indicates whether to force the revoke action.
    ///            If true, the Redshift-managed VPC endpoints associated with the endpoint authorization are also deleted.</p>
    public let force: Swift.Bool
    /// <p>The virtual private cloud (VPC) identifiers for which access is to be revoked.</p>
    public let vpcIds: [Swift.String]?

    public init (
        account: Swift.String? = nil,
        clusterIdentifier: Swift.String? = nil,
        force: Swift.Bool = false,
        vpcIds: [Swift.String]? = nil
    )
    {
        self.account = account
        self.clusterIdentifier = clusterIdentifier
        self.force = force
        self.vpcIds = vpcIds
    }
}

extension RevokeEndpointAccessOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RevokeEndpointAccessOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EndpointAuthorizationNotFoundFault" : self = .endpointAuthorizationNotFoundFault(try EndpointAuthorizationNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EndpointNotFoundFault" : self = .endpointNotFoundFault(try EndpointNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAuthorizationStateFault" : self = .invalidAuthorizationStateFault(try InvalidAuthorizationStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterSecurityGroupStateFault" : self = .invalidClusterSecurityGroupStateFault(try InvalidClusterSecurityGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointStateFault" : self = .invalidEndpointStateFault(try InvalidEndpointStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RevokeEndpointAccessOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case endpointAuthorizationNotFoundFault(EndpointAuthorizationNotFoundFault)
    case endpointNotFoundFault(EndpointNotFoundFault)
    case invalidAuthorizationStateFault(InvalidAuthorizationStateFault)
    case invalidClusterSecurityGroupStateFault(InvalidClusterSecurityGroupStateFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidEndpointStateFault(InvalidEndpointStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RevokeEndpointAccessOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RevokeEndpointAccessOutputResponse(allowedAllVPCs: \(Swift.String(describing: allowedAllVPCs)), allowedVPCs: \(Swift.String(describing: allowedVPCs)), authorizeTime: \(Swift.String(describing: authorizeTime)), clusterIdentifier: \(Swift.String(describing: clusterIdentifier)), clusterStatus: \(Swift.String(describing: clusterStatus)), endpointCount: \(Swift.String(describing: endpointCount)), grantee: \(Swift.String(describing: grantee)), grantor: \(Swift.String(describing: grantor)), status: \(Swift.String(describing: status)))"}
}

extension RevokeEndpointAccessOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RevokeEndpointAccessOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.allowedAllVPCs = output.allowedAllVPCs
            self.allowedVPCs = output.allowedVPCs
            self.authorizeTime = output.authorizeTime
            self.clusterIdentifier = output.clusterIdentifier
            self.clusterStatus = output.clusterStatus
            self.endpointCount = output.endpointCount
            self.grantee = output.grantee
            self.grantor = output.grantor
            self.status = output.status
        } else {
            self.allowedAllVPCs = false
            self.allowedVPCs = nil
            self.authorizeTime = nil
            self.clusterIdentifier = nil
            self.clusterStatus = nil
            self.endpointCount = 0
            self.grantee = nil
            self.grantor = nil
            self.status = nil
        }
    }
}

/// <p>Describes an endpoint authorization for authorizing Redshift-managed VPC endpoint access to a cluster across AWS accounts.</p>
public struct RevokeEndpointAccessOutputResponse: Swift.Equatable {
    /// <p>Indicates whether all VPCs in the grantee account are allowed access to the cluster.</p>
    public let allowedAllVPCs: Swift.Bool
    /// <p>The VPCs allowed access to the cluster.</p>
    public let allowedVPCs: [Swift.String]?
    /// <p>The time (UTC) when the authorization was created.</p>
    public let authorizeTime: ClientRuntime.Date?
    /// <p>The cluster identifier.</p>
    public let clusterIdentifier: Swift.String?
    /// <p>The status of the cluster.</p>
    public let clusterStatus: Swift.String?
    /// <p>The number of Redshift-managed VPC endpoints created for the authorization.</p>
    public let endpointCount: Swift.Int
    /// <p>The AWS account ID of the grantee of the cluster.</p>
    public let grantee: Swift.String?
    /// <p>The AWS account ID of the cluster owner.</p>
    public let grantor: Swift.String?
    /// <p>The status of the authorization action.</p>
    public let status: RedshiftClientTypes.AuthorizationStatus?

    public init (
        allowedAllVPCs: Swift.Bool = false,
        allowedVPCs: [Swift.String]? = nil,
        authorizeTime: ClientRuntime.Date? = nil,
        clusterIdentifier: Swift.String? = nil,
        clusterStatus: Swift.String? = nil,
        endpointCount: Swift.Int = 0,
        grantee: Swift.String? = nil,
        grantor: Swift.String? = nil,
        status: RedshiftClientTypes.AuthorizationStatus? = nil
    )
    {
        self.allowedAllVPCs = allowedAllVPCs
        self.allowedVPCs = allowedVPCs
        self.authorizeTime = authorizeTime
        self.clusterIdentifier = clusterIdentifier
        self.clusterStatus = clusterStatus
        self.endpointCount = endpointCount
        self.grantee = grantee
        self.grantor = grantor
        self.status = status
    }
}

struct RevokeEndpointAccessOutputResponseBody: Swift.Equatable {
    public let grantor: Swift.String?
    public let grantee: Swift.String?
    public let clusterIdentifier: Swift.String?
    public let authorizeTime: ClientRuntime.Date?
    public let clusterStatus: Swift.String?
    public let status: RedshiftClientTypes.AuthorizationStatus?
    public let allowedAllVPCs: Swift.Bool
    public let allowedVPCs: [Swift.String]?
    public let endpointCount: Swift.Int
}

extension RevokeEndpointAccessOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedAllVPCs = "AllowedAllVPCs"
        case allowedVPCs = "AllowedVPCs"
        case authorizeTime = "AuthorizeTime"
        case clusterIdentifier = "ClusterIdentifier"
        case clusterStatus = "ClusterStatus"
        case endpointCount = "EndpointCount"
        case grantee = "Grantee"
        case grantor = "Grantor"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("RevokeEndpointAccessResult"))
        let grantorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .grantor)
        grantor = grantorDecoded
        let granteeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .grantee)
        grantee = granteeDecoded
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let authorizeTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizeTime)
        var authorizeTimeBuffer:ClientRuntime.Date? = nil
        if let authorizeTimeDecoded = authorizeTimeDecoded {
            authorizeTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(authorizeTimeDecoded, format: .dateTime)
        }
        authorizeTime = authorizeTimeBuffer
        let clusterStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterStatus)
        clusterStatus = clusterStatusDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.AuthorizationStatus.self, forKey: .status)
        status = statusDecoded
        let allowedAllVPCsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .allowedAllVPCs)
        allowedAllVPCs = allowedAllVPCsDecoded
        if containerValues.contains(.allowedVPCs) {
            struct KeyVal0{struct VpcIdentifier{}}
            let allowedVPCsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.VpcIdentifier>.CodingKeys.self, forKey: .allowedVPCs)
            if let allowedVPCsWrappedContainer = allowedVPCsWrappedContainer {
                let allowedVPCsContainer = try allowedVPCsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var allowedVPCsBuffer:[Swift.String]? = nil
                if let allowedVPCsContainer = allowedVPCsContainer {
                    allowedVPCsBuffer = [Swift.String]()
                    for stringContainer0 in allowedVPCsContainer {
                        allowedVPCsBuffer?.append(stringContainer0)
                    }
                }
                allowedVPCs = allowedVPCsBuffer
            } else {
                allowedVPCs = []
            }
        } else {
            allowedVPCs = nil
        }
        let endpointCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .endpointCount)
        endpointCount = endpointCountDecoded
    }
}

public struct RevokeSnapshotAccessInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RevokeSnapshotAccessInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RevokeSnapshotAccessInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RevokeSnapshotAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RevokeSnapshotAccessInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RevokeSnapshotAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RevokeSnapshotAccessOutputError>
}

extension RevokeSnapshotAccessInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RevokeSnapshotAccessInput(accountWithRestoreAccess: \(Swift.String(describing: accountWithRestoreAccess)), snapshotClusterIdentifier: \(Swift.String(describing: snapshotClusterIdentifier)), snapshotIdentifier: \(Swift.String(describing: snapshotIdentifier)))"}
}

extension RevokeSnapshotAccessInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let accountWithRestoreAccess = accountWithRestoreAccess {
            try container.encode(accountWithRestoreAccess, forKey: ClientRuntime.Key("AccountWithRestoreAccess"))
        }
        if let snapshotClusterIdentifier = snapshotClusterIdentifier {
            try container.encode(snapshotClusterIdentifier, forKey: ClientRuntime.Key("SnapshotClusterIdentifier"))
        }
        if let snapshotIdentifier = snapshotIdentifier {
            try container.encode(snapshotIdentifier, forKey: ClientRuntime.Key("SnapshotIdentifier"))
        }
        try container.encode("RevokeSnapshotAccess", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct RevokeSnapshotAccessInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RevokeSnapshotAccessInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RevokeSnapshotAccessInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RevokeSnapshotAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RevokeSnapshotAccessInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RevokeSnapshotAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RevokeSnapshotAccessOutputError>
}

public struct RevokeSnapshotAccessInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RevokeSnapshotAccessInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RevokeSnapshotAccessInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RevokeSnapshotAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RevokeSnapshotAccessInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RevokeSnapshotAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RevokeSnapshotAccessOutputError>
}

/// <p></p>
public struct RevokeSnapshotAccessInput: Swift.Equatable {
    /// <p>The identifier of the AWS customer account that can no longer restore the specified
    ///             snapshot.</p>
    public let accountWithRestoreAccess: Swift.String?
    /// <p>The identifier of the cluster the snapshot was created from. This parameter is
    ///             required if your IAM user has a policy containing a snapshot resource element that
    ///             specifies anything other than * for the cluster name.</p>
    public let snapshotClusterIdentifier: Swift.String?
    /// <p>The identifier of the snapshot that the account can no longer access.</p>
    public let snapshotIdentifier: Swift.String?

    public init (
        accountWithRestoreAccess: Swift.String? = nil,
        snapshotClusterIdentifier: Swift.String? = nil,
        snapshotIdentifier: Swift.String? = nil
    )
    {
        self.accountWithRestoreAccess = accountWithRestoreAccess
        self.snapshotClusterIdentifier = snapshotClusterIdentifier
        self.snapshotIdentifier = snapshotIdentifier
    }
}

extension RevokeSnapshotAccessOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RevokeSnapshotAccessOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessToSnapshotDeniedFault" : self = .accessToSnapshotDeniedFault(try AccessToSnapshotDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationNotFoundFault" : self = .authorizationNotFoundFault(try AuthorizationNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterSnapshotNotFoundFault" : self = .clusterSnapshotNotFoundFault(try ClusterSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RevokeSnapshotAccessOutputError: Swift.Error, Swift.Equatable {
    case accessToSnapshotDeniedFault(AccessToSnapshotDeniedFault)
    case authorizationNotFoundFault(AuthorizationNotFoundFault)
    case clusterSnapshotNotFoundFault(ClusterSnapshotNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RevokeSnapshotAccessOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RevokeSnapshotAccessOutputResponse(snapshot: \(Swift.String(describing: snapshot)))"}
}

extension RevokeSnapshotAccessOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RevokeSnapshotAccessOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.snapshot = output.snapshot
        } else {
            self.snapshot = nil
        }
    }
}

public struct RevokeSnapshotAccessOutputResponse: Swift.Equatable {
    /// <p>Describes a snapshot.</p>
    public let snapshot: RedshiftClientTypes.Snapshot?

    public init (
        snapshot: RedshiftClientTypes.Snapshot? = nil
    )
    {
        self.snapshot = snapshot
    }
}

struct RevokeSnapshotAccessOutputResponseBody: Swift.Equatable {
    public let snapshot: RedshiftClientTypes.Snapshot?
}

extension RevokeSnapshotAccessOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshot = "Snapshot"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("RevokeSnapshotAccessResult"))
        let snapshotDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.Snapshot.self, forKey: .snapshot)
        snapshot = snapshotDecoded
    }
}

public struct RotateEncryptionKeyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RotateEncryptionKeyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RotateEncryptionKeyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RotateEncryptionKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RotateEncryptionKeyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RotateEncryptionKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RotateEncryptionKeyOutputError>
}

extension RotateEncryptionKeyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RotateEncryptionKeyInput(clusterIdentifier: \(Swift.String(describing: clusterIdentifier)))"}
}

extension RotateEncryptionKeyInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: ClientRuntime.Key("ClusterIdentifier"))
        }
        try container.encode("RotateEncryptionKey", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct RotateEncryptionKeyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RotateEncryptionKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RotateEncryptionKeyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RotateEncryptionKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RotateEncryptionKeyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RotateEncryptionKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RotateEncryptionKeyOutputError>
}

public struct RotateEncryptionKeyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RotateEncryptionKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RotateEncryptionKeyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RotateEncryptionKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RotateEncryptionKeyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RotateEncryptionKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RotateEncryptionKeyOutputError>
}

/// <p></p>
public struct RotateEncryptionKeyInput: Swift.Equatable {
    /// <p>The unique identifier of the cluster that you want to rotate the encryption keys
    ///             for.</p>
    ///         <p>Constraints: Must be the name of valid cluster that has encryption
    ///             enabled.</p>
    public let clusterIdentifier: Swift.String?

    public init (
        clusterIdentifier: Swift.String? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
    }
}

extension RotateEncryptionKeyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RotateEncryptionKeyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependentServiceRequestThrottlingFault" : self = .dependentServiceRequestThrottlingFault(try DependentServiceRequestThrottlingFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RotateEncryptionKeyOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case dependentServiceRequestThrottlingFault(DependentServiceRequestThrottlingFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RotateEncryptionKeyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RotateEncryptionKeyOutputResponse(cluster: \(Swift.String(describing: cluster)))"}
}

extension RotateEncryptionKeyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RotateEncryptionKeyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct RotateEncryptionKeyOutputResponse: Swift.Equatable {
    /// <p>Describes a cluster.</p>
    public let cluster: RedshiftClientTypes.Cluster?

    public init (
        cluster: RedshiftClientTypes.Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct RotateEncryptionKeyOutputResponseBody: Swift.Equatable {
    public let cluster: RedshiftClientTypes.Cluster?
}

extension RotateEncryptionKeyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cluster = "Cluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("RotateEncryptionKeyResult"))
        let clusterDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

extension SNSInvalidTopicFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SNSInvalidTopicFault(message: \(Swift.String(describing: message)))"}
}

extension SNSInvalidTopicFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<SNSInvalidTopicFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Amazon SNS has responded that there is a problem with the specified Amazon SNS
///             topic.</p>
public struct SNSInvalidTopicFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SNSInvalidTopicFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SNSInvalidTopicFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SNSNoAuthorizationFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SNSNoAuthorizationFault(message: \(Swift.String(describing: message)))"}
}

extension SNSNoAuthorizationFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<SNSNoAuthorizationFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You do not have permission to publish to the specified Amazon SNS topic.</p>
public struct SNSNoAuthorizationFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SNSNoAuthorizationFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SNSNoAuthorizationFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SNSTopicArnNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SNSTopicArnNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension SNSTopicArnNotFoundFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<SNSTopicArnNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An Amazon SNS topic with the specified Amazon Resource Name (ARN) does not
///             exist.</p>
public struct SNSTopicArnNotFoundFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SNSTopicArnNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SNSTopicArnNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ScheduleDefinitionTypeUnsupportedFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ScheduleDefinitionTypeUnsupportedFault(message: \(Swift.String(describing: message)))"}
}

extension ScheduleDefinitionTypeUnsupportedFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<ScheduleDefinitionTypeUnsupportedFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The definition you submitted is not supported.</p>
public struct ScheduleDefinitionTypeUnsupportedFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ScheduleDefinitionTypeUnsupportedFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ScheduleDefinitionTypeUnsupportedFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RedshiftClientTypes {
    public enum ScheduleState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case failed
        case modifying
        case sdkUnknown(Swift.String)

        public static var allCases: [ScheduleState] {
            return [
                .active,
                .failed,
                .modifying,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .failed: return "FAILED"
            case .modifying: return "MODIFYING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScheduleState(rawValue: rawValue) ?? ScheduleState.sdkUnknown(rawValue)
        }
    }
}

extension RedshiftClientTypes.ScheduledAction: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case iamRole = "IamRole"
        case nextInvocations = "NextInvocations"
        case schedule = "Schedule"
        case scheduledActionDescription = "ScheduledActionDescription"
        case scheduledActionName = "ScheduledActionName"
        case startTime = "StartTime"
        case state = "State"
        case targetAction = "TargetAction"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let endTime = endTime {
            try container.encode(ClientRuntime.TimestampWrapper(endTime, format: .dateTime), forKey: ClientRuntime.Key("endTime"))
        }
        if let iamRole = iamRole {
            try container.encode(iamRole, forKey: ClientRuntime.Key("IamRole"))
        }
        if let nextInvocations = nextInvocations {
            var nextInvocationsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("NextInvocations"))
            for (index0, tstamp0) in nextInvocations.enumerated() {
                try nextInvocationsContainer.encode(TimestampWrapper(tstamp0, format: .dateTime), forKey: ClientRuntime.Key("ScheduledActionTime.\(index0.advanced(by: 1))"))
            }
        }
        if let schedule = schedule {
            try container.encode(schedule, forKey: ClientRuntime.Key("Schedule"))
        }
        if let scheduledActionDescription = scheduledActionDescription {
            try container.encode(scheduledActionDescription, forKey: ClientRuntime.Key("ScheduledActionDescription"))
        }
        if let scheduledActionName = scheduledActionName {
            try container.encode(scheduledActionName, forKey: ClientRuntime.Key("ScheduledActionName"))
        }
        if let startTime = startTime {
            try container.encode(ClientRuntime.TimestampWrapper(startTime, format: .dateTime), forKey: ClientRuntime.Key("startTime"))
        }
        if let state = state {
            try container.encode(state, forKey: ClientRuntime.Key("State"))
        }
        if let targetAction = targetAction {
            try container.encode(targetAction, forKey: ClientRuntime.Key("TargetAction"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduledActionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduledActionName)
        scheduledActionName = scheduledActionNameDecoded
        let targetActionDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.ScheduledActionType.self, forKey: .targetAction)
        targetAction = targetActionDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schedule)
        schedule = scheduleDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
        let scheduledActionDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduledActionDescription)
        scheduledActionDescription = scheduledActionDescriptionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.ScheduledActionState.self, forKey: .state)
        state = stateDecoded
        if containerValues.contains(.nextInvocations) {
            struct KeyVal0{struct ScheduledActionTime{}}
            let nextInvocationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ScheduledActionTime>.CodingKeys.self, forKey: .nextInvocations)
            if let nextInvocationsWrappedContainer = nextInvocationsWrappedContainer {
                let nextInvocationsContainer = try nextInvocationsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var nextInvocationsBuffer:[ClientRuntime.Date]? = nil
                if let nextInvocationsContainer = nextInvocationsContainer {
                    nextInvocationsBuffer = [ClientRuntime.Date]()
                    for timestampContainer0 in nextInvocationsContainer {
                        try nextInvocationsBuffer?.append(ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(timestampContainer0, format: .dateTime))
                    }
                }
                nextInvocations = nextInvocationsBuffer
            } else {
                nextInvocations = []
            }
        } else {
            nextInvocations = nil
        }
        let startTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startTime)
        var startTimeBuffer:ClientRuntime.Date? = nil
        if let startTimeDecoded = startTimeDecoded {
            startTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(startTimeDecoded, format: .dateTime)
        }
        startTime = startTimeBuffer
        let endTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endTime)
        var endTimeBuffer:ClientRuntime.Date? = nil
        if let endTimeDecoded = endTimeDecoded {
            endTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(endTimeDecoded, format: .dateTime)
        }
        endTime = endTimeBuffer
    }
}

extension RedshiftClientTypes.ScheduledAction: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ScheduledAction(endTime: \(Swift.String(describing: endTime)), iamRole: \(Swift.String(describing: iamRole)), nextInvocations: \(Swift.String(describing: nextInvocations)), schedule: \(Swift.String(describing: schedule)), scheduledActionDescription: \(Swift.String(describing: scheduledActionDescription)), scheduledActionName: \(Swift.String(describing: scheduledActionName)), startTime: \(Swift.String(describing: startTime)), state: \(Swift.String(describing: state)), targetAction: \(Swift.String(describing: targetAction)))"}
}

extension RedshiftClientTypes {
    /// <p>Describes a scheduled action. You can use a scheduled action to trigger some Amazon Redshift API operations on a schedule.
    ///             For information about which API operations can be scheduled, see  <a>ScheduledActionType</a>. </p>
    public struct ScheduledAction: Swift.Equatable {
        /// <p>The end time in UTC when the schedule is no longer active. After this time, the scheduled action does not trigger. </p>
        public let endTime: ClientRuntime.Date?
        /// <p>The IAM role to assume to run the scheduled action.
        ///             This IAM role must have permission to run the Amazon Redshift API operation in the scheduled action.
        ///             This IAM role must allow the Amazon Redshift scheduler (Principal scheduler.redshift.amazonaws.com) to assume permissions on your behalf.
        ///
        /// For more information about the IAM role to use with the Amazon Redshift scheduler, see
        /// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html">Using Identity-Based Policies for Amazon Redshift</a>
        /// in the <i>Amazon Redshift Cluster Management Guide</i>.
        /// </p>
        public let iamRole: Swift.String?
        /// <p>List of times when the scheduled action will run. </p>
        public let nextInvocations: [ClientRuntime.Date]?
        /// <p>The schedule for a one-time (at format) or recurring (cron format) scheduled action.
        ///             Schedule invocations must be separated by at least one hour.</p>
        ///         <p>Format of at expressions is "<code>at(yyyy-mm-ddThh:mm:ss)</code>". For example, "<code>at(2016-03-04T17:27:00)</code>".</p>
        ///         <p>Format of cron expressions is "<code>cron(Minutes Hours Day-of-month Month Day-of-week Year)</code>".
        ///             For example, "<code>cron(0 10 ? * MON *)</code>". For more information, see
        ///             <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/events/ScheduledEvents.html#CronExpressions">Cron Expressions</a>
        ///             in the <i>Amazon CloudWatch Events User Guide</i>.</p>
        public let schedule: Swift.String?
        /// <p>The description of the scheduled action. </p>
        public let scheduledActionDescription: Swift.String?
        /// <p>The name of the scheduled action. </p>
        public let scheduledActionName: Swift.String?
        /// <p>The start time in UTC when the schedule is active. Before this time, the scheduled action does not trigger. </p>
        public let startTime: ClientRuntime.Date?
        /// <p>The state of the scheduled action. For example, <code>DISABLED</code>. </p>
        public let state: RedshiftClientTypes.ScheduledActionState?
        /// <p>A JSON format string of the Amazon Redshift API operation with input parameters. </p>
        ///         <p>"<code>{\"ResizeCluster\":{\"NodeType\":\"ds2.8xlarge\",\"ClusterIdentifier\":\"my-test-cluster\",\"NumberOfNodes\":3}}</code>". </p>
        public let targetAction: RedshiftClientTypes.ScheduledActionType?

        public init (
            endTime: ClientRuntime.Date? = nil,
            iamRole: Swift.String? = nil,
            nextInvocations: [ClientRuntime.Date]? = nil,
            schedule: Swift.String? = nil,
            scheduledActionDescription: Swift.String? = nil,
            scheduledActionName: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            state: RedshiftClientTypes.ScheduledActionState? = nil,
            targetAction: RedshiftClientTypes.ScheduledActionType? = nil
        )
        {
            self.endTime = endTime
            self.iamRole = iamRole
            self.nextInvocations = nextInvocations
            self.schedule = schedule
            self.scheduledActionDescription = scheduledActionDescription
            self.scheduledActionName = scheduledActionName
            self.startTime = startTime
            self.state = state
            self.targetAction = targetAction
        }
    }

}

extension ScheduledActionAlreadyExistsFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ScheduledActionAlreadyExistsFault(message: \(Swift.String(describing: message)))"}
}

extension ScheduledActionAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<ScheduledActionAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The scheduled action already exists. </p>
public struct ScheduledActionAlreadyExistsFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ScheduledActionAlreadyExistsFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ScheduledActionAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RedshiftClientTypes.ScheduledActionFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let values = values {
            var valuesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Values"))
            for (index0, string0) in values.enumerated() {
                try valuesContainer.encode(string0, forKey: ClientRuntime.Key("item.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.ScheduledActionFilterName.self, forKey: .name)
        name = nameDecoded
        if containerValues.contains(.values) {
            struct KeyVal0{struct item{}}
            let valuesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .values)
            if let valuesWrappedContainer = valuesWrappedContainer {
                let valuesContainer = try valuesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var valuesBuffer:[Swift.String]? = nil
                if let valuesContainer = valuesContainer {
                    valuesBuffer = [Swift.String]()
                    for stringContainer0 in valuesContainer {
                        valuesBuffer?.append(stringContainer0)
                    }
                }
                values = valuesBuffer
            } else {
                values = []
            }
        } else {
            values = nil
        }
    }
}

extension RedshiftClientTypes.ScheduledActionFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ScheduledActionFilter(name: \(Swift.String(describing: name)), values: \(Swift.String(describing: values)))"}
}

extension RedshiftClientTypes {
    /// <p>A set of elements to filter the returned scheduled actions. </p>
    public struct ScheduledActionFilter: Swift.Equatable {
        /// <p>The type of element to filter. </p>
        public let name: RedshiftClientTypes.ScheduledActionFilterName?
        /// <p>List of values. Compare if the value (of type defined by <code>Name</code>) equals an item in the list of scheduled actions. </p>
        public let values: [Swift.String]?

        public init (
            name: RedshiftClientTypes.ScheduledActionFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension RedshiftClientTypes {
    public enum ScheduledActionFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case clusterIdentifier
        case iamRole
        case sdkUnknown(Swift.String)

        public static var allCases: [ScheduledActionFilterName] {
            return [
                .clusterIdentifier,
                .iamRole,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .clusterIdentifier: return "cluster-identifier"
            case .iamRole: return "iam-role"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScheduledActionFilterName(rawValue: rawValue) ?? ScheduledActionFilterName.sdkUnknown(rawValue)
        }
    }
}

extension ScheduledActionNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ScheduledActionNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension ScheduledActionNotFoundFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<ScheduledActionNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The scheduled action cannot be found. </p>
public struct ScheduledActionNotFoundFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ScheduledActionNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ScheduledActionNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ScheduledActionQuotaExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ScheduledActionQuotaExceededFault(message: \(Swift.String(describing: message)))"}
}

extension ScheduledActionQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<ScheduledActionQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The quota for scheduled actions exceeded. </p>
public struct ScheduledActionQuotaExceededFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ScheduledActionQuotaExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ScheduledActionQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RedshiftClientTypes {
    public enum ScheduledActionState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case disabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ScheduledActionState] {
            return [
                .active,
                .disabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .disabled: return "DISABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScheduledActionState(rawValue: rawValue) ?? ScheduledActionState.sdkUnknown(rawValue)
        }
    }
}

extension RedshiftClientTypes.ScheduledActionType: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pauseCluster = "PauseCluster"
        case resizeCluster = "ResizeCluster"
        case resumeCluster = "ResumeCluster"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let pauseCluster = pauseCluster {
            try container.encode(pauseCluster, forKey: ClientRuntime.Key("PauseCluster"))
        }
        if let resizeCluster = resizeCluster {
            try container.encode(resizeCluster, forKey: ClientRuntime.Key("ResizeCluster"))
        }
        if let resumeCluster = resumeCluster {
            try container.encode(resumeCluster, forKey: ClientRuntime.Key("ResumeCluster"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resizeClusterDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.ResizeClusterMessage.self, forKey: .resizeCluster)
        resizeCluster = resizeClusterDecoded
        let pauseClusterDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.PauseClusterMessage.self, forKey: .pauseCluster)
        pauseCluster = pauseClusterDecoded
        let resumeClusterDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.ResumeClusterMessage.self, forKey: .resumeCluster)
        resumeCluster = resumeClusterDecoded
    }
}

extension RedshiftClientTypes.ScheduledActionType: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ScheduledActionType(pauseCluster: \(Swift.String(describing: pauseCluster)), resizeCluster: \(Swift.String(describing: resizeCluster)), resumeCluster: \(Swift.String(describing: resumeCluster)))"}
}

extension RedshiftClientTypes {
    /// <p>The action type that specifies an Amazon Redshift API operation that is supported by the Amazon Redshift scheduler. </p>
    public struct ScheduledActionType: Swift.Equatable {
        /// <p>An action that runs a <code>PauseCluster</code> API operation. </p>
        public let pauseCluster: RedshiftClientTypes.PauseClusterMessage?
        /// <p>An action that runs a <code>ResizeCluster</code> API operation. </p>
        public let resizeCluster: RedshiftClientTypes.ResizeClusterMessage?
        /// <p>An action that runs a <code>ResumeCluster</code> API operation. </p>
        public let resumeCluster: RedshiftClientTypes.ResumeClusterMessage?

        public init (
            pauseCluster: RedshiftClientTypes.PauseClusterMessage? = nil,
            resizeCluster: RedshiftClientTypes.ResizeClusterMessage? = nil,
            resumeCluster: RedshiftClientTypes.ResumeClusterMessage? = nil
        )
        {
            self.pauseCluster = pauseCluster
            self.resizeCluster = resizeCluster
            self.resumeCluster = resumeCluster
        }
    }

}

extension ScheduledActionTypeUnsupportedFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ScheduledActionTypeUnsupportedFault(message: \(Swift.String(describing: message)))"}
}

extension ScheduledActionTypeUnsupportedFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<ScheduledActionTypeUnsupportedFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The action type specified for a scheduled action is not supported. </p>
public struct ScheduledActionTypeUnsupportedFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ScheduledActionTypeUnsupportedFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ScheduledActionTypeUnsupportedFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RedshiftClientTypes {
    public enum ScheduledActionTypeValues: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case pauseCluster
        case resizeCluster
        case resumeCluster
        case sdkUnknown(Swift.String)

        public static var allCases: [ScheduledActionTypeValues] {
            return [
                .pauseCluster,
                .resizeCluster,
                .resumeCluster,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .pauseCluster: return "PauseCluster"
            case .resizeCluster: return "ResizeCluster"
            case .resumeCluster: return "ResumeCluster"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScheduledActionTypeValues(rawValue: rawValue) ?? ScheduledActionTypeValues.sdkUnknown(rawValue)
        }
    }
}

extension RedshiftClientTypes.Snapshot: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountsWithRestoreAccess = "AccountsWithRestoreAccess"
        case actualIncrementalBackupSizeInMegaBytes = "ActualIncrementalBackupSizeInMegaBytes"
        case availabilityZone = "AvailabilityZone"
        case backupProgressInMegaBytes = "BackupProgressInMegaBytes"
        case clusterCreateTime = "ClusterCreateTime"
        case clusterIdentifier = "ClusterIdentifier"
        case clusterVersion = "ClusterVersion"
        case currentBackupRateInMegaBytesPerSecond = "CurrentBackupRateInMegaBytesPerSecond"
        case dBName = "DBName"
        case elapsedTimeInSeconds = "ElapsedTimeInSeconds"
        case encrypted = "Encrypted"
        case encryptedWithHSM = "EncryptedWithHSM"
        case engineFullVersion = "EngineFullVersion"
        case enhancedVpcRouting = "EnhancedVpcRouting"
        case estimatedSecondsToCompletion = "EstimatedSecondsToCompletion"
        case kmsKeyId = "KmsKeyId"
        case maintenanceTrackName = "MaintenanceTrackName"
        case manualSnapshotRemainingDays = "ManualSnapshotRemainingDays"
        case manualSnapshotRetentionPeriod = "ManualSnapshotRetentionPeriod"
        case masterUsername = "MasterUsername"
        case nodeType = "NodeType"
        case numberOfNodes = "NumberOfNodes"
        case ownerAccount = "OwnerAccount"
        case port = "Port"
        case restorableNodeTypes = "RestorableNodeTypes"
        case snapshotCreateTime = "SnapshotCreateTime"
        case snapshotIdentifier = "SnapshotIdentifier"
        case snapshotRetentionStartTime = "SnapshotRetentionStartTime"
        case snapshotType = "SnapshotType"
        case sourceRegion = "SourceRegion"
        case status = "Status"
        case tags = "Tags"
        case totalBackupSizeInMegaBytes = "TotalBackupSizeInMegaBytes"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let accountsWithRestoreAccess = accountsWithRestoreAccess {
            var accountsWithRestoreAccessContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AccountsWithRestoreAccess"))
            for (index0, accountwithrestoreaccess0) in accountsWithRestoreAccess.enumerated() {
                try accountsWithRestoreAccessContainer.encode(accountwithrestoreaccess0, forKey: ClientRuntime.Key("AccountWithRestoreAccess.\(index0.advanced(by: 1))"))
            }
        }
        if actualIncrementalBackupSizeInMegaBytes != 0.0 {
            try container.encode(Swift.String(actualIncrementalBackupSizeInMegaBytes), forKey: ClientRuntime.Key("ActualIncrementalBackupSizeInMegaBytes"))
        }
        if let availabilityZone = availabilityZone {
            try container.encode(availabilityZone, forKey: ClientRuntime.Key("AvailabilityZone"))
        }
        if backupProgressInMegaBytes != 0.0 {
            try container.encode(Swift.String(backupProgressInMegaBytes), forKey: ClientRuntime.Key("BackupProgressInMegaBytes"))
        }
        if let clusterCreateTime = clusterCreateTime {
            try container.encode(ClientRuntime.TimestampWrapper(clusterCreateTime, format: .dateTime), forKey: ClientRuntime.Key("clusterCreateTime"))
        }
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: ClientRuntime.Key("ClusterIdentifier"))
        }
        if let clusterVersion = clusterVersion {
            try container.encode(clusterVersion, forKey: ClientRuntime.Key("ClusterVersion"))
        }
        if currentBackupRateInMegaBytesPerSecond != 0.0 {
            try container.encode(Swift.String(currentBackupRateInMegaBytesPerSecond), forKey: ClientRuntime.Key("CurrentBackupRateInMegaBytesPerSecond"))
        }
        if let dBName = dBName {
            try container.encode(dBName, forKey: ClientRuntime.Key("DBName"))
        }
        if elapsedTimeInSeconds != 0 {
            try container.encode(elapsedTimeInSeconds, forKey: ClientRuntime.Key("ElapsedTimeInSeconds"))
        }
        if encrypted != false {
            try container.encode(encrypted, forKey: ClientRuntime.Key("Encrypted"))
        }
        if encryptedWithHSM != false {
            try container.encode(encryptedWithHSM, forKey: ClientRuntime.Key("EncryptedWithHSM"))
        }
        if let engineFullVersion = engineFullVersion {
            try container.encode(engineFullVersion, forKey: ClientRuntime.Key("EngineFullVersion"))
        }
        if enhancedVpcRouting != false {
            try container.encode(enhancedVpcRouting, forKey: ClientRuntime.Key("EnhancedVpcRouting"))
        }
        if estimatedSecondsToCompletion != 0 {
            try container.encode(estimatedSecondsToCompletion, forKey: ClientRuntime.Key("EstimatedSecondsToCompletion"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: ClientRuntime.Key("KmsKeyId"))
        }
        if let maintenanceTrackName = maintenanceTrackName {
            try container.encode(maintenanceTrackName, forKey: ClientRuntime.Key("MaintenanceTrackName"))
        }
        if let manualSnapshotRemainingDays = manualSnapshotRemainingDays {
            try container.encode(manualSnapshotRemainingDays, forKey: ClientRuntime.Key("ManualSnapshotRemainingDays"))
        }
        if let manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriod {
            try container.encode(manualSnapshotRetentionPeriod, forKey: ClientRuntime.Key("ManualSnapshotRetentionPeriod"))
        }
        if let masterUsername = masterUsername {
            try container.encode(masterUsername, forKey: ClientRuntime.Key("MasterUsername"))
        }
        if let nodeType = nodeType {
            try container.encode(nodeType, forKey: ClientRuntime.Key("NodeType"))
        }
        if numberOfNodes != 0 {
            try container.encode(numberOfNodes, forKey: ClientRuntime.Key("NumberOfNodes"))
        }
        if let ownerAccount = ownerAccount {
            try container.encode(ownerAccount, forKey: ClientRuntime.Key("OwnerAccount"))
        }
        if port != 0 {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
        if let restorableNodeTypes = restorableNodeTypes {
            var restorableNodeTypesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("RestorableNodeTypes"))
            for (index0, string0) in restorableNodeTypes.enumerated() {
                try restorableNodeTypesContainer.encode(string0, forKey: ClientRuntime.Key("NodeType.\(index0.advanced(by: 1))"))
            }
        }
        if let snapshotCreateTime = snapshotCreateTime {
            try container.encode(ClientRuntime.TimestampWrapper(snapshotCreateTime, format: .dateTime), forKey: ClientRuntime.Key("snapshotCreateTime"))
        }
        if let snapshotIdentifier = snapshotIdentifier {
            try container.encode(snapshotIdentifier, forKey: ClientRuntime.Key("SnapshotIdentifier"))
        }
        if let snapshotRetentionStartTime = snapshotRetentionStartTime {
            try container.encode(ClientRuntime.TimestampWrapper(snapshotRetentionStartTime, format: .dateTime), forKey: ClientRuntime.Key("snapshotRetentionStartTime"))
        }
        if let snapshotType = snapshotType {
            try container.encode(snapshotType, forKey: ClientRuntime.Key("SnapshotType"))
        }
        if let sourceRegion = sourceRegion {
            try container.encode(sourceRegion, forKey: ClientRuntime.Key("SourceRegion"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if totalBackupSizeInMegaBytes != 0.0 {
            try container.encode(Swift.String(totalBackupSizeInMegaBytes), forKey: ClientRuntime.Key("TotalBackupSizeInMegaBytes"))
        }
        if let vpcId = vpcId {
            try container.encode(vpcId, forKey: ClientRuntime.Key("VpcId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotIdentifier)
        snapshotIdentifier = snapshotIdentifierDecoded
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let snapshotCreateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotCreateTime)
        var snapshotCreateTimeBuffer:ClientRuntime.Date? = nil
        if let snapshotCreateTimeDecoded = snapshotCreateTimeDecoded {
            snapshotCreateTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(snapshotCreateTimeDecoded, format: .dateTime)
        }
        snapshotCreateTime = snapshotCreateTimeBuffer
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let portDecoded = try containerValues.decode(Swift.Int.self, forKey: .port)
        port = portDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let clusterCreateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterCreateTime)
        var clusterCreateTimeBuffer:ClientRuntime.Date? = nil
        if let clusterCreateTimeDecoded = clusterCreateTimeDecoded {
            clusterCreateTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(clusterCreateTimeDecoded, format: .dateTime)
        }
        clusterCreateTime = clusterCreateTimeBuffer
        let masterUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterUsername)
        masterUsername = masterUsernameDecoded
        let clusterVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterVersion)
        clusterVersion = clusterVersionDecoded
        let engineFullVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineFullVersion)
        engineFullVersion = engineFullVersionDecoded
        let snapshotTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotType)
        snapshotType = snapshotTypeDecoded
        let nodeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeType)
        nodeType = nodeTypeDecoded
        let numberOfNodesDecoded = try containerValues.decode(Swift.Int.self, forKey: .numberOfNodes)
        numberOfNodes = numberOfNodesDecoded
        let dBNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBName)
        dBName = dBNameDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let encryptedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let encryptedWithHSMDecoded = try containerValues.decode(Swift.Bool.self, forKey: .encryptedWithHSM)
        encryptedWithHSM = encryptedWithHSMDecoded
        if containerValues.contains(.accountsWithRestoreAccess) {
            struct KeyVal0{struct AccountWithRestoreAccess{}}
            let accountsWithRestoreAccessWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AccountWithRestoreAccess>.CodingKeys.self, forKey: .accountsWithRestoreAccess)
            if let accountsWithRestoreAccessWrappedContainer = accountsWithRestoreAccessWrappedContainer {
                let accountsWithRestoreAccessContainer = try accountsWithRestoreAccessWrappedContainer.decodeIfPresent([RedshiftClientTypes.AccountWithRestoreAccess].self, forKey: .member)
                var accountsWithRestoreAccessBuffer:[RedshiftClientTypes.AccountWithRestoreAccess]? = nil
                if let accountsWithRestoreAccessContainer = accountsWithRestoreAccessContainer {
                    accountsWithRestoreAccessBuffer = [RedshiftClientTypes.AccountWithRestoreAccess]()
                    for structureContainer0 in accountsWithRestoreAccessContainer {
                        accountsWithRestoreAccessBuffer?.append(structureContainer0)
                    }
                }
                accountsWithRestoreAccess = accountsWithRestoreAccessBuffer
            } else {
                accountsWithRestoreAccess = []
            }
        } else {
            accountsWithRestoreAccess = nil
        }
        let ownerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let totalBackupSizeInMegaBytesDecoded = try containerValues.decode(Swift.Double.self, forKey: .totalBackupSizeInMegaBytes)
        totalBackupSizeInMegaBytes = totalBackupSizeInMegaBytesDecoded
        let actualIncrementalBackupSizeInMegaBytesDecoded = try containerValues.decode(Swift.Double.self, forKey: .actualIncrementalBackupSizeInMegaBytes)
        actualIncrementalBackupSizeInMegaBytes = actualIncrementalBackupSizeInMegaBytesDecoded
        let backupProgressInMegaBytesDecoded = try containerValues.decode(Swift.Double.self, forKey: .backupProgressInMegaBytes)
        backupProgressInMegaBytes = backupProgressInMegaBytesDecoded
        let currentBackupRateInMegaBytesPerSecondDecoded = try containerValues.decode(Swift.Double.self, forKey: .currentBackupRateInMegaBytesPerSecond)
        currentBackupRateInMegaBytesPerSecond = currentBackupRateInMegaBytesPerSecondDecoded
        let estimatedSecondsToCompletionDecoded = try containerValues.decode(Swift.Int.self, forKey: .estimatedSecondsToCompletion)
        estimatedSecondsToCompletion = estimatedSecondsToCompletionDecoded
        let elapsedTimeInSecondsDecoded = try containerValues.decode(Swift.Int.self, forKey: .elapsedTimeInSeconds)
        elapsedTimeInSeconds = elapsedTimeInSecondsDecoded
        let sourceRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceRegion)
        sourceRegion = sourceRegionDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([RedshiftClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[RedshiftClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [RedshiftClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        if containerValues.contains(.restorableNodeTypes) {
            struct KeyVal0{struct NodeType{}}
            let restorableNodeTypesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.NodeType>.CodingKeys.self, forKey: .restorableNodeTypes)
            if let restorableNodeTypesWrappedContainer = restorableNodeTypesWrappedContainer {
                let restorableNodeTypesContainer = try restorableNodeTypesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var restorableNodeTypesBuffer:[Swift.String]? = nil
                if let restorableNodeTypesContainer = restorableNodeTypesContainer {
                    restorableNodeTypesBuffer = [Swift.String]()
                    for stringContainer0 in restorableNodeTypesContainer {
                        restorableNodeTypesBuffer?.append(stringContainer0)
                    }
                }
                restorableNodeTypes = restorableNodeTypesBuffer
            } else {
                restorableNodeTypes = []
            }
        } else {
            restorableNodeTypes = nil
        }
        let enhancedVpcRoutingDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enhancedVpcRouting)
        enhancedVpcRouting = enhancedVpcRoutingDecoded
        let maintenanceTrackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maintenanceTrackName)
        maintenanceTrackName = maintenanceTrackNameDecoded
        let manualSnapshotRetentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .manualSnapshotRetentionPeriod)
        manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriodDecoded
        let manualSnapshotRemainingDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .manualSnapshotRemainingDays)
        manualSnapshotRemainingDays = manualSnapshotRemainingDaysDecoded
        let snapshotRetentionStartTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotRetentionStartTime)
        var snapshotRetentionStartTimeBuffer:ClientRuntime.Date? = nil
        if let snapshotRetentionStartTimeDecoded = snapshotRetentionStartTimeDecoded {
            snapshotRetentionStartTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(snapshotRetentionStartTimeDecoded, format: .dateTime)
        }
        snapshotRetentionStartTime = snapshotRetentionStartTimeBuffer
    }
}

extension RedshiftClientTypes.Snapshot: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Snapshot(accountsWithRestoreAccess: \(Swift.String(describing: accountsWithRestoreAccess)), actualIncrementalBackupSizeInMegaBytes: \(Swift.String(describing: actualIncrementalBackupSizeInMegaBytes)), availabilityZone: \(Swift.String(describing: availabilityZone)), backupProgressInMegaBytes: \(Swift.String(describing: backupProgressInMegaBytes)), clusterCreateTime: \(Swift.String(describing: clusterCreateTime)), clusterIdentifier: \(Swift.String(describing: clusterIdentifier)), clusterVersion: \(Swift.String(describing: clusterVersion)), currentBackupRateInMegaBytesPerSecond: \(Swift.String(describing: currentBackupRateInMegaBytesPerSecond)), dBName: \(Swift.String(describing: dBName)), elapsedTimeInSeconds: \(Swift.String(describing: elapsedTimeInSeconds)), encrypted: \(Swift.String(describing: encrypted)), encryptedWithHSM: \(Swift.String(describing: encryptedWithHSM)), engineFullVersion: \(Swift.String(describing: engineFullVersion)), enhancedVpcRouting: \(Swift.String(describing: enhancedVpcRouting)), estimatedSecondsToCompletion: \(Swift.String(describing: estimatedSecondsToCompletion)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), maintenanceTrackName: \(Swift.String(describing: maintenanceTrackName)), manualSnapshotRemainingDays: \(Swift.String(describing: manualSnapshotRemainingDays)), manualSnapshotRetentionPeriod: \(Swift.String(describing: manualSnapshotRetentionPeriod)), masterUsername: \(Swift.String(describing: masterUsername)), nodeType: \(Swift.String(describing: nodeType)), numberOfNodes: \(Swift.String(describing: numberOfNodes)), ownerAccount: \(Swift.String(describing: ownerAccount)), port: \(Swift.String(describing: port)), restorableNodeTypes: \(Swift.String(describing: restorableNodeTypes)), snapshotCreateTime: \(Swift.String(describing: snapshotCreateTime)), snapshotIdentifier: \(Swift.String(describing: snapshotIdentifier)), snapshotRetentionStartTime: \(Swift.String(describing: snapshotRetentionStartTime)), snapshotType: \(Swift.String(describing: snapshotType)), sourceRegion: \(Swift.String(describing: sourceRegion)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)), totalBackupSizeInMegaBytes: \(Swift.String(describing: totalBackupSizeInMegaBytes)), vpcId: \(Swift.String(describing: vpcId)))"}
}

extension RedshiftClientTypes {
    /// <p>Describes a snapshot.</p>
    public struct Snapshot: Swift.Equatable {
        /// <p>A list of the AWS customer accounts authorized to restore the snapshot. Returns
        ///                 <code>null</code> if no accounts are authorized. Visible only to the snapshot owner.
        ///         </p>
        public let accountsWithRestoreAccess: [RedshiftClientTypes.AccountWithRestoreAccess]?
        /// <p>The size of the incremental backup.</p>
        public let actualIncrementalBackupSizeInMegaBytes: Swift.Double
        /// <p>The Availability Zone in which the cluster was created.</p>
        public let availabilityZone: Swift.String?
        /// <p>The number of megabytes that have been transferred to the snapshot
        ///             backup.</p>
        public let backupProgressInMegaBytes: Swift.Double
        /// <p>The time (UTC) when the cluster was originally created.</p>
        public let clusterCreateTime: ClientRuntime.Date?
        /// <p>The identifier of the cluster for which the snapshot was taken.</p>
        public let clusterIdentifier: Swift.String?
        /// <p>The version ID of the Amazon Redshift engine that is running on the cluster.</p>
        public let clusterVersion: Swift.String?
        /// <p>The number of megabytes per second being transferred to the snapshot backup.
        ///             Returns <code>0</code> for a completed backup. </p>
        public let currentBackupRateInMegaBytesPerSecond: Swift.Double
        /// <p>The name of the database that was created when the cluster was created.</p>
        public let dBName: Swift.String?
        /// <p>The amount of time an in-progress snapshot backup has been running, or the amount
        ///             of time it took a completed backup to finish.</p>
        public let elapsedTimeInSeconds: Swift.Int
        /// <p>If <code>true</code>, the data in the snapshot is encrypted at rest.</p>
        public let encrypted: Swift.Bool
        /// <p>A boolean that indicates whether the snapshot data is encrypted using the HSM keys
        ///             of the source cluster. <code>true</code> indicates that the data is encrypted using HSM
        ///             keys.</p>
        public let encryptedWithHSM: Swift.Bool
        /// <p>The cluster version of the cluster used to create the snapshot. For example, 1.0.15503. </p>
        public let engineFullVersion: Swift.String?
        /// <p>An option that specifies whether to create the cluster with enhanced VPC routing
        ///             enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a
        ///             VPC. For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in
        ///             the Amazon Redshift Cluster Management Guide.</p>
        ///         <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p>
        ///         <p>Default: false</p>
        public let enhancedVpcRouting: Swift.Bool
        /// <p>The estimate of the time remaining before the snapshot backup will complete.
        ///             Returns <code>0</code> for a completed backup. </p>
        public let estimatedSecondsToCompletion: Swift.Int
        /// <p>The AWS Key Management Service (KMS) key ID of the encryption key that was used to
        ///             encrypt data in the cluster from which the snapshot was taken.</p>
        public let kmsKeyId: Swift.String?
        /// <p>The name of the maintenance track for the snapshot.</p>
        public let maintenanceTrackName: Swift.String?
        /// <p>The number of days until a manual snapshot will pass its retention period.</p>
        public let manualSnapshotRemainingDays: Swift.Int?
        /// <p>The number of days that a manual snapshot is retained. If the value is -1, the manual
        ///             snapshot is retained indefinitely. </p>
        ///
        ///         <p>The value must be either -1 or an integer between 1 and 3,653.</p>
        public let manualSnapshotRetentionPeriod: Swift.Int?
        /// <p>The master user name for the cluster.</p>
        public let masterUsername: Swift.String?
        /// <p>The node type of the nodes in the cluster.</p>
        public let nodeType: Swift.String?
        /// <p>The number of nodes in the cluster.</p>
        public let numberOfNodes: Swift.Int
        /// <p>For manual snapshots, the AWS customer account used to create or copy the snapshot.
        ///             For automatic snapshots, the owner of the cluster. The owner can perform all snapshot
        ///             actions, such as sharing a manual snapshot.</p>
        public let ownerAccount: Swift.String?
        /// <p>The port that the cluster is listening on.</p>
        public let port: Swift.Int
        /// <p>The list of node types that this cluster snapshot is able to restore
        ///             into.</p>
        public let restorableNodeTypes: [Swift.String]?
        /// <p>The time (in UTC format) when Amazon Redshift began the snapshot. A snapshot contains a
        ///             copy of the cluster data as of this exact time.</p>
        public let snapshotCreateTime: ClientRuntime.Date?
        /// <p>The snapshot identifier that is provided in the request.</p>
        public let snapshotIdentifier: Swift.String?
        /// <p>A timestamp representing the start of the retention period for the snapshot.</p>
        public let snapshotRetentionStartTime: ClientRuntime.Date?
        /// <p>The snapshot type. Snapshots created using <a>CreateClusterSnapshot</a>
        ///             and <a>CopyClusterSnapshot</a> are of type "manual". </p>
        public let snapshotType: Swift.String?
        /// <p>The source region from which the snapshot was copied.</p>
        public let sourceRegion: Swift.String?
        /// <p>The snapshot status. The value of the status depends on the API operation used: </p>
        ///         <ul>
        ///             <li>
        ///                 <p>
        ///                     <a>CreateClusterSnapshot</a> and <a>CopyClusterSnapshot</a> returns status as "creating". </p>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                     <a>DescribeClusterSnapshots</a> returns status as "creating",
        ///                     "available", "final snapshot", or "failed".</p>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                     <a>DeleteClusterSnapshot</a> returns status as "deleted".</p>
        ///             </li>
        ///          </ul>
        public let status: Swift.String?
        /// <p>The list of tags for the cluster snapshot.</p>
        public let tags: [RedshiftClientTypes.Tag]?
        /// <p>The size of the complete set of backup data that would be used to restore the
        ///             cluster.</p>
        public let totalBackupSizeInMegaBytes: Swift.Double
        /// <p>The VPC identifier of the cluster if the snapshot is from a cluster in a VPC.
        ///             Otherwise, this field is not in the output.</p>
        public let vpcId: Swift.String?

        public init (
            accountsWithRestoreAccess: [RedshiftClientTypes.AccountWithRestoreAccess]? = nil,
            actualIncrementalBackupSizeInMegaBytes: Swift.Double = 0.0,
            availabilityZone: Swift.String? = nil,
            backupProgressInMegaBytes: Swift.Double = 0.0,
            clusterCreateTime: ClientRuntime.Date? = nil,
            clusterIdentifier: Swift.String? = nil,
            clusterVersion: Swift.String? = nil,
            currentBackupRateInMegaBytesPerSecond: Swift.Double = 0.0,
            dBName: Swift.String? = nil,
            elapsedTimeInSeconds: Swift.Int = 0,
            encrypted: Swift.Bool = false,
            encryptedWithHSM: Swift.Bool = false,
            engineFullVersion: Swift.String? = nil,
            enhancedVpcRouting: Swift.Bool = false,
            estimatedSecondsToCompletion: Swift.Int = 0,
            kmsKeyId: Swift.String? = nil,
            maintenanceTrackName: Swift.String? = nil,
            manualSnapshotRemainingDays: Swift.Int? = nil,
            manualSnapshotRetentionPeriod: Swift.Int? = nil,
            masterUsername: Swift.String? = nil,
            nodeType: Swift.String? = nil,
            numberOfNodes: Swift.Int = 0,
            ownerAccount: Swift.String? = nil,
            port: Swift.Int = 0,
            restorableNodeTypes: [Swift.String]? = nil,
            snapshotCreateTime: ClientRuntime.Date? = nil,
            snapshotIdentifier: Swift.String? = nil,
            snapshotRetentionStartTime: ClientRuntime.Date? = nil,
            snapshotType: Swift.String? = nil,
            sourceRegion: Swift.String? = nil,
            status: Swift.String? = nil,
            tags: [RedshiftClientTypes.Tag]? = nil,
            totalBackupSizeInMegaBytes: Swift.Double = 0.0,
            vpcId: Swift.String? = nil
        )
        {
            self.accountsWithRestoreAccess = accountsWithRestoreAccess
            self.actualIncrementalBackupSizeInMegaBytes = actualIncrementalBackupSizeInMegaBytes
            self.availabilityZone = availabilityZone
            self.backupProgressInMegaBytes = backupProgressInMegaBytes
            self.clusterCreateTime = clusterCreateTime
            self.clusterIdentifier = clusterIdentifier
            self.clusterVersion = clusterVersion
            self.currentBackupRateInMegaBytesPerSecond = currentBackupRateInMegaBytesPerSecond
            self.dBName = dBName
            self.elapsedTimeInSeconds = elapsedTimeInSeconds
            self.encrypted = encrypted
            self.encryptedWithHSM = encryptedWithHSM
            self.engineFullVersion = engineFullVersion
            self.enhancedVpcRouting = enhancedVpcRouting
            self.estimatedSecondsToCompletion = estimatedSecondsToCompletion
            self.kmsKeyId = kmsKeyId
            self.maintenanceTrackName = maintenanceTrackName
            self.manualSnapshotRemainingDays = manualSnapshotRemainingDays
            self.manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriod
            self.masterUsername = masterUsername
            self.nodeType = nodeType
            self.numberOfNodes = numberOfNodes
            self.ownerAccount = ownerAccount
            self.port = port
            self.restorableNodeTypes = restorableNodeTypes
            self.snapshotCreateTime = snapshotCreateTime
            self.snapshotIdentifier = snapshotIdentifier
            self.snapshotRetentionStartTime = snapshotRetentionStartTime
            self.snapshotType = snapshotType
            self.sourceRegion = sourceRegion
            self.status = status
            self.tags = tags
            self.totalBackupSizeInMegaBytes = totalBackupSizeInMegaBytes
            self.vpcId = vpcId
        }
    }

}

extension RedshiftClientTypes {
    public enum SnapshotAttributeToSortBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createTime
        case sourceType
        case totalSize
        case sdkUnknown(Swift.String)

        public static var allCases: [SnapshotAttributeToSortBy] {
            return [
                .createTime,
                .sourceType,
                .totalSize,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createTime: return "CREATE_TIME"
            case .sourceType: return "SOURCE_TYPE"
            case .totalSize: return "TOTAL_SIZE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SnapshotAttributeToSortBy(rawValue: rawValue) ?? SnapshotAttributeToSortBy.sdkUnknown(rawValue)
        }
    }
}

extension SnapshotCopyAlreadyDisabledFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SnapshotCopyAlreadyDisabledFault(message: \(Swift.String(describing: message)))"}
}

extension SnapshotCopyAlreadyDisabledFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<SnapshotCopyAlreadyDisabledFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The cluster already has cross-region snapshot copy disabled.</p>
public struct SnapshotCopyAlreadyDisabledFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SnapshotCopyAlreadyDisabledFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SnapshotCopyAlreadyDisabledFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnapshotCopyAlreadyEnabledFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SnapshotCopyAlreadyEnabledFault(message: \(Swift.String(describing: message)))"}
}

extension SnapshotCopyAlreadyEnabledFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<SnapshotCopyAlreadyEnabledFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The cluster already has cross-region snapshot copy enabled.</p>
public struct SnapshotCopyAlreadyEnabledFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SnapshotCopyAlreadyEnabledFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SnapshotCopyAlreadyEnabledFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnapshotCopyDisabledFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SnapshotCopyDisabledFault(message: \(Swift.String(describing: message)))"}
}

extension SnapshotCopyDisabledFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<SnapshotCopyDisabledFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Cross-region snapshot copy was temporarily disabled. Try your request
///             again.</p>
public struct SnapshotCopyDisabledFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SnapshotCopyDisabledFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SnapshotCopyDisabledFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RedshiftClientTypes.SnapshotCopyGrant: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyId = "KmsKeyId"
        case snapshotCopyGrantName = "SnapshotCopyGrantName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: ClientRuntime.Key("KmsKeyId"))
        }
        if let snapshotCopyGrantName = snapshotCopyGrantName {
            try container.encode(snapshotCopyGrantName, forKey: ClientRuntime.Key("SnapshotCopyGrantName"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotCopyGrantNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotCopyGrantName)
        snapshotCopyGrantName = snapshotCopyGrantNameDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([RedshiftClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[RedshiftClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [RedshiftClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension RedshiftClientTypes.SnapshotCopyGrant: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SnapshotCopyGrant(kmsKeyId: \(Swift.String(describing: kmsKeyId)), snapshotCopyGrantName: \(Swift.String(describing: snapshotCopyGrantName)), tags: \(Swift.String(describing: tags)))"}
}

extension RedshiftClientTypes {
    /// <p>The snapshot copy grant that grants Amazon Redshift permission to encrypt copied
    ///             snapshots with the specified customer master key (CMK) from AWS KMS in the destination
    ///             region.</p>
    ///         <p>
    /// For more information about managing snapshot copy grants, go to
    /// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a>
    /// in the <i>Amazon Redshift Cluster Management Guide</i>.
    /// </p>
    public struct SnapshotCopyGrant: Swift.Equatable {
        /// <p>The unique identifier of the customer master key (CMK) in AWS KMS to which
        ///             Amazon Redshift is granted permission.</p>
        public let kmsKeyId: Swift.String?
        /// <p>The name of the snapshot copy grant.</p>
        public let snapshotCopyGrantName: Swift.String?
        /// <p>A list of tag instances.</p>
        public let tags: [RedshiftClientTypes.Tag]?

        public init (
            kmsKeyId: Swift.String? = nil,
            snapshotCopyGrantName: Swift.String? = nil,
            tags: [RedshiftClientTypes.Tag]? = nil
        )
        {
            self.kmsKeyId = kmsKeyId
            self.snapshotCopyGrantName = snapshotCopyGrantName
            self.tags = tags
        }
    }

}

extension SnapshotCopyGrantAlreadyExistsFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SnapshotCopyGrantAlreadyExistsFault(message: \(Swift.String(describing: message)))"}
}

extension SnapshotCopyGrantAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<SnapshotCopyGrantAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The snapshot copy grant can't be created because a grant with the same name already
///             exists.</p>
public struct SnapshotCopyGrantAlreadyExistsFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SnapshotCopyGrantAlreadyExistsFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SnapshotCopyGrantAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnapshotCopyGrantNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SnapshotCopyGrantNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension SnapshotCopyGrantNotFoundFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<SnapshotCopyGrantNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified snapshot copy grant can't be found. Make sure that the name is typed
///             correctly and that the grant exists in the destination region.</p>
public struct SnapshotCopyGrantNotFoundFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SnapshotCopyGrantNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SnapshotCopyGrantNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnapshotCopyGrantQuotaExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SnapshotCopyGrantQuotaExceededFault(message: \(Swift.String(describing: message)))"}
}

extension SnapshotCopyGrantQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<SnapshotCopyGrantQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The AWS account has exceeded the maximum number of snapshot copy grants in this
///             region.</p>
public struct SnapshotCopyGrantQuotaExceededFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SnapshotCopyGrantQuotaExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SnapshotCopyGrantQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RedshiftClientTypes.SnapshotErrorMessage: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureCode = "FailureCode"
        case failureReason = "FailureReason"
        case snapshotClusterIdentifier = "SnapshotClusterIdentifier"
        case snapshotIdentifier = "SnapshotIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let failureCode = failureCode {
            try container.encode(failureCode, forKey: ClientRuntime.Key("FailureCode"))
        }
        if let failureReason = failureReason {
            try container.encode(failureReason, forKey: ClientRuntime.Key("FailureReason"))
        }
        if let snapshotClusterIdentifier = snapshotClusterIdentifier {
            try container.encode(snapshotClusterIdentifier, forKey: ClientRuntime.Key("SnapshotClusterIdentifier"))
        }
        if let snapshotIdentifier = snapshotIdentifier {
            try container.encode(snapshotIdentifier, forKey: ClientRuntime.Key("SnapshotIdentifier"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotIdentifier)
        snapshotIdentifier = snapshotIdentifierDecoded
        let snapshotClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotClusterIdentifier)
        snapshotClusterIdentifier = snapshotClusterIdentifierDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension RedshiftClientTypes.SnapshotErrorMessage: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SnapshotErrorMessage(failureCode: \(Swift.String(describing: failureCode)), failureReason: \(Swift.String(describing: failureReason)), snapshotClusterIdentifier: \(Swift.String(describing: snapshotClusterIdentifier)), snapshotIdentifier: \(Swift.String(describing: snapshotIdentifier)))"}
}

extension RedshiftClientTypes {
    /// <p>Describes the errors returned by a snapshot.</p>
    public struct SnapshotErrorMessage: Swift.Equatable {
        /// <p>The failure code for the error.</p>
        public let failureCode: Swift.String?
        /// <p>The text message describing the error.</p>
        public let failureReason: Swift.String?
        /// <p>A unique identifier for the cluster.</p>
        public let snapshotClusterIdentifier: Swift.String?
        /// <p>A unique identifier for the snapshot returning the error.</p>
        public let snapshotIdentifier: Swift.String?

        public init (
            failureCode: Swift.String? = nil,
            failureReason: Swift.String? = nil,
            snapshotClusterIdentifier: Swift.String? = nil,
            snapshotIdentifier: Swift.String? = nil
        )
        {
            self.failureCode = failureCode
            self.failureReason = failureReason
            self.snapshotClusterIdentifier = snapshotClusterIdentifier
            self.snapshotIdentifier = snapshotIdentifier
        }
    }

}

extension RedshiftClientTypes.SnapshotSchedule: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedClusterCount = "AssociatedClusterCount"
        case associatedClusters = "AssociatedClusters"
        case nextInvocations = "NextInvocations"
        case scheduleDefinitions = "ScheduleDefinitions"
        case scheduleDescription = "ScheduleDescription"
        case scheduleIdentifier = "ScheduleIdentifier"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let associatedClusterCount = associatedClusterCount {
            try container.encode(associatedClusterCount, forKey: ClientRuntime.Key("AssociatedClusterCount"))
        }
        if let associatedClusters = associatedClusters {
            var associatedClustersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AssociatedClusters"))
            for (index0, clusterassociatedtoschedule0) in associatedClusters.enumerated() {
                try associatedClustersContainer.encode(clusterassociatedtoschedule0, forKey: ClientRuntime.Key("ClusterAssociatedToSchedule.\(index0.advanced(by: 1))"))
            }
        }
        if let nextInvocations = nextInvocations {
            var nextInvocationsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("NextInvocations"))
            for (index0, tstamp0) in nextInvocations.enumerated() {
                try nextInvocationsContainer.encode(TimestampWrapper(tstamp0, format: .dateTime), forKey: ClientRuntime.Key("SnapshotTime.\(index0.advanced(by: 1))"))
            }
        }
        if let scheduleDefinitions = scheduleDefinitions {
            var scheduleDefinitionsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ScheduleDefinitions"))
            for (index0, string0) in scheduleDefinitions.enumerated() {
                try scheduleDefinitionsContainer.encode(string0, forKey: ClientRuntime.Key("ScheduleDefinition.\(index0.advanced(by: 1))"))
            }
        }
        if let scheduleDescription = scheduleDescription {
            try container.encode(scheduleDescription, forKey: ClientRuntime.Key("ScheduleDescription"))
        }
        if let scheduleIdentifier = scheduleIdentifier {
            try container.encode(scheduleIdentifier, forKey: ClientRuntime.Key("ScheduleIdentifier"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.scheduleDefinitions) {
            struct KeyVal0{struct ScheduleDefinition{}}
            let scheduleDefinitionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ScheduleDefinition>.CodingKeys.self, forKey: .scheduleDefinitions)
            if let scheduleDefinitionsWrappedContainer = scheduleDefinitionsWrappedContainer {
                let scheduleDefinitionsContainer = try scheduleDefinitionsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var scheduleDefinitionsBuffer:[Swift.String]? = nil
                if let scheduleDefinitionsContainer = scheduleDefinitionsContainer {
                    scheduleDefinitionsBuffer = [Swift.String]()
                    for stringContainer0 in scheduleDefinitionsContainer {
                        scheduleDefinitionsBuffer?.append(stringContainer0)
                    }
                }
                scheduleDefinitions = scheduleDefinitionsBuffer
            } else {
                scheduleDefinitions = []
            }
        } else {
            scheduleDefinitions = nil
        }
        let scheduleIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleIdentifier)
        scheduleIdentifier = scheduleIdentifierDecoded
        let scheduleDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleDescription)
        scheduleDescription = scheduleDescriptionDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([RedshiftClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[RedshiftClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [RedshiftClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        if containerValues.contains(.nextInvocations) {
            struct KeyVal0{struct SnapshotTime{}}
            let nextInvocationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.SnapshotTime>.CodingKeys.self, forKey: .nextInvocations)
            if let nextInvocationsWrappedContainer = nextInvocationsWrappedContainer {
                let nextInvocationsContainer = try nextInvocationsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var nextInvocationsBuffer:[ClientRuntime.Date]? = nil
                if let nextInvocationsContainer = nextInvocationsContainer {
                    nextInvocationsBuffer = [ClientRuntime.Date]()
                    for timestampContainer0 in nextInvocationsContainer {
                        try nextInvocationsBuffer?.append(ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(timestampContainer0, format: .dateTime))
                    }
                }
                nextInvocations = nextInvocationsBuffer
            } else {
                nextInvocations = []
            }
        } else {
            nextInvocations = nil
        }
        let associatedClusterCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .associatedClusterCount)
        associatedClusterCount = associatedClusterCountDecoded
        if containerValues.contains(.associatedClusters) {
            struct KeyVal0{struct ClusterAssociatedToSchedule{}}
            let associatedClustersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ClusterAssociatedToSchedule>.CodingKeys.self, forKey: .associatedClusters)
            if let associatedClustersWrappedContainer = associatedClustersWrappedContainer {
                let associatedClustersContainer = try associatedClustersWrappedContainer.decodeIfPresent([RedshiftClientTypes.ClusterAssociatedToSchedule].self, forKey: .member)
                var associatedClustersBuffer:[RedshiftClientTypes.ClusterAssociatedToSchedule]? = nil
                if let associatedClustersContainer = associatedClustersContainer {
                    associatedClustersBuffer = [RedshiftClientTypes.ClusterAssociatedToSchedule]()
                    for structureContainer0 in associatedClustersContainer {
                        associatedClustersBuffer?.append(structureContainer0)
                    }
                }
                associatedClusters = associatedClustersBuffer
            } else {
                associatedClusters = []
            }
        } else {
            associatedClusters = nil
        }
    }
}

extension RedshiftClientTypes.SnapshotSchedule: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SnapshotSchedule(associatedClusterCount: \(Swift.String(describing: associatedClusterCount)), associatedClusters: \(Swift.String(describing: associatedClusters)), nextInvocations: \(Swift.String(describing: nextInvocations)), scheduleDefinitions: \(Swift.String(describing: scheduleDefinitions)), scheduleDescription: \(Swift.String(describing: scheduleDescription)), scheduleIdentifier: \(Swift.String(describing: scheduleIdentifier)), tags: \(Swift.String(describing: tags)))"}
}

extension RedshiftClientTypes {
    /// <p>Describes a snapshot schedule. You can set a regular interval for creating
    ///             snapshots of a cluster. You can also schedule snapshots for specific dates. </p>
    public struct SnapshotSchedule: Swift.Equatable {
        /// <p>The number of clusters associated with the schedule.</p>
        public let associatedClusterCount: Swift.Int?
        /// <p>A list of clusters associated with the schedule. A maximum of 100 clusters is returned.</p>
        public let associatedClusters: [RedshiftClientTypes.ClusterAssociatedToSchedule]?
        /// <p></p>
        public let nextInvocations: [ClientRuntime.Date]?
        /// <p>A list of ScheduleDefinitions.</p>
        public let scheduleDefinitions: [Swift.String]?
        /// <p>The description of the schedule.</p>
        public let scheduleDescription: Swift.String?
        /// <p>A unique identifier for the schedule.</p>
        public let scheduleIdentifier: Swift.String?
        /// <p>An optional set of tags describing the schedule.</p>
        public let tags: [RedshiftClientTypes.Tag]?

        public init (
            associatedClusterCount: Swift.Int? = nil,
            associatedClusters: [RedshiftClientTypes.ClusterAssociatedToSchedule]? = nil,
            nextInvocations: [ClientRuntime.Date]? = nil,
            scheduleDefinitions: [Swift.String]? = nil,
            scheduleDescription: Swift.String? = nil,
            scheduleIdentifier: Swift.String? = nil,
            tags: [RedshiftClientTypes.Tag]? = nil
        )
        {
            self.associatedClusterCount = associatedClusterCount
            self.associatedClusters = associatedClusters
            self.nextInvocations = nextInvocations
            self.scheduleDefinitions = scheduleDefinitions
            self.scheduleDescription = scheduleDescription
            self.scheduleIdentifier = scheduleIdentifier
            self.tags = tags
        }
    }

}

extension SnapshotScheduleAlreadyExistsFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SnapshotScheduleAlreadyExistsFault(message: \(Swift.String(describing: message)))"}
}

extension SnapshotScheduleAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<SnapshotScheduleAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified snapshot schedule already exists. </p>
public struct SnapshotScheduleAlreadyExistsFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SnapshotScheduleAlreadyExistsFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SnapshotScheduleAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnapshotScheduleNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SnapshotScheduleNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension SnapshotScheduleNotFoundFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<SnapshotScheduleNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>We could not find the specified snapshot schedule. </p>
public struct SnapshotScheduleNotFoundFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SnapshotScheduleNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SnapshotScheduleNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnapshotScheduleQuotaExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SnapshotScheduleQuotaExceededFault(message: \(Swift.String(describing: message)))"}
}

extension SnapshotScheduleQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<SnapshotScheduleQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have exceeded the quota of snapshot schedules. </p>
public struct SnapshotScheduleQuotaExceededFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SnapshotScheduleQuotaExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SnapshotScheduleQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnapshotScheduleUpdateInProgressFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SnapshotScheduleUpdateInProgressFault(message: \(Swift.String(describing: message)))"}
}

extension SnapshotScheduleUpdateInProgressFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<SnapshotScheduleUpdateInProgressFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified snapshot schedule is already being updated.</p>
public struct SnapshotScheduleUpdateInProgressFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SnapshotScheduleUpdateInProgressFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SnapshotScheduleUpdateInProgressFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RedshiftClientTypes.SnapshotSortingEntity: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attribute = "Attribute"
        case sortOrder = "SortOrder"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let attribute = attribute {
            try container.encode(attribute, forKey: ClientRuntime.Key("Attribute"))
        }
        if let sortOrder = sortOrder {
            try container.encode(sortOrder, forKey: ClientRuntime.Key("SortOrder"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.SnapshotAttributeToSortBy.self, forKey: .attribute)
        attribute = attributeDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.SortByOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
    }
}

extension RedshiftClientTypes.SnapshotSortingEntity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SnapshotSortingEntity(attribute: \(Swift.String(describing: attribute)), sortOrder: \(Swift.String(describing: sortOrder)))"}
}

extension RedshiftClientTypes {
    /// <p>Describes a sorting entity</p>
    public struct SnapshotSortingEntity: Swift.Equatable {
        /// <p>The category for sorting the snapshots.</p>
        public let attribute: RedshiftClientTypes.SnapshotAttributeToSortBy?
        /// <p>The order for listing the attributes.</p>
        public let sortOrder: RedshiftClientTypes.SortByOrder?

        public init (
            attribute: RedshiftClientTypes.SnapshotAttributeToSortBy? = nil,
            sortOrder: RedshiftClientTypes.SortByOrder? = nil
        )
        {
            self.attribute = attribute
            self.sortOrder = sortOrder
        }
    }

}

extension RedshiftClientTypes {
    public enum SortByOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortByOrder] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASC"
            case .descending: return "DESC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortByOrder(rawValue: rawValue) ?? SortByOrder.sdkUnknown(rawValue)
        }
    }
}

extension SourceNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SourceNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension SourceNotFoundFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<SourceNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified Amazon Redshift event source could not be found.</p>
public struct SourceNotFoundFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SourceNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SourceNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RedshiftClientTypes {
    public enum SourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cluster
        case clusterParameterGroup
        case clusterSecurityGroup
        case clusterSnapshot
        case scheduledAction
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceType] {
            return [
                .cluster,
                .clusterParameterGroup,
                .clusterSecurityGroup,
                .clusterSnapshot,
                .scheduledAction,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cluster: return "cluster"
            case .clusterParameterGroup: return "cluster-parameter-group"
            case .clusterSecurityGroup: return "cluster-security-group"
            case .clusterSnapshot: return "cluster-snapshot"
            case .scheduledAction: return "scheduled-action"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SourceType(rawValue: rawValue) ?? SourceType.sdkUnknown(rawValue)
        }
    }
}

extension RedshiftClientTypes.Subnet: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subnetAvailabilityZone = "SubnetAvailabilityZone"
        case subnetIdentifier = "SubnetIdentifier"
        case subnetStatus = "SubnetStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let subnetAvailabilityZone = subnetAvailabilityZone {
            try container.encode(subnetAvailabilityZone, forKey: ClientRuntime.Key("SubnetAvailabilityZone"))
        }
        if let subnetIdentifier = subnetIdentifier {
            try container.encode(subnetIdentifier, forKey: ClientRuntime.Key("SubnetIdentifier"))
        }
        if let subnetStatus = subnetStatus {
            try container.encode(subnetStatus, forKey: ClientRuntime.Key("SubnetStatus"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetIdentifier)
        subnetIdentifier = subnetIdentifierDecoded
        let subnetAvailabilityZoneDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.AvailabilityZone.self, forKey: .subnetAvailabilityZone)
        subnetAvailabilityZone = subnetAvailabilityZoneDecoded
        let subnetStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetStatus)
        subnetStatus = subnetStatusDecoded
    }
}

extension RedshiftClientTypes.Subnet: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Subnet(subnetAvailabilityZone: \(Swift.String(describing: subnetAvailabilityZone)), subnetIdentifier: \(Swift.String(describing: subnetIdentifier)), subnetStatus: \(Swift.String(describing: subnetStatus)))"}
}

extension RedshiftClientTypes {
    /// <p>Describes a subnet.</p>
    public struct Subnet: Swift.Equatable {
        /// <p></p>
        public let subnetAvailabilityZone: RedshiftClientTypes.AvailabilityZone?
        /// <p>The identifier of the subnet.</p>
        public let subnetIdentifier: Swift.String?
        /// <p>The status of the subnet.</p>
        public let subnetStatus: Swift.String?

        public init (
            subnetAvailabilityZone: RedshiftClientTypes.AvailabilityZone? = nil,
            subnetIdentifier: Swift.String? = nil,
            subnetStatus: Swift.String? = nil
        )
        {
            self.subnetAvailabilityZone = subnetAvailabilityZone
            self.subnetIdentifier = subnetIdentifier
            self.subnetStatus = subnetStatus
        }
    }

}

extension SubnetAlreadyInUse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubnetAlreadyInUse(message: \(Swift.String(describing: message)))"}
}

extension SubnetAlreadyInUse: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<SubnetAlreadyInUseBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A specified subnet is already in use by another cluster.</p>
public struct SubnetAlreadyInUse: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SubnetAlreadyInUseBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SubnetAlreadyInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SubscriptionAlreadyExistFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubscriptionAlreadyExistFault(message: \(Swift.String(describing: message)))"}
}

extension SubscriptionAlreadyExistFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<SubscriptionAlreadyExistFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There is already an existing event notification subscription with the specified
///             name.</p>
public struct SubscriptionAlreadyExistFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SubscriptionAlreadyExistFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SubscriptionAlreadyExistFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SubscriptionCategoryNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubscriptionCategoryNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension SubscriptionCategoryNotFoundFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<SubscriptionCategoryNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The value specified for the event category was not one of the allowed values, or it
///             specified a category that does not apply to the specified source type. The allowed
///             values are Configuration, Management, Monitoring, and Security.</p>
public struct SubscriptionCategoryNotFoundFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SubscriptionCategoryNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SubscriptionCategoryNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SubscriptionEventIdNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubscriptionEventIdNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension SubscriptionEventIdNotFoundFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<SubscriptionEventIdNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An Amazon Redshift event with the specified event ID does not exist.</p>
public struct SubscriptionEventIdNotFoundFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SubscriptionEventIdNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SubscriptionEventIdNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SubscriptionNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubscriptionNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension SubscriptionNotFoundFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<SubscriptionNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An Amazon Redshift event notification subscription with the specified name does not
///             exist.</p>
public struct SubscriptionNotFoundFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SubscriptionNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SubscriptionNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SubscriptionSeverityNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubscriptionSeverityNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension SubscriptionSeverityNotFoundFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<SubscriptionSeverityNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The value specified for the event severity was not one of the allowed values, or it
///             specified a severity that does not apply to the specified source type. The allowed
///             values are ERROR and INFO.</p>
public struct SubscriptionSeverityNotFoundFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SubscriptionSeverityNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SubscriptionSeverityNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RedshiftClientTypes.SupportedOperation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationName = "OperationName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let operationName = operationName {
            try container.encode(operationName, forKey: ClientRuntime.Key("OperationName"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationName)
        operationName = operationNameDecoded
    }
}

extension RedshiftClientTypes.SupportedOperation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SupportedOperation(operationName: \(Swift.String(describing: operationName)))"}
}

extension RedshiftClientTypes {
    /// <p>Describes the operations that are allowed on a maintenance track.</p>
    public struct SupportedOperation: Swift.Equatable {
        /// <p>A list of the supported operations.</p>
        public let operationName: Swift.String?

        public init (
            operationName: Swift.String? = nil
        )
        {
            self.operationName = operationName
        }
    }

}

extension RedshiftClientTypes.SupportedPlatform: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension RedshiftClientTypes.SupportedPlatform: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SupportedPlatform(name: \(Swift.String(describing: name)))"}
}

extension RedshiftClientTypes {
    /// <p>A list of supported platforms for orderable clusters.</p>
    public struct SupportedPlatform: Swift.Equatable {
        /// <p></p>
        public let name: Swift.String?

        public init (
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension TableLimitExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TableLimitExceededFault(message: \(Swift.String(describing: message)))"}
}

extension TableLimitExceededFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TableLimitExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of tables in the cluster exceeds the limit for the requested new cluster
///             node type. </p>
public struct TableLimitExceededFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TableLimitExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TableLimitExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TableRestoreNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TableRestoreNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension TableRestoreNotFoundFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TableRestoreNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified <code>TableRestoreRequestId</code> value was not found.</p>
public struct TableRestoreNotFoundFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TableRestoreNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TableRestoreNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RedshiftClientTypes.TableRestoreStatus: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterIdentifier = "ClusterIdentifier"
        case message = "Message"
        case newTableName = "NewTableName"
        case progressInMegaBytes = "ProgressInMegaBytes"
        case requestTime = "RequestTime"
        case snapshotIdentifier = "SnapshotIdentifier"
        case sourceDatabaseName = "SourceDatabaseName"
        case sourceSchemaName = "SourceSchemaName"
        case sourceTableName = "SourceTableName"
        case status = "Status"
        case tableRestoreRequestId = "TableRestoreRequestId"
        case targetDatabaseName = "TargetDatabaseName"
        case targetSchemaName = "TargetSchemaName"
        case totalDataInMegaBytes = "TotalDataInMegaBytes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: ClientRuntime.Key("ClusterIdentifier"))
        }
        if let message = message {
            try container.encode(message, forKey: ClientRuntime.Key("Message"))
        }
        if let newTableName = newTableName {
            try container.encode(newTableName, forKey: ClientRuntime.Key("NewTableName"))
        }
        if let progressInMegaBytes = progressInMegaBytes {
            try container.encode(progressInMegaBytes, forKey: ClientRuntime.Key("ProgressInMegaBytes"))
        }
        if let requestTime = requestTime {
            try container.encode(ClientRuntime.TimestampWrapper(requestTime, format: .dateTime), forKey: ClientRuntime.Key("requestTime"))
        }
        if let snapshotIdentifier = snapshotIdentifier {
            try container.encode(snapshotIdentifier, forKey: ClientRuntime.Key("SnapshotIdentifier"))
        }
        if let sourceDatabaseName = sourceDatabaseName {
            try container.encode(sourceDatabaseName, forKey: ClientRuntime.Key("SourceDatabaseName"))
        }
        if let sourceSchemaName = sourceSchemaName {
            try container.encode(sourceSchemaName, forKey: ClientRuntime.Key("SourceSchemaName"))
        }
        if let sourceTableName = sourceTableName {
            try container.encode(sourceTableName, forKey: ClientRuntime.Key("SourceTableName"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let tableRestoreRequestId = tableRestoreRequestId {
            try container.encode(tableRestoreRequestId, forKey: ClientRuntime.Key("TableRestoreRequestId"))
        }
        if let targetDatabaseName = targetDatabaseName {
            try container.encode(targetDatabaseName, forKey: ClientRuntime.Key("TargetDatabaseName"))
        }
        if let targetSchemaName = targetSchemaName {
            try container.encode(targetSchemaName, forKey: ClientRuntime.Key("TargetSchemaName"))
        }
        if let totalDataInMegaBytes = totalDataInMegaBytes {
            try container.encode(totalDataInMegaBytes, forKey: ClientRuntime.Key("TotalDataInMegaBytes"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableRestoreRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableRestoreRequestId)
        tableRestoreRequestId = tableRestoreRequestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.TableRestoreStatusType.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestTime)
        var requestTimeBuffer:ClientRuntime.Date? = nil
        if let requestTimeDecoded = requestTimeDecoded {
            requestTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(requestTimeDecoded, format: .dateTime)
        }
        requestTime = requestTimeBuffer
        let progressInMegaBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .progressInMegaBytes)
        progressInMegaBytes = progressInMegaBytesDecoded
        let totalDataInMegaBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalDataInMegaBytes)
        totalDataInMegaBytes = totalDataInMegaBytesDecoded
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let snapshotIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotIdentifier)
        snapshotIdentifier = snapshotIdentifierDecoded
        let sourceDatabaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceDatabaseName)
        sourceDatabaseName = sourceDatabaseNameDecoded
        let sourceSchemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceSchemaName)
        sourceSchemaName = sourceSchemaNameDecoded
        let sourceTableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceTableName)
        sourceTableName = sourceTableNameDecoded
        let targetDatabaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetDatabaseName)
        targetDatabaseName = targetDatabaseNameDecoded
        let targetSchemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetSchemaName)
        targetSchemaName = targetSchemaNameDecoded
        let newTableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .newTableName)
        newTableName = newTableNameDecoded
    }
}

extension RedshiftClientTypes.TableRestoreStatus: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TableRestoreStatus(clusterIdentifier: \(Swift.String(describing: clusterIdentifier)), message: \(Swift.String(describing: message)), newTableName: \(Swift.String(describing: newTableName)), progressInMegaBytes: \(Swift.String(describing: progressInMegaBytes)), requestTime: \(Swift.String(describing: requestTime)), snapshotIdentifier: \(Swift.String(describing: snapshotIdentifier)), sourceDatabaseName: \(Swift.String(describing: sourceDatabaseName)), sourceSchemaName: \(Swift.String(describing: sourceSchemaName)), sourceTableName: \(Swift.String(describing: sourceTableName)), status: \(Swift.String(describing: status)), tableRestoreRequestId: \(Swift.String(describing: tableRestoreRequestId)), targetDatabaseName: \(Swift.String(describing: targetDatabaseName)), targetSchemaName: \(Swift.String(describing: targetSchemaName)), totalDataInMegaBytes: \(Swift.String(describing: totalDataInMegaBytes)))"}
}

extension RedshiftClientTypes {
    /// <p>Describes the status of a <a>RestoreTableFromClusterSnapshot</a>
    ///             operation.</p>
    public struct TableRestoreStatus: Swift.Equatable {
        /// <p>The identifier of the Amazon Redshift cluster that the table is being restored
        ///             to.</p>
        public let clusterIdentifier: Swift.String?
        /// <p>A description of the status of the table restore request. Status values include
        ///                 <code>SUCCEEDED</code>, <code>FAILED</code>, <code>CANCELED</code>,
        ///                 <code>PENDING</code>, <code>IN_PROGRESS</code>.</p>
        public let message: Swift.String?
        /// <p>The name of the table to create as a result of the table restore request.</p>
        public let newTableName: Swift.String?
        /// <p>The amount of data restored to the new table so far, in megabytes (MB).</p>
        public let progressInMegaBytes: Swift.Int?
        /// <p>The time that the table restore request was made, in Universal Coordinated Time
        ///             (UTC).</p>
        public let requestTime: ClientRuntime.Date?
        /// <p>The identifier of the snapshot that the table is being restored from.</p>
        public let snapshotIdentifier: Swift.String?
        /// <p>The name of the source database that contains the table being restored.</p>
        public let sourceDatabaseName: Swift.String?
        /// <p>The name of the source schema that contains the table being restored.</p>
        public let sourceSchemaName: Swift.String?
        /// <p>The name of the source table being restored.</p>
        public let sourceTableName: Swift.String?
        /// <p>A value that describes the current state of the table restore request.</p>
        ///         <p>Valid Values: <code>SUCCEEDED</code>, <code>FAILED</code>, <code>CANCELED</code>,
        ///                 <code>PENDING</code>, <code>IN_PROGRESS</code>
        ///         </p>
        public let status: RedshiftClientTypes.TableRestoreStatusType?
        /// <p>The unique identifier for the table restore request.</p>
        public let tableRestoreRequestId: Swift.String?
        /// <p>The name of the database to restore the table to.</p>
        public let targetDatabaseName: Swift.String?
        /// <p>The name of the schema to restore the table to.</p>
        public let targetSchemaName: Swift.String?
        /// <p>The total amount of data to restore to the new table, in megabytes (MB).</p>
        public let totalDataInMegaBytes: Swift.Int?

        public init (
            clusterIdentifier: Swift.String? = nil,
            message: Swift.String? = nil,
            newTableName: Swift.String? = nil,
            progressInMegaBytes: Swift.Int? = nil,
            requestTime: ClientRuntime.Date? = nil,
            snapshotIdentifier: Swift.String? = nil,
            sourceDatabaseName: Swift.String? = nil,
            sourceSchemaName: Swift.String? = nil,
            sourceTableName: Swift.String? = nil,
            status: RedshiftClientTypes.TableRestoreStatusType? = nil,
            tableRestoreRequestId: Swift.String? = nil,
            targetDatabaseName: Swift.String? = nil,
            targetSchemaName: Swift.String? = nil,
            totalDataInMegaBytes: Swift.Int? = nil
        )
        {
            self.clusterIdentifier = clusterIdentifier
            self.message = message
            self.newTableName = newTableName
            self.progressInMegaBytes = progressInMegaBytes
            self.requestTime = requestTime
            self.snapshotIdentifier = snapshotIdentifier
            self.sourceDatabaseName = sourceDatabaseName
            self.sourceSchemaName = sourceSchemaName
            self.sourceTableName = sourceTableName
            self.status = status
            self.tableRestoreRequestId = tableRestoreRequestId
            self.targetDatabaseName = targetDatabaseName
            self.targetSchemaName = targetSchemaName
            self.totalDataInMegaBytes = totalDataInMegaBytes
        }
    }

}

extension RedshiftClientTypes {
    public enum TableRestoreStatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canceled
        case failed
        case inProgress
        case pending
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [TableRestoreStatusType] {
            return [
                .canceled,
                .failed,
                .inProgress,
                .pending,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .pending: return "PENDING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TableRestoreStatusType(rawValue: rawValue) ?? TableRestoreStatusType.sdkUnknown(rawValue)
        }
    }
}

extension RedshiftClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let key = key {
            try container.encode(key, forKey: ClientRuntime.Key("Key"))
        }
        if let value = value {
            try container.encode(value, forKey: ClientRuntime.Key("Value"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension RedshiftClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension RedshiftClientTypes {
    /// <p>A tag consisting of a name/value pair for a resource.</p>
    public struct Tag: Swift.Equatable {
        /// <p>The key, or name, for the resource tag.</p>
        public let key: Swift.String?
        /// <p>The value for the resource tag.</p>
        public let value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagLimitExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagLimitExceededFault(message: \(Swift.String(describing: message)))"}
}

extension TagLimitExceededFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TagLimitExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have exceeded the number of tags allowed.</p>
public struct TagLimitExceededFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TagLimitExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TagLimitExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RedshiftClientTypes.TaggedResource: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceName = "ResourceName"
        case resourceType = "ResourceType"
        case tag = "Tag"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let resourceName = resourceName {
            try container.encode(resourceName, forKey: ClientRuntime.Key("ResourceName"))
        }
        if let resourceType = resourceType {
            try container.encode(resourceType, forKey: ClientRuntime.Key("ResourceType"))
        }
        if let tag = tag {
            try container.encode(tag, forKey: ClientRuntime.Key("Tag"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.Tag.self, forKey: .tag)
        tag = tagDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension RedshiftClientTypes.TaggedResource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TaggedResource(resourceName: \(Swift.String(describing: resourceName)), resourceType: \(Swift.String(describing: resourceType)), tag: \(Swift.String(describing: tag)))"}
}

extension RedshiftClientTypes {
    /// <p>A tag and its associated resource.</p>
    public struct TaggedResource: Swift.Equatable {
        /// <p>The Amazon Resource Name (ARN) with which the tag is associated, for example:
        ///                 <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>.</p>
        public let resourceName: Swift.String?
        /// <p>The type of resource with which the tag is associated. Valid resource types are: </p>
        ///         <ul>
        ///             <li>
        ///                 <p>Cluster</p>
        ///             </li>
        ///             <li>
        ///                 <p>CIDR/IP</p>
        ///             </li>
        ///             <li>
        ///                 <p>EC2 security group</p>
        ///             </li>
        ///             <li>
        ///                 <p>Snapshot</p>
        ///             </li>
        ///             <li>
        ///                 <p>Cluster security group</p>
        ///             </li>
        ///             <li>
        ///                 <p>Subnet group</p>
        ///             </li>
        ///             <li>
        ///                 <p>HSM connection</p>
        ///             </li>
        ///             <li>
        ///                 <p>HSM certificate</p>
        ///             </li>
        ///             <li>
        ///                 <p>Parameter group</p>
        ///             </li>
        ///          </ul>
        ///         <p>For more information about Amazon Redshift resource types and constructing ARNs, go to
        ///                 <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-overview.html#redshift-iam-access-control-specify-actions">Constructing an Amazon Redshift Amazon Resource Name (ARN)</a> in the
        ///             Amazon Redshift Cluster Management Guide. </p>
        public let resourceType: Swift.String?
        /// <p>The tag for the resource.</p>
        public let tag: RedshiftClientTypes.Tag?

        public init (
            resourceName: Swift.String? = nil,
            resourceType: Swift.String? = nil,
            tag: RedshiftClientTypes.Tag? = nil
        )
        {
            self.resourceName = resourceName
            self.resourceType = resourceType
            self.tag = tag
        }
    }

}

extension UnauthorizedOperation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnauthorizedOperation(message: \(Swift.String(describing: message)))"}
}

extension UnauthorizedOperation: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<UnauthorizedOperationBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Your account is not authorized to perform the requested operation.</p>
public struct UnauthorizedOperation: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnauthorizedOperationBody: Swift.Equatable {
    public let message: Swift.String?
}

extension UnauthorizedOperationBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnauthorizedPartnerIntegrationFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnauthorizedPartnerIntegrationFault(message: \(Swift.String(describing: message)))"}
}

extension UnauthorizedPartnerIntegrationFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<UnauthorizedPartnerIntegrationFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The partner integration is not authorized.</p>
public struct UnauthorizedPartnerIntegrationFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnauthorizedPartnerIntegrationFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension UnauthorizedPartnerIntegrationFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnknownSnapshotCopyRegionFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnknownSnapshotCopyRegionFault(message: \(Swift.String(describing: message)))"}
}

extension UnknownSnapshotCopyRegionFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<UnknownSnapshotCopyRegionFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified region is incorrect or does not exist.</p>
public struct UnknownSnapshotCopyRegionFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnknownSnapshotCopyRegionFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension UnknownSnapshotCopyRegionFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnsupportedOperationFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnsupportedOperationFault(message: \(Swift.String(describing: message)))"}
}

extension UnsupportedOperationFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<UnsupportedOperationFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested operation isn't supported.</p>
public struct UnsupportedOperationFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedOperationFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension UnsupportedOperationFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnsupportedOptionFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnsupportedOptionFault(message: \(Swift.String(describing: message)))"}
}

extension UnsupportedOptionFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<UnsupportedOptionFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A request option was specified that is not supported.</p>
public struct UnsupportedOptionFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedOptionFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension UnsupportedOptionFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UpdatePartnerStatusInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePartnerStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePartnerStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePartnerStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePartnerStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePartnerStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePartnerStatusOutputError>
}

extension UpdatePartnerStatusInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePartnerStatusInput(accountId: \(Swift.String(describing: accountId)), clusterIdentifier: \(Swift.String(describing: clusterIdentifier)), databaseName: \(Swift.String(describing: databaseName)), partnerName: \(Swift.String(describing: partnerName)), status: \(Swift.String(describing: status)), statusMessage: \(Swift.String(describing: statusMessage)))"}
}

extension UpdatePartnerStatusInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let accountId = accountId {
            try container.encode(accountId, forKey: ClientRuntime.Key("AccountId"))
        }
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: ClientRuntime.Key("ClusterIdentifier"))
        }
        if let databaseName = databaseName {
            try container.encode(databaseName, forKey: ClientRuntime.Key("DatabaseName"))
        }
        if let partnerName = partnerName {
            try container.encode(partnerName, forKey: ClientRuntime.Key("PartnerName"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let statusMessage = statusMessage {
            try container.encode(statusMessage, forKey: ClientRuntime.Key("StatusMessage"))
        }
        try container.encode("UpdatePartnerStatus", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct UpdatePartnerStatusInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePartnerStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePartnerStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePartnerStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePartnerStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePartnerStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePartnerStatusOutputError>
}

public struct UpdatePartnerStatusInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePartnerStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePartnerStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePartnerStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePartnerStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePartnerStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePartnerStatusOutputError>
}

public struct UpdatePartnerStatusInput: Swift.Equatable {
    /// <p>The AWS account ID that owns the cluster.</p>
    public let accountId: Swift.String?
    /// <p>The cluster identifier of the cluster whose partner integration status is being updated.</p>
    public let clusterIdentifier: Swift.String?
    /// <p>The name of the database whose partner integration status is being updated.</p>
    public let databaseName: Swift.String?
    /// <p>The name of the partner whose integration status is being updated.</p>
    public let partnerName: Swift.String?
    /// <p>The value of the updated status.</p>
    public let status: RedshiftClientTypes.PartnerIntegrationStatus?
    /// <p>The status message provided by the partner.</p>
    public let statusMessage: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        clusterIdentifier: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        partnerName: Swift.String? = nil,
        status: RedshiftClientTypes.PartnerIntegrationStatus? = nil,
        statusMessage: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.clusterIdentifier = clusterIdentifier
        self.databaseName = databaseName
        self.partnerName = partnerName
        self.status = status
        self.statusMessage = statusMessage
    }
}

extension UpdatePartnerStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdatePartnerStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PartnerNotFoundFault" : self = .partnerNotFoundFault(try PartnerNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedPartnerIntegrationFault" : self = .unauthorizedPartnerIntegrationFault(try UnauthorizedPartnerIntegrationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePartnerStatusOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case partnerNotFoundFault(PartnerNotFoundFault)
    case unauthorizedPartnerIntegrationFault(UnauthorizedPartnerIntegrationFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePartnerStatusOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePartnerStatusOutputResponse(databaseName: \(Swift.String(describing: databaseName)), partnerName: \(Swift.String(describing: partnerName)))"}
}

extension UpdatePartnerStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdatePartnerStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.databaseName = output.databaseName
            self.partnerName = output.partnerName
        } else {
            self.databaseName = nil
            self.partnerName = nil
        }
    }
}

public struct UpdatePartnerStatusOutputResponse: Swift.Equatable {
    /// <p>The name of the database that receives data from the partner.</p>
    public let databaseName: Swift.String?
    /// <p>The name of the partner that is authorized to send data.</p>
    public let partnerName: Swift.String?

    public init (
        databaseName: Swift.String? = nil,
        partnerName: Swift.String? = nil
    )
    {
        self.databaseName = databaseName
        self.partnerName = partnerName
    }
}

struct UpdatePartnerStatusOutputResponseBody: Swift.Equatable {
    public let databaseName: Swift.String?
    public let partnerName: Swift.String?
}

extension UpdatePartnerStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName = "DatabaseName"
        case partnerName = "PartnerName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("UpdatePartnerStatusResult"))
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let partnerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .partnerName)
        partnerName = partnerNameDecoded
    }
}

extension RedshiftClientTypes.UpdateTarget: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseVersion = "DatabaseVersion"
        case maintenanceTrackName = "MaintenanceTrackName"
        case supportedOperations = "SupportedOperations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let databaseVersion = databaseVersion {
            try container.encode(databaseVersion, forKey: ClientRuntime.Key("DatabaseVersion"))
        }
        if let maintenanceTrackName = maintenanceTrackName {
            try container.encode(maintenanceTrackName, forKey: ClientRuntime.Key("MaintenanceTrackName"))
        }
        if let supportedOperations = supportedOperations {
            var supportedOperationsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SupportedOperations"))
            for (index0, supportedoperation0) in supportedOperations.enumerated() {
                try supportedOperationsContainer.encode(supportedoperation0, forKey: ClientRuntime.Key("SupportedOperation.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maintenanceTrackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maintenanceTrackName)
        maintenanceTrackName = maintenanceTrackNameDecoded
        let databaseVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseVersion)
        databaseVersion = databaseVersionDecoded
        if containerValues.contains(.supportedOperations) {
            struct KeyVal0{struct SupportedOperation{}}
            let supportedOperationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.SupportedOperation>.CodingKeys.self, forKey: .supportedOperations)
            if let supportedOperationsWrappedContainer = supportedOperationsWrappedContainer {
                let supportedOperationsContainer = try supportedOperationsWrappedContainer.decodeIfPresent([RedshiftClientTypes.SupportedOperation].self, forKey: .member)
                var supportedOperationsBuffer:[RedshiftClientTypes.SupportedOperation]? = nil
                if let supportedOperationsContainer = supportedOperationsContainer {
                    supportedOperationsBuffer = [RedshiftClientTypes.SupportedOperation]()
                    for structureContainer0 in supportedOperationsContainer {
                        supportedOperationsBuffer?.append(structureContainer0)
                    }
                }
                supportedOperations = supportedOperationsBuffer
            } else {
                supportedOperations = []
            }
        } else {
            supportedOperations = nil
        }
    }
}

extension RedshiftClientTypes.UpdateTarget: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateTarget(databaseVersion: \(Swift.String(describing: databaseVersion)), maintenanceTrackName: \(Swift.String(describing: maintenanceTrackName)), supportedOperations: \(Swift.String(describing: supportedOperations)))"}
}

extension RedshiftClientTypes {
    /// <p>A maintenance track that you can switch the current track to.</p>
    public struct UpdateTarget: Swift.Equatable {
        /// <p>The cluster version for the new maintenance track.</p>
        public let databaseVersion: Swift.String?
        /// <p>The name of the new maintenance track.</p>
        public let maintenanceTrackName: Swift.String?
        /// <p>A list of operations supported by the maintenance track.</p>
        public let supportedOperations: [RedshiftClientTypes.SupportedOperation]?

        public init (
            databaseVersion: Swift.String? = nil,
            maintenanceTrackName: Swift.String? = nil,
            supportedOperations: [RedshiftClientTypes.SupportedOperation]? = nil
        )
        {
            self.databaseVersion = databaseVersion
            self.maintenanceTrackName = maintenanceTrackName
            self.supportedOperations = supportedOperations
        }
    }

}

extension RedshiftClientTypes.UsageLimit: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amount = "Amount"
        case breachAction = "BreachAction"
        case clusterIdentifier = "ClusterIdentifier"
        case featureType = "FeatureType"
        case limitType = "LimitType"
        case period = "Period"
        case tags = "Tags"
        case usageLimitId = "UsageLimitId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if amount != 0 {
            try container.encode(amount, forKey: ClientRuntime.Key("Amount"))
        }
        if let breachAction = breachAction {
            try container.encode(breachAction, forKey: ClientRuntime.Key("BreachAction"))
        }
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: ClientRuntime.Key("ClusterIdentifier"))
        }
        if let featureType = featureType {
            try container.encode(featureType, forKey: ClientRuntime.Key("FeatureType"))
        }
        if let limitType = limitType {
            try container.encode(limitType, forKey: ClientRuntime.Key("LimitType"))
        }
        if let period = period {
            try container.encode(period, forKey: ClientRuntime.Key("Period"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let usageLimitId = usageLimitId {
            try container.encode(usageLimitId, forKey: ClientRuntime.Key("UsageLimitId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usageLimitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .usageLimitId)
        usageLimitId = usageLimitIdDecoded
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let featureTypeDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.UsageLimitFeatureType.self, forKey: .featureType)
        featureType = featureTypeDecoded
        let limitTypeDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.UsageLimitLimitType.self, forKey: .limitType)
        limitType = limitTypeDecoded
        let amountDecoded = try containerValues.decode(Swift.Int.self, forKey: .amount)
        amount = amountDecoded
        let periodDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.UsageLimitPeriod.self, forKey: .period)
        period = periodDecoded
        let breachActionDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.UsageLimitBreachAction.self, forKey: .breachAction)
        breachAction = breachActionDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([RedshiftClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[RedshiftClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [RedshiftClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension RedshiftClientTypes.UsageLimit: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UsageLimit(amount: \(Swift.String(describing: amount)), breachAction: \(Swift.String(describing: breachAction)), clusterIdentifier: \(Swift.String(describing: clusterIdentifier)), featureType: \(Swift.String(describing: featureType)), limitType: \(Swift.String(describing: limitType)), period: \(Swift.String(describing: period)), tags: \(Swift.String(describing: tags)), usageLimitId: \(Swift.String(describing: usageLimitId)))"}
}

extension RedshiftClientTypes {
    /// <p>Describes a usage limit object for a cluster. </p>
    public struct UsageLimit: Swift.Equatable {
        /// <p>The limit amount. If time-based, this amount is in minutes. If data-based, this amount is in terabytes (TB).</p>
        public let amount: Swift.Int
        /// <p>The action that Amazon Redshift takes when the limit is reached. Possible values are: </p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <b>log</b> - To log an event in a system table. The default is log.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <b>emit-metric</b> - To emit CloudWatch metrics.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <b>disable</b> - To disable the feature until the next usage period begins.</p>
        ///             </li>
        ///          </ul>
        public let breachAction: RedshiftClientTypes.UsageLimitBreachAction?
        /// <p>The identifier of the cluster with a usage limit.</p>
        public let clusterIdentifier: Swift.String?
        /// <p>The Amazon Redshift feature to which the limit applies.</p>
        public let featureType: RedshiftClientTypes.UsageLimitFeatureType?
        /// <p>The type of limit. Depending on the feature type, this can be based on a time duration or data size.</p>
        public let limitType: RedshiftClientTypes.UsageLimitLimitType?
        /// <p>The time period that the amount applies to. A <code>weekly</code> period begins on Sunday. The default is <code>monthly</code>. </p>
        public let period: RedshiftClientTypes.UsageLimitPeriod?
        /// <p>A list of tag instances.</p>
        public let tags: [RedshiftClientTypes.Tag]?
        /// <p>The identifier of the usage limit.</p>
        public let usageLimitId: Swift.String?

        public init (
            amount: Swift.Int = 0,
            breachAction: RedshiftClientTypes.UsageLimitBreachAction? = nil,
            clusterIdentifier: Swift.String? = nil,
            featureType: RedshiftClientTypes.UsageLimitFeatureType? = nil,
            limitType: RedshiftClientTypes.UsageLimitLimitType? = nil,
            period: RedshiftClientTypes.UsageLimitPeriod? = nil,
            tags: [RedshiftClientTypes.Tag]? = nil,
            usageLimitId: Swift.String? = nil
        )
        {
            self.amount = amount
            self.breachAction = breachAction
            self.clusterIdentifier = clusterIdentifier
            self.featureType = featureType
            self.limitType = limitType
            self.period = period
            self.tags = tags
            self.usageLimitId = usageLimitId
        }
    }

}

extension UsageLimitAlreadyExistsFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UsageLimitAlreadyExistsFault(message: \(Swift.String(describing: message)))"}
}

extension UsageLimitAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<UsageLimitAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The usage limit already exists. </p>
public struct UsageLimitAlreadyExistsFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UsageLimitAlreadyExistsFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension UsageLimitAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RedshiftClientTypes {
    public enum UsageLimitBreachAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disable
        case emitMetric
        case log
        case sdkUnknown(Swift.String)

        public static var allCases: [UsageLimitBreachAction] {
            return [
                .disable,
                .emitMetric,
                .log,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disable: return "disable"
            case .emitMetric: return "emit-metric"
            case .log: return "log"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UsageLimitBreachAction(rawValue: rawValue) ?? UsageLimitBreachAction.sdkUnknown(rawValue)
        }
    }
}

extension RedshiftClientTypes {
    public enum UsageLimitFeatureType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case concurrencyScaling
        case spectrum
        case sdkUnknown(Swift.String)

        public static var allCases: [UsageLimitFeatureType] {
            return [
                .concurrencyScaling,
                .spectrum,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .concurrencyScaling: return "concurrency-scaling"
            case .spectrum: return "spectrum"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UsageLimitFeatureType(rawValue: rawValue) ?? UsageLimitFeatureType.sdkUnknown(rawValue)
        }
    }
}

extension RedshiftClientTypes {
    public enum UsageLimitLimitType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dataScanned
        case time
        case sdkUnknown(Swift.String)

        public static var allCases: [UsageLimitLimitType] {
            return [
                .dataScanned,
                .time,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dataScanned: return "data-scanned"
            case .time: return "time"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UsageLimitLimitType(rawValue: rawValue) ?? UsageLimitLimitType.sdkUnknown(rawValue)
        }
    }
}

extension UsageLimitNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UsageLimitNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension UsageLimitNotFoundFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<UsageLimitNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The usage limit identifier can't be found.</p>
public struct UsageLimitNotFoundFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UsageLimitNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension UsageLimitNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RedshiftClientTypes {
    public enum UsageLimitPeriod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case daily
        case monthly
        case weekly
        case sdkUnknown(Swift.String)

        public static var allCases: [UsageLimitPeriod] {
            return [
                .daily,
                .monthly,
                .weekly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .daily: return "daily"
            case .monthly: return "monthly"
            case .weekly: return "weekly"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UsageLimitPeriod(rawValue: rawValue) ?? UsageLimitPeriod.sdkUnknown(rawValue)
        }
    }
}

extension RedshiftClientTypes.VpcEndpoint: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkInterfaces = "NetworkInterfaces"
        case vpcEndpointId = "VpcEndpointId"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let networkInterfaces = networkInterfaces {
            var networkInterfacesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("NetworkInterfaces"))
            for (index0, networkinterface0) in networkInterfaces.enumerated() {
                try networkInterfacesContainer.encode(networkinterface0, forKey: ClientRuntime.Key("NetworkInterface.\(index0.advanced(by: 1))"))
            }
        }
        if let vpcEndpointId = vpcEndpointId {
            try container.encode(vpcEndpointId, forKey: ClientRuntime.Key("VpcEndpointId"))
        }
        if let vpcId = vpcId {
            try container.encode(vpcId, forKey: ClientRuntime.Key("VpcId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcEndpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcEndpointId)
        vpcEndpointId = vpcEndpointIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        if containerValues.contains(.networkInterfaces) {
            struct KeyVal0{struct NetworkInterface{}}
            let networkInterfacesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.NetworkInterface>.CodingKeys.self, forKey: .networkInterfaces)
            if let networkInterfacesWrappedContainer = networkInterfacesWrappedContainer {
                let networkInterfacesContainer = try networkInterfacesWrappedContainer.decodeIfPresent([RedshiftClientTypes.NetworkInterface].self, forKey: .member)
                var networkInterfacesBuffer:[RedshiftClientTypes.NetworkInterface]? = nil
                if let networkInterfacesContainer = networkInterfacesContainer {
                    networkInterfacesBuffer = [RedshiftClientTypes.NetworkInterface]()
                    for structureContainer0 in networkInterfacesContainer {
                        networkInterfacesBuffer?.append(structureContainer0)
                    }
                }
                networkInterfaces = networkInterfacesBuffer
            } else {
                networkInterfaces = []
            }
        } else {
            networkInterfaces = nil
        }
    }
}

extension RedshiftClientTypes.VpcEndpoint: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VpcEndpoint(networkInterfaces: \(Swift.String(describing: networkInterfaces)), vpcEndpointId: \(Swift.String(describing: vpcEndpointId)), vpcId: \(Swift.String(describing: vpcId)))"}
}

extension RedshiftClientTypes {
    /// <p>The connection endpoint for connecting to an Amazon Redshift cluster through the proxy.</p>
    public struct VpcEndpoint: Swift.Equatable {
        /// <p>One or more network interfaces of the endpoint. Also known as an interface endpoint. </p>
        public let networkInterfaces: [RedshiftClientTypes.NetworkInterface]?
        /// <p>The connection endpoint ID for connecting an Amazon Redshift cluster through the proxy.</p>
        public let vpcEndpointId: Swift.String?
        /// <p>The VPC identifier that the endpoint is associated. </p>
        public let vpcId: Swift.String?

        public init (
            networkInterfaces: [RedshiftClientTypes.NetworkInterface]? = nil,
            vpcEndpointId: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.networkInterfaces = networkInterfaces
            self.vpcEndpointId = vpcEndpointId
            self.vpcId = vpcId
        }
    }

}

extension RedshiftClientTypes.VpcSecurityGroupMembership: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
        case vpcSecurityGroupId = "VpcSecurityGroupId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let vpcSecurityGroupId = vpcSecurityGroupId {
            try container.encode(vpcSecurityGroupId, forKey: ClientRuntime.Key("VpcSecurityGroupId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcSecurityGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcSecurityGroupId)
        vpcSecurityGroupId = vpcSecurityGroupIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension RedshiftClientTypes.VpcSecurityGroupMembership: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VpcSecurityGroupMembership(status: \(Swift.String(describing: status)), vpcSecurityGroupId: \(Swift.String(describing: vpcSecurityGroupId)))"}
}

extension RedshiftClientTypes {
    /// <p>Describes the members of a VPC security group.</p>
    public struct VpcSecurityGroupMembership: Swift.Equatable {
        /// <p>The status of the VPC security group.</p>
        public let status: Swift.String?
        /// <p>The identifier of the VPC security group.</p>
        public let vpcSecurityGroupId: Swift.String?

        public init (
            status: Swift.String? = nil,
            vpcSecurityGroupId: Swift.String? = nil
        )
        {
            self.status = status
            self.vpcSecurityGroupId = vpcSecurityGroupId
        }
    }

}
