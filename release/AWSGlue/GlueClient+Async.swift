// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

#if swift(>=5.5) && canImport(_Concurrency)
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, macCatalyst 15.0, *)
public extension GlueClient {
    /// Creates one or more partitions in a batch operation.
    func batchCreatePartition(input: BatchCreatePartitionInput) async throws -> BatchCreatePartitionOutputResponse
    {
        typealias batchCreatePartitionContinuation = CheckedContinuation<BatchCreatePartitionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: batchCreatePartitionContinuation) in
            batchCreatePartition(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes a list of connection definitions from the Data Catalog.
    func batchDeleteConnection(input: BatchDeleteConnectionInput) async throws -> BatchDeleteConnectionOutputResponse
    {
        typealias batchDeleteConnectionContinuation = CheckedContinuation<BatchDeleteConnectionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: batchDeleteConnectionContinuation) in
            batchDeleteConnection(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes one or more partitions in a batch operation.
    func batchDeletePartition(input: BatchDeletePartitionInput) async throws -> BatchDeletePartitionOutputResponse
    {
        typealias batchDeletePartitionContinuation = CheckedContinuation<BatchDeletePartitionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: batchDeletePartitionContinuation) in
            batchDeletePartition(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes multiple tables at once. After completing this operation, you no longer have access to the table versions and partitions that belong to the deleted table. Glue deletes these "orphaned" resources asynchronously in a timely manner, at the discretion of the service. To ensure the immediate deletion of all related resources, before calling BatchDeleteTable, use DeleteTableVersion or BatchDeleteTableVersion, and DeletePartition or BatchDeletePartition, to delete any resources that belong to the table.
    func batchDeleteTable(input: BatchDeleteTableInput) async throws -> BatchDeleteTableOutputResponse
    {
        typealias batchDeleteTableContinuation = CheckedContinuation<BatchDeleteTableOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: batchDeleteTableContinuation) in
            batchDeleteTable(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes a specified batch of versions of a table.
    func batchDeleteTableVersion(input: BatchDeleteTableVersionInput) async throws -> BatchDeleteTableVersionOutputResponse
    {
        typealias batchDeleteTableVersionContinuation = CheckedContinuation<BatchDeleteTableVersionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: batchDeleteTableVersionContinuation) in
            batchDeleteTableVersion(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves information about a list of blueprints.
    func batchGetBlueprints(input: BatchGetBlueprintsInput) async throws -> BatchGetBlueprintsOutputResponse
    {
        typealias batchGetBlueprintsContinuation = CheckedContinuation<BatchGetBlueprintsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: batchGetBlueprintsContinuation) in
            batchGetBlueprints(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns a list of resource metadata for a given list of crawler names. After calling the ListCrawlers operation, you can call this operation to access the data to which you have been granted permissions. This operation supports all IAM permissions, including permission conditions that uses tags.
    func batchGetCrawlers(input: BatchGetCrawlersInput) async throws -> BatchGetCrawlersOutputResponse
    {
        typealias batchGetCrawlersContinuation = CheckedContinuation<BatchGetCrawlersOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: batchGetCrawlersContinuation) in
            batchGetCrawlers(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns a list of resource metadata for a given list of development endpoint names. After calling the ListDevEndpoints operation, you can call this operation to access the data to which you have been granted permissions. This operation supports all IAM permissions, including permission conditions that uses tags.
    func batchGetDevEndpoints(input: BatchGetDevEndpointsInput) async throws -> BatchGetDevEndpointsOutputResponse
    {
        typealias batchGetDevEndpointsContinuation = CheckedContinuation<BatchGetDevEndpointsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: batchGetDevEndpointsContinuation) in
            batchGetDevEndpoints(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns a list of resource metadata for a given list of job names. After calling the ListJobs operation, you can call this operation to access the data to which you have been granted permissions. This operation supports all IAM permissions, including permission conditions that uses tags.
    func batchGetJobs(input: BatchGetJobsInput) async throws -> BatchGetJobsOutputResponse
    {
        typealias batchGetJobsContinuation = CheckedContinuation<BatchGetJobsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: batchGetJobsContinuation) in
            batchGetJobs(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves partitions in a batch request.
    func batchGetPartition(input: BatchGetPartitionInput) async throws -> BatchGetPartitionOutputResponse
    {
        typealias batchGetPartitionContinuation = CheckedContinuation<BatchGetPartitionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: batchGetPartitionContinuation) in
            batchGetPartition(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns a list of resource metadata for a given list of trigger names. After calling the ListTriggers operation, you can call this operation to access the data to which you have been granted permissions. This operation supports all IAM permissions, including permission conditions that uses tags.
    func batchGetTriggers(input: BatchGetTriggersInput) async throws -> BatchGetTriggersOutputResponse
    {
        typealias batchGetTriggersContinuation = CheckedContinuation<BatchGetTriggersOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: batchGetTriggersContinuation) in
            batchGetTriggers(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns a list of resource metadata for a given list of workflow names. After calling the ListWorkflows operation, you can call this operation to access the data to which you have been granted permissions. This operation supports all IAM permissions, including permission conditions that uses tags.
    func batchGetWorkflows(input: BatchGetWorkflowsInput) async throws -> BatchGetWorkflowsOutputResponse
    {
        typealias batchGetWorkflowsContinuation = CheckedContinuation<BatchGetWorkflowsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: batchGetWorkflowsContinuation) in
            batchGetWorkflows(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Stops one or more job runs for a specified job definition.
    func batchStopJobRun(input: BatchStopJobRunInput) async throws -> BatchStopJobRunOutputResponse
    {
        typealias batchStopJobRunContinuation = CheckedContinuation<BatchStopJobRunOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: batchStopJobRunContinuation) in
            batchStopJobRun(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates one or more partitions in a batch operation.
    func batchUpdatePartition(input: BatchUpdatePartitionInput) async throws -> BatchUpdatePartitionOutputResponse
    {
        typealias batchUpdatePartitionContinuation = CheckedContinuation<BatchUpdatePartitionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: batchUpdatePartitionContinuation) in
            batchUpdatePartition(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Cancels (stops) a task run. Machine learning task runs are asynchronous tasks that Glue runs on your behalf as part of various machine learning workflows. You can cancel a machine learning task run at any time by calling CancelMLTaskRun with a task run's parent transform's TransformID and the task run's TaskRunId.
    func cancelMLTaskRun(input: CancelMLTaskRunInput) async throws -> CancelMLTaskRunOutputResponse
    {
        typealias cancelMLTaskRunContinuation = CheckedContinuation<CancelMLTaskRunOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: cancelMLTaskRunContinuation) in
            cancelMLTaskRun(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Validates the supplied schema. This call has no side effects, it simply validates using the supplied schema using DataFormat as the format. Since it does not take a schema set name, no compatibility checks are performed.
    func checkSchemaVersionValidity(input: CheckSchemaVersionValidityInput) async throws -> CheckSchemaVersionValidityOutputResponse
    {
        typealias checkSchemaVersionValidityContinuation = CheckedContinuation<CheckSchemaVersionValidityOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: checkSchemaVersionValidityContinuation) in
            checkSchemaVersionValidity(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Registers a blueprint with Glue.
    func createBlueprint(input: CreateBlueprintInput) async throws -> CreateBlueprintOutputResponse
    {
        typealias createBlueprintContinuation = CheckedContinuation<CreateBlueprintOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createBlueprintContinuation) in
            createBlueprint(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a classifier in the user's account. This can be a GrokClassifier, an XMLClassifier, a JsonClassifier, or a CsvClassifier, depending on which field of the request is present.
    func createClassifier(input: CreateClassifierInput) async throws -> CreateClassifierOutputResponse
    {
        typealias createClassifierContinuation = CheckedContinuation<CreateClassifierOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createClassifierContinuation) in
            createClassifier(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a connection definition in the Data Catalog.
    func createConnection(input: CreateConnectionInput) async throws -> CreateConnectionOutputResponse
    {
        typealias createConnectionContinuation = CheckedContinuation<CreateConnectionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createConnectionContinuation) in
            createConnection(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a new crawler with specified targets, role, configuration, and optional schedule. At least one crawl target must be specified, in the s3Targets field, the jdbcTargets field, or the DynamoDBTargets field.
    func createCrawler(input: CreateCrawlerInput) async throws -> CreateCrawlerOutputResponse
    {
        typealias createCrawlerContinuation = CheckedContinuation<CreateCrawlerOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createCrawlerContinuation) in
            createCrawler(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a new database in a Data Catalog.
    func createDatabase(input: CreateDatabaseInput) async throws -> CreateDatabaseOutputResponse
    {
        typealias createDatabaseContinuation = CheckedContinuation<CreateDatabaseOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createDatabaseContinuation) in
            createDatabase(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a new development endpoint.
    func createDevEndpoint(input: CreateDevEndpointInput) async throws -> CreateDevEndpointOutputResponse
    {
        typealias createDevEndpointContinuation = CheckedContinuation<CreateDevEndpointOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createDevEndpointContinuation) in
            createDevEndpoint(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a new job definition.
    func createJob(input: CreateJobInput) async throws -> CreateJobOutputResponse
    {
        typealias createJobContinuation = CheckedContinuation<CreateJobOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createJobContinuation) in
            createJob(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates an Glue machine learning transform. This operation creates the transform and all the necessary parameters to train it. Call this operation as the first step in the process of using a machine learning transform (such as the FindMatches transform) for deduplicating data. You can provide an optional Description, in addition to the parameters that you want to use for your algorithm. You must also specify certain parameters for the tasks that Glue runs on your behalf as part of learning from your data and creating a high-quality machine learning transform. These parameters include Role, and optionally, AllocatedCapacity, Timeout, and MaxRetries. For more information, see [Jobs](https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-jobs-job.html).
    func createMLTransform(input: CreateMLTransformInput) async throws -> CreateMLTransformOutputResponse
    {
        typealias createMLTransformContinuation = CheckedContinuation<CreateMLTransformOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createMLTransformContinuation) in
            createMLTransform(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a new partition.
    func createPartition(input: CreatePartitionInput) async throws -> CreatePartitionOutputResponse
    {
        typealias createPartitionContinuation = CheckedContinuation<CreatePartitionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createPartitionContinuation) in
            createPartition(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a specified partition index in an existing table.
    func createPartitionIndex(input: CreatePartitionIndexInput) async throws -> CreatePartitionIndexOutputResponse
    {
        typealias createPartitionIndexContinuation = CheckedContinuation<CreatePartitionIndexOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createPartitionIndexContinuation) in
            createPartitionIndex(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a new registry which may be used to hold a collection of schemas.
    func createRegistry(input: CreateRegistryInput) async throws -> CreateRegistryOutputResponse
    {
        typealias createRegistryContinuation = CheckedContinuation<CreateRegistryOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createRegistryContinuation) in
            createRegistry(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a new schema set and registers the schema definition. Returns an error if the schema set already exists without actually registering the version. When the schema set is created, a version checkpoint will be set to the first version. Compatibility mode "DISABLED" restricts any additional schema versions from being added after the first schema version. For all other compatibility modes, validation of compatibility settings will be applied only from the second version onwards when the RegisterSchemaVersion API is used. When this API is called without a RegistryId, this will create an entry for a "default-registry" in the registry database tables, if it is not already present.
    func createSchema(input: CreateSchemaInput) async throws -> CreateSchemaOutputResponse
    {
        typealias createSchemaContinuation = CheckedContinuation<CreateSchemaOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createSchemaContinuation) in
            createSchema(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Transforms a directed acyclic graph (DAG) into code.
    func createScript(input: CreateScriptInput) async throws -> CreateScriptOutputResponse
    {
        typealias createScriptContinuation = CheckedContinuation<CreateScriptOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createScriptContinuation) in
            createScript(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a new security configuration. A security configuration is a set of security properties that can be used by Glue. You can use a security configuration to encrypt data at rest. For information about using security configurations in Glue, see [Encrypting Data Written by Crawlers, Jobs, and Development Endpoints](https://docs.aws.amazon.com/glue/latest/dg/encryption-security-configuration.html).
    func createSecurityConfiguration(input: CreateSecurityConfigurationInput) async throws -> CreateSecurityConfigurationOutputResponse
    {
        typealias createSecurityConfigurationContinuation = CheckedContinuation<CreateSecurityConfigurationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createSecurityConfigurationContinuation) in
            createSecurityConfiguration(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a new table definition in the Data Catalog.
    func createTable(input: CreateTableInput) async throws -> CreateTableOutputResponse
    {
        typealias createTableContinuation = CheckedContinuation<CreateTableOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createTableContinuation) in
            createTable(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a new trigger.
    func createTrigger(input: CreateTriggerInput) async throws -> CreateTriggerOutputResponse
    {
        typealias createTriggerContinuation = CheckedContinuation<CreateTriggerOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createTriggerContinuation) in
            createTrigger(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a new function definition in the Data Catalog.
    func createUserDefinedFunction(input: CreateUserDefinedFunctionInput) async throws -> CreateUserDefinedFunctionOutputResponse
    {
        typealias createUserDefinedFunctionContinuation = CheckedContinuation<CreateUserDefinedFunctionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createUserDefinedFunctionContinuation) in
            createUserDefinedFunction(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a new workflow.
    func createWorkflow(input: CreateWorkflowInput) async throws -> CreateWorkflowOutputResponse
    {
        typealias createWorkflowContinuation = CheckedContinuation<CreateWorkflowOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createWorkflowContinuation) in
            createWorkflow(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes an existing blueprint.
    func deleteBlueprint(input: DeleteBlueprintInput) async throws -> DeleteBlueprintOutputResponse
    {
        typealias deleteBlueprintContinuation = CheckedContinuation<DeleteBlueprintOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteBlueprintContinuation) in
            deleteBlueprint(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Removes a classifier from the Data Catalog.
    func deleteClassifier(input: DeleteClassifierInput) async throws -> DeleteClassifierOutputResponse
    {
        typealias deleteClassifierContinuation = CheckedContinuation<DeleteClassifierOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteClassifierContinuation) in
            deleteClassifier(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Delete the partition column statistics of a column. The Identity and Access Management (IAM) permission required for this operation is DeletePartition.
    func deleteColumnStatisticsForPartition(input: DeleteColumnStatisticsForPartitionInput) async throws -> DeleteColumnStatisticsForPartitionOutputResponse
    {
        typealias deleteColumnStatisticsForPartitionContinuation = CheckedContinuation<DeleteColumnStatisticsForPartitionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteColumnStatisticsForPartitionContinuation) in
            deleteColumnStatisticsForPartition(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves table statistics of columns. The Identity and Access Management (IAM) permission required for this operation is DeleteTable.
    func deleteColumnStatisticsForTable(input: DeleteColumnStatisticsForTableInput) async throws -> DeleteColumnStatisticsForTableOutputResponse
    {
        typealias deleteColumnStatisticsForTableContinuation = CheckedContinuation<DeleteColumnStatisticsForTableOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteColumnStatisticsForTableContinuation) in
            deleteColumnStatisticsForTable(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes a connection from the Data Catalog.
    func deleteConnection(input: DeleteConnectionInput) async throws -> DeleteConnectionOutputResponse
    {
        typealias deleteConnectionContinuation = CheckedContinuation<DeleteConnectionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteConnectionContinuation) in
            deleteConnection(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Removes a specified crawler from the Glue Data Catalog, unless the crawler state is RUNNING.
    func deleteCrawler(input: DeleteCrawlerInput) async throws -> DeleteCrawlerOutputResponse
    {
        typealias deleteCrawlerContinuation = CheckedContinuation<DeleteCrawlerOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteCrawlerContinuation) in
            deleteCrawler(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Removes a specified database from a Data Catalog. After completing this operation, you no longer have access to the tables (and all table versions and partitions that might belong to the tables) and the user-defined functions in the deleted database. Glue deletes these "orphaned" resources asynchronously in a timely manner, at the discretion of the service. To ensure the immediate deletion of all related resources, before calling DeleteDatabase, use DeleteTableVersion or BatchDeleteTableVersion, DeletePartition or BatchDeletePartition, DeleteUserDefinedFunction, and DeleteTable or BatchDeleteTable, to delete any resources that belong to the database.
    func deleteDatabase(input: DeleteDatabaseInput) async throws -> DeleteDatabaseOutputResponse
    {
        typealias deleteDatabaseContinuation = CheckedContinuation<DeleteDatabaseOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteDatabaseContinuation) in
            deleteDatabase(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes a specified development endpoint.
    func deleteDevEndpoint(input: DeleteDevEndpointInput) async throws -> DeleteDevEndpointOutputResponse
    {
        typealias deleteDevEndpointContinuation = CheckedContinuation<DeleteDevEndpointOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteDevEndpointContinuation) in
            deleteDevEndpoint(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes a specified job definition. If the job definition is not found, no exception is thrown.
    func deleteJob(input: DeleteJobInput) async throws -> DeleteJobOutputResponse
    {
        typealias deleteJobContinuation = CheckedContinuation<DeleteJobOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteJobContinuation) in
            deleteJob(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes an Glue machine learning transform. Machine learning transforms are a special type of transform that use machine learning to learn the details of the transformation to be performed by learning from examples provided by humans. These transformations are then saved by Glue. If you no longer need a transform, you can delete it by calling DeleteMLTransforms. However, any Glue jobs that still reference the deleted transform will no longer succeed.
    func deleteMLTransform(input: DeleteMLTransformInput) async throws -> DeleteMLTransformOutputResponse
    {
        typealias deleteMLTransformContinuation = CheckedContinuation<DeleteMLTransformOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteMLTransformContinuation) in
            deleteMLTransform(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes a specified partition.
    func deletePartition(input: DeletePartitionInput) async throws -> DeletePartitionOutputResponse
    {
        typealias deletePartitionContinuation = CheckedContinuation<DeletePartitionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deletePartitionContinuation) in
            deletePartition(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes a specified partition index from an existing table.
    func deletePartitionIndex(input: DeletePartitionIndexInput) async throws -> DeletePartitionIndexOutputResponse
    {
        typealias deletePartitionIndexContinuation = CheckedContinuation<DeletePartitionIndexOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deletePartitionIndexContinuation) in
            deletePartitionIndex(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Delete the entire registry including schema and all of its versions. To get the status of the delete operation, you can call the GetRegistry API after the asynchronous call. Deleting a registry will deactivate all online operations for the registry such as the UpdateRegistry, CreateSchema, UpdateSchema, and RegisterSchemaVersion APIs.
    func deleteRegistry(input: DeleteRegistryInput) async throws -> DeleteRegistryOutputResponse
    {
        typealias deleteRegistryContinuation = CheckedContinuation<DeleteRegistryOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteRegistryContinuation) in
            deleteRegistry(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes a specified policy.
    func deleteResourcePolicy(input: DeleteResourcePolicyInput) async throws -> DeleteResourcePolicyOutputResponse
    {
        typealias deleteResourcePolicyContinuation = CheckedContinuation<DeleteResourcePolicyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteResourcePolicyContinuation) in
            deleteResourcePolicy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes the entire schema set, including the schema set and all of its versions. To get the status of the delete operation, you can call GetSchema API after the asynchronous call. Deleting a registry will deactivate all online operations for the schema, such as the GetSchemaByDefinition, and RegisterSchemaVersion APIs.
    func deleteSchema(input: DeleteSchemaInput) async throws -> DeleteSchemaOutputResponse
    {
        typealias deleteSchemaContinuation = CheckedContinuation<DeleteSchemaOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteSchemaContinuation) in
            deleteSchema(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Remove versions from the specified schema. A version number or range may be supplied. If the compatibility mode forbids deleting of a version that is necessary, such as BACKWARDS_FULL, an error is returned. Calling the GetSchemaVersions API after this call will list the status of the deleted versions. When the range of version numbers contain check pointed version, the API will return a 409 conflict and will not proceed with the deletion. You have to remove the checkpoint first using the DeleteSchemaCheckpoint API before using this API. You cannot use the DeleteSchemaVersions API to delete the first schema version in the schema set. The first schema version can only be deleted by the DeleteSchema API. This operation will also delete the attached SchemaVersionMetadata under the schema versions. Hard deletes will be enforced on the database. If the compatibility mode forbids deleting of a version that is necessary, such as BACKWARDS_FULL, an error is returned.
    func deleteSchemaVersions(input: DeleteSchemaVersionsInput) async throws -> DeleteSchemaVersionsOutputResponse
    {
        typealias deleteSchemaVersionsContinuation = CheckedContinuation<DeleteSchemaVersionsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteSchemaVersionsContinuation) in
            deleteSchemaVersions(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes a specified security configuration.
    func deleteSecurityConfiguration(input: DeleteSecurityConfigurationInput) async throws -> DeleteSecurityConfigurationOutputResponse
    {
        typealias deleteSecurityConfigurationContinuation = CheckedContinuation<DeleteSecurityConfigurationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteSecurityConfigurationContinuation) in
            deleteSecurityConfiguration(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Removes a table definition from the Data Catalog. After completing this operation, you no longer have access to the table versions and partitions that belong to the deleted table. Glue deletes these "orphaned" resources asynchronously in a timely manner, at the discretion of the service. To ensure the immediate deletion of all related resources, before calling DeleteTable, use DeleteTableVersion or BatchDeleteTableVersion, and DeletePartition or BatchDeletePartition, to delete any resources that belong to the table.
    func deleteTable(input: DeleteTableInput) async throws -> DeleteTableOutputResponse
    {
        typealias deleteTableContinuation = CheckedContinuation<DeleteTableOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteTableContinuation) in
            deleteTable(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes a specified version of a table.
    func deleteTableVersion(input: DeleteTableVersionInput) async throws -> DeleteTableVersionOutputResponse
    {
        typealias deleteTableVersionContinuation = CheckedContinuation<DeleteTableVersionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteTableVersionContinuation) in
            deleteTableVersion(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes a specified trigger. If the trigger is not found, no exception is thrown.
    func deleteTrigger(input: DeleteTriggerInput) async throws -> DeleteTriggerOutputResponse
    {
        typealias deleteTriggerContinuation = CheckedContinuation<DeleteTriggerOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteTriggerContinuation) in
            deleteTrigger(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes an existing function definition from the Data Catalog.
    func deleteUserDefinedFunction(input: DeleteUserDefinedFunctionInput) async throws -> DeleteUserDefinedFunctionOutputResponse
    {
        typealias deleteUserDefinedFunctionContinuation = CheckedContinuation<DeleteUserDefinedFunctionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteUserDefinedFunctionContinuation) in
            deleteUserDefinedFunction(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes a workflow.
    func deleteWorkflow(input: DeleteWorkflowInput) async throws -> DeleteWorkflowOutputResponse
    {
        typealias deleteWorkflowContinuation = CheckedContinuation<DeleteWorkflowOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteWorkflowContinuation) in
            deleteWorkflow(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves the details of a blueprint.
    func getBlueprint(input: GetBlueprintInput) async throws -> GetBlueprintOutputResponse
    {
        typealias getBlueprintContinuation = CheckedContinuation<GetBlueprintOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getBlueprintContinuation) in
            getBlueprint(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves the details of a blueprint run.
    func getBlueprintRun(input: GetBlueprintRunInput) async throws -> GetBlueprintRunOutputResponse
    {
        typealias getBlueprintRunContinuation = CheckedContinuation<GetBlueprintRunOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getBlueprintRunContinuation) in
            getBlueprintRun(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves the details of blueprint runs for a specified blueprint.
    func getBlueprintRuns(input: GetBlueprintRunsInput) async throws -> GetBlueprintRunsOutputResponse
    {
        typealias getBlueprintRunsContinuation = CheckedContinuation<GetBlueprintRunsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getBlueprintRunsContinuation) in
            getBlueprintRuns(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves the status of a migration operation.
    func getCatalogImportStatus(input: GetCatalogImportStatusInput) async throws -> GetCatalogImportStatusOutputResponse
    {
        typealias getCatalogImportStatusContinuation = CheckedContinuation<GetCatalogImportStatusOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getCatalogImportStatusContinuation) in
            getCatalogImportStatus(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieve a classifier by name.
    func getClassifier(input: GetClassifierInput) async throws -> GetClassifierOutputResponse
    {
        typealias getClassifierContinuation = CheckedContinuation<GetClassifierOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getClassifierContinuation) in
            getClassifier(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Lists all classifier objects in the Data Catalog.
    func getClassifiers(input: GetClassifiersInput) async throws -> GetClassifiersOutputResponse
    {
        typealias getClassifiersContinuation = CheckedContinuation<GetClassifiersOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getClassifiersContinuation) in
            getClassifiers(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves partition statistics of columns. The Identity and Access Management (IAM) permission required for this operation is GetPartition.
    func getColumnStatisticsForPartition(input: GetColumnStatisticsForPartitionInput) async throws -> GetColumnStatisticsForPartitionOutputResponse
    {
        typealias getColumnStatisticsForPartitionContinuation = CheckedContinuation<GetColumnStatisticsForPartitionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getColumnStatisticsForPartitionContinuation) in
            getColumnStatisticsForPartition(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves table statistics of columns. The Identity and Access Management (IAM) permission required for this operation is GetTable.
    func getColumnStatisticsForTable(input: GetColumnStatisticsForTableInput) async throws -> GetColumnStatisticsForTableOutputResponse
    {
        typealias getColumnStatisticsForTableContinuation = CheckedContinuation<GetColumnStatisticsForTableOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getColumnStatisticsForTableContinuation) in
            getColumnStatisticsForTable(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves a connection definition from the Data Catalog.
    func getConnection(input: GetConnectionInput) async throws -> GetConnectionOutputResponse
    {
        typealias getConnectionContinuation = CheckedContinuation<GetConnectionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getConnectionContinuation) in
            getConnection(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves a list of connection definitions from the Data Catalog.
    func getConnections(input: GetConnectionsInput) async throws -> GetConnectionsOutputResponse
    {
        typealias getConnectionsContinuation = CheckedContinuation<GetConnectionsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getConnectionsContinuation) in
            getConnections(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves metadata for a specified crawler.
    func getCrawler(input: GetCrawlerInput) async throws -> GetCrawlerOutputResponse
    {
        typealias getCrawlerContinuation = CheckedContinuation<GetCrawlerOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getCrawlerContinuation) in
            getCrawler(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves metrics about specified crawlers.
    func getCrawlerMetrics(input: GetCrawlerMetricsInput) async throws -> GetCrawlerMetricsOutputResponse
    {
        typealias getCrawlerMetricsContinuation = CheckedContinuation<GetCrawlerMetricsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getCrawlerMetricsContinuation) in
            getCrawlerMetrics(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves metadata for all crawlers defined in the customer account.
    func getCrawlers(input: GetCrawlersInput) async throws -> GetCrawlersOutputResponse
    {
        typealias getCrawlersContinuation = CheckedContinuation<GetCrawlersOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getCrawlersContinuation) in
            getCrawlers(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves the security configuration for a specified catalog.
    func getDataCatalogEncryptionSettings(input: GetDataCatalogEncryptionSettingsInput) async throws -> GetDataCatalogEncryptionSettingsOutputResponse
    {
        typealias getDataCatalogEncryptionSettingsContinuation = CheckedContinuation<GetDataCatalogEncryptionSettingsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getDataCatalogEncryptionSettingsContinuation) in
            getDataCatalogEncryptionSettings(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves the definition of a specified database.
    func getDatabase(input: GetDatabaseInput) async throws -> GetDatabaseOutputResponse
    {
        typealias getDatabaseContinuation = CheckedContinuation<GetDatabaseOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getDatabaseContinuation) in
            getDatabase(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves all databases defined in a given Data Catalog.
    func getDatabases(input: GetDatabasesInput) async throws -> GetDatabasesOutputResponse
    {
        typealias getDatabasesContinuation = CheckedContinuation<GetDatabasesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getDatabasesContinuation) in
            getDatabases(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Transforms a Python script into a directed acyclic graph (DAG).
    func getDataflowGraph(input: GetDataflowGraphInput) async throws -> GetDataflowGraphOutputResponse
    {
        typealias getDataflowGraphContinuation = CheckedContinuation<GetDataflowGraphOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getDataflowGraphContinuation) in
            getDataflowGraph(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves information about a specified development endpoint. When you create a development endpoint in a virtual private cloud (VPC), Glue returns only a private IP address, and the public IP address field is not populated. When you create a non-VPC development endpoint, Glue returns only a public IP address.
    func getDevEndpoint(input: GetDevEndpointInput) async throws -> GetDevEndpointOutputResponse
    {
        typealias getDevEndpointContinuation = CheckedContinuation<GetDevEndpointOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getDevEndpointContinuation) in
            getDevEndpoint(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves all the development endpoints in this AWS account. When you create a development endpoint in a virtual private cloud (VPC), Glue returns only a private IP address and the public IP address field is not populated. When you create a non-VPC development endpoint, Glue returns only a public IP address.
    func getDevEndpoints(input: GetDevEndpointsInput) async throws -> GetDevEndpointsOutputResponse
    {
        typealias getDevEndpointsContinuation = CheckedContinuation<GetDevEndpointsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getDevEndpointsContinuation) in
            getDevEndpoints(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves an existing job definition.
    func getJob(input: GetJobInput) async throws -> GetJobOutputResponse
    {
        typealias getJobContinuation = CheckedContinuation<GetJobOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getJobContinuation) in
            getJob(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns information on a job bookmark entry.
    func getJobBookmark(input: GetJobBookmarkInput) async throws -> GetJobBookmarkOutputResponse
    {
        typealias getJobBookmarkContinuation = CheckedContinuation<GetJobBookmarkOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getJobBookmarkContinuation) in
            getJobBookmark(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves the metadata for a given job run.
    func getJobRun(input: GetJobRunInput) async throws -> GetJobRunOutputResponse
    {
        typealias getJobRunContinuation = CheckedContinuation<GetJobRunOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getJobRunContinuation) in
            getJobRun(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves metadata for all runs of a given job definition.
    func getJobRuns(input: GetJobRunsInput) async throws -> GetJobRunsOutputResponse
    {
        typealias getJobRunsContinuation = CheckedContinuation<GetJobRunsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getJobRunsContinuation) in
            getJobRuns(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves all current job definitions.
    func getJobs(input: GetJobsInput) async throws -> GetJobsOutputResponse
    {
        typealias getJobsContinuation = CheckedContinuation<GetJobsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getJobsContinuation) in
            getJobs(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Gets details for a specific task run on a machine learning transform. Machine learning task runs are asynchronous tasks that Glue runs on your behalf as part of various machine learning workflows. You can check the stats of any task run by calling GetMLTaskRun with the TaskRunID and its parent transform's TransformID.
    func getMLTaskRun(input: GetMLTaskRunInput) async throws -> GetMLTaskRunOutputResponse
    {
        typealias getMLTaskRunContinuation = CheckedContinuation<GetMLTaskRunOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getMLTaskRunContinuation) in
            getMLTaskRun(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Gets a list of runs for a machine learning transform. Machine learning task runs are asynchronous tasks that Glue runs on your behalf as part of various machine learning workflows. You can get a sortable, filterable list of machine learning task runs by calling GetMLTaskRuns with their parent transform's TransformID and other optional parameters as documented in this section. This operation returns a list of historic runs and must be paginated.
    func getMLTaskRuns(input: GetMLTaskRunsInput) async throws -> GetMLTaskRunsOutputResponse
    {
        typealias getMLTaskRunsContinuation = CheckedContinuation<GetMLTaskRunsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getMLTaskRunsContinuation) in
            getMLTaskRuns(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Gets an Glue machine learning transform artifact and all its corresponding metadata. Machine learning transforms are a special type of transform that use machine learning to learn the details of the transformation to be performed by learning from examples provided by humans. These transformations are then saved by Glue. You can retrieve their metadata by calling GetMLTransform.
    func getMLTransform(input: GetMLTransformInput) async throws -> GetMLTransformOutputResponse
    {
        typealias getMLTransformContinuation = CheckedContinuation<GetMLTransformOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getMLTransformContinuation) in
            getMLTransform(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Gets a sortable, filterable list of existing Glue machine learning transforms. Machine learning transforms are a special type of transform that use machine learning to learn the details of the transformation to be performed by learning from examples provided by humans. These transformations are then saved by Glue, and you can retrieve their metadata by calling GetMLTransforms.
    func getMLTransforms(input: GetMLTransformsInput) async throws -> GetMLTransformsOutputResponse
    {
        typealias getMLTransformsContinuation = CheckedContinuation<GetMLTransformsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getMLTransformsContinuation) in
            getMLTransforms(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates mappings.
    func getMapping(input: GetMappingInput) async throws -> GetMappingOutputResponse
    {
        typealias getMappingContinuation = CheckedContinuation<GetMappingOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getMappingContinuation) in
            getMapping(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves information about a specified partition.
    func getPartition(input: GetPartitionInput) async throws -> GetPartitionOutputResponse
    {
        typealias getPartitionContinuation = CheckedContinuation<GetPartitionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getPartitionContinuation) in
            getPartition(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves the partition indexes associated with a table.
    func getPartitionIndexes(input: GetPartitionIndexesInput) async throws -> GetPartitionIndexesOutputResponse
    {
        typealias getPartitionIndexesContinuation = CheckedContinuation<GetPartitionIndexesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getPartitionIndexesContinuation) in
            getPartitionIndexes(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves information about the partitions in a table.
    func getPartitions(input: GetPartitionsInput) async throws -> GetPartitionsOutputResponse
    {
        typealias getPartitionsContinuation = CheckedContinuation<GetPartitionsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getPartitionsContinuation) in
            getPartitions(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Gets code to perform a specified mapping.
    func getPlan(input: GetPlanInput) async throws -> GetPlanOutputResponse
    {
        typealias getPlanContinuation = CheckedContinuation<GetPlanOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getPlanContinuation) in
            getPlan(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Describes the specified registry in detail.
    func getRegistry(input: GetRegistryInput) async throws -> GetRegistryOutputResponse
    {
        typealias getRegistryContinuation = CheckedContinuation<GetRegistryOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getRegistryContinuation) in
            getRegistry(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves the resource policies set on individual resources by Resource Access Manager during cross-account permission grants. Also retrieves the Data Catalog resource policy. If you enabled metadata encryption in Data Catalog settings, and you do not have permission on the KMS key, the operation can't return the Data Catalog resource policy.
    func getResourcePolicies(input: GetResourcePoliciesInput) async throws -> GetResourcePoliciesOutputResponse
    {
        typealias getResourcePoliciesContinuation = CheckedContinuation<GetResourcePoliciesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getResourcePoliciesContinuation) in
            getResourcePolicies(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves a specified resource policy.
    func getResourcePolicy(input: GetResourcePolicyInput) async throws -> GetResourcePolicyOutputResponse
    {
        typealias getResourcePolicyContinuation = CheckedContinuation<GetResourcePolicyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getResourcePolicyContinuation) in
            getResourcePolicy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Describes the specified schema in detail.
    func getSchema(input: GetSchemaInput) async throws -> GetSchemaOutputResponse
    {
        typealias getSchemaContinuation = CheckedContinuation<GetSchemaOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getSchemaContinuation) in
            getSchema(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves a schema by the SchemaDefinition. The schema definition is sent to the Schema Registry, canonicalized, and hashed. If the hash is matched within the scope of the SchemaName or ARN (or the default registry, if none is supplied), that schema’s metadata is returned. Otherwise, a 404 or NotFound error is returned. Schema versions in Deleted statuses will not be included in the results.
    func getSchemaByDefinition(input: GetSchemaByDefinitionInput) async throws -> GetSchemaByDefinitionOutputResponse
    {
        typealias getSchemaByDefinitionContinuation = CheckedContinuation<GetSchemaByDefinitionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getSchemaByDefinitionContinuation) in
            getSchemaByDefinition(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Get the specified schema by its unique ID assigned when a version of the schema is created or registered. Schema versions in Deleted status will not be included in the results.
    func getSchemaVersion(input: GetSchemaVersionInput) async throws -> GetSchemaVersionOutputResponse
    {
        typealias getSchemaVersionContinuation = CheckedContinuation<GetSchemaVersionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getSchemaVersionContinuation) in
            getSchemaVersion(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Fetches the schema version difference in the specified difference type between two stored schema versions in the Schema Registry. This API allows you to compare two schema versions between two schema definitions under the same schema.
    func getSchemaVersionsDiff(input: GetSchemaVersionsDiffInput) async throws -> GetSchemaVersionsDiffOutputResponse
    {
        typealias getSchemaVersionsDiffContinuation = CheckedContinuation<GetSchemaVersionsDiffOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getSchemaVersionsDiffContinuation) in
            getSchemaVersionsDiff(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves a specified security configuration.
    func getSecurityConfiguration(input: GetSecurityConfigurationInput) async throws -> GetSecurityConfigurationOutputResponse
    {
        typealias getSecurityConfigurationContinuation = CheckedContinuation<GetSecurityConfigurationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getSecurityConfigurationContinuation) in
            getSecurityConfiguration(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves a list of all security configurations.
    func getSecurityConfigurations(input: GetSecurityConfigurationsInput) async throws -> GetSecurityConfigurationsOutputResponse
    {
        typealias getSecurityConfigurationsContinuation = CheckedContinuation<GetSecurityConfigurationsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getSecurityConfigurationsContinuation) in
            getSecurityConfigurations(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves the Table definition in a Data Catalog for a specified table.
    func getTable(input: GetTableInput) async throws -> GetTableOutputResponse
    {
        typealias getTableContinuation = CheckedContinuation<GetTableOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getTableContinuation) in
            getTable(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves a specified version of a table.
    func getTableVersion(input: GetTableVersionInput) async throws -> GetTableVersionOutputResponse
    {
        typealias getTableVersionContinuation = CheckedContinuation<GetTableVersionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getTableVersionContinuation) in
            getTableVersion(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves a list of strings that identify available versions of a specified table.
    func getTableVersions(input: GetTableVersionsInput) async throws -> GetTableVersionsOutputResponse
    {
        typealias getTableVersionsContinuation = CheckedContinuation<GetTableVersionsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getTableVersionsContinuation) in
            getTableVersions(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves the definitions of some or all of the tables in a given Database.
    func getTables(input: GetTablesInput) async throws -> GetTablesOutputResponse
    {
        typealias getTablesContinuation = CheckedContinuation<GetTablesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getTablesContinuation) in
            getTables(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves a list of tags associated with a resource.
    func getTags(input: GetTagsInput) async throws -> GetTagsOutputResponse
    {
        typealias getTagsContinuation = CheckedContinuation<GetTagsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getTagsContinuation) in
            getTags(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves the definition of a trigger.
    func getTrigger(input: GetTriggerInput) async throws -> GetTriggerOutputResponse
    {
        typealias getTriggerContinuation = CheckedContinuation<GetTriggerOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getTriggerContinuation) in
            getTrigger(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Gets all the triggers associated with a job.
    func getTriggers(input: GetTriggersInput) async throws -> GetTriggersOutputResponse
    {
        typealias getTriggersContinuation = CheckedContinuation<GetTriggersOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getTriggersContinuation) in
            getTriggers(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves a specified function definition from the Data Catalog.
    func getUserDefinedFunction(input: GetUserDefinedFunctionInput) async throws -> GetUserDefinedFunctionOutputResponse
    {
        typealias getUserDefinedFunctionContinuation = CheckedContinuation<GetUserDefinedFunctionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getUserDefinedFunctionContinuation) in
            getUserDefinedFunction(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves multiple function definitions from the Data Catalog.
    func getUserDefinedFunctions(input: GetUserDefinedFunctionsInput) async throws -> GetUserDefinedFunctionsOutputResponse
    {
        typealias getUserDefinedFunctionsContinuation = CheckedContinuation<GetUserDefinedFunctionsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getUserDefinedFunctionsContinuation) in
            getUserDefinedFunctions(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves resource metadata for a workflow.
    func getWorkflow(input: GetWorkflowInput) async throws -> GetWorkflowOutputResponse
    {
        typealias getWorkflowContinuation = CheckedContinuation<GetWorkflowOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getWorkflowContinuation) in
            getWorkflow(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves the metadata for a given workflow run.
    func getWorkflowRun(input: GetWorkflowRunInput) async throws -> GetWorkflowRunOutputResponse
    {
        typealias getWorkflowRunContinuation = CheckedContinuation<GetWorkflowRunOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getWorkflowRunContinuation) in
            getWorkflowRun(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves the workflow run properties which were set during the run.
    func getWorkflowRunProperties(input: GetWorkflowRunPropertiesInput) async throws -> GetWorkflowRunPropertiesOutputResponse
    {
        typealias getWorkflowRunPropertiesContinuation = CheckedContinuation<GetWorkflowRunPropertiesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getWorkflowRunPropertiesContinuation) in
            getWorkflowRunProperties(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves metadata for all runs of a given workflow.
    func getWorkflowRuns(input: GetWorkflowRunsInput) async throws -> GetWorkflowRunsOutputResponse
    {
        typealias getWorkflowRunsContinuation = CheckedContinuation<GetWorkflowRunsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getWorkflowRunsContinuation) in
            getWorkflowRuns(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Imports an existing Amazon Athena Data Catalog to Glue.
    func importCatalogToGlue(input: ImportCatalogToGlueInput) async throws -> ImportCatalogToGlueOutputResponse
    {
        typealias importCatalogToGlueContinuation = CheckedContinuation<ImportCatalogToGlueOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: importCatalogToGlueContinuation) in
            importCatalogToGlue(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Lists all the blueprint names in an account.
    func listBlueprints(input: ListBlueprintsInput) async throws -> ListBlueprintsOutputResponse
    {
        typealias listBlueprintsContinuation = CheckedContinuation<ListBlueprintsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listBlueprintsContinuation) in
            listBlueprints(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves the names of all crawler resources in this Amazon Web Services account, or the resources with the specified tag. This operation allows you to see which resources are available in your account, and their names. This operation takes the optional Tags field, which you can use as a filter on the response so that tagged resources can be retrieved as a group. If you choose to use tags filtering, only resources with the tag are retrieved.
    func listCrawlers(input: ListCrawlersInput) async throws -> ListCrawlersOutputResponse
    {
        typealias listCrawlersContinuation = CheckedContinuation<ListCrawlersOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listCrawlersContinuation) in
            listCrawlers(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves the names of all DevEndpoint resources in this Amazon Web Services account, or the resources with the specified tag. This operation allows you to see which resources are available in your account, and their names. This operation takes the optional Tags field, which you can use as a filter on the response so that tagged resources can be retrieved as a group. If you choose to use tags filtering, only resources with the tag are retrieved.
    func listDevEndpoints(input: ListDevEndpointsInput) async throws -> ListDevEndpointsOutputResponse
    {
        typealias listDevEndpointsContinuation = CheckedContinuation<ListDevEndpointsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listDevEndpointsContinuation) in
            listDevEndpoints(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves the names of all job resources in this Amazon Web Services account, or the resources with the specified tag. This operation allows you to see which resources are available in your account, and their names. This operation takes the optional Tags field, which you can use as a filter on the response so that tagged resources can be retrieved as a group. If you choose to use tags filtering, only resources with the tag are retrieved.
    func listJobs(input: ListJobsInput) async throws -> ListJobsOutputResponse
    {
        typealias listJobsContinuation = CheckedContinuation<ListJobsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listJobsContinuation) in
            listJobs(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves a sortable, filterable list of existing Glue machine learning transforms in this Amazon Web Services account, or the resources with the specified tag. This operation takes the optional Tags field, which you can use as a filter of the responses so that tagged resources can be retrieved as a group. If you choose to use tag filtering, only resources with the tags are retrieved.
    func listMLTransforms(input: ListMLTransformsInput) async throws -> ListMLTransformsOutputResponse
    {
        typealias listMLTransformsContinuation = CheckedContinuation<ListMLTransformsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listMLTransformsContinuation) in
            listMLTransforms(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns a list of registries that you have created, with minimal registry information. Registries in the Deleting status will not be included in the results. Empty results will be returned if there are no registries available.
    func listRegistries(input: ListRegistriesInput) async throws -> ListRegistriesOutputResponse
    {
        typealias listRegistriesContinuation = CheckedContinuation<ListRegistriesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listRegistriesContinuation) in
            listRegistries(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns a list of schema versions that you have created, with minimal information. Schema versions in Deleted status will not be included in the results. Empty results will be returned if there are no schema versions available.
    func listSchemaVersions(input: ListSchemaVersionsInput) async throws -> ListSchemaVersionsOutputResponse
    {
        typealias listSchemaVersionsContinuation = CheckedContinuation<ListSchemaVersionsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listSchemaVersionsContinuation) in
            listSchemaVersions(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns a list of schemas with minimal details. Schemas in Deleting status will not be included in the results. Empty results will be returned if there are no schemas available. When the RegistryId is not provided, all the schemas across registries will be part of the API response.
    func listSchemas(input: ListSchemasInput) async throws -> ListSchemasOutputResponse
    {
        typealias listSchemasContinuation = CheckedContinuation<ListSchemasOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listSchemasContinuation) in
            listSchemas(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves the names of all trigger resources in this Amazon Web Services account, or the resources with the specified tag. This operation allows you to see which resources are available in your account, and their names. This operation takes the optional Tags field, which you can use as a filter on the response so that tagged resources can be retrieved as a group. If you choose to use tags filtering, only resources with the tag are retrieved.
    func listTriggers(input: ListTriggersInput) async throws -> ListTriggersOutputResponse
    {
        typealias listTriggersContinuation = CheckedContinuation<ListTriggersOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listTriggersContinuation) in
            listTriggers(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Lists names of workflows created in the account.
    func listWorkflows(input: ListWorkflowsInput) async throws -> ListWorkflowsOutputResponse
    {
        typealias listWorkflowsContinuation = CheckedContinuation<ListWorkflowsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listWorkflowsContinuation) in
            listWorkflows(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Sets the security configuration for a specified catalog. After the configuration has been set, the specified encryption is applied to every catalog write thereafter.
    func putDataCatalogEncryptionSettings(input: PutDataCatalogEncryptionSettingsInput) async throws -> PutDataCatalogEncryptionSettingsOutputResponse
    {
        typealias putDataCatalogEncryptionSettingsContinuation = CheckedContinuation<PutDataCatalogEncryptionSettingsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putDataCatalogEncryptionSettingsContinuation) in
            putDataCatalogEncryptionSettings(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Sets the Data Catalog resource policy for access control.
    func putResourcePolicy(input: PutResourcePolicyInput) async throws -> PutResourcePolicyOutputResponse
    {
        typealias putResourcePolicyContinuation = CheckedContinuation<PutResourcePolicyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putResourcePolicyContinuation) in
            putResourcePolicy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Puts the metadata key value pair for a specified schema version ID. A maximum of 10 key value pairs will be allowed per schema version. They can be added over one or more calls.
    func putSchemaVersionMetadata(input: PutSchemaVersionMetadataInput) async throws -> PutSchemaVersionMetadataOutputResponse
    {
        typealias putSchemaVersionMetadataContinuation = CheckedContinuation<PutSchemaVersionMetadataOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putSchemaVersionMetadataContinuation) in
            putSchemaVersionMetadata(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Puts the specified workflow run properties for the given workflow run. If a property already exists for the specified run, then it overrides the value otherwise adds the property to existing properties.
    func putWorkflowRunProperties(input: PutWorkflowRunPropertiesInput) async throws -> PutWorkflowRunPropertiesOutputResponse
    {
        typealias putWorkflowRunPropertiesContinuation = CheckedContinuation<PutWorkflowRunPropertiesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putWorkflowRunPropertiesContinuation) in
            putWorkflowRunProperties(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Queries for the schema version metadata information.
    func querySchemaVersionMetadata(input: QuerySchemaVersionMetadataInput) async throws -> QuerySchemaVersionMetadataOutputResponse
    {
        typealias querySchemaVersionMetadataContinuation = CheckedContinuation<QuerySchemaVersionMetadataOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: querySchemaVersionMetadataContinuation) in
            querySchemaVersionMetadata(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Adds a new version to the existing schema. Returns an error if new version of schema does not meet the compatibility requirements of the schema set. This API will not create a new schema set and will return a 404 error if the schema set is not already present in the Schema Registry. If this is the first schema definition to be registered in the Schema Registry, this API will store the schema version and return immediately. Otherwise, this call has the potential to run longer than other operations due to compatibility modes. You can call the GetSchemaVersion API with the SchemaVersionId to check compatibility modes. If the same schema definition is already stored in Schema Registry as a version, the schema ID of the existing schema is returned to the caller.
    func registerSchemaVersion(input: RegisterSchemaVersionInput) async throws -> RegisterSchemaVersionOutputResponse
    {
        typealias registerSchemaVersionContinuation = CheckedContinuation<RegisterSchemaVersionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: registerSchemaVersionContinuation) in
            registerSchemaVersion(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Removes a key value pair from the schema version metadata for the specified schema version ID.
    func removeSchemaVersionMetadata(input: RemoveSchemaVersionMetadataInput) async throws -> RemoveSchemaVersionMetadataOutputResponse
    {
        typealias removeSchemaVersionMetadataContinuation = CheckedContinuation<RemoveSchemaVersionMetadataOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: removeSchemaVersionMetadataContinuation) in
            removeSchemaVersionMetadata(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Resets a bookmark entry.
    func resetJobBookmark(input: ResetJobBookmarkInput) async throws -> ResetJobBookmarkOutputResponse
    {
        typealias resetJobBookmarkContinuation = CheckedContinuation<ResetJobBookmarkOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: resetJobBookmarkContinuation) in
            resetJobBookmark(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Restarts selected nodes of a previous partially completed workflow run and resumes the workflow run. The selected nodes and all nodes that are downstream from the selected nodes are run.
    func resumeWorkflowRun(input: ResumeWorkflowRunInput) async throws -> ResumeWorkflowRunOutputResponse
    {
        typealias resumeWorkflowRunContinuation = CheckedContinuation<ResumeWorkflowRunOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: resumeWorkflowRunContinuation) in
            resumeWorkflowRun(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Searches a set of tables based on properties in the table metadata as well as on the parent database. You can search against text or filter conditions. You can only get tables that you have access to based on the security policies defined in Lake Formation. You need at least a read-only access to the table for it to be returned. If you do not have access to all the columns in the table, these columns will not be searched against when returning the list of tables back to you. If you have access to the columns but not the data in the columns, those columns and the associated metadata for those columns will be included in the search.
    func searchTables(input: SearchTablesInput) async throws -> SearchTablesOutputResponse
    {
        typealias searchTablesContinuation = CheckedContinuation<SearchTablesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: searchTablesContinuation) in
            searchTables(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Starts a new run of the specified blueprint.
    func startBlueprintRun(input: StartBlueprintRunInput) async throws -> StartBlueprintRunOutputResponse
    {
        typealias startBlueprintRunContinuation = CheckedContinuation<StartBlueprintRunOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: startBlueprintRunContinuation) in
            startBlueprintRun(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Starts a crawl using the specified crawler, regardless of what is scheduled. If the crawler is already running, returns a [CrawlerRunningException](https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-exceptions.html#aws-glue-api-exceptions-CrawlerRunningException).
    func startCrawler(input: StartCrawlerInput) async throws -> StartCrawlerOutputResponse
    {
        typealias startCrawlerContinuation = CheckedContinuation<StartCrawlerOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: startCrawlerContinuation) in
            startCrawler(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Changes the schedule state of the specified crawler to SCHEDULED, unless the crawler is already running or the schedule state is already SCHEDULED.
    func startCrawlerSchedule(input: StartCrawlerScheduleInput) async throws -> StartCrawlerScheduleOutputResponse
    {
        typealias startCrawlerScheduleContinuation = CheckedContinuation<StartCrawlerScheduleOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: startCrawlerScheduleContinuation) in
            startCrawlerSchedule(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Begins an asynchronous task to export all labeled data for a particular transform. This task is the only label-related API call that is not part of the typical active learning workflow. You typically use StartExportLabelsTaskRun when you want to work with all of your existing labels at the same time, such as when you want to remove or change labels that were previously submitted as truth. This API operation accepts the TransformId whose labels you want to export and an Amazon Simple Storage Service (Amazon S3) path to export the labels to. The operation returns a TaskRunId. You can check on the status of your task run by calling the GetMLTaskRun API.
    func startExportLabelsTaskRun(input: StartExportLabelsTaskRunInput) async throws -> StartExportLabelsTaskRunOutputResponse
    {
        typealias startExportLabelsTaskRunContinuation = CheckedContinuation<StartExportLabelsTaskRunOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: startExportLabelsTaskRunContinuation) in
            startExportLabelsTaskRun(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Enables you to provide additional labels (examples of truth) to be used to teach the machine learning transform and improve its quality. This API operation is generally used as part of the active learning workflow that starts with the StartMLLabelingSetGenerationTaskRun call and that ultimately results in improving the quality of your machine learning transform. After the StartMLLabelingSetGenerationTaskRun finishes, Glue machine learning will have generated a series of questions for humans to answer. (Answering these questions is often called 'labeling' in the machine learning workflows). In the case of the FindMatches transform, these questions are of the form, “What is the correct way to group these rows together into groups composed entirely of matching records?” After the labeling process is finished, users upload their answers/labels with a call to StartImportLabelsTaskRun. After StartImportLabelsTaskRun finishes, all future runs of the machine learning transform use the new and improved labels and perform a higher-quality transformation. By default, StartMLLabelingSetGenerationTaskRun continually learns from and combines all labels that you upload unless you set Replace to true. If you set Replace to true, StartImportLabelsTaskRun deletes and forgets all previously uploaded labels and learns only from the exact set that you upload. Replacing labels can be helpful if you realize that you previously uploaded incorrect labels, and you believe that they are having a negative effect on your transform quality. You can check on the status of your task run by calling the GetMLTaskRun operation.
    func startImportLabelsTaskRun(input: StartImportLabelsTaskRunInput) async throws -> StartImportLabelsTaskRunOutputResponse
    {
        typealias startImportLabelsTaskRunContinuation = CheckedContinuation<StartImportLabelsTaskRunOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: startImportLabelsTaskRunContinuation) in
            startImportLabelsTaskRun(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Starts a job run using a job definition.
    func startJobRun(input: StartJobRunInput) async throws -> StartJobRunOutputResponse
    {
        typealias startJobRunContinuation = CheckedContinuation<StartJobRunOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: startJobRunContinuation) in
            startJobRun(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Starts a task to estimate the quality of the transform. When you provide label sets as examples of truth, Glue machine learning uses some of those examples to learn from them. The rest of the labels are used as a test to estimate quality. Returns a unique identifier for the run. You can call GetMLTaskRun to get more information about the stats of the EvaluationTaskRun.
    func startMLEvaluationTaskRun(input: StartMLEvaluationTaskRunInput) async throws -> StartMLEvaluationTaskRunOutputResponse
    {
        typealias startMLEvaluationTaskRunContinuation = CheckedContinuation<StartMLEvaluationTaskRunOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: startMLEvaluationTaskRunContinuation) in
            startMLEvaluationTaskRun(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Starts the active learning workflow for your machine learning transform to improve the transform's quality by generating label sets and adding labels. When the StartMLLabelingSetGenerationTaskRun finishes, Glue will have generated a "labeling set" or a set of questions for humans to answer. In the case of the FindMatches transform, these questions are of the form, “What is the correct way to group these rows together into groups composed entirely of matching records?” After the labeling process is finished, you can upload your labels with a call to StartImportLabelsTaskRun. After StartImportLabelsTaskRun finishes, all future runs of the machine learning transform will use the new and improved labels and perform a higher-quality transformation.
    func startMLLabelingSetGenerationTaskRun(input: StartMLLabelingSetGenerationTaskRunInput) async throws -> StartMLLabelingSetGenerationTaskRunOutputResponse
    {
        typealias startMLLabelingSetGenerationTaskRunContinuation = CheckedContinuation<StartMLLabelingSetGenerationTaskRunOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: startMLLabelingSetGenerationTaskRunContinuation) in
            startMLLabelingSetGenerationTaskRun(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Starts an existing trigger. See [Triggering Jobs](https://docs.aws.amazon.com/glue/latest/dg/trigger-job.html) for information about how different types of trigger are started.
    func startTrigger(input: StartTriggerInput) async throws -> StartTriggerOutputResponse
    {
        typealias startTriggerContinuation = CheckedContinuation<StartTriggerOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: startTriggerContinuation) in
            startTrigger(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Starts a new run of the specified workflow.
    func startWorkflowRun(input: StartWorkflowRunInput) async throws -> StartWorkflowRunOutputResponse
    {
        typealias startWorkflowRunContinuation = CheckedContinuation<StartWorkflowRunOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: startWorkflowRunContinuation) in
            startWorkflowRun(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// If the specified crawler is running, stops the crawl.
    func stopCrawler(input: StopCrawlerInput) async throws -> StopCrawlerOutputResponse
    {
        typealias stopCrawlerContinuation = CheckedContinuation<StopCrawlerOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: stopCrawlerContinuation) in
            stopCrawler(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Sets the schedule state of the specified crawler to NOT_SCHEDULED, but does not stop the crawler if it is already running.
    func stopCrawlerSchedule(input: StopCrawlerScheduleInput) async throws -> StopCrawlerScheduleOutputResponse
    {
        typealias stopCrawlerScheduleContinuation = CheckedContinuation<StopCrawlerScheduleOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: stopCrawlerScheduleContinuation) in
            stopCrawlerSchedule(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Stops a specified trigger.
    func stopTrigger(input: StopTriggerInput) async throws -> StopTriggerOutputResponse
    {
        typealias stopTriggerContinuation = CheckedContinuation<StopTriggerOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: stopTriggerContinuation) in
            stopTrigger(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Stops the execution of the specified workflow run.
    func stopWorkflowRun(input: StopWorkflowRunInput) async throws -> StopWorkflowRunOutputResponse
    {
        typealias stopWorkflowRunContinuation = CheckedContinuation<StopWorkflowRunOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: stopWorkflowRunContinuation) in
            stopWorkflowRun(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Adds tags to a resource. A tag is a label you can assign to an Amazon Web Services resource. In Glue, you can tag only certain resources. For information about what resources you can tag, see [Amazon Web Services Tags in Glue](https://docs.aws.amazon.com/glue/latest/dg/monitor-tags.html).
    func tagResource(input: TagResourceInput) async throws -> TagResourceOutputResponse
    {
        typealias tagResourceContinuation = CheckedContinuation<TagResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: tagResourceContinuation) in
            tagResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Removes tags from a resource.
    func untagResource(input: UntagResourceInput) async throws -> UntagResourceOutputResponse
    {
        typealias untagResourceContinuation = CheckedContinuation<UntagResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: untagResourceContinuation) in
            untagResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates a registered blueprint.
    func updateBlueprint(input: UpdateBlueprintInput) async throws -> UpdateBlueprintOutputResponse
    {
        typealias updateBlueprintContinuation = CheckedContinuation<UpdateBlueprintOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateBlueprintContinuation) in
            updateBlueprint(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Modifies an existing classifier (a GrokClassifier, an XMLClassifier, a JsonClassifier, or a CsvClassifier, depending on which field is present).
    func updateClassifier(input: UpdateClassifierInput) async throws -> UpdateClassifierOutputResponse
    {
        typealias updateClassifierContinuation = CheckedContinuation<UpdateClassifierOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateClassifierContinuation) in
            updateClassifier(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates or updates partition statistics of columns. The Identity and Access Management (IAM) permission required for this operation is UpdatePartition.
    func updateColumnStatisticsForPartition(input: UpdateColumnStatisticsForPartitionInput) async throws -> UpdateColumnStatisticsForPartitionOutputResponse
    {
        typealias updateColumnStatisticsForPartitionContinuation = CheckedContinuation<UpdateColumnStatisticsForPartitionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateColumnStatisticsForPartitionContinuation) in
            updateColumnStatisticsForPartition(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates or updates table statistics of columns. The Identity and Access Management (IAM) permission required for this operation is UpdateTable.
    func updateColumnStatisticsForTable(input: UpdateColumnStatisticsForTableInput) async throws -> UpdateColumnStatisticsForTableOutputResponse
    {
        typealias updateColumnStatisticsForTableContinuation = CheckedContinuation<UpdateColumnStatisticsForTableOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateColumnStatisticsForTableContinuation) in
            updateColumnStatisticsForTable(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates a connection definition in the Data Catalog.
    func updateConnection(input: UpdateConnectionInput) async throws -> UpdateConnectionOutputResponse
    {
        typealias updateConnectionContinuation = CheckedContinuation<UpdateConnectionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateConnectionContinuation) in
            updateConnection(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates a crawler. If a crawler is running, you must stop it using StopCrawler before updating it.
    func updateCrawler(input: UpdateCrawlerInput) async throws -> UpdateCrawlerOutputResponse
    {
        typealias updateCrawlerContinuation = CheckedContinuation<UpdateCrawlerOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateCrawlerContinuation) in
            updateCrawler(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates the schedule of a crawler using a cron expression.
    func updateCrawlerSchedule(input: UpdateCrawlerScheduleInput) async throws -> UpdateCrawlerScheduleOutputResponse
    {
        typealias updateCrawlerScheduleContinuation = CheckedContinuation<UpdateCrawlerScheduleOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateCrawlerScheduleContinuation) in
            updateCrawlerSchedule(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates an existing database definition in a Data Catalog.
    func updateDatabase(input: UpdateDatabaseInput) async throws -> UpdateDatabaseOutputResponse
    {
        typealias updateDatabaseContinuation = CheckedContinuation<UpdateDatabaseOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateDatabaseContinuation) in
            updateDatabase(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates a specified development endpoint.
    func updateDevEndpoint(input: UpdateDevEndpointInput) async throws -> UpdateDevEndpointOutputResponse
    {
        typealias updateDevEndpointContinuation = CheckedContinuation<UpdateDevEndpointOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateDevEndpointContinuation) in
            updateDevEndpoint(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates an existing job definition.
    func updateJob(input: UpdateJobInput) async throws -> UpdateJobOutputResponse
    {
        typealias updateJobContinuation = CheckedContinuation<UpdateJobOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateJobContinuation) in
            updateJob(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates an existing machine learning transform. Call this operation to tune the algorithm parameters to achieve better results. After calling this operation, you can call the StartMLEvaluationTaskRun operation to assess how well your new parameters achieved your goals (such as improving the quality of your machine learning transform, or making it more cost-effective).
    func updateMLTransform(input: UpdateMLTransformInput) async throws -> UpdateMLTransformOutputResponse
    {
        typealias updateMLTransformContinuation = CheckedContinuation<UpdateMLTransformOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateMLTransformContinuation) in
            updateMLTransform(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates a partition.
    func updatePartition(input: UpdatePartitionInput) async throws -> UpdatePartitionOutputResponse
    {
        typealias updatePartitionContinuation = CheckedContinuation<UpdatePartitionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updatePartitionContinuation) in
            updatePartition(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates an existing registry which is used to hold a collection of schemas. The updated properties relate to the registry, and do not modify any of the schemas within the registry.
    func updateRegistry(input: UpdateRegistryInput) async throws -> UpdateRegistryOutputResponse
    {
        typealias updateRegistryContinuation = CheckedContinuation<UpdateRegistryOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateRegistryContinuation) in
            updateRegistry(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates the description, compatibility setting, or version checkpoint for a schema set. For updating the compatibility setting, the call will not validate compatibility for the entire set of schema versions with the new compatibility setting. If the value for Compatibility is provided, the VersionNumber (a checkpoint) is also required. The API will validate the checkpoint version number for consistency. If the value for the VersionNumber (checkpoint) is provided, Compatibility is optional and this can be used to set/reset a checkpoint for the schema. This update will happen only if the schema is in the AVAILABLE state.
    func updateSchema(input: UpdateSchemaInput) async throws -> UpdateSchemaOutputResponse
    {
        typealias updateSchemaContinuation = CheckedContinuation<UpdateSchemaOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateSchemaContinuation) in
            updateSchema(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates a metadata table in the Data Catalog.
    func updateTable(input: UpdateTableInput) async throws -> UpdateTableOutputResponse
    {
        typealias updateTableContinuation = CheckedContinuation<UpdateTableOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateTableContinuation) in
            updateTable(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates a trigger definition.
    func updateTrigger(input: UpdateTriggerInput) async throws -> UpdateTriggerOutputResponse
    {
        typealias updateTriggerContinuation = CheckedContinuation<UpdateTriggerOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateTriggerContinuation) in
            updateTrigger(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates an existing function definition in the Data Catalog.
    func updateUserDefinedFunction(input: UpdateUserDefinedFunctionInput) async throws -> UpdateUserDefinedFunctionOutputResponse
    {
        typealias updateUserDefinedFunctionContinuation = CheckedContinuation<UpdateUserDefinedFunctionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateUserDefinedFunctionContinuation) in
            updateUserDefinedFunction(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates an existing workflow.
    func updateWorkflow(input: UpdateWorkflowInput) async throws -> UpdateWorkflowOutputResponse
    {
        typealias updateWorkflowContinuation = CheckedContinuation<UpdateWorkflowOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateWorkflowContinuation) in
            updateWorkflow(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

}
#endif
