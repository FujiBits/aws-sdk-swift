// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ChimeSdkMessagingClientTypes.AppInstanceUserMembershipSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case readMarkerTimestamp = "ReadMarkerTimestamp"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let readMarkerTimestamp = readMarkerTimestamp {
            try encodeContainer.encode(readMarkerTimestamp.timeIntervalSince1970, forKey: .readMarkerTimestamp)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelMembershipType.self, forKey: .type)
        type = typeDecoded
        let readMarkerTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .readMarkerTimestamp)
        readMarkerTimestamp = readMarkerTimestampDecoded
    }
}

extension ChimeSdkMessagingClientTypes.AppInstanceUserMembershipSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AppInstanceUserMembershipSummary(readMarkerTimestamp: \(Swift.String(describing: readMarkerTimestamp)), type: \(Swift.String(describing: type)))"}
}

extension ChimeSdkMessagingClientTypes {
    /// Summary of the membership details of an AppInstanceUser.
    public struct AppInstanceUserMembershipSummary: Swift.Equatable {
        /// The time at which a message was last read.
        public var readMarkerTimestamp: ClientRuntime.Date?
        /// The type of ChannelMembership.
        public var type: ChimeSdkMessagingClientTypes.ChannelMembershipType?

        public init (
            readMarkerTimestamp: ClientRuntime.Date? = nil,
            type: ChimeSdkMessagingClientTypes.ChannelMembershipType? = nil
        )
        {
            self.readMarkerTimestamp = readMarkerTimestamp
            self.type = type
        }
    }

}

extension BadRequestException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BadRequestException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension BadRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input parameters don't match the service's restrictions.
public struct BadRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeSdkMessagingClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeSdkMessagingClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    public let code: ChimeSdkMessagingClientTypes.ErrorCode?
    public let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ChimeSdkMessagingClientTypes.BatchChannelMemberships: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case invitedBy = "InvitedBy"
        case members = "Members"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let invitedBy = invitedBy {
            try encodeContainer.encode(invitedBy, forKey: .invitedBy)
        }
        if let members = members {
            var membersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .members)
            for members0 in members {
                try membersContainer.encode(members0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invitedByDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.Identity.self, forKey: .invitedBy)
        invitedBy = invitedByDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelMembershipType.self, forKey: .type)
        type = typeDecoded
        let membersContainer = try containerValues.decodeIfPresent([ChimeSdkMessagingClientTypes.Identity?].self, forKey: .members)
        var membersDecoded0:[ChimeSdkMessagingClientTypes.Identity]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [ChimeSdkMessagingClientTypes.Identity]()
            for structure0 in membersContainer {
                if let structure0 = structure0 {
                    membersDecoded0?.append(structure0)
                }
            }
        }
        members = membersDecoded0
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
    }
}

extension ChimeSdkMessagingClientTypes.BatchChannelMemberships: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchChannelMemberships(channelArn: \(Swift.String(describing: channelArn)), invitedBy: \(Swift.String(describing: invitedBy)), members: \(Swift.String(describing: members)), type: \(Swift.String(describing: type)))"}
}

extension ChimeSdkMessagingClientTypes {
    /// The membership information, including member ARNs, the channel ARN, and membership types.
    public struct BatchChannelMemberships: Swift.Equatable {
        /// The ARN of the channel to which you're adding users.
        public var channelArn: Swift.String?
        /// The identifier of the member who invited another member.
        public var invitedBy: ChimeSdkMessagingClientTypes.Identity?
        /// The users successfully added to the request.
        public var members: [ChimeSdkMessagingClientTypes.Identity]?
        /// The membership types set for the channel users.
        public var type: ChimeSdkMessagingClientTypes.ChannelMembershipType?

        public init (
            channelArn: Swift.String? = nil,
            invitedBy: ChimeSdkMessagingClientTypes.Identity? = nil,
            members: [ChimeSdkMessagingClientTypes.Identity]? = nil,
            type: ChimeSdkMessagingClientTypes.ChannelMembershipType? = nil
        )
        {
            self.channelArn = channelArn
            self.invitedBy = invitedBy
            self.members = members
            self.type = type
        }
    }

}

extension ChimeSdkMessagingClientTypes.BatchCreateChannelMembershipError: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case memberArn = "MemberArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let memberArn = memberArn {
            try encodeContainer.encode(memberArn, forKey: .memberArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberArn)
        memberArn = memberArnDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension ChimeSdkMessagingClientTypes.BatchCreateChannelMembershipError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchCreateChannelMembershipError(errorCode: \(Swift.String(describing: errorCode)), errorMessage: \(Swift.String(describing: errorMessage)), memberArn: \(Swift.String(describing: memberArn)))"}
}

extension ChimeSdkMessagingClientTypes {
    /// A list of failed member ARNs, error codes, and error messages.
    public struct BatchCreateChannelMembershipError: Swift.Equatable {
        /// The error code.
        public var errorCode: ChimeSdkMessagingClientTypes.ErrorCode?
        /// The error message.
        public var errorMessage: Swift.String?
        /// The ARN of the member that the service couldn't add.
        public var memberArn: Swift.String?

        public init (
            errorCode: ChimeSdkMessagingClientTypes.ErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            memberArn: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.memberArn = memberArn
        }
    }

}

public struct BatchCreateChannelMembershipInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchCreateChannelMembershipInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchCreateChannelMembershipInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchCreateChannelMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchCreateChannelMembershipInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchCreateChannelMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchCreateChannelMembershipOutputError>
}

extension BatchCreateChannelMembershipInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchCreateChannelMembershipInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), memberArns: \(Swift.String(describing: memberArns)), type: \(Swift.String(describing: type)))"}
}

extension BatchCreateChannelMembershipInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberArns = "MemberArns"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let memberArns = memberArns {
            var memberArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .memberArns)
            for memberarns0 in memberArns {
                try memberArnsContainer.encode(memberarns0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct BatchCreateChannelMembershipInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchCreateChannelMembershipInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchCreateChannelMembershipInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchCreateChannelMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let chimeBearer = input.operationInput.chimeBearer {
            input.builder.withHeader(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchCreateChannelMembershipInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchCreateChannelMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchCreateChannelMembershipOutputError>
}

public struct BatchCreateChannelMembershipInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchCreateChannelMembershipInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchCreateChannelMembershipInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchCreateChannelMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "operation", value: "batch-create"))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchCreateChannelMembershipInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchCreateChannelMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchCreateChannelMembershipOutputError>
}

public struct BatchCreateChannelMembershipInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchCreateChannelMembershipInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: BatchCreateChannelMembershipInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchCreateChannelMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BatchCreateChannelMembershipInput
    public typealias MOutput = ClientRuntime.OperationOutput<BatchCreateChannelMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchCreateChannelMembershipOutputError>
}

public struct BatchCreateChannelMembershipInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchCreateChannelMembershipInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: BatchCreateChannelMembershipInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchCreateChannelMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelArn = input.channelArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channels/\(channelArn.urlPercentEncoding())/memberships"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BatchCreateChannelMembershipInput
    public typealias MOutput = ClientRuntime.OperationOutput<BatchCreateChannelMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchCreateChannelMembershipOutputError>
}

public struct BatchCreateChannelMembershipInput: Swift.Equatable {
    /// The ARN of the channel to which you're adding users.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The ARNs of the members you want to add to the channel.
    /// This member is required.
    public var memberArns: [Swift.String]?
    /// The membership type of a user, DEFAULT or HIDDEN. Default members are always returned as part of ListChannelMemberships. Hidden members are only returned if the type filter in ListChannelMemberships equals HIDDEN. Otherwise hidden members are not returned. This is only supported by moderators.
    public var type: ChimeSdkMessagingClientTypes.ChannelMembershipType?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        memberArns: [Swift.String]? = nil,
        type: ChimeSdkMessagingClientTypes.ChannelMembershipType? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.memberArns = memberArns
        self.type = type
    }
}

struct BatchCreateChannelMembershipInputBody: Swift.Equatable {
    public let type: ChimeSdkMessagingClientTypes.ChannelMembershipType?
    public let memberArns: [Swift.String]?
}

extension BatchCreateChannelMembershipInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberArns = "MemberArns"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelMembershipType.self, forKey: .type)
        type = typeDecoded
        let memberArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .memberArns)
        var memberArnsDecoded0:[Swift.String]? = nil
        if let memberArnsContainer = memberArnsContainer {
            memberArnsDecoded0 = [Swift.String]()
            for string0 in memberArnsContainer {
                if let string0 = string0 {
                    memberArnsDecoded0?.append(string0)
                }
            }
        }
        memberArns = memberArnsDecoded0
    }
}

extension BatchCreateChannelMembershipOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchCreateChannelMembershipOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchCreateChannelMembershipOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchCreateChannelMembershipOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchCreateChannelMembershipOutputResponse(batchChannelMemberships: \(Swift.String(describing: batchChannelMemberships)), errors: \(Swift.String(describing: errors)))"}
}

extension BatchCreateChannelMembershipOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchCreateChannelMembershipOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.batchChannelMemberships = output.batchChannelMemberships
            self.errors = output.errors
        } else {
            self.batchChannelMemberships = nil
            self.errors = nil
        }
    }
}

public struct BatchCreateChannelMembershipOutputResponse: Swift.Equatable {
    /// The list of channel memberships in the response.
    public var batchChannelMemberships: ChimeSdkMessagingClientTypes.BatchChannelMemberships?
    /// If the action fails for one or more of the memberships in the request, a list of the memberships is returned, along with error codes and error messages.
    public var errors: [ChimeSdkMessagingClientTypes.BatchCreateChannelMembershipError]?

    public init (
        batchChannelMemberships: ChimeSdkMessagingClientTypes.BatchChannelMemberships? = nil,
        errors: [ChimeSdkMessagingClientTypes.BatchCreateChannelMembershipError]? = nil
    )
    {
        self.batchChannelMemberships = batchChannelMemberships
        self.errors = errors
    }
}

struct BatchCreateChannelMembershipOutputResponseBody: Swift.Equatable {
    public let batchChannelMemberships: ChimeSdkMessagingClientTypes.BatchChannelMemberships?
    public let errors: [ChimeSdkMessagingClientTypes.BatchCreateChannelMembershipError]?
}

extension BatchCreateChannelMembershipOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchChannelMemberships = "BatchChannelMemberships"
        case errors = "Errors"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchChannelMembershipsDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.BatchChannelMemberships.self, forKey: .batchChannelMemberships)
        batchChannelMemberships = batchChannelMembershipsDecoded
        let errorsContainer = try containerValues.decodeIfPresent([ChimeSdkMessagingClientTypes.BatchCreateChannelMembershipError?].self, forKey: .errors)
        var errorsDecoded0:[ChimeSdkMessagingClientTypes.BatchCreateChannelMembershipError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [ChimeSdkMessagingClientTypes.BatchCreateChannelMembershipError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension ChimeSdkMessagingClientTypes.Channel: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case createdBy = "CreatedBy"
        case createdTimestamp = "CreatedTimestamp"
        case lastMessageTimestamp = "LastMessageTimestamp"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case metadata = "Metadata"
        case mode = "Mode"
        case name = "Name"
        case privacy = "Privacy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let createdTimestamp = createdTimestamp {
            try encodeContainer.encode(createdTimestamp.timeIntervalSince1970, forKey: .createdTimestamp)
        }
        if let lastMessageTimestamp = lastMessageTimestamp {
            try encodeContainer.encode(lastMessageTimestamp.timeIntervalSince1970, forKey: .lastMessageTimestamp)
        }
        if let lastUpdatedTimestamp = lastUpdatedTimestamp {
            try encodeContainer.encode(lastUpdatedTimestamp.timeIntervalSince1970, forKey: .lastUpdatedTimestamp)
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let mode = mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let privacy = privacy {
            try encodeContainer.encode(privacy.rawValue, forKey: .privacy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let modeDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelMode.self, forKey: .mode)
        mode = modeDecoded
        let privacyDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelPrivacy.self, forKey: .privacy)
        privacy = privacyDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.Identity.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastMessageTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastMessageTimestamp)
        lastMessageTimestamp = lastMessageTimestampDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
    }
}

extension ChimeSdkMessagingClientTypes.Channel: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Channel(channelArn: \(Swift.String(describing: channelArn)), createdBy: \(Swift.String(describing: createdBy)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), lastMessageTimestamp: \(Swift.String(describing: lastMessageTimestamp)), lastUpdatedTimestamp: \(Swift.String(describing: lastUpdatedTimestamp)), metadata: \(Swift.String(describing: metadata)), mode: \(Swift.String(describing: mode)), name: \(Swift.String(describing: name)), privacy: \(Swift.String(describing: privacy)))"}
}

extension ChimeSdkMessagingClientTypes {
    /// The details of a channel.
    public struct Channel: Swift.Equatable {
        /// The ARN of a channel.
        public var channelArn: Swift.String?
        /// The AppInstanceUser who created the channel.
        public var createdBy: ChimeSdkMessagingClientTypes.Identity?
        /// The time at which the AppInstanceUser created the channel.
        public var createdTimestamp: ClientRuntime.Date?
        /// The time at which a member sent the last message in the channel.
        public var lastMessageTimestamp: ClientRuntime.Date?
        /// The time at which a channel was last updated.
        public var lastUpdatedTimestamp: ClientRuntime.Date?
        /// The channel's metadata.
        public var metadata: Swift.String?
        /// The mode of the channel.
        public var mode: ChimeSdkMessagingClientTypes.ChannelMode?
        /// The name of a channel.
        public var name: Swift.String?
        /// The channel's privacy setting.
        public var privacy: ChimeSdkMessagingClientTypes.ChannelPrivacy?

        public init (
            channelArn: Swift.String? = nil,
            createdBy: ChimeSdkMessagingClientTypes.Identity? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            lastMessageTimestamp: ClientRuntime.Date? = nil,
            lastUpdatedTimestamp: ClientRuntime.Date? = nil,
            metadata: Swift.String? = nil,
            mode: ChimeSdkMessagingClientTypes.ChannelMode? = nil,
            name: Swift.String? = nil,
            privacy: ChimeSdkMessagingClientTypes.ChannelPrivacy? = nil
        )
        {
            self.channelArn = channelArn
            self.createdBy = createdBy
            self.createdTimestamp = createdTimestamp
            self.lastMessageTimestamp = lastMessageTimestamp
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.metadata = metadata
            self.mode = mode
            self.name = name
            self.privacy = privacy
        }
    }

}

extension ChimeSdkMessagingClientTypes.ChannelBan: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case createdBy = "CreatedBy"
        case createdTimestamp = "CreatedTimestamp"
        case member = "Member"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let createdTimestamp = createdTimestamp {
            try encodeContainer.encode(createdTimestamp.timeIntervalSince1970, forKey: .createdTimestamp)
        }
        if let member = member {
            try encodeContainer.encode(member, forKey: .member)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.Identity.self, forKey: .member)
        member = memberDecoded
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.Identity.self, forKey: .createdBy)
        createdBy = createdByDecoded
    }
}

extension ChimeSdkMessagingClientTypes.ChannelBan: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChannelBan(channelArn: \(Swift.String(describing: channelArn)), createdBy: \(Swift.String(describing: createdBy)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), member: \(Swift.String(describing: member)))"}
}

extension ChimeSdkMessagingClientTypes {
    /// The details of a channel ban.
    public struct ChannelBan: Swift.Equatable {
        /// The ARN of the channel from which a member is being banned.
        public var channelArn: Swift.String?
        /// The AppInstanceUser who created the ban.
        public var createdBy: ChimeSdkMessagingClientTypes.Identity?
        /// The time at which the ban was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// The member being banned from the channel.
        public var member: ChimeSdkMessagingClientTypes.Identity?

        public init (
            channelArn: Swift.String? = nil,
            createdBy: ChimeSdkMessagingClientTypes.Identity? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            member: ChimeSdkMessagingClientTypes.Identity? = nil
        )
        {
            self.channelArn = channelArn
            self.createdBy = createdBy
            self.createdTimestamp = createdTimestamp
            self.member = member
        }
    }

}

extension ChimeSdkMessagingClientTypes.ChannelBanSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case member = "Member"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let member = member {
            try encodeContainer.encode(member, forKey: .member)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.Identity.self, forKey: .member)
        member = memberDecoded
    }
}

extension ChimeSdkMessagingClientTypes.ChannelBanSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChannelBanSummary(member: \(Swift.String(describing: member)))"}
}

extension ChimeSdkMessagingClientTypes {
    /// Summary of the details of a ChannelBan.
    public struct ChannelBanSummary: Swift.Equatable {
        /// The member being banned from a channel.
        public var member: ChimeSdkMessagingClientTypes.Identity?

        public init (
            member: ChimeSdkMessagingClientTypes.Identity? = nil
        )
        {
            self.member = member
        }
    }

}

extension ChimeSdkMessagingClientTypes.ChannelMembership: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case createdTimestamp = "CreatedTimestamp"
        case invitedBy = "InvitedBy"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case member = "Member"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let createdTimestamp = createdTimestamp {
            try encodeContainer.encode(createdTimestamp.timeIntervalSince1970, forKey: .createdTimestamp)
        }
        if let invitedBy = invitedBy {
            try encodeContainer.encode(invitedBy, forKey: .invitedBy)
        }
        if let lastUpdatedTimestamp = lastUpdatedTimestamp {
            try encodeContainer.encode(lastUpdatedTimestamp.timeIntervalSince1970, forKey: .lastUpdatedTimestamp)
        }
        if let member = member {
            try encodeContainer.encode(member, forKey: .member)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invitedByDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.Identity.self, forKey: .invitedBy)
        invitedBy = invitedByDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelMembershipType.self, forKey: .type)
        type = typeDecoded
        let memberDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.Identity.self, forKey: .member)
        member = memberDecoded
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
    }
}

extension ChimeSdkMessagingClientTypes.ChannelMembership: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChannelMembership(channelArn: \(Swift.String(describing: channelArn)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), invitedBy: \(Swift.String(describing: invitedBy)), lastUpdatedTimestamp: \(Swift.String(describing: lastUpdatedTimestamp)), member: \(Swift.String(describing: member)), type: \(Swift.String(describing: type)))"}
}

extension ChimeSdkMessagingClientTypes {
    /// The details of a channel member.
    public struct ChannelMembership: Swift.Equatable {
        /// The ARN of the member's channel.
        public var channelArn: Swift.String?
        /// The time at which the channel membership was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// The identifier of the member who invited another member.
        public var invitedBy: ChimeSdkMessagingClientTypes.Identity?
        /// The time at which a channel membership was last updated.
        public var lastUpdatedTimestamp: ClientRuntime.Date?
        /// The data of the channel member.
        public var member: ChimeSdkMessagingClientTypes.Identity?
        /// The membership type set for the channel member.
        public var type: ChimeSdkMessagingClientTypes.ChannelMembershipType?

        public init (
            channelArn: Swift.String? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            invitedBy: ChimeSdkMessagingClientTypes.Identity? = nil,
            lastUpdatedTimestamp: ClientRuntime.Date? = nil,
            member: ChimeSdkMessagingClientTypes.Identity? = nil,
            type: ChimeSdkMessagingClientTypes.ChannelMembershipType? = nil
        )
        {
            self.channelArn = channelArn
            self.createdTimestamp = createdTimestamp
            self.invitedBy = invitedBy
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.member = member
            self.type = type
        }
    }

}

extension ChimeSdkMessagingClientTypes.ChannelMembershipForAppInstanceUserSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceUserMembershipSummary = "AppInstanceUserMembershipSummary"
        case channelSummary = "ChannelSummary"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appInstanceUserMembershipSummary = appInstanceUserMembershipSummary {
            try encodeContainer.encode(appInstanceUserMembershipSummary, forKey: .appInstanceUserMembershipSummary)
        }
        if let channelSummary = channelSummary {
            try encodeContainer.encode(channelSummary, forKey: .channelSummary)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelSummaryDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelSummary.self, forKey: .channelSummary)
        channelSummary = channelSummaryDecoded
        let appInstanceUserMembershipSummaryDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.AppInstanceUserMembershipSummary.self, forKey: .appInstanceUserMembershipSummary)
        appInstanceUserMembershipSummary = appInstanceUserMembershipSummaryDecoded
    }
}

extension ChimeSdkMessagingClientTypes.ChannelMembershipForAppInstanceUserSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChannelMembershipForAppInstanceUserSummary(appInstanceUserMembershipSummary: \(Swift.String(describing: appInstanceUserMembershipSummary)), channelSummary: \(Swift.String(describing: channelSummary)))"}
}

extension ChimeSdkMessagingClientTypes {
    /// Summary of the channel membership details of an AppInstanceUser.
    public struct ChannelMembershipForAppInstanceUserSummary: Swift.Equatable {
        /// Returns the channel membership data for an AppInstance.
        public var appInstanceUserMembershipSummary: ChimeSdkMessagingClientTypes.AppInstanceUserMembershipSummary?
        /// Returns the channel data for an AppInstance.
        public var channelSummary: ChimeSdkMessagingClientTypes.ChannelSummary?

        public init (
            appInstanceUserMembershipSummary: ChimeSdkMessagingClientTypes.AppInstanceUserMembershipSummary? = nil,
            channelSummary: ChimeSdkMessagingClientTypes.ChannelSummary? = nil
        )
        {
            self.appInstanceUserMembershipSummary = appInstanceUserMembershipSummary
            self.channelSummary = channelSummary
        }
    }

}

extension ChimeSdkMessagingClientTypes.ChannelMembershipSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case member = "Member"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let member = member {
            try encodeContainer.encode(member, forKey: .member)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.Identity.self, forKey: .member)
        member = memberDecoded
    }
}

extension ChimeSdkMessagingClientTypes.ChannelMembershipSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChannelMembershipSummary(member: \(Swift.String(describing: member)))"}
}

extension ChimeSdkMessagingClientTypes {
    /// Summary of the details of a ChannelMembership.
    public struct ChannelMembershipSummary: Swift.Equatable {
        /// A member's summary data.
        public var member: ChimeSdkMessagingClientTypes.Identity?

        public init (
            member: ChimeSdkMessagingClientTypes.Identity? = nil
        )
        {
            self.member = member
        }
    }

}

extension ChimeSdkMessagingClientTypes {
    public enum ChannelMembershipType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `default`
        case hidden
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelMembershipType] {
            return [
                .default,
                .hidden,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .default: return "DEFAULT"
            case .hidden: return "HIDDEN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChannelMembershipType(rawValue: rawValue) ?? ChannelMembershipType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSdkMessagingClientTypes.ChannelMessage: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case content = "Content"
        case createdTimestamp = "CreatedTimestamp"
        case lastEditedTimestamp = "LastEditedTimestamp"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case messageId = "MessageId"
        case metadata = "Metadata"
        case persistence = "Persistence"
        case redacted = "Redacted"
        case sender = "Sender"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let createdTimestamp = createdTimestamp {
            try encodeContainer.encode(createdTimestamp.timeIntervalSince1970, forKey: .createdTimestamp)
        }
        if let lastEditedTimestamp = lastEditedTimestamp {
            try encodeContainer.encode(lastEditedTimestamp.timeIntervalSince1970, forKey: .lastEditedTimestamp)
        }
        if let lastUpdatedTimestamp = lastUpdatedTimestamp {
            try encodeContainer.encode(lastUpdatedTimestamp.timeIntervalSince1970, forKey: .lastUpdatedTimestamp)
        }
        if let messageId = messageId {
            try encodeContainer.encode(messageId, forKey: .messageId)
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let persistence = persistence {
            try encodeContainer.encode(persistence.rawValue, forKey: .persistence)
        }
        if redacted != false {
            try encodeContainer.encode(redacted, forKey: .redacted)
        }
        if let sender = sender {
            try encodeContainer.encode(sender, forKey: .sender)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelMessageType.self, forKey: .type)
        type = typeDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastEditedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastEditedTimestamp)
        lastEditedTimestamp = lastEditedTimestampDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let senderDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.Identity.self, forKey: .sender)
        sender = senderDecoded
        let redactedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .redacted)
        redacted = redactedDecoded
        let persistenceDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelMessagePersistenceType.self, forKey: .persistence)
        persistence = persistenceDecoded
    }
}

extension ChimeSdkMessagingClientTypes.ChannelMessage: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChannelMessage(channelArn: \(Swift.String(describing: channelArn)), content: \(Swift.String(describing: content)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), lastEditedTimestamp: \(Swift.String(describing: lastEditedTimestamp)), lastUpdatedTimestamp: \(Swift.String(describing: lastUpdatedTimestamp)), messageId: \(Swift.String(describing: messageId)), metadata: \(Swift.String(describing: metadata)), persistence: \(Swift.String(describing: persistence)), redacted: \(Swift.String(describing: redacted)), sender: \(Swift.String(describing: sender)), type: \(Swift.String(describing: type)))"}
}

extension ChimeSdkMessagingClientTypes {
    /// The details of a message in a channel.
    public struct ChannelMessage: Swift.Equatable {
        /// The ARN of the channel.
        public var channelArn: Swift.String?
        /// The message content.
        public var content: Swift.String?
        /// The time at which the message was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// The time at which a message was edited.
        public var lastEditedTimestamp: ClientRuntime.Date?
        /// The time at which a message was updated.
        public var lastUpdatedTimestamp: ClientRuntime.Date?
        /// The ID of a message.
        public var messageId: Swift.String?
        /// The message metadata.
        public var metadata: Swift.String?
        /// The persistence setting for a channel message.
        public var persistence: ChimeSdkMessagingClientTypes.ChannelMessagePersistenceType?
        /// Hides the content of a message.
        public var redacted: Swift.Bool
        /// The message sender.
        public var sender: ChimeSdkMessagingClientTypes.Identity?
        /// The message type.
        public var type: ChimeSdkMessagingClientTypes.ChannelMessageType?

        public init (
            channelArn: Swift.String? = nil,
            content: Swift.String? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            lastEditedTimestamp: ClientRuntime.Date? = nil,
            lastUpdatedTimestamp: ClientRuntime.Date? = nil,
            messageId: Swift.String? = nil,
            metadata: Swift.String? = nil,
            persistence: ChimeSdkMessagingClientTypes.ChannelMessagePersistenceType? = nil,
            redacted: Swift.Bool = false,
            sender: ChimeSdkMessagingClientTypes.Identity? = nil,
            type: ChimeSdkMessagingClientTypes.ChannelMessageType? = nil
        )
        {
            self.channelArn = channelArn
            self.content = content
            self.createdTimestamp = createdTimestamp
            self.lastEditedTimestamp = lastEditedTimestamp
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.messageId = messageId
            self.metadata = metadata
            self.persistence = persistence
            self.redacted = redacted
            self.sender = sender
            self.type = type
        }
    }

}

extension ChimeSdkMessagingClientTypes {
    public enum ChannelMessagePersistenceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case nonPersistent
        case persistent
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelMessagePersistenceType] {
            return [
                .nonPersistent,
                .persistent,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .nonPersistent: return "NON_PERSISTENT"
            case .persistent: return "PERSISTENT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChannelMessagePersistenceType(rawValue: rawValue) ?? ChannelMessagePersistenceType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSdkMessagingClientTypes.ChannelMessageSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
        case createdTimestamp = "CreatedTimestamp"
        case lastEditedTimestamp = "LastEditedTimestamp"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case messageId = "MessageId"
        case metadata = "Metadata"
        case redacted = "Redacted"
        case sender = "Sender"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let createdTimestamp = createdTimestamp {
            try encodeContainer.encode(createdTimestamp.timeIntervalSince1970, forKey: .createdTimestamp)
        }
        if let lastEditedTimestamp = lastEditedTimestamp {
            try encodeContainer.encode(lastEditedTimestamp.timeIntervalSince1970, forKey: .lastEditedTimestamp)
        }
        if let lastUpdatedTimestamp = lastUpdatedTimestamp {
            try encodeContainer.encode(lastUpdatedTimestamp.timeIntervalSince1970, forKey: .lastUpdatedTimestamp)
        }
        if let messageId = messageId {
            try encodeContainer.encode(messageId, forKey: .messageId)
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if redacted != false {
            try encodeContainer.encode(redacted, forKey: .redacted)
        }
        if let sender = sender {
            try encodeContainer.encode(sender, forKey: .sender)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelMessageType.self, forKey: .type)
        type = typeDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let lastEditedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastEditedTimestamp)
        lastEditedTimestamp = lastEditedTimestampDecoded
        let senderDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.Identity.self, forKey: .sender)
        sender = senderDecoded
        let redactedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .redacted)
        redacted = redactedDecoded
    }
}

extension ChimeSdkMessagingClientTypes.ChannelMessageSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChannelMessageSummary(content: \(Swift.String(describing: content)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), lastEditedTimestamp: \(Swift.String(describing: lastEditedTimestamp)), lastUpdatedTimestamp: \(Swift.String(describing: lastUpdatedTimestamp)), messageId: \(Swift.String(describing: messageId)), metadata: \(Swift.String(describing: metadata)), redacted: \(Swift.String(describing: redacted)), sender: \(Swift.String(describing: sender)), type: \(Swift.String(describing: type)))"}
}

extension ChimeSdkMessagingClientTypes {
    /// Summary of the messages in a Channel.
    public struct ChannelMessageSummary: Swift.Equatable {
        /// The content of the message.
        public var content: Swift.String?
        /// The time at which the message summary was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// The time at which a message was last edited.
        public var lastEditedTimestamp: ClientRuntime.Date?
        /// The time at which a message was last updated.
        public var lastUpdatedTimestamp: ClientRuntime.Date?
        /// The ID of the message.
        public var messageId: Swift.String?
        /// The metadata of the message.
        public var metadata: Swift.String?
        /// Indicates whether a message was redacted.
        public var redacted: Swift.Bool
        /// The message sender.
        public var sender: ChimeSdkMessagingClientTypes.Identity?
        /// The type of message.
        public var type: ChimeSdkMessagingClientTypes.ChannelMessageType?

        public init (
            content: Swift.String? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            lastEditedTimestamp: ClientRuntime.Date? = nil,
            lastUpdatedTimestamp: ClientRuntime.Date? = nil,
            messageId: Swift.String? = nil,
            metadata: Swift.String? = nil,
            redacted: Swift.Bool = false,
            sender: ChimeSdkMessagingClientTypes.Identity? = nil,
            type: ChimeSdkMessagingClientTypes.ChannelMessageType? = nil
        )
        {
            self.content = content
            self.createdTimestamp = createdTimestamp
            self.lastEditedTimestamp = lastEditedTimestamp
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.messageId = messageId
            self.metadata = metadata
            self.redacted = redacted
            self.sender = sender
            self.type = type
        }
    }

}

extension ChimeSdkMessagingClientTypes {
    public enum ChannelMessageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case control
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelMessageType] {
            return [
                .control,
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .control: return "CONTROL"
            case .standard: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChannelMessageType(rawValue: rawValue) ?? ChannelMessageType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSdkMessagingClientTypes {
    public enum ChannelMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case restricted
        case unrestricted
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelMode] {
            return [
                .restricted,
                .unrestricted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .restricted: return "RESTRICTED"
            case .unrestricted: return "UNRESTRICTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChannelMode(rawValue: rawValue) ?? ChannelMode.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSdkMessagingClientTypes.ChannelModeratedByAppInstanceUserSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelSummary = "ChannelSummary"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelSummary = channelSummary {
            try encodeContainer.encode(channelSummary, forKey: .channelSummary)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelSummaryDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelSummary.self, forKey: .channelSummary)
        channelSummary = channelSummaryDecoded
    }
}

extension ChimeSdkMessagingClientTypes.ChannelModeratedByAppInstanceUserSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChannelModeratedByAppInstanceUserSummary(channelSummary: \(Swift.String(describing: channelSummary)))"}
}

extension ChimeSdkMessagingClientTypes {
    /// Summary of the details of a moderated channel.
    public struct ChannelModeratedByAppInstanceUserSummary: Swift.Equatable {
        /// Summary of the details of a Channel.
        public var channelSummary: ChimeSdkMessagingClientTypes.ChannelSummary?

        public init (
            channelSummary: ChimeSdkMessagingClientTypes.ChannelSummary? = nil
        )
        {
            self.channelSummary = channelSummary
        }
    }

}

extension ChimeSdkMessagingClientTypes.ChannelModerator: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case createdBy = "CreatedBy"
        case createdTimestamp = "CreatedTimestamp"
        case moderator = "Moderator"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let createdTimestamp = createdTimestamp {
            try encodeContainer.encode(createdTimestamp.timeIntervalSince1970, forKey: .createdTimestamp)
        }
        if let moderator = moderator {
            try encodeContainer.encode(moderator, forKey: .moderator)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let moderatorDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.Identity.self, forKey: .moderator)
        moderator = moderatorDecoded
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.Identity.self, forKey: .createdBy)
        createdBy = createdByDecoded
    }
}

extension ChimeSdkMessagingClientTypes.ChannelModerator: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChannelModerator(channelArn: \(Swift.String(describing: channelArn)), createdBy: \(Swift.String(describing: createdBy)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), moderator: \(Swift.String(describing: moderator)))"}
}

extension ChimeSdkMessagingClientTypes {
    /// The details of a channel moderator.
    public struct ChannelModerator: Swift.Equatable {
        /// The ARN of the moderator's channel.
        public var channelArn: Swift.String?
        /// The AppInstanceUser who created the moderator.
        public var createdBy: ChimeSdkMessagingClientTypes.Identity?
        /// The time at which the moderator was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// The moderator's data.
        public var moderator: ChimeSdkMessagingClientTypes.Identity?

        public init (
            channelArn: Swift.String? = nil,
            createdBy: ChimeSdkMessagingClientTypes.Identity? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            moderator: ChimeSdkMessagingClientTypes.Identity? = nil
        )
        {
            self.channelArn = channelArn
            self.createdBy = createdBy
            self.createdTimestamp = createdTimestamp
            self.moderator = moderator
        }
    }

}

extension ChimeSdkMessagingClientTypes.ChannelModeratorSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case moderator = "Moderator"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let moderator = moderator {
            try encodeContainer.encode(moderator, forKey: .moderator)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let moderatorDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.Identity.self, forKey: .moderator)
        moderator = moderatorDecoded
    }
}

extension ChimeSdkMessagingClientTypes.ChannelModeratorSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChannelModeratorSummary(moderator: \(Swift.String(describing: moderator)))"}
}

extension ChimeSdkMessagingClientTypes {
    /// Summary of the details of a ChannelModerator.
    public struct ChannelModeratorSummary: Swift.Equatable {
        /// The data for a moderator.
        public var moderator: ChimeSdkMessagingClientTypes.Identity?

        public init (
            moderator: ChimeSdkMessagingClientTypes.Identity? = nil
        )
        {
            self.moderator = moderator
        }
    }

}

extension ChimeSdkMessagingClientTypes {
    public enum ChannelPrivacy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `private`
        case `public`
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelPrivacy] {
            return [
                .private,
                .public,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .private: return "PRIVATE"
            case .public: return "PUBLIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChannelPrivacy(rawValue: rawValue) ?? ChannelPrivacy.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSdkMessagingClientTypes.ChannelSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case lastMessageTimestamp = "LastMessageTimestamp"
        case metadata = "Metadata"
        case mode = "Mode"
        case name = "Name"
        case privacy = "Privacy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let lastMessageTimestamp = lastMessageTimestamp {
            try encodeContainer.encode(lastMessageTimestamp.timeIntervalSince1970, forKey: .lastMessageTimestamp)
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let mode = mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let privacy = privacy {
            try encodeContainer.encode(privacy.rawValue, forKey: .privacy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let modeDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelMode.self, forKey: .mode)
        mode = modeDecoded
        let privacyDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelPrivacy.self, forKey: .privacy)
        privacy = privacyDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let lastMessageTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastMessageTimestamp)
        lastMessageTimestamp = lastMessageTimestampDecoded
    }
}

extension ChimeSdkMessagingClientTypes.ChannelSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChannelSummary(channelArn: \(Swift.String(describing: channelArn)), lastMessageTimestamp: \(Swift.String(describing: lastMessageTimestamp)), metadata: \(Swift.String(describing: metadata)), mode: \(Swift.String(describing: mode)), name: \(Swift.String(describing: name)), privacy: \(Swift.String(describing: privacy)))"}
}

extension ChimeSdkMessagingClientTypes {
    /// Summary of the details of a Channel.
    public struct ChannelSummary: Swift.Equatable {
        /// The ARN of the channel.
        public var channelArn: Swift.String?
        /// The time at which the last message in a channel was sent.
        public var lastMessageTimestamp: ClientRuntime.Date?
        /// The metadata of the channel.
        public var metadata: Swift.String?
        /// The mode of the channel.
        public var mode: ChimeSdkMessagingClientTypes.ChannelMode?
        /// The name of the channel.
        public var name: Swift.String?
        /// The privacy setting of the channel.
        public var privacy: ChimeSdkMessagingClientTypes.ChannelPrivacy?

        public init (
            channelArn: Swift.String? = nil,
            lastMessageTimestamp: ClientRuntime.Date? = nil,
            metadata: Swift.String? = nil,
            mode: ChimeSdkMessagingClientTypes.ChannelMode? = nil,
            name: Swift.String? = nil,
            privacy: ChimeSdkMessagingClientTypes.ChannelPrivacy? = nil
        )
        {
            self.channelArn = channelArn
            self.lastMessageTimestamp = lastMessageTimestamp
            self.metadata = metadata
            self.mode = mode
            self.name = name
            self.privacy = privacy
        }
    }

}

extension ConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request could not be processed because of conflict in the current state of the resource.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeSdkMessagingClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeSdkMessagingClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    public let code: ChimeSdkMessagingClientTypes.ErrorCode?
    public let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateChannelBanInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChannelBanInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateChannelBanInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChannelBanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateChannelBanInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChannelBanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChannelBanOutputError>
}

extension CreateChannelBanInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateChannelBanInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), memberArn: \(Swift.String(describing: memberArn)))"}
}

extension CreateChannelBanInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberArn = "MemberArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let memberArn = memberArn {
            try encodeContainer.encode(memberArn, forKey: .memberArn)
        }
    }
}

public struct CreateChannelBanInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChannelBanInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateChannelBanInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChannelBanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let chimeBearer = input.operationInput.chimeBearer {
            input.builder.withHeader(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateChannelBanInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChannelBanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChannelBanOutputError>
}

public struct CreateChannelBanInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChannelBanInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateChannelBanInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChannelBanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateChannelBanInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChannelBanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChannelBanOutputError>
}

public struct CreateChannelBanInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChannelBanInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateChannelBanInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChannelBanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateChannelBanInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChannelBanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChannelBanOutputError>
}

public struct CreateChannelBanInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChannelBanInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateChannelBanInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChannelBanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelArn = input.channelArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channels/\(channelArn.urlPercentEncoding())/bans"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateChannelBanInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChannelBanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChannelBanOutputError>
}

public struct CreateChannelBanInput: Swift.Equatable {
    /// The ARN of the ban request.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The ARN of the member being banned.
    /// This member is required.
    public var memberArn: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        memberArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.memberArn = memberArn
    }
}

struct CreateChannelBanInputBody: Swift.Equatable {
    public let memberArn: Swift.String?
}

extension CreateChannelBanInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberArn = "MemberArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberArn)
        memberArn = memberArnDecoded
    }
}

extension CreateChannelBanOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateChannelBanOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateChannelBanOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateChannelBanOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateChannelBanOutputResponse(channelArn: \(Swift.String(describing: channelArn)), member: \(Swift.String(describing: member)))"}
}

extension CreateChannelBanOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateChannelBanOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.member = output.member
        } else {
            self.channelArn = nil
            self.member = nil
        }
    }
}

public struct CreateChannelBanOutputResponse: Swift.Equatable {
    /// The ARN of the response to the ban request.
    public var channelArn: Swift.String?
    /// The ChannelArn and BannedIdentity of the member in the ban response.
    public var member: ChimeSdkMessagingClientTypes.Identity?

    public init (
        channelArn: Swift.String? = nil,
        member: ChimeSdkMessagingClientTypes.Identity? = nil
    )
    {
        self.channelArn = channelArn
        self.member = member
    }
}

struct CreateChannelBanOutputResponseBody: Swift.Equatable {
    public let channelArn: Swift.String?
    public let member: ChimeSdkMessagingClientTypes.Identity?
}

extension CreateChannelBanOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case member = "Member"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let memberDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.Identity.self, forKey: .member)
        member = memberDecoded
    }
}

public struct CreateChannelInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChannelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChannelOutputError>
}

extension CreateChannelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateChannelInput(appInstanceArn: \(Swift.String(describing: appInstanceArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), clientRequestToken: \(Swift.String(describing: clientRequestToken)), metadata: \(Swift.String(describing: metadata)), mode: \(Swift.String(describing: mode)), name: \(Swift.String(describing: name)), privacy: \(Swift.String(describing: privacy)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateChannelInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceArn = "AppInstanceArn"
        case clientRequestToken = "ClientRequestToken"
        case metadata = "Metadata"
        case mode = "Mode"
        case name = "Name"
        case privacy = "Privacy"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appInstanceArn = appInstanceArn {
            try encodeContainer.encode(appInstanceArn, forKey: .appInstanceArn)
        }
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let mode = mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let privacy = privacy {
            try encodeContainer.encode(privacy.rawValue, forKey: .privacy)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateChannelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let chimeBearer = input.operationInput.chimeBearer {
            input.builder.withHeader(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChannelOutputError>
}

public struct CreateChannelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChannelOutputError>
}

public struct CreateChannelInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChannelInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateChannelInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateChannelInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChannelOutputError>
}

public struct CreateChannelInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChannelInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateChannelInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/channels"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateChannelInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChannelOutputError>
}

public struct CreateChannelInput: Swift.Equatable {
    /// The ARN of the channel request.
    /// This member is required.
    public var appInstanceArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The client token for the request. An Idempotency token.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The metadata of the creation request. Limited to 1KB and UTF-8.
    public var metadata: Swift.String?
    /// The channel mode: UNRESTRICTED or RESTRICTED. Administrators, moderators, and channel members can add themselves and other members to unrestricted channels. Only administrators and moderators can add members to restricted channels.
    public var mode: ChimeSdkMessagingClientTypes.ChannelMode?
    /// The name of the channel.
    /// This member is required.
    public var name: Swift.String?
    /// The channel's privacy level: PUBLIC or PRIVATE. Private channels aren't discoverable by users outside the channel. Public channels are discoverable by anyone in the AppInstance.
    public var privacy: ChimeSdkMessagingClientTypes.ChannelPrivacy?
    /// The tags for the creation request.
    public var tags: [ChimeSdkMessagingClientTypes.Tag]?

    public init (
        appInstanceArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        metadata: Swift.String? = nil,
        mode: ChimeSdkMessagingClientTypes.ChannelMode? = nil,
        name: Swift.String? = nil,
        privacy: ChimeSdkMessagingClientTypes.ChannelPrivacy? = nil,
        tags: [ChimeSdkMessagingClientTypes.Tag]? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.chimeBearer = chimeBearer
        self.clientRequestToken = clientRequestToken
        self.metadata = metadata
        self.mode = mode
        self.name = name
        self.privacy = privacy
        self.tags = tags
    }
}

struct CreateChannelInputBody: Swift.Equatable {
    public let appInstanceArn: Swift.String?
    public let name: Swift.String?
    public let mode: ChimeSdkMessagingClientTypes.ChannelMode?
    public let privacy: ChimeSdkMessagingClientTypes.ChannelPrivacy?
    public let metadata: Swift.String?
    public let clientRequestToken: Swift.String?
    public let tags: [ChimeSdkMessagingClientTypes.Tag]?
}

extension CreateChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceArn = "AppInstanceArn"
        case clientRequestToken = "ClientRequestToken"
        case metadata = "Metadata"
        case mode = "Mode"
        case name = "Name"
        case privacy = "Privacy"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceArn)
        appInstanceArn = appInstanceArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let modeDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelMode.self, forKey: .mode)
        mode = modeDecoded
        let privacyDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelPrivacy.self, forKey: .privacy)
        privacy = privacyDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ChimeSdkMessagingClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeSdkMessagingClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeSdkMessagingClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct CreateChannelMembershipInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChannelMembershipInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateChannelMembershipInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChannelMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateChannelMembershipInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChannelMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChannelMembershipOutputError>
}

extension CreateChannelMembershipInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateChannelMembershipInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), memberArn: \(Swift.String(describing: memberArn)), type: \(Swift.String(describing: type)))"}
}

extension CreateChannelMembershipInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberArn = "MemberArn"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let memberArn = memberArn {
            try encodeContainer.encode(memberArn, forKey: .memberArn)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct CreateChannelMembershipInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChannelMembershipInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateChannelMembershipInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChannelMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let chimeBearer = input.operationInput.chimeBearer {
            input.builder.withHeader(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateChannelMembershipInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChannelMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChannelMembershipOutputError>
}

public struct CreateChannelMembershipInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChannelMembershipInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateChannelMembershipInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChannelMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateChannelMembershipInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChannelMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChannelMembershipOutputError>
}

public struct CreateChannelMembershipInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChannelMembershipInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateChannelMembershipInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChannelMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateChannelMembershipInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChannelMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChannelMembershipOutputError>
}

public struct CreateChannelMembershipInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChannelMembershipInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateChannelMembershipInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChannelMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelArn = input.channelArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channels/\(channelArn.urlPercentEncoding())/memberships"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateChannelMembershipInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChannelMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChannelMembershipOutputError>
}

public struct CreateChannelMembershipInput: Swift.Equatable {
    /// The ARN of the channel to which you're adding users.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The ARN of the member you want to add to the channel.
    /// This member is required.
    public var memberArn: Swift.String?
    /// The membership type of a user, DEFAULT or HIDDEN. Default members are always returned as part of ListChannelMemberships. Hidden members are only returned if the type filter in ListChannelMemberships equals HIDDEN. Otherwise hidden members are not returned. This is only supported by moderators.
    /// This member is required.
    public var type: ChimeSdkMessagingClientTypes.ChannelMembershipType?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        memberArn: Swift.String? = nil,
        type: ChimeSdkMessagingClientTypes.ChannelMembershipType? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.memberArn = memberArn
        self.type = type
    }
}

struct CreateChannelMembershipInputBody: Swift.Equatable {
    public let memberArn: Swift.String?
    public let type: ChimeSdkMessagingClientTypes.ChannelMembershipType?
}

extension CreateChannelMembershipInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberArn = "MemberArn"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberArn)
        memberArn = memberArnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelMembershipType.self, forKey: .type)
        type = typeDecoded
    }
}

extension CreateChannelMembershipOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateChannelMembershipOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateChannelMembershipOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateChannelMembershipOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateChannelMembershipOutputResponse(channelArn: \(Swift.String(describing: channelArn)), member: \(Swift.String(describing: member)))"}
}

extension CreateChannelMembershipOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateChannelMembershipOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.member = output.member
        } else {
            self.channelArn = nil
            self.member = nil
        }
    }
}

public struct CreateChannelMembershipOutputResponse: Swift.Equatable {
    /// The ARN of the channel.
    public var channelArn: Swift.String?
    /// The ARN and metadata of the member being added.
    public var member: ChimeSdkMessagingClientTypes.Identity?

    public init (
        channelArn: Swift.String? = nil,
        member: ChimeSdkMessagingClientTypes.Identity? = nil
    )
    {
        self.channelArn = channelArn
        self.member = member
    }
}

struct CreateChannelMembershipOutputResponseBody: Swift.Equatable {
    public let channelArn: Swift.String?
    public let member: ChimeSdkMessagingClientTypes.Identity?
}

extension CreateChannelMembershipOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case member = "Member"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let memberDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.Identity.self, forKey: .member)
        member = memberDecoded
    }
}

public struct CreateChannelModeratorInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChannelModeratorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateChannelModeratorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChannelModeratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateChannelModeratorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChannelModeratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChannelModeratorOutputError>
}

extension CreateChannelModeratorInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateChannelModeratorInput(channelArn: \(Swift.String(describing: channelArn)), channelModeratorArn: \(Swift.String(describing: channelModeratorArn)), chimeBearer: \(Swift.String(describing: chimeBearer)))"}
}

extension CreateChannelModeratorInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelModeratorArn = "ChannelModeratorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelModeratorArn = channelModeratorArn {
            try encodeContainer.encode(channelModeratorArn, forKey: .channelModeratorArn)
        }
    }
}

public struct CreateChannelModeratorInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChannelModeratorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateChannelModeratorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChannelModeratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let chimeBearer = input.operationInput.chimeBearer {
            input.builder.withHeader(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateChannelModeratorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChannelModeratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChannelModeratorOutputError>
}

public struct CreateChannelModeratorInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChannelModeratorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateChannelModeratorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChannelModeratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateChannelModeratorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChannelModeratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChannelModeratorOutputError>
}

public struct CreateChannelModeratorInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChannelModeratorInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateChannelModeratorInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChannelModeratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateChannelModeratorInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChannelModeratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChannelModeratorOutputError>
}

public struct CreateChannelModeratorInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChannelModeratorInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateChannelModeratorInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChannelModeratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelArn = input.channelArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channels/\(channelArn.urlPercentEncoding())/moderators"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateChannelModeratorInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChannelModeratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChannelModeratorOutputError>
}

public struct CreateChannelModeratorInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The ARN of the moderator.
    /// This member is required.
    public var channelModeratorArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        channelModeratorArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.channelModeratorArn = channelModeratorArn
        self.chimeBearer = chimeBearer
    }
}

struct CreateChannelModeratorInputBody: Swift.Equatable {
    public let channelModeratorArn: Swift.String?
}

extension CreateChannelModeratorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelModeratorArn = "ChannelModeratorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelModeratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelModeratorArn)
        channelModeratorArn = channelModeratorArnDecoded
    }
}

extension CreateChannelModeratorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateChannelModeratorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateChannelModeratorOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateChannelModeratorOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateChannelModeratorOutputResponse(channelArn: \(Swift.String(describing: channelArn)), channelModerator: \(Swift.String(describing: channelModerator)))"}
}

extension CreateChannelModeratorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateChannelModeratorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.channelModerator = output.channelModerator
        } else {
            self.channelArn = nil
            self.channelModerator = nil
        }
    }
}

public struct CreateChannelModeratorOutputResponse: Swift.Equatable {
    /// The ARN of the channel.
    public var channelArn: Swift.String?
    /// The ARNs of the channel and the moderator.
    public var channelModerator: ChimeSdkMessagingClientTypes.Identity?

    public init (
        channelArn: Swift.String? = nil,
        channelModerator: ChimeSdkMessagingClientTypes.Identity? = nil
    )
    {
        self.channelArn = channelArn
        self.channelModerator = channelModerator
    }
}

struct CreateChannelModeratorOutputResponseBody: Swift.Equatable {
    public let channelArn: Swift.String?
    public let channelModerator: ChimeSdkMessagingClientTypes.Identity?
}

extension CreateChannelModeratorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case channelModerator = "ChannelModerator"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let channelModeratorDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.Identity.self, forKey: .channelModerator)
        channelModerator = channelModeratorDecoded
    }
}

extension CreateChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateChannelOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateChannelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateChannelOutputResponse(channelArn: \(Swift.String(describing: channelArn)))"}
}

extension CreateChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateChannelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
        } else {
            self.channelArn = nil
        }
    }
}

public struct CreateChannelOutputResponse: Swift.Equatable {
    /// The ARN of the channel.
    public var channelArn: Swift.String?

    public init (
        channelArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
    }
}

struct CreateChannelOutputResponseBody: Swift.Equatable {
    public let channelArn: Swift.String?
}

extension CreateChannelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
    }
}

extension DeleteChannelBanInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteChannelBanInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), memberArn: \(Swift.String(describing: memberArn)))"}
}

extension DeleteChannelBanInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteChannelBanInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChannelBanInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteChannelBanInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChannelBanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let chimeBearer = input.operationInput.chimeBearer {
            input.builder.withHeader(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteChannelBanInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChannelBanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChannelBanOutputError>
}

public struct DeleteChannelBanInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChannelBanInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteChannelBanInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChannelBanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteChannelBanInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChannelBanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChannelBanOutputError>
}

public struct DeleteChannelBanInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChannelBanInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteChannelBanInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChannelBanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteChannelBanInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChannelBanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChannelBanOutputError>
}

public struct DeleteChannelBanInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChannelBanInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteChannelBanInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChannelBanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelArn = input.channelArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelArn is nil and needs a value for the path of this operation"))))
        }
        guard let memberArn = input.memberArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("memberArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channels/\(channelArn.urlPercentEncoding())/bans/\(memberArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteChannelBanInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChannelBanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChannelBanOutputError>
}

public struct DeleteChannelBanInput: Swift.Equatable {
    /// The ARN of the channel from which the AppInstanceUser was banned.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The ARN of the AppInstanceUser that you want to reinstate.
    /// This member is required.
    public var memberArn: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        memberArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.memberArn = memberArn
    }
}

struct DeleteChannelBanInputBody: Swift.Equatable {
}

extension DeleteChannelBanInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteChannelBanOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteChannelBanOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteChannelBanOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteChannelBanOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteChannelBanOutputResponse()"}
}

extension DeleteChannelBanOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteChannelBanOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteChannelBanOutputResponseBody: Swift.Equatable {
}

extension DeleteChannelBanOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteChannelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteChannelInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)))"}
}

extension DeleteChannelInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteChannelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let chimeBearer = input.operationInput.chimeBearer {
            input.builder.withHeader(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChannelOutputError>
}

public struct DeleteChannelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChannelOutputError>
}

public struct DeleteChannelInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChannelInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteChannelInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteChannelInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChannelOutputError>
}

public struct DeleteChannelInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChannelInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteChannelInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelArn = input.channelArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channels/\(channelArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteChannelInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChannelOutputError>
}

public struct DeleteChannelInput: Swift.Equatable {
    /// The ARN of the channel being deleted.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
    }
}

struct DeleteChannelInputBody: Swift.Equatable {
}

extension DeleteChannelInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteChannelMembershipInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteChannelMembershipInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), memberArn: \(Swift.String(describing: memberArn)))"}
}

extension DeleteChannelMembershipInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteChannelMembershipInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChannelMembershipInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteChannelMembershipInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChannelMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let chimeBearer = input.operationInput.chimeBearer {
            input.builder.withHeader(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteChannelMembershipInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChannelMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChannelMembershipOutputError>
}

public struct DeleteChannelMembershipInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChannelMembershipInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteChannelMembershipInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChannelMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteChannelMembershipInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChannelMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChannelMembershipOutputError>
}

public struct DeleteChannelMembershipInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChannelMembershipInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteChannelMembershipInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChannelMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteChannelMembershipInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChannelMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChannelMembershipOutputError>
}

public struct DeleteChannelMembershipInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChannelMembershipInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteChannelMembershipInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChannelMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelArn = input.channelArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelArn is nil and needs a value for the path of this operation"))))
        }
        guard let memberArn = input.memberArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("memberArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channels/\(channelArn.urlPercentEncoding())/memberships/\(memberArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteChannelMembershipInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChannelMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChannelMembershipOutputError>
}

public struct DeleteChannelMembershipInput: Swift.Equatable {
    /// The ARN of the channel from which you want to remove the user.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The ARN of the member that you're removing from the channel.
    /// This member is required.
    public var memberArn: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        memberArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.memberArn = memberArn
    }
}

struct DeleteChannelMembershipInputBody: Swift.Equatable {
}

extension DeleteChannelMembershipInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteChannelMembershipOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteChannelMembershipOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteChannelMembershipOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteChannelMembershipOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteChannelMembershipOutputResponse()"}
}

extension DeleteChannelMembershipOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteChannelMembershipOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteChannelMembershipOutputResponseBody: Swift.Equatable {
}

extension DeleteChannelMembershipOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteChannelMessageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteChannelMessageInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), messageId: \(Swift.String(describing: messageId)))"}
}

extension DeleteChannelMessageInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteChannelMessageInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChannelMessageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteChannelMessageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChannelMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let chimeBearer = input.operationInput.chimeBearer {
            input.builder.withHeader(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteChannelMessageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChannelMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChannelMessageOutputError>
}

public struct DeleteChannelMessageInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChannelMessageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteChannelMessageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChannelMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteChannelMessageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChannelMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChannelMessageOutputError>
}

public struct DeleteChannelMessageInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChannelMessageInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteChannelMessageInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChannelMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteChannelMessageInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChannelMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChannelMessageOutputError>
}

public struct DeleteChannelMessageInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChannelMessageInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteChannelMessageInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChannelMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelArn = input.channelArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelArn is nil and needs a value for the path of this operation"))))
        }
        guard let messageId = input.messageId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("messageId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channels/\(channelArn.urlPercentEncoding())/messages/\(messageId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteChannelMessageInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChannelMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChannelMessageOutputError>
}

public struct DeleteChannelMessageInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The ID of the message being deleted.
    /// This member is required.
    public var messageId: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        messageId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.messageId = messageId
    }
}

struct DeleteChannelMessageInputBody: Swift.Equatable {
}

extension DeleteChannelMessageInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteChannelMessageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteChannelMessageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteChannelMessageOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteChannelMessageOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteChannelMessageOutputResponse()"}
}

extension DeleteChannelMessageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteChannelMessageOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteChannelMessageOutputResponseBody: Swift.Equatable {
}

extension DeleteChannelMessageOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteChannelModeratorInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteChannelModeratorInput(channelArn: \(Swift.String(describing: channelArn)), channelModeratorArn: \(Swift.String(describing: channelModeratorArn)), chimeBearer: \(Swift.String(describing: chimeBearer)))"}
}

extension DeleteChannelModeratorInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteChannelModeratorInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChannelModeratorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteChannelModeratorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChannelModeratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let chimeBearer = input.operationInput.chimeBearer {
            input.builder.withHeader(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteChannelModeratorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChannelModeratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChannelModeratorOutputError>
}

public struct DeleteChannelModeratorInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChannelModeratorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteChannelModeratorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChannelModeratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteChannelModeratorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChannelModeratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChannelModeratorOutputError>
}

public struct DeleteChannelModeratorInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChannelModeratorInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteChannelModeratorInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChannelModeratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteChannelModeratorInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChannelModeratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChannelModeratorOutputError>
}

public struct DeleteChannelModeratorInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChannelModeratorInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteChannelModeratorInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChannelModeratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelArn = input.channelArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelArn is nil and needs a value for the path of this operation"))))
        }
        guard let channelModeratorArn = input.channelModeratorArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelModeratorArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channels/\(channelArn.urlPercentEncoding())/moderators/\(channelModeratorArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteChannelModeratorInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChannelModeratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChannelModeratorOutputError>
}

public struct DeleteChannelModeratorInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The ARN of the moderator being deleted.
    /// This member is required.
    public var channelModeratorArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        channelModeratorArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.channelModeratorArn = channelModeratorArn
        self.chimeBearer = chimeBearer
    }
}

struct DeleteChannelModeratorInputBody: Swift.Equatable {
}

extension DeleteChannelModeratorInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteChannelModeratorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteChannelModeratorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteChannelModeratorOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteChannelModeratorOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteChannelModeratorOutputResponse()"}
}

extension DeleteChannelModeratorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteChannelModeratorOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteChannelModeratorOutputResponseBody: Swift.Equatable {
}

extension DeleteChannelModeratorOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteChannelOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteChannelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteChannelOutputResponse()"}
}

extension DeleteChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteChannelOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteChannelOutputResponseBody: Swift.Equatable {
}

extension DeleteChannelOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeChannelBanInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeChannelBanInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), memberArn: \(Swift.String(describing: memberArn)))"}
}

extension DescribeChannelBanInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeChannelBanInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChannelBanInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeChannelBanInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChannelBanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let chimeBearer = input.operationInput.chimeBearer {
            input.builder.withHeader(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeChannelBanInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChannelBanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChannelBanOutputError>
}

public struct DescribeChannelBanInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChannelBanInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeChannelBanInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChannelBanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeChannelBanInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChannelBanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChannelBanOutputError>
}

public struct DescribeChannelBanInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChannelBanInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeChannelBanInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChannelBanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeChannelBanInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChannelBanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChannelBanOutputError>
}

public struct DescribeChannelBanInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChannelBanInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeChannelBanInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChannelBanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelArn = input.channelArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelArn is nil and needs a value for the path of this operation"))))
        }
        guard let memberArn = input.memberArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("memberArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channels/\(channelArn.urlPercentEncoding())/bans/\(memberArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeChannelBanInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChannelBanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChannelBanOutputError>
}

public struct DescribeChannelBanInput: Swift.Equatable {
    /// The ARN of the channel from which the user is banned.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The ARN of the member being banned.
    /// This member is required.
    public var memberArn: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        memberArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.memberArn = memberArn
    }
}

struct DescribeChannelBanInputBody: Swift.Equatable {
}

extension DescribeChannelBanInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeChannelBanOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeChannelBanOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeChannelBanOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeChannelBanOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeChannelBanOutputResponse(channelBan: \(Swift.String(describing: channelBan)))"}
}

extension DescribeChannelBanOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeChannelBanOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelBan = output.channelBan
        } else {
            self.channelBan = nil
        }
    }
}

public struct DescribeChannelBanOutputResponse: Swift.Equatable {
    /// The details of the ban.
    public var channelBan: ChimeSdkMessagingClientTypes.ChannelBan?

    public init (
        channelBan: ChimeSdkMessagingClientTypes.ChannelBan? = nil
    )
    {
        self.channelBan = channelBan
    }
}

struct DescribeChannelBanOutputResponseBody: Swift.Equatable {
    public let channelBan: ChimeSdkMessagingClientTypes.ChannelBan?
}

extension DescribeChannelBanOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelBan = "ChannelBan"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelBanDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelBan.self, forKey: .channelBan)
        channelBan = channelBanDecoded
    }
}

extension DescribeChannelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeChannelInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)))"}
}

extension DescribeChannelInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeChannelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let chimeBearer = input.operationInput.chimeBearer {
            input.builder.withHeader(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChannelOutputError>
}

public struct DescribeChannelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChannelOutputError>
}

public struct DescribeChannelInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChannelInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeChannelInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeChannelInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChannelOutputError>
}

public struct DescribeChannelInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChannelInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeChannelInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelArn = input.channelArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channels/\(channelArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeChannelInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChannelOutputError>
}

public struct DescribeChannelInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
    }
}

struct DescribeChannelInputBody: Swift.Equatable {
}

extension DescribeChannelInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeChannelMembershipForAppInstanceUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeChannelMembershipForAppInstanceUserInput(appInstanceUserArn: \(Swift.String(describing: appInstanceUserArn)), channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)))"}
}

extension DescribeChannelMembershipForAppInstanceUserInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeChannelMembershipForAppInstanceUserInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChannelMembershipForAppInstanceUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeChannelMembershipForAppInstanceUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChannelMembershipForAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let chimeBearer = input.operationInput.chimeBearer {
            input.builder.withHeader(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeChannelMembershipForAppInstanceUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChannelMembershipForAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChannelMembershipForAppInstanceUserOutputError>
}

public struct DescribeChannelMembershipForAppInstanceUserInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChannelMembershipForAppInstanceUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeChannelMembershipForAppInstanceUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChannelMembershipForAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "scope", value: "app-instance-user-membership"))
        if let appInstanceUserArn = input.operationInput.appInstanceUserArn {
            let appInstanceUserArnQueryItem = ClientRuntime.URLQueryItem(name: "app-instance-user-arn".urlPercentEncoding(), value: Swift.String(appInstanceUserArn).urlPercentEncoding())
            input.builder.withQueryItem(appInstanceUserArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeChannelMembershipForAppInstanceUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChannelMembershipForAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChannelMembershipForAppInstanceUserOutputError>
}

public struct DescribeChannelMembershipForAppInstanceUserInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChannelMembershipForAppInstanceUserInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeChannelMembershipForAppInstanceUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChannelMembershipForAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeChannelMembershipForAppInstanceUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChannelMembershipForAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChannelMembershipForAppInstanceUserOutputError>
}

public struct DescribeChannelMembershipForAppInstanceUserInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChannelMembershipForAppInstanceUserInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeChannelMembershipForAppInstanceUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChannelMembershipForAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelArn = input.channelArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channels/\(channelArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeChannelMembershipForAppInstanceUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChannelMembershipForAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChannelMembershipForAppInstanceUserOutputError>
}

public struct DescribeChannelMembershipForAppInstanceUserInput: Swift.Equatable {
    /// The ARN of the user in a channel.
    /// This member is required.
    public var appInstanceUserArn: Swift.String?
    /// The ARN of the channel to which the user belongs.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?

    public init (
        appInstanceUserArn: Swift.String? = nil,
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
    }
}

struct DescribeChannelMembershipForAppInstanceUserInputBody: Swift.Equatable {
}

extension DescribeChannelMembershipForAppInstanceUserInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeChannelMembershipForAppInstanceUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeChannelMembershipForAppInstanceUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeChannelMembershipForAppInstanceUserOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeChannelMembershipForAppInstanceUserOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeChannelMembershipForAppInstanceUserOutputResponse(channelMembership: \(Swift.String(describing: channelMembership)))"}
}

extension DescribeChannelMembershipForAppInstanceUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeChannelMembershipForAppInstanceUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelMembership = output.channelMembership
        } else {
            self.channelMembership = nil
        }
    }
}

public struct DescribeChannelMembershipForAppInstanceUserOutputResponse: Swift.Equatable {
    /// The channel to which a user belongs.
    public var channelMembership: ChimeSdkMessagingClientTypes.ChannelMembershipForAppInstanceUserSummary?

    public init (
        channelMembership: ChimeSdkMessagingClientTypes.ChannelMembershipForAppInstanceUserSummary? = nil
    )
    {
        self.channelMembership = channelMembership
    }
}

struct DescribeChannelMembershipForAppInstanceUserOutputResponseBody: Swift.Equatable {
    public let channelMembership: ChimeSdkMessagingClientTypes.ChannelMembershipForAppInstanceUserSummary?
}

extension DescribeChannelMembershipForAppInstanceUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelMembership = "ChannelMembership"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelMembershipDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelMembershipForAppInstanceUserSummary.self, forKey: .channelMembership)
        channelMembership = channelMembershipDecoded
    }
}

extension DescribeChannelMembershipInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeChannelMembershipInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), memberArn: \(Swift.String(describing: memberArn)))"}
}

extension DescribeChannelMembershipInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeChannelMembershipInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChannelMembershipInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeChannelMembershipInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChannelMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let chimeBearer = input.operationInput.chimeBearer {
            input.builder.withHeader(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeChannelMembershipInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChannelMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChannelMembershipOutputError>
}

public struct DescribeChannelMembershipInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChannelMembershipInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeChannelMembershipInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChannelMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeChannelMembershipInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChannelMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChannelMembershipOutputError>
}

public struct DescribeChannelMembershipInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChannelMembershipInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeChannelMembershipInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChannelMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeChannelMembershipInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChannelMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChannelMembershipOutputError>
}

public struct DescribeChannelMembershipInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChannelMembershipInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeChannelMembershipInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChannelMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelArn = input.channelArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelArn is nil and needs a value for the path of this operation"))))
        }
        guard let memberArn = input.memberArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("memberArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channels/\(channelArn.urlPercentEncoding())/memberships/\(memberArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeChannelMembershipInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChannelMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChannelMembershipOutputError>
}

public struct DescribeChannelMembershipInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The ARN of the member.
    /// This member is required.
    public var memberArn: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        memberArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.memberArn = memberArn
    }
}

struct DescribeChannelMembershipInputBody: Swift.Equatable {
}

extension DescribeChannelMembershipInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeChannelMembershipOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeChannelMembershipOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeChannelMembershipOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeChannelMembershipOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeChannelMembershipOutputResponse(channelMembership: \(Swift.String(describing: channelMembership)))"}
}

extension DescribeChannelMembershipOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeChannelMembershipOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelMembership = output.channelMembership
        } else {
            self.channelMembership = nil
        }
    }
}

public struct DescribeChannelMembershipOutputResponse: Swift.Equatable {
    /// The details of the membership.
    public var channelMembership: ChimeSdkMessagingClientTypes.ChannelMembership?

    public init (
        channelMembership: ChimeSdkMessagingClientTypes.ChannelMembership? = nil
    )
    {
        self.channelMembership = channelMembership
    }
}

struct DescribeChannelMembershipOutputResponseBody: Swift.Equatable {
    public let channelMembership: ChimeSdkMessagingClientTypes.ChannelMembership?
}

extension DescribeChannelMembershipOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelMembership = "ChannelMembership"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelMembershipDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelMembership.self, forKey: .channelMembership)
        channelMembership = channelMembershipDecoded
    }
}

extension DescribeChannelModeratedByAppInstanceUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeChannelModeratedByAppInstanceUserInput(appInstanceUserArn: \(Swift.String(describing: appInstanceUserArn)), channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)))"}
}

extension DescribeChannelModeratedByAppInstanceUserInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeChannelModeratedByAppInstanceUserInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChannelModeratedByAppInstanceUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeChannelModeratedByAppInstanceUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChannelModeratedByAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let chimeBearer = input.operationInput.chimeBearer {
            input.builder.withHeader(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeChannelModeratedByAppInstanceUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChannelModeratedByAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChannelModeratedByAppInstanceUserOutputError>
}

public struct DescribeChannelModeratedByAppInstanceUserInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChannelModeratedByAppInstanceUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeChannelModeratedByAppInstanceUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChannelModeratedByAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "scope", value: "app-instance-user-moderated-channel"))
        if let appInstanceUserArn = input.operationInput.appInstanceUserArn {
            let appInstanceUserArnQueryItem = ClientRuntime.URLQueryItem(name: "app-instance-user-arn".urlPercentEncoding(), value: Swift.String(appInstanceUserArn).urlPercentEncoding())
            input.builder.withQueryItem(appInstanceUserArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeChannelModeratedByAppInstanceUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChannelModeratedByAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChannelModeratedByAppInstanceUserOutputError>
}

public struct DescribeChannelModeratedByAppInstanceUserInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChannelModeratedByAppInstanceUserInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeChannelModeratedByAppInstanceUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChannelModeratedByAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeChannelModeratedByAppInstanceUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChannelModeratedByAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChannelModeratedByAppInstanceUserOutputError>
}

public struct DescribeChannelModeratedByAppInstanceUserInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChannelModeratedByAppInstanceUserInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeChannelModeratedByAppInstanceUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChannelModeratedByAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelArn = input.channelArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channels/\(channelArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeChannelModeratedByAppInstanceUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChannelModeratedByAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChannelModeratedByAppInstanceUserOutputError>
}

public struct DescribeChannelModeratedByAppInstanceUserInput: Swift.Equatable {
    /// The ARN of the AppInstanceUser in the moderated channel.
    /// This member is required.
    public var appInstanceUserArn: Swift.String?
    /// The ARN of the moderated channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?

    public init (
        appInstanceUserArn: Swift.String? = nil,
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
    }
}

struct DescribeChannelModeratedByAppInstanceUserInputBody: Swift.Equatable {
}

extension DescribeChannelModeratedByAppInstanceUserInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeChannelModeratedByAppInstanceUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeChannelModeratedByAppInstanceUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeChannelModeratedByAppInstanceUserOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeChannelModeratedByAppInstanceUserOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeChannelModeratedByAppInstanceUserOutputResponse(channel: \(Swift.String(describing: channel)))"}
}

extension DescribeChannelModeratedByAppInstanceUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeChannelModeratedByAppInstanceUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channel = output.channel
        } else {
            self.channel = nil
        }
    }
}

public struct DescribeChannelModeratedByAppInstanceUserOutputResponse: Swift.Equatable {
    /// The moderated channel.
    public var channel: ChimeSdkMessagingClientTypes.ChannelModeratedByAppInstanceUserSummary?

    public init (
        channel: ChimeSdkMessagingClientTypes.ChannelModeratedByAppInstanceUserSummary? = nil
    )
    {
        self.channel = channel
    }
}

struct DescribeChannelModeratedByAppInstanceUserOutputResponseBody: Swift.Equatable {
    public let channel: ChimeSdkMessagingClientTypes.ChannelModeratedByAppInstanceUserSummary?
}

extension DescribeChannelModeratedByAppInstanceUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channel = "Channel"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelModeratedByAppInstanceUserSummary.self, forKey: .channel)
        channel = channelDecoded
    }
}

extension DescribeChannelModeratorInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeChannelModeratorInput(channelArn: \(Swift.String(describing: channelArn)), channelModeratorArn: \(Swift.String(describing: channelModeratorArn)), chimeBearer: \(Swift.String(describing: chimeBearer)))"}
}

extension DescribeChannelModeratorInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeChannelModeratorInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChannelModeratorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeChannelModeratorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChannelModeratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let chimeBearer = input.operationInput.chimeBearer {
            input.builder.withHeader(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeChannelModeratorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChannelModeratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChannelModeratorOutputError>
}

public struct DescribeChannelModeratorInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChannelModeratorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeChannelModeratorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChannelModeratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeChannelModeratorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChannelModeratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChannelModeratorOutputError>
}

public struct DescribeChannelModeratorInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChannelModeratorInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeChannelModeratorInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChannelModeratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeChannelModeratorInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChannelModeratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChannelModeratorOutputError>
}

public struct DescribeChannelModeratorInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChannelModeratorInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeChannelModeratorInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChannelModeratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelArn = input.channelArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelArn is nil and needs a value for the path of this operation"))))
        }
        guard let channelModeratorArn = input.channelModeratorArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelModeratorArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channels/\(channelArn.urlPercentEncoding())/moderators/\(channelModeratorArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeChannelModeratorInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChannelModeratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChannelModeratorOutputError>
}

public struct DescribeChannelModeratorInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The ARN of the channel moderator.
    /// This member is required.
    public var channelModeratorArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        channelModeratorArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.channelModeratorArn = channelModeratorArn
        self.chimeBearer = chimeBearer
    }
}

struct DescribeChannelModeratorInputBody: Swift.Equatable {
}

extension DescribeChannelModeratorInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeChannelModeratorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeChannelModeratorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeChannelModeratorOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeChannelModeratorOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeChannelModeratorOutputResponse(channelModerator: \(Swift.String(describing: channelModerator)))"}
}

extension DescribeChannelModeratorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeChannelModeratorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelModerator = output.channelModerator
        } else {
            self.channelModerator = nil
        }
    }
}

public struct DescribeChannelModeratorOutputResponse: Swift.Equatable {
    /// The details of the channel moderator.
    public var channelModerator: ChimeSdkMessagingClientTypes.ChannelModerator?

    public init (
        channelModerator: ChimeSdkMessagingClientTypes.ChannelModerator? = nil
    )
    {
        self.channelModerator = channelModerator
    }
}

struct DescribeChannelModeratorOutputResponseBody: Swift.Equatable {
    public let channelModerator: ChimeSdkMessagingClientTypes.ChannelModerator?
}

extension DescribeChannelModeratorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelModerator = "ChannelModerator"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelModeratorDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelModerator.self, forKey: .channelModerator)
        channelModerator = channelModeratorDecoded
    }
}

extension DescribeChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeChannelOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeChannelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeChannelOutputResponse(channel: \(Swift.String(describing: channel)))"}
}

extension DescribeChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeChannelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channel = output.channel
        } else {
            self.channel = nil
        }
    }
}

public struct DescribeChannelOutputResponse: Swift.Equatable {
    /// The channel details.
    public var channel: ChimeSdkMessagingClientTypes.Channel?

    public init (
        channel: ChimeSdkMessagingClientTypes.Channel? = nil
    )
    {
        self.channel = channel
    }
}

struct DescribeChannelOutputResponseBody: Swift.Equatable {
    public let channel: ChimeSdkMessagingClientTypes.Channel?
}

extension DescribeChannelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channel = "Channel"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.Channel.self, forKey: .channel)
        channel = channelDecoded
    }
}

extension ChimeSdkMessagingClientTypes {
    public enum ErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessdenied
        case badrequest
        case conflict
        case forbidden
        case notfound
        case phonenumberassociationsexist
        case preconditionfailed
        case resourcelimitexceeded
        case servicefailure
        case serviceunavailable
        case throttled
        case throttling
        case unauthorized
        case unprocessable
        case voiceconnectorgroupassociationsexist
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCode] {
            return [
                .accessdenied,
                .badrequest,
                .conflict,
                .forbidden,
                .notfound,
                .phonenumberassociationsexist,
                .preconditionfailed,
                .resourcelimitexceeded,
                .servicefailure,
                .serviceunavailable,
                .throttled,
                .throttling,
                .unauthorized,
                .unprocessable,
                .voiceconnectorgroupassociationsexist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessdenied: return "AccessDenied"
            case .badrequest: return "BadRequest"
            case .conflict: return "Conflict"
            case .forbidden: return "Forbidden"
            case .notfound: return "NotFound"
            case .phonenumberassociationsexist: return "PhoneNumberAssociationsExist"
            case .preconditionfailed: return "PreconditionFailed"
            case .resourcelimitexceeded: return "ResourceLimitExceeded"
            case .servicefailure: return "ServiceFailure"
            case .serviceunavailable: return "ServiceUnavailable"
            case .throttled: return "Throttled"
            case .throttling: return "Throttling"
            case .unauthorized: return "Unauthorized"
            case .unprocessable: return "Unprocessable"
            case .voiceconnectorgroupassociationsexist: return "VoiceConnectorGroupAssociationsExist"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ErrorCode(rawValue: rawValue) ?? ErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension ForbiddenException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ForbiddenException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension ForbiddenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ForbiddenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The client is permanently forbidden from making the request.
public struct ForbiddenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeSdkMessagingClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeSdkMessagingClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ForbiddenExceptionBody: Swift.Equatable {
    public let code: ChimeSdkMessagingClientTypes.ErrorCode?
    public let message: Swift.String?
}

extension ForbiddenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GetChannelMessageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetChannelMessageInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), messageId: \(Swift.String(describing: messageId)))"}
}

extension GetChannelMessageInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetChannelMessageInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetChannelMessageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetChannelMessageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetChannelMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let chimeBearer = input.operationInput.chimeBearer {
            input.builder.withHeader(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetChannelMessageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetChannelMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetChannelMessageOutputError>
}

public struct GetChannelMessageInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetChannelMessageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetChannelMessageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetChannelMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetChannelMessageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetChannelMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetChannelMessageOutputError>
}

public struct GetChannelMessageInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetChannelMessageInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetChannelMessageInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetChannelMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetChannelMessageInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetChannelMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetChannelMessageOutputError>
}

public struct GetChannelMessageInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetChannelMessageInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetChannelMessageInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetChannelMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelArn = input.channelArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelArn is nil and needs a value for the path of this operation"))))
        }
        guard let messageId = input.messageId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("messageId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channels/\(channelArn.urlPercentEncoding())/messages/\(messageId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetChannelMessageInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetChannelMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetChannelMessageOutputError>
}

public struct GetChannelMessageInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The ID of the message.
    /// This member is required.
    public var messageId: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        messageId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.messageId = messageId
    }
}

struct GetChannelMessageInputBody: Swift.Equatable {
}

extension GetChannelMessageInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetChannelMessageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetChannelMessageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetChannelMessageOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetChannelMessageOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetChannelMessageOutputResponse(channelMessage: \(Swift.String(describing: channelMessage)))"}
}

extension GetChannelMessageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetChannelMessageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelMessage = output.channelMessage
        } else {
            self.channelMessage = nil
        }
    }
}

public struct GetChannelMessageOutputResponse: Swift.Equatable {
    /// The details of and content in the message.
    public var channelMessage: ChimeSdkMessagingClientTypes.ChannelMessage?

    public init (
        channelMessage: ChimeSdkMessagingClientTypes.ChannelMessage? = nil
    )
    {
        self.channelMessage = channelMessage
    }
}

struct GetChannelMessageOutputResponseBody: Swift.Equatable {
    public let channelMessage: ChimeSdkMessagingClientTypes.ChannelMessage?
}

extension GetChannelMessageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelMessage = "ChannelMessage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelMessageDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelMessage.self, forKey: .channelMessage)
        channelMessage = channelMessageDecoded
    }
}

extension GetMessagingSessionEndpointInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMessagingSessionEndpointInput()"}
}

extension GetMessagingSessionEndpointInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetMessagingSessionEndpointInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMessagingSessionEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetMessagingSessionEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMessagingSessionEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetMessagingSessionEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetMessagingSessionEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMessagingSessionEndpointOutputError>
}

public struct GetMessagingSessionEndpointInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMessagingSessionEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetMessagingSessionEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMessagingSessionEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetMessagingSessionEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetMessagingSessionEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMessagingSessionEndpointOutputError>
}

public struct GetMessagingSessionEndpointInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMessagingSessionEndpointInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetMessagingSessionEndpointInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMessagingSessionEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetMessagingSessionEndpointInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetMessagingSessionEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMessagingSessionEndpointOutputError>
}

public struct GetMessagingSessionEndpointInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMessagingSessionEndpointInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetMessagingSessionEndpointInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMessagingSessionEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/endpoints/messaging-session"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetMessagingSessionEndpointInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetMessagingSessionEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMessagingSessionEndpointOutputError>
}

public struct GetMessagingSessionEndpointInput: Swift.Equatable {

    public init() {}
}

struct GetMessagingSessionEndpointInputBody: Swift.Equatable {
}

extension GetMessagingSessionEndpointInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetMessagingSessionEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMessagingSessionEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMessagingSessionEndpointOutputError: Swift.Error, Swift.Equatable {
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMessagingSessionEndpointOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMessagingSessionEndpointOutputResponse(endpoint: \(Swift.String(describing: endpoint)))"}
}

extension GetMessagingSessionEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetMessagingSessionEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endpoint = output.endpoint
        } else {
            self.endpoint = nil
        }
    }
}

public struct GetMessagingSessionEndpointOutputResponse: Swift.Equatable {
    /// The endpoint returned in the response.
    public var endpoint: ChimeSdkMessagingClientTypes.MessagingSessionEndpoint?

    public init (
        endpoint: ChimeSdkMessagingClientTypes.MessagingSessionEndpoint? = nil
    )
    {
        self.endpoint = endpoint
    }
}

struct GetMessagingSessionEndpointOutputResponseBody: Swift.Equatable {
    public let endpoint: ChimeSdkMessagingClientTypes.MessagingSessionEndpoint?
}

extension GetMessagingSessionEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoint = "Endpoint"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.MessagingSessionEndpoint.self, forKey: .endpoint)
        endpoint = endpointDecoded
    }
}

extension ChimeSdkMessagingClientTypes.Identity: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension ChimeSdkMessagingClientTypes.Identity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Identity(arn: \(Swift.String(describing: arn)), name: \(Swift.String(describing: name)))"}
}

extension ChimeSdkMessagingClientTypes {
    /// The details of a user.
    public struct Identity: Swift.Equatable {
        /// The ARN in an Identity.
        public var arn: Swift.String?
        /// The name in an Identity.
        public var name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.name = name
        }
    }

}

extension ListChannelBansInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelBansInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListChannelBansInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListChannelBansInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelBansInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListChannelBansInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelBansOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let chimeBearer = input.operationInput.chimeBearer {
            input.builder.withHeader(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListChannelBansInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelBansOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelBansOutputError>
}

public struct ListChannelBansInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelBansInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListChannelBansInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelBansOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListChannelBansInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelBansOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelBansOutputError>
}

public struct ListChannelBansInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelBansInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListChannelBansInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelBansOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListChannelBansInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelBansOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelBansOutputError>
}

public struct ListChannelBansInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelBansInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListChannelBansInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelBansOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelArn = input.channelArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channels/\(channelArn.urlPercentEncoding())/bans"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListChannelBansInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelBansOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelBansOutputError>
}

public struct ListChannelBansInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The maximum number of bans that you want returned.
    public var maxResults: Swift.Int?
    /// The token passed by previous API calls until all requested bans are returned.
    public var nextToken: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListChannelBansInputBody: Swift.Equatable {
}

extension ListChannelBansInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListChannelBansOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListChannelBansOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListChannelBansOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListChannelBansOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelBansOutputResponse(channelArn: \(Swift.String(describing: channelArn)), channelBans: \(Swift.String(describing: channelBans)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListChannelBansOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListChannelBansOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.channelBans = output.channelBans
            self.nextToken = output.nextToken
        } else {
            self.channelArn = nil
            self.channelBans = nil
            self.nextToken = nil
        }
    }
}

public struct ListChannelBansOutputResponse: Swift.Equatable {
    /// The ARN of the channel.
    public var channelArn: Swift.String?
    /// The information for each requested ban.
    public var channelBans: [ChimeSdkMessagingClientTypes.ChannelBanSummary]?
    /// The token passed by previous API calls until all requested bans are returned.
    public var nextToken: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        channelBans: [ChimeSdkMessagingClientTypes.ChannelBanSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.channelBans = channelBans
        self.nextToken = nextToken
    }
}

struct ListChannelBansOutputResponseBody: Swift.Equatable {
    public let channelArn: Swift.String?
    public let nextToken: Swift.String?
    public let channelBans: [ChimeSdkMessagingClientTypes.ChannelBanSummary]?
}

extension ListChannelBansOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case channelBans = "ChannelBans"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let channelBansContainer = try containerValues.decodeIfPresent([ChimeSdkMessagingClientTypes.ChannelBanSummary?].self, forKey: .channelBans)
        var channelBansDecoded0:[ChimeSdkMessagingClientTypes.ChannelBanSummary]? = nil
        if let channelBansContainer = channelBansContainer {
            channelBansDecoded0 = [ChimeSdkMessagingClientTypes.ChannelBanSummary]()
            for structure0 in channelBansContainer {
                if let structure0 = structure0 {
                    channelBansDecoded0?.append(structure0)
                }
            }
        }
        channelBans = channelBansDecoded0
    }
}

extension ListChannelMembershipsForAppInstanceUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelMembershipsForAppInstanceUserInput(appInstanceUserArn: \(Swift.String(describing: appInstanceUserArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListChannelMembershipsForAppInstanceUserInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListChannelMembershipsForAppInstanceUserInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelMembershipsForAppInstanceUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListChannelMembershipsForAppInstanceUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelMembershipsForAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let chimeBearer = input.operationInput.chimeBearer {
            input.builder.withHeader(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListChannelMembershipsForAppInstanceUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelMembershipsForAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelMembershipsForAppInstanceUserOutputError>
}

public struct ListChannelMembershipsForAppInstanceUserInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelMembershipsForAppInstanceUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListChannelMembershipsForAppInstanceUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelMembershipsForAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "scope", value: "app-instance-user-memberships"))
        if let appInstanceUserArn = input.operationInput.appInstanceUserArn {
            let appInstanceUserArnQueryItem = ClientRuntime.URLQueryItem(name: "app-instance-user-arn".urlPercentEncoding(), value: Swift.String(appInstanceUserArn).urlPercentEncoding())
            input.builder.withQueryItem(appInstanceUserArnQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListChannelMembershipsForAppInstanceUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelMembershipsForAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelMembershipsForAppInstanceUserOutputError>
}

public struct ListChannelMembershipsForAppInstanceUserInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelMembershipsForAppInstanceUserInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListChannelMembershipsForAppInstanceUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelMembershipsForAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListChannelMembershipsForAppInstanceUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelMembershipsForAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelMembershipsForAppInstanceUserOutputError>
}

public struct ListChannelMembershipsForAppInstanceUserInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelMembershipsForAppInstanceUserInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListChannelMembershipsForAppInstanceUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelMembershipsForAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/channels"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListChannelMembershipsForAppInstanceUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelMembershipsForAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelMembershipsForAppInstanceUserOutputError>
}

public struct ListChannelMembershipsForAppInstanceUserInput: Swift.Equatable {
    /// The ARN of the AppInstanceUsers
    public var appInstanceUserArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The maximum number of users that you want returned.
    public var maxResults: Swift.Int?
    /// The token returned from previous API requests until the number of channel memberships is reached.
    public var nextToken: Swift.String?

    public init (
        appInstanceUserArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
        self.chimeBearer = chimeBearer
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListChannelMembershipsForAppInstanceUserInputBody: Swift.Equatable {
}

extension ListChannelMembershipsForAppInstanceUserInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListChannelMembershipsForAppInstanceUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListChannelMembershipsForAppInstanceUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListChannelMembershipsForAppInstanceUserOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListChannelMembershipsForAppInstanceUserOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelMembershipsForAppInstanceUserOutputResponse(channelMemberships: \(Swift.String(describing: channelMemberships)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListChannelMembershipsForAppInstanceUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListChannelMembershipsForAppInstanceUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelMemberships = output.channelMemberships
            self.nextToken = output.nextToken
        } else {
            self.channelMemberships = nil
            self.nextToken = nil
        }
    }
}

public struct ListChannelMembershipsForAppInstanceUserOutputResponse: Swift.Equatable {
    /// The token passed by previous API calls until all requested users are returned.
    public var channelMemberships: [ChimeSdkMessagingClientTypes.ChannelMembershipForAppInstanceUserSummary]?
    /// The token passed by previous API calls until all requested users are returned.
    public var nextToken: Swift.String?

    public init (
        channelMemberships: [ChimeSdkMessagingClientTypes.ChannelMembershipForAppInstanceUserSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelMemberships = channelMemberships
        self.nextToken = nextToken
    }
}

struct ListChannelMembershipsForAppInstanceUserOutputResponseBody: Swift.Equatable {
    public let channelMemberships: [ChimeSdkMessagingClientTypes.ChannelMembershipForAppInstanceUserSummary]?
    public let nextToken: Swift.String?
}

extension ListChannelMembershipsForAppInstanceUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelMemberships = "ChannelMemberships"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelMembershipsContainer = try containerValues.decodeIfPresent([ChimeSdkMessagingClientTypes.ChannelMembershipForAppInstanceUserSummary?].self, forKey: .channelMemberships)
        var channelMembershipsDecoded0:[ChimeSdkMessagingClientTypes.ChannelMembershipForAppInstanceUserSummary]? = nil
        if let channelMembershipsContainer = channelMembershipsContainer {
            channelMembershipsDecoded0 = [ChimeSdkMessagingClientTypes.ChannelMembershipForAppInstanceUserSummary]()
            for structure0 in channelMembershipsContainer {
                if let structure0 = structure0 {
                    channelMembershipsDecoded0?.append(structure0)
                }
            }
        }
        channelMemberships = channelMembershipsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListChannelMembershipsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelMembershipsInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), type: \(Swift.String(describing: type)))"}
}

extension ListChannelMembershipsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListChannelMembershipsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelMembershipsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListChannelMembershipsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelMembershipsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let chimeBearer = input.operationInput.chimeBearer {
            input.builder.withHeader(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListChannelMembershipsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelMembershipsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelMembershipsOutputError>
}

public struct ListChannelMembershipsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelMembershipsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListChannelMembershipsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelMembershipsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let type = input.operationInput.type {
            let typeQueryItem = ClientRuntime.URLQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(typeQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListChannelMembershipsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelMembershipsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelMembershipsOutputError>
}

public struct ListChannelMembershipsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelMembershipsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListChannelMembershipsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelMembershipsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListChannelMembershipsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelMembershipsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelMembershipsOutputError>
}

public struct ListChannelMembershipsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelMembershipsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListChannelMembershipsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelMembershipsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelArn = input.channelArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channels/\(channelArn.urlPercentEncoding())/memberships"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListChannelMembershipsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelMembershipsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelMembershipsOutputError>
}

public struct ListChannelMembershipsInput: Swift.Equatable {
    /// The maximum number of channel memberships that you want returned.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The maximum number of channel memberships that you want returned.
    public var maxResults: Swift.Int?
    /// The token passed by previous API calls until all requested channel memberships are returned.
    public var nextToken: Swift.String?
    /// The membership type of a user, DEFAULT or HIDDEN. Default members are always returned as part of ListChannelMemberships. Hidden members are only returned if the type filter in ListChannelMemberships equals HIDDEN. Otherwise hidden members are not returned.
    public var type: ChimeSdkMessagingClientTypes.ChannelMembershipType?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        type: ChimeSdkMessagingClientTypes.ChannelMembershipType? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.type = type
    }
}

struct ListChannelMembershipsInputBody: Swift.Equatable {
}

extension ListChannelMembershipsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListChannelMembershipsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListChannelMembershipsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListChannelMembershipsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListChannelMembershipsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelMembershipsOutputResponse(channelArn: \(Swift.String(describing: channelArn)), channelMemberships: \(Swift.String(describing: channelMemberships)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListChannelMembershipsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListChannelMembershipsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.channelMemberships = output.channelMemberships
            self.nextToken = output.nextToken
        } else {
            self.channelArn = nil
            self.channelMemberships = nil
            self.nextToken = nil
        }
    }
}

public struct ListChannelMembershipsOutputResponse: Swift.Equatable {
    /// The ARN of the channel.
    public var channelArn: Swift.String?
    /// The information for the requested channel memberships.
    public var channelMemberships: [ChimeSdkMessagingClientTypes.ChannelMembershipSummary]?
    /// The token passed by previous API calls until all requested channel memberships are returned.
    public var nextToken: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        channelMemberships: [ChimeSdkMessagingClientTypes.ChannelMembershipSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.channelMemberships = channelMemberships
        self.nextToken = nextToken
    }
}

struct ListChannelMembershipsOutputResponseBody: Swift.Equatable {
    public let channelArn: Swift.String?
    public let channelMemberships: [ChimeSdkMessagingClientTypes.ChannelMembershipSummary]?
    public let nextToken: Swift.String?
}

extension ListChannelMembershipsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case channelMemberships = "ChannelMemberships"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let channelMembershipsContainer = try containerValues.decodeIfPresent([ChimeSdkMessagingClientTypes.ChannelMembershipSummary?].self, forKey: .channelMemberships)
        var channelMembershipsDecoded0:[ChimeSdkMessagingClientTypes.ChannelMembershipSummary]? = nil
        if let channelMembershipsContainer = channelMembershipsContainer {
            channelMembershipsDecoded0 = [ChimeSdkMessagingClientTypes.ChannelMembershipSummary]()
            for structure0 in channelMembershipsContainer {
                if let structure0 = structure0 {
                    channelMembershipsDecoded0?.append(structure0)
                }
            }
        }
        channelMemberships = channelMembershipsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListChannelMessagesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelMessagesInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), notAfter: \(Swift.String(describing: notAfter)), notBefore: \(Swift.String(describing: notBefore)), sortOrder: \(Swift.String(describing: sortOrder)))"}
}

extension ListChannelMessagesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListChannelMessagesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelMessagesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListChannelMessagesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelMessagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let chimeBearer = input.operationInput.chimeBearer {
            input.builder.withHeader(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListChannelMessagesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelMessagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelMessagesOutputError>
}

public struct ListChannelMessagesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelMessagesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListChannelMessagesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelMessagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let sortOrder = input.operationInput.sortOrder {
            let sortOrderQueryItem = ClientRuntime.URLQueryItem(name: "sort-order".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(sortOrderQueryItem)
        }
        if let notBefore = input.operationInput.notBefore {
            let notBeforeQueryItem = ClientRuntime.URLQueryItem(name: "not-before".urlPercentEncoding(), value: Swift.String(notBefore.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(notBeforeQueryItem)
        }
        if let notAfter = input.operationInput.notAfter {
            let notAfterQueryItem = ClientRuntime.URLQueryItem(name: "not-after".urlPercentEncoding(), value: Swift.String(notAfter.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(notAfterQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListChannelMessagesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelMessagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelMessagesOutputError>
}

public struct ListChannelMessagesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelMessagesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListChannelMessagesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelMessagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListChannelMessagesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelMessagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelMessagesOutputError>
}

public struct ListChannelMessagesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelMessagesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListChannelMessagesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelMessagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelArn = input.channelArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channels/\(channelArn.urlPercentEncoding())/messages"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListChannelMessagesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelMessagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelMessagesOutputError>
}

public struct ListChannelMessagesInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The maximum number of messages that you want returned.
    public var maxResults: Swift.Int?
    /// The token passed by previous API calls until all requested messages are returned.
    public var nextToken: Swift.String?
    /// The final or ending time stamp for your requested messages.
    public var notAfter: ClientRuntime.Date?
    /// The initial or starting time stamp for your requested messages.
    public var notBefore: ClientRuntime.Date?
    /// The order in which you want messages sorted. Default is Descending, based on time created.
    public var sortOrder: ChimeSdkMessagingClientTypes.SortOrder?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        notAfter: ClientRuntime.Date? = nil,
        notBefore: ClientRuntime.Date? = nil,
        sortOrder: ChimeSdkMessagingClientTypes.SortOrder? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.notAfter = notAfter
        self.notBefore = notBefore
        self.sortOrder = sortOrder
    }
}

struct ListChannelMessagesInputBody: Swift.Equatable {
}

extension ListChannelMessagesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListChannelMessagesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListChannelMessagesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListChannelMessagesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListChannelMessagesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelMessagesOutputResponse(channelArn: \(Swift.String(describing: channelArn)), channelMessages: \(Swift.String(describing: channelMessages)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListChannelMessagesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListChannelMessagesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.channelMessages = output.channelMessages
            self.nextToken = output.nextToken
        } else {
            self.channelArn = nil
            self.channelMessages = nil
            self.nextToken = nil
        }
    }
}

public struct ListChannelMessagesOutputResponse: Swift.Equatable {
    /// The ARN of the channel containing the requested messages.
    public var channelArn: Swift.String?
    /// The information about, and content of, each requested message.
    public var channelMessages: [ChimeSdkMessagingClientTypes.ChannelMessageSummary]?
    /// The token passed by previous API calls until all requested messages are returned.
    public var nextToken: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        channelMessages: [ChimeSdkMessagingClientTypes.ChannelMessageSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.channelMessages = channelMessages
        self.nextToken = nextToken
    }
}

struct ListChannelMessagesOutputResponseBody: Swift.Equatable {
    public let channelArn: Swift.String?
    public let nextToken: Swift.String?
    public let channelMessages: [ChimeSdkMessagingClientTypes.ChannelMessageSummary]?
}

extension ListChannelMessagesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case channelMessages = "ChannelMessages"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let channelMessagesContainer = try containerValues.decodeIfPresent([ChimeSdkMessagingClientTypes.ChannelMessageSummary?].self, forKey: .channelMessages)
        var channelMessagesDecoded0:[ChimeSdkMessagingClientTypes.ChannelMessageSummary]? = nil
        if let channelMessagesContainer = channelMessagesContainer {
            channelMessagesDecoded0 = [ChimeSdkMessagingClientTypes.ChannelMessageSummary]()
            for structure0 in channelMessagesContainer {
                if let structure0 = structure0 {
                    channelMessagesDecoded0?.append(structure0)
                }
            }
        }
        channelMessages = channelMessagesDecoded0
    }
}

extension ListChannelModeratorsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelModeratorsInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListChannelModeratorsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListChannelModeratorsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelModeratorsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListChannelModeratorsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelModeratorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let chimeBearer = input.operationInput.chimeBearer {
            input.builder.withHeader(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListChannelModeratorsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelModeratorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelModeratorsOutputError>
}

public struct ListChannelModeratorsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelModeratorsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListChannelModeratorsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelModeratorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListChannelModeratorsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelModeratorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelModeratorsOutputError>
}

public struct ListChannelModeratorsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelModeratorsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListChannelModeratorsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelModeratorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListChannelModeratorsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelModeratorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelModeratorsOutputError>
}

public struct ListChannelModeratorsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelModeratorsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListChannelModeratorsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelModeratorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelArn = input.channelArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channels/\(channelArn.urlPercentEncoding())/moderators"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListChannelModeratorsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelModeratorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelModeratorsOutputError>
}

public struct ListChannelModeratorsInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The maximum number of moderators that you want returned.
    public var maxResults: Swift.Int?
    /// The token passed by previous API calls until all requested moderators are returned.
    public var nextToken: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListChannelModeratorsInputBody: Swift.Equatable {
}

extension ListChannelModeratorsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListChannelModeratorsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListChannelModeratorsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListChannelModeratorsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListChannelModeratorsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelModeratorsOutputResponse(channelArn: \(Swift.String(describing: channelArn)), channelModerators: \(Swift.String(describing: channelModerators)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListChannelModeratorsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListChannelModeratorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.channelModerators = output.channelModerators
            self.nextToken = output.nextToken
        } else {
            self.channelArn = nil
            self.channelModerators = nil
            self.nextToken = nil
        }
    }
}

public struct ListChannelModeratorsOutputResponse: Swift.Equatable {
    /// The ARN of the channel.
    public var channelArn: Swift.String?
    /// The information about and names of each moderator.
    public var channelModerators: [ChimeSdkMessagingClientTypes.ChannelModeratorSummary]?
    /// The token passed by previous API calls until all requested moderators are returned.
    public var nextToken: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        channelModerators: [ChimeSdkMessagingClientTypes.ChannelModeratorSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.channelModerators = channelModerators
        self.nextToken = nextToken
    }
}

struct ListChannelModeratorsOutputResponseBody: Swift.Equatable {
    public let channelArn: Swift.String?
    public let nextToken: Swift.String?
    public let channelModerators: [ChimeSdkMessagingClientTypes.ChannelModeratorSummary]?
}

extension ListChannelModeratorsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case channelModerators = "ChannelModerators"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let channelModeratorsContainer = try containerValues.decodeIfPresent([ChimeSdkMessagingClientTypes.ChannelModeratorSummary?].self, forKey: .channelModerators)
        var channelModeratorsDecoded0:[ChimeSdkMessagingClientTypes.ChannelModeratorSummary]? = nil
        if let channelModeratorsContainer = channelModeratorsContainer {
            channelModeratorsDecoded0 = [ChimeSdkMessagingClientTypes.ChannelModeratorSummary]()
            for structure0 in channelModeratorsContainer {
                if let structure0 = structure0 {
                    channelModeratorsDecoded0?.append(structure0)
                }
            }
        }
        channelModerators = channelModeratorsDecoded0
    }
}

extension ListChannelsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelsInput(appInstanceArn: \(Swift.String(describing: appInstanceArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), privacy: \(Swift.String(describing: privacy)))"}
}

extension ListChannelsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListChannelsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListChannelsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let chimeBearer = input.operationInput.chimeBearer {
            input.builder.withHeader(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListChannelsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelsOutputError>
}

public struct ListChannelsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListChannelsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let privacy = input.operationInput.privacy {
            let privacyQueryItem = ClientRuntime.URLQueryItem(name: "privacy".urlPercentEncoding(), value: Swift.String(privacy.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(privacyQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let appInstanceArn = input.operationInput.appInstanceArn {
            let appInstanceArnQueryItem = ClientRuntime.URLQueryItem(name: "app-instance-arn".urlPercentEncoding(), value: Swift.String(appInstanceArn).urlPercentEncoding())
            input.builder.withQueryItem(appInstanceArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListChannelsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelsOutputError>
}

public struct ListChannelsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListChannelsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListChannelsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelsOutputError>
}

public struct ListChannelsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListChannelsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/channels"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListChannelsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelsOutputError>
}

public struct ListChannelsInput: Swift.Equatable {
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The maximum number of channels that you want to return.
    public var maxResults: Swift.Int?
    /// The token passed by previous API calls until all requested channels are returned.
    public var nextToken: Swift.String?
    /// The privacy setting. PUBLIC retrieves all the public channels. PRIVATE retrieves private channels. Only an AppInstanceAdmin can retrieve private channels.
    public var privacy: ChimeSdkMessagingClientTypes.ChannelPrivacy?

    public init (
        appInstanceArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        privacy: ChimeSdkMessagingClientTypes.ChannelPrivacy? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.chimeBearer = chimeBearer
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.privacy = privacy
    }
}

struct ListChannelsInputBody: Swift.Equatable {
}

extension ListChannelsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListChannelsModeratedByAppInstanceUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelsModeratedByAppInstanceUserInput(appInstanceUserArn: \(Swift.String(describing: appInstanceUserArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListChannelsModeratedByAppInstanceUserInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListChannelsModeratedByAppInstanceUserInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelsModeratedByAppInstanceUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListChannelsModeratedByAppInstanceUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelsModeratedByAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let chimeBearer = input.operationInput.chimeBearer {
            input.builder.withHeader(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListChannelsModeratedByAppInstanceUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelsModeratedByAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelsModeratedByAppInstanceUserOutputError>
}

public struct ListChannelsModeratedByAppInstanceUserInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelsModeratedByAppInstanceUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListChannelsModeratedByAppInstanceUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelsModeratedByAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "scope", value: "app-instance-user-moderated-channels"))
        if let appInstanceUserArn = input.operationInput.appInstanceUserArn {
            let appInstanceUserArnQueryItem = ClientRuntime.URLQueryItem(name: "app-instance-user-arn".urlPercentEncoding(), value: Swift.String(appInstanceUserArn).urlPercentEncoding())
            input.builder.withQueryItem(appInstanceUserArnQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListChannelsModeratedByAppInstanceUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelsModeratedByAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelsModeratedByAppInstanceUserOutputError>
}

public struct ListChannelsModeratedByAppInstanceUserInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelsModeratedByAppInstanceUserInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListChannelsModeratedByAppInstanceUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelsModeratedByAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListChannelsModeratedByAppInstanceUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelsModeratedByAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelsModeratedByAppInstanceUserOutputError>
}

public struct ListChannelsModeratedByAppInstanceUserInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelsModeratedByAppInstanceUserInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListChannelsModeratedByAppInstanceUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelsModeratedByAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/channels"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListChannelsModeratedByAppInstanceUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelsModeratedByAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelsModeratedByAppInstanceUserOutputError>
}

public struct ListChannelsModeratedByAppInstanceUserInput: Swift.Equatable {
    /// The ARN of the user in the moderated channel.
    public var appInstanceUserArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The maximum number of channels in the request.
    public var maxResults: Swift.Int?
    /// The token returned from previous API requests until the number of channels moderated by the user is reached.
    public var nextToken: Swift.String?

    public init (
        appInstanceUserArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
        self.chimeBearer = chimeBearer
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListChannelsModeratedByAppInstanceUserInputBody: Swift.Equatable {
}

extension ListChannelsModeratedByAppInstanceUserInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListChannelsModeratedByAppInstanceUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListChannelsModeratedByAppInstanceUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListChannelsModeratedByAppInstanceUserOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListChannelsModeratedByAppInstanceUserOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelsModeratedByAppInstanceUserOutputResponse(channels: \(Swift.String(describing: channels)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListChannelsModeratedByAppInstanceUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListChannelsModeratedByAppInstanceUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channels = output.channels
            self.nextToken = output.nextToken
        } else {
            self.channels = nil
            self.nextToken = nil
        }
    }
}

public struct ListChannelsModeratedByAppInstanceUserOutputResponse: Swift.Equatable {
    /// The moderated channels in the request.
    public var channels: [ChimeSdkMessagingClientTypes.ChannelModeratedByAppInstanceUserSummary]?
    /// The token returned from previous API requests until the number of channels moderated by the user is reached.
    public var nextToken: Swift.String?

    public init (
        channels: [ChimeSdkMessagingClientTypes.ChannelModeratedByAppInstanceUserSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channels = channels
        self.nextToken = nextToken
    }
}

struct ListChannelsModeratedByAppInstanceUserOutputResponseBody: Swift.Equatable {
    public let channels: [ChimeSdkMessagingClientTypes.ChannelModeratedByAppInstanceUserSummary]?
    public let nextToken: Swift.String?
}

extension ListChannelsModeratedByAppInstanceUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channels = "Channels"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelsContainer = try containerValues.decodeIfPresent([ChimeSdkMessagingClientTypes.ChannelModeratedByAppInstanceUserSummary?].self, forKey: .channels)
        var channelsDecoded0:[ChimeSdkMessagingClientTypes.ChannelModeratedByAppInstanceUserSummary]? = nil
        if let channelsContainer = channelsContainer {
            channelsDecoded0 = [ChimeSdkMessagingClientTypes.ChannelModeratedByAppInstanceUserSummary]()
            for structure0 in channelsContainer {
                if let structure0 = structure0 {
                    channelsDecoded0?.append(structure0)
                }
            }
        }
        channels = channelsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListChannelsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListChannelsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListChannelsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListChannelsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelsOutputResponse(channels: \(Swift.String(describing: channels)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListChannelsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListChannelsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channels = output.channels
            self.nextToken = output.nextToken
        } else {
            self.channels = nil
            self.nextToken = nil
        }
    }
}

public struct ListChannelsOutputResponse: Swift.Equatable {
    /// The information about each channel.
    public var channels: [ChimeSdkMessagingClientTypes.ChannelSummary]?
    /// The token returned from previous API requests until the number of channels is reached.
    public var nextToken: Swift.String?

    public init (
        channels: [ChimeSdkMessagingClientTypes.ChannelSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channels = channels
        self.nextToken = nextToken
    }
}

struct ListChannelsOutputResponseBody: Swift.Equatable {
    public let channels: [ChimeSdkMessagingClientTypes.ChannelSummary]?
    public let nextToken: Swift.String?
}

extension ListChannelsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channels = "Channels"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelsContainer = try containerValues.decodeIfPresent([ChimeSdkMessagingClientTypes.ChannelSummary?].self, forKey: .channels)
        var channelsDecoded0:[ChimeSdkMessagingClientTypes.ChannelSummary]? = nil
        if let channelsContainer = channelsContainer {
            channelsDecoded0 = [ChimeSdkMessagingClientTypes.ChannelSummary]()
            for structure0 in channelsContainer {
                if let structure0 = structure0 {
                    channelsDecoded0?.append(structure0)
                }
            }
        }
        channels = channelsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ChimeSdkMessagingClientTypes.MessagingSessionEndpoint: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case url = "Url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension ChimeSdkMessagingClientTypes.MessagingSessionEndpoint: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MessagingSessionEndpoint(url: \(Swift.String(describing: url)))"}
}

extension ChimeSdkMessagingClientTypes {
    /// The websocket endpoint used to connect to Amazon Chime SDK messaging.
    public struct MessagingSessionEndpoint: Swift.Equatable {
        /// The endpoint to which you establish a websocket connection.
        public var url: Swift.String?

        public init (
            url: Swift.String? = nil
        )
        {
            self.url = url
        }
    }

}

extension NotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotFoundException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension NotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more of the resources in the request does not exist in the system.
public struct NotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeSdkMessagingClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeSdkMessagingClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    public let code: ChimeSdkMessagingClientTypes.ErrorCode?
    public let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RedactChannelMessageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RedactChannelMessageInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), messageId: \(Swift.String(describing: messageId)))"}
}

extension RedactChannelMessageInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct RedactChannelMessageInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RedactChannelMessageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RedactChannelMessageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RedactChannelMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let chimeBearer = input.operationInput.chimeBearer {
            input.builder.withHeader(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RedactChannelMessageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RedactChannelMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RedactChannelMessageOutputError>
}

public struct RedactChannelMessageInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RedactChannelMessageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RedactChannelMessageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RedactChannelMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "operation", value: "redact"))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RedactChannelMessageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RedactChannelMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RedactChannelMessageOutputError>
}

public struct RedactChannelMessageInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RedactChannelMessageInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: RedactChannelMessageInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RedactChannelMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RedactChannelMessageInput
    public typealias MOutput = ClientRuntime.OperationOutput<RedactChannelMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RedactChannelMessageOutputError>
}

public struct RedactChannelMessageInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RedactChannelMessageInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: RedactChannelMessageInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RedactChannelMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelArn = input.channelArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelArn is nil and needs a value for the path of this operation"))))
        }
        guard let messageId = input.messageId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("messageId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channels/\(channelArn.urlPercentEncoding())/messages/\(messageId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RedactChannelMessageInput
    public typealias MOutput = ClientRuntime.OperationOutput<RedactChannelMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RedactChannelMessageOutputError>
}

public struct RedactChannelMessageInput: Swift.Equatable {
    /// The ARN of the channel containing the messages that you want to redact.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The ID of the message being redacted.
    /// This member is required.
    public var messageId: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        messageId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.messageId = messageId
    }
}

struct RedactChannelMessageInputBody: Swift.Equatable {
}

extension RedactChannelMessageInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension RedactChannelMessageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RedactChannelMessageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RedactChannelMessageOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RedactChannelMessageOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RedactChannelMessageOutputResponse(channelArn: \(Swift.String(describing: channelArn)), messageId: \(Swift.String(describing: messageId)))"}
}

extension RedactChannelMessageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RedactChannelMessageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.messageId = output.messageId
        } else {
            self.channelArn = nil
            self.messageId = nil
        }
    }
}

public struct RedactChannelMessageOutputResponse: Swift.Equatable {
    /// The ARN of the channel containing the messages that you want to redact.
    public var channelArn: Swift.String?
    /// The ID of the message being redacted.
    public var messageId: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        messageId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.messageId = messageId
    }
}

struct RedactChannelMessageOutputResponseBody: Swift.Equatable {
    public let channelArn: Swift.String?
    public let messageId: Swift.String?
}

extension RedactChannelMessageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case messageId = "MessageId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
    }
}

extension ResourceLimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceLimitExceededException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension ResourceLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request exceeds the resource limit.
public struct ResourceLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeSdkMessagingClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeSdkMessagingClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ResourceLimitExceededExceptionBody: Swift.Equatable {
    public let code: ChimeSdkMessagingClientTypes.ErrorCode?
    public let message: Swift.String?
}

extension ResourceLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct SendChannelMessageInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SendChannelMessageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SendChannelMessageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SendChannelMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SendChannelMessageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SendChannelMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SendChannelMessageOutputError>
}

extension SendChannelMessageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SendChannelMessageInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), clientRequestToken: \(Swift.String(describing: clientRequestToken)), content: \(Swift.String(describing: content)), metadata: \(Swift.String(describing: metadata)), persistence: \(Swift.String(describing: persistence)), type: \(Swift.String(describing: type)))"}
}

extension SendChannelMessageInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case content = "Content"
        case metadata = "Metadata"
        case persistence = "Persistence"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let persistence = persistence {
            try encodeContainer.encode(persistence.rawValue, forKey: .persistence)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct SendChannelMessageInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SendChannelMessageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SendChannelMessageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SendChannelMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let chimeBearer = input.operationInput.chimeBearer {
            input.builder.withHeader(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SendChannelMessageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SendChannelMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SendChannelMessageOutputError>
}

public struct SendChannelMessageInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SendChannelMessageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SendChannelMessageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SendChannelMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SendChannelMessageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SendChannelMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SendChannelMessageOutputError>
}

public struct SendChannelMessageInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SendChannelMessageInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: SendChannelMessageInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SendChannelMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = SendChannelMessageInput
    public typealias MOutput = ClientRuntime.OperationOutput<SendChannelMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SendChannelMessageOutputError>
}

public struct SendChannelMessageInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SendChannelMessageInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: SendChannelMessageInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SendChannelMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelArn = input.channelArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channels/\(channelArn.urlPercentEncoding())/messages"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = SendChannelMessageInput
    public typealias MOutput = ClientRuntime.OperationOutput<SendChannelMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SendChannelMessageOutputError>
}

public struct SendChannelMessageInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The Idempotency token for each client request.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The content of the message.
    /// This member is required.
    public var content: Swift.String?
    /// The optional metadata for each message.
    public var metadata: Swift.String?
    /// Boolean that controls whether the message is persisted on the back end. Required.
    /// This member is required.
    public var persistence: ChimeSdkMessagingClientTypes.ChannelMessagePersistenceType?
    /// The type of message, STANDARD or CONTROL.
    /// This member is required.
    public var type: ChimeSdkMessagingClientTypes.ChannelMessageType?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        content: Swift.String? = nil,
        metadata: Swift.String? = nil,
        persistence: ChimeSdkMessagingClientTypes.ChannelMessagePersistenceType? = nil,
        type: ChimeSdkMessagingClientTypes.ChannelMessageType? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.clientRequestToken = clientRequestToken
        self.content = content
        self.metadata = metadata
        self.persistence = persistence
        self.type = type
    }
}

struct SendChannelMessageInputBody: Swift.Equatable {
    public let content: Swift.String?
    public let type: ChimeSdkMessagingClientTypes.ChannelMessageType?
    public let persistence: ChimeSdkMessagingClientTypes.ChannelMessagePersistenceType?
    public let metadata: Swift.String?
    public let clientRequestToken: Swift.String?
}

extension SendChannelMessageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case content = "Content"
        case metadata = "Metadata"
        case persistence = "Persistence"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelMessageType.self, forKey: .type)
        type = typeDecoded
        let persistenceDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelMessagePersistenceType.self, forKey: .persistence)
        persistence = persistenceDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension SendChannelMessageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendChannelMessageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendChannelMessageOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendChannelMessageOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SendChannelMessageOutputResponse(channelArn: \(Swift.String(describing: channelArn)), messageId: \(Swift.String(describing: messageId)))"}
}

extension SendChannelMessageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SendChannelMessageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.messageId = output.messageId
        } else {
            self.channelArn = nil
            self.messageId = nil
        }
    }
}

public struct SendChannelMessageOutputResponse: Swift.Equatable {
    /// The ARN of the channel.
    public var channelArn: Swift.String?
    /// The ID string assigned to each message.
    public var messageId: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        messageId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.messageId = messageId
    }
}

struct SendChannelMessageOutputResponseBody: Swift.Equatable {
    public let channelArn: Swift.String?
    public let messageId: Swift.String?
}

extension SendChannelMessageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case messageId = "MessageId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
    }
}

extension ServiceFailureException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceFailureException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension ServiceFailureException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The service encountered an unexpected error.
public struct ServiceFailureException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var code: ChimeSdkMessagingClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeSdkMessagingClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ServiceFailureExceptionBody: Swift.Equatable {
    public let code: ChimeSdkMessagingClientTypes.ErrorCode?
    public let message: Swift.String?
}

extension ServiceFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceUnavailableException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceUnavailableException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension ServiceUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The service is currently unavailable.
public struct ServiceUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var code: ChimeSdkMessagingClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeSdkMessagingClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    public let code: ChimeSdkMessagingClientTypes.ErrorCode?
    public let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ChimeSdkMessagingClientTypes {
    public enum SortOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortOrder(rawValue: rawValue) ?? SortOrder.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSdkMessagingClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ChimeSdkMessagingClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension ChimeSdkMessagingClientTypes {
    /// Describes a tag applied to a resource.
    public struct Tag: Swift.Equatable {
        /// The key of the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the tag.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension ThrottledClientException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ThrottledClientException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension ThrottledClientException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottledClientExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The client exceeded its request rate limit.
public struct ThrottledClientException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeSdkMessagingClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeSdkMessagingClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ThrottledClientExceptionBody: Swift.Equatable {
    public let code: ChimeSdkMessagingClientTypes.ErrorCode?
    public let message: Swift.String?
}

extension ThrottledClientExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnauthorizedClientException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnauthorizedClientException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension UnauthorizedClientException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnauthorizedClientExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The client is not currently authorized to make the request.
public struct UnauthorizedClientException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeSdkMessagingClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeSdkMessagingClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct UnauthorizedClientExceptionBody: Swift.Equatable {
    public let code: ChimeSdkMessagingClientTypes.ErrorCode?
    public let message: Swift.String?
}

extension UnauthorizedClientExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UpdateChannelInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateChannelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateChannelOutputError>
}

extension UpdateChannelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateChannelInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), metadata: \(Swift.String(describing: metadata)), mode: \(Swift.String(describing: mode)), name: \(Swift.String(describing: name)))"}
}

extension UpdateChannelInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata = "Metadata"
        case mode = "Mode"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let mode = mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateChannelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let chimeBearer = input.operationInput.chimeBearer {
            input.builder.withHeader(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateChannelOutputError>
}

public struct UpdateChannelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateChannelOutputError>
}

public struct UpdateChannelInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateChannelInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateChannelInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateChannelInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateChannelOutputError>
}

public struct UpdateChannelInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateChannelInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateChannelInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelArn = input.channelArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channels/\(channelArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateChannelInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateChannelOutputError>
}

public struct UpdateChannelInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The metadata for the update request.
    public var metadata: Swift.String?
    /// The mode of the update request.
    /// This member is required.
    public var mode: ChimeSdkMessagingClientTypes.ChannelMode?
    /// The name of the channel.
    /// This member is required.
    public var name: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        metadata: Swift.String? = nil,
        mode: ChimeSdkMessagingClientTypes.ChannelMode? = nil,
        name: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.metadata = metadata
        self.mode = mode
        self.name = name
    }
}

struct UpdateChannelInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let mode: ChimeSdkMessagingClientTypes.ChannelMode?
    public let metadata: Swift.String?
}

extension UpdateChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata = "Metadata"
        case mode = "Mode"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let modeDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelMode.self, forKey: .mode)
        mode = modeDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

public struct UpdateChannelMessageInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateChannelMessageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateChannelMessageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateChannelMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateChannelMessageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateChannelMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateChannelMessageOutputError>
}

extension UpdateChannelMessageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateChannelMessageInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), content: \(Swift.String(describing: content)), messageId: \(Swift.String(describing: messageId)), metadata: \(Swift.String(describing: metadata)))"}
}

extension UpdateChannelMessageInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
        case metadata = "Metadata"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
    }
}

public struct UpdateChannelMessageInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateChannelMessageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateChannelMessageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateChannelMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let chimeBearer = input.operationInput.chimeBearer {
            input.builder.withHeader(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateChannelMessageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateChannelMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateChannelMessageOutputError>
}

public struct UpdateChannelMessageInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateChannelMessageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateChannelMessageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateChannelMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateChannelMessageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateChannelMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateChannelMessageOutputError>
}

public struct UpdateChannelMessageInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateChannelMessageInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateChannelMessageInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateChannelMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateChannelMessageInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateChannelMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateChannelMessageOutputError>
}

public struct UpdateChannelMessageInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateChannelMessageInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateChannelMessageInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateChannelMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelArn = input.channelArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelArn is nil and needs a value for the path of this operation"))))
        }
        guard let messageId = input.messageId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("messageId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channels/\(channelArn.urlPercentEncoding())/messages/\(messageId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateChannelMessageInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateChannelMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateChannelMessageOutputError>
}

public struct UpdateChannelMessageInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The content of the message being updated.
    public var content: Swift.String?
    /// The ID string of the message being updated.
    /// This member is required.
    public var messageId: Swift.String?
    /// The metadata of the message being updated.
    public var metadata: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        content: Swift.String? = nil,
        messageId: Swift.String? = nil,
        metadata: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.content = content
        self.messageId = messageId
        self.metadata = metadata
    }
}

struct UpdateChannelMessageInputBody: Swift.Equatable {
    public let content: Swift.String?
    public let metadata: Swift.String?
}

extension UpdateChannelMessageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
        case metadata = "Metadata"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

extension UpdateChannelMessageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateChannelMessageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateChannelMessageOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateChannelMessageOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateChannelMessageOutputResponse(channelArn: \(Swift.String(describing: channelArn)), messageId: \(Swift.String(describing: messageId)))"}
}

extension UpdateChannelMessageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateChannelMessageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.messageId = output.messageId
        } else {
            self.channelArn = nil
            self.messageId = nil
        }
    }
}

public struct UpdateChannelMessageOutputResponse: Swift.Equatable {
    /// The ARN of the channel.
    public var channelArn: Swift.String?
    /// The ID string of the message being updated.
    public var messageId: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        messageId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.messageId = messageId
    }
}

struct UpdateChannelMessageOutputResponseBody: Swift.Equatable {
    public let channelArn: Swift.String?
    public let messageId: Swift.String?
}

extension UpdateChannelMessageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case messageId = "MessageId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
    }
}

extension UpdateChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateChannelOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateChannelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateChannelOutputResponse(channelArn: \(Swift.String(describing: channelArn)))"}
}

extension UpdateChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateChannelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
        } else {
            self.channelArn = nil
        }
    }
}

public struct UpdateChannelOutputResponse: Swift.Equatable {
    /// The ARN of the channel.
    public var channelArn: Swift.String?

    public init (
        channelArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
    }
}

struct UpdateChannelOutputResponseBody: Swift.Equatable {
    public let channelArn: Swift.String?
}

extension UpdateChannelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
    }
}

extension UpdateChannelReadMarkerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateChannelReadMarkerInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)))"}
}

extension UpdateChannelReadMarkerInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct UpdateChannelReadMarkerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateChannelReadMarkerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateChannelReadMarkerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateChannelReadMarkerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let chimeBearer = input.operationInput.chimeBearer {
            input.builder.withHeader(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateChannelReadMarkerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateChannelReadMarkerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateChannelReadMarkerOutputError>
}

public struct UpdateChannelReadMarkerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateChannelReadMarkerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateChannelReadMarkerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateChannelReadMarkerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateChannelReadMarkerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateChannelReadMarkerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateChannelReadMarkerOutputError>
}

public struct UpdateChannelReadMarkerInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateChannelReadMarkerInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateChannelReadMarkerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateChannelReadMarkerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateChannelReadMarkerInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateChannelReadMarkerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateChannelReadMarkerOutputError>
}

public struct UpdateChannelReadMarkerInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateChannelReadMarkerInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateChannelReadMarkerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateChannelReadMarkerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelArn = input.channelArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channels/\(channelArn.urlPercentEncoding())/readMarker"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateChannelReadMarkerInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateChannelReadMarkerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateChannelReadMarkerOutputError>
}

public struct UpdateChannelReadMarkerInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
    }
}

struct UpdateChannelReadMarkerInputBody: Swift.Equatable {
}

extension UpdateChannelReadMarkerInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UpdateChannelReadMarkerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateChannelReadMarkerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateChannelReadMarkerOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateChannelReadMarkerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateChannelReadMarkerOutputResponse(channelArn: \(Swift.String(describing: channelArn)))"}
}

extension UpdateChannelReadMarkerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateChannelReadMarkerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
        } else {
            self.channelArn = nil
        }
    }
}

public struct UpdateChannelReadMarkerOutputResponse: Swift.Equatable {
    /// The ARN of the channel.
    public var channelArn: Swift.String?

    public init (
        channelArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
    }
}

struct UpdateChannelReadMarkerOutputResponseBody: Swift.Equatable {
    public let channelArn: Swift.String?
}

extension UpdateChannelReadMarkerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
    }
}
