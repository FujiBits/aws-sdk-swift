// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ChimeSdkMessagingClientTypes {
    public enum AllowNotifications: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case filtered
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [AllowNotifications] {
            return [
                .all,
                .filtered,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .filtered: return "FILTERED"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AllowNotifications(rawValue: rawValue) ?? AllowNotifications.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSdkMessagingClientTypes.AppInstanceUserMembershipSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case readMarkerTimestamp = "ReadMarkerTimestamp"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let readMarkerTimestamp = readMarkerTimestamp {
            try encodeContainer.encode(readMarkerTimestamp.timeIntervalSince1970, forKey: .readMarkerTimestamp)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelMembershipType.self, forKey: .type)
        type = typeDecoded
        let readMarkerTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .readMarkerTimestamp)
        readMarkerTimestamp = readMarkerTimestampDecoded
    }
}

extension ChimeSdkMessagingClientTypes {
    /// Summary of the membership details of an AppInstanceUser.
    public struct AppInstanceUserMembershipSummary: Swift.Equatable {
        /// The time at which a message was last read.
        var readMarkerTimestamp: ClientRuntime.Date?
        /// The type of ChannelMembership.
        var type: ChimeSdkMessagingClientTypes.ChannelMembershipType?

        public init (
            readMarkerTimestamp: ClientRuntime.Date? = nil,
            type: ChimeSdkMessagingClientTypes.ChannelMembershipType? = nil
        )
        {
            self.readMarkerTimestamp = readMarkerTimestamp
            self.type = type
        }
    }

}

extension AssociateChannelFlowInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelFlowArn = "ChannelFlowArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelFlowArn = channelFlowArn {
            try encodeContainer.encode(channelFlowArn, forKey: .channelFlowArn)
        }
    }
}

extension AssociateChannelFlowInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension AssociateChannelFlowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/channel-flow"
    }
}

public struct AssociateChannelFlowInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    var channelArn: Swift.String?
    /// The ARN of the channel flow.
    /// This member is required.
    var channelFlowArn: Swift.String?
    /// The AppInstanceUserArn of the user making the API call.
    /// This member is required.
    var chimeBearer: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        channelFlowArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.channelFlowArn = channelFlowArn
        self.chimeBearer = chimeBearer
    }
}

struct AssociateChannelFlowInputBody: Swift.Equatable {
    let channelFlowArn: Swift.String?
}

extension AssociateChannelFlowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelFlowArn = "ChannelFlowArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelFlowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelFlowArn)
        channelFlowArn = channelFlowArnDecoded
    }
}

extension AssociateChannelFlowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateChannelFlowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateChannelFlowOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateChannelFlowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateChannelFlowOutputResponse: Swift.Equatable {

}

extension BadRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input parameters don't match the service's restrictions.
public struct BadRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeSdkMessagingClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeSdkMessagingClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let code: ChimeSdkMessagingClientTypes.ErrorCode?
    let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ChimeSdkMessagingClientTypes.BatchChannelMemberships: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case invitedBy = "InvitedBy"
        case members = "Members"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let invitedBy = invitedBy {
            try encodeContainer.encode(invitedBy, forKey: .invitedBy)
        }
        if let members = members {
            var membersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .members)
            for members0 in members {
                try membersContainer.encode(members0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invitedByDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.Identity.self, forKey: .invitedBy)
        invitedBy = invitedByDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelMembershipType.self, forKey: .type)
        type = typeDecoded
        let membersContainer = try containerValues.decodeIfPresent([ChimeSdkMessagingClientTypes.Identity?].self, forKey: .members)
        var membersDecoded0:[ChimeSdkMessagingClientTypes.Identity]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [ChimeSdkMessagingClientTypes.Identity]()
            for structure0 in membersContainer {
                if let structure0 = structure0 {
                    membersDecoded0?.append(structure0)
                }
            }
        }
        members = membersDecoded0
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
    }
}

extension ChimeSdkMessagingClientTypes {
    /// The membership information, including member ARNs, the channel ARN, and membership types.
    public struct BatchChannelMemberships: Swift.Equatable {
        /// The ARN of the channel to which you're adding users.
        var channelArn: Swift.String?
        /// The identifier of the member who invited another member.
        var invitedBy: ChimeSdkMessagingClientTypes.Identity?
        /// The users successfully added to the request.
        var members: [ChimeSdkMessagingClientTypes.Identity]?
        /// The membership types set for the channel users.
        var type: ChimeSdkMessagingClientTypes.ChannelMembershipType?

        public init (
            channelArn: Swift.String? = nil,
            invitedBy: ChimeSdkMessagingClientTypes.Identity? = nil,
            members: [ChimeSdkMessagingClientTypes.Identity]? = nil,
            type: ChimeSdkMessagingClientTypes.ChannelMembershipType? = nil
        )
        {
            self.channelArn = channelArn
            self.invitedBy = invitedBy
            self.members = members
            self.type = type
        }
    }

}

extension ChimeSdkMessagingClientTypes.BatchCreateChannelMembershipError: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case memberArn = "MemberArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let memberArn = memberArn {
            try encodeContainer.encode(memberArn, forKey: .memberArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberArn)
        memberArn = memberArnDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension ChimeSdkMessagingClientTypes {
    /// A list of failed member ARNs, error codes, and error messages.
    public struct BatchCreateChannelMembershipError: Swift.Equatable {
        /// The error code.
        var errorCode: ChimeSdkMessagingClientTypes.ErrorCode?
        /// The error message.
        var errorMessage: Swift.String?
        /// The AppInstanceUserArn of the member that the service couldn't add.
        var memberArn: Swift.String?

        public init (
            errorCode: ChimeSdkMessagingClientTypes.ErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            memberArn: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.memberArn = memberArn
        }
    }

}

extension BatchCreateChannelMembershipInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberArns = "MemberArns"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let memberArns = memberArns {
            var memberArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .memberArns)
            for memberarns0 in memberArns {
                try memberArnsContainer.encode(memberarns0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension BatchCreateChannelMembershipInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension BatchCreateChannelMembershipInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "operation", value: "batch-create"))
        return items
    }
}

extension BatchCreateChannelMembershipInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/memberships"
    }
}

public struct BatchCreateChannelMembershipInput: Swift.Equatable {
    /// The ARN of the channel to which you're adding users.
    /// This member is required.
    var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    var chimeBearer: Swift.String?
    /// The AppInstanceUserArns of the members you want to add to the channel.
    /// This member is required.
    var memberArns: [Swift.String]?
    /// The membership type of a user, DEFAULT or HIDDEN. Default members are always returned as part of ListChannelMemberships. Hidden members are only returned if the type filter in ListChannelMemberships equals HIDDEN. Otherwise hidden members are not returned. This is only supported by moderators.
    var type: ChimeSdkMessagingClientTypes.ChannelMembershipType?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        memberArns: [Swift.String]? = nil,
        type: ChimeSdkMessagingClientTypes.ChannelMembershipType? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.memberArns = memberArns
        self.type = type
    }
}

struct BatchCreateChannelMembershipInputBody: Swift.Equatable {
    let type: ChimeSdkMessagingClientTypes.ChannelMembershipType?
    let memberArns: [Swift.String]?
}

extension BatchCreateChannelMembershipInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberArns = "MemberArns"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelMembershipType.self, forKey: .type)
        type = typeDecoded
        let memberArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .memberArns)
        var memberArnsDecoded0:[Swift.String]? = nil
        if let memberArnsContainer = memberArnsContainer {
            memberArnsDecoded0 = [Swift.String]()
            for string0 in memberArnsContainer {
                if let string0 = string0 {
                    memberArnsDecoded0?.append(string0)
                }
            }
        }
        memberArns = memberArnsDecoded0
    }
}

extension BatchCreateChannelMembershipOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchCreateChannelMembershipOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchCreateChannelMembershipOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchCreateChannelMembershipOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchCreateChannelMembershipOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.batchChannelMemberships = output.batchChannelMemberships
            self.errors = output.errors
        } else {
            self.batchChannelMemberships = nil
            self.errors = nil
        }
    }
}

public struct BatchCreateChannelMembershipOutputResponse: Swift.Equatable {
    /// The list of channel memberships in the response.
    var batchChannelMemberships: ChimeSdkMessagingClientTypes.BatchChannelMemberships?
    /// If the action fails for one or more of the memberships in the request, a list of the memberships is returned, along with error codes and error messages.
    var errors: [ChimeSdkMessagingClientTypes.BatchCreateChannelMembershipError]?

    public init (
        batchChannelMemberships: ChimeSdkMessagingClientTypes.BatchChannelMemberships? = nil,
        errors: [ChimeSdkMessagingClientTypes.BatchCreateChannelMembershipError]? = nil
    )
    {
        self.batchChannelMemberships = batchChannelMemberships
        self.errors = errors
    }
}

struct BatchCreateChannelMembershipOutputResponseBody: Swift.Equatable {
    let batchChannelMemberships: ChimeSdkMessagingClientTypes.BatchChannelMemberships?
    let errors: [ChimeSdkMessagingClientTypes.BatchCreateChannelMembershipError]?
}

extension BatchCreateChannelMembershipOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchChannelMemberships = "BatchChannelMemberships"
        case errors = "Errors"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchChannelMembershipsDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.BatchChannelMemberships.self, forKey: .batchChannelMemberships)
        batchChannelMemberships = batchChannelMembershipsDecoded
        let errorsContainer = try containerValues.decodeIfPresent([ChimeSdkMessagingClientTypes.BatchCreateChannelMembershipError?].self, forKey: .errors)
        var errorsDecoded0:[ChimeSdkMessagingClientTypes.BatchCreateChannelMembershipError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [ChimeSdkMessagingClientTypes.BatchCreateChannelMembershipError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension ChimeSdkMessagingClientTypes.Channel: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case channelFlowArn = "ChannelFlowArn"
        case createdBy = "CreatedBy"
        case createdTimestamp = "CreatedTimestamp"
        case lastMessageTimestamp = "LastMessageTimestamp"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case metadata = "Metadata"
        case mode = "Mode"
        case name = "Name"
        case privacy = "Privacy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let channelFlowArn = channelFlowArn {
            try encodeContainer.encode(channelFlowArn, forKey: .channelFlowArn)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let createdTimestamp = createdTimestamp {
            try encodeContainer.encode(createdTimestamp.timeIntervalSince1970, forKey: .createdTimestamp)
        }
        if let lastMessageTimestamp = lastMessageTimestamp {
            try encodeContainer.encode(lastMessageTimestamp.timeIntervalSince1970, forKey: .lastMessageTimestamp)
        }
        if let lastUpdatedTimestamp = lastUpdatedTimestamp {
            try encodeContainer.encode(lastUpdatedTimestamp.timeIntervalSince1970, forKey: .lastUpdatedTimestamp)
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let mode = mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let privacy = privacy {
            try encodeContainer.encode(privacy.rawValue, forKey: .privacy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let modeDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelMode.self, forKey: .mode)
        mode = modeDecoded
        let privacyDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelPrivacy.self, forKey: .privacy)
        privacy = privacyDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.Identity.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastMessageTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastMessageTimestamp)
        lastMessageTimestamp = lastMessageTimestampDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let channelFlowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelFlowArn)
        channelFlowArn = channelFlowArnDecoded
    }
}

extension ChimeSdkMessagingClientTypes {
    /// The details of a channel.
    public struct Channel: Swift.Equatable {
        /// The ARN of a channel.
        var channelArn: Swift.String?
        /// The ARN of the channel flow.
        var channelFlowArn: Swift.String?
        /// The AppInstanceUser who created the channel.
        var createdBy: ChimeSdkMessagingClientTypes.Identity?
        /// The time at which the AppInstanceUser created the channel.
        var createdTimestamp: ClientRuntime.Date?
        /// The time at which a member sent the last message in the channel.
        var lastMessageTimestamp: ClientRuntime.Date?
        /// The time at which a channel was last updated.
        var lastUpdatedTimestamp: ClientRuntime.Date?
        /// The channel's metadata.
        var metadata: Swift.String?
        /// The mode of the channel.
        var mode: ChimeSdkMessagingClientTypes.ChannelMode?
        /// The name of a channel.
        var name: Swift.String?
        /// The channel's privacy setting.
        var privacy: ChimeSdkMessagingClientTypes.ChannelPrivacy?

        public init (
            channelArn: Swift.String? = nil,
            channelFlowArn: Swift.String? = nil,
            createdBy: ChimeSdkMessagingClientTypes.Identity? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            lastMessageTimestamp: ClientRuntime.Date? = nil,
            lastUpdatedTimestamp: ClientRuntime.Date? = nil,
            metadata: Swift.String? = nil,
            mode: ChimeSdkMessagingClientTypes.ChannelMode? = nil,
            name: Swift.String? = nil,
            privacy: ChimeSdkMessagingClientTypes.ChannelPrivacy? = nil
        )
        {
            self.channelArn = channelArn
            self.channelFlowArn = channelFlowArn
            self.createdBy = createdBy
            self.createdTimestamp = createdTimestamp
            self.lastMessageTimestamp = lastMessageTimestamp
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.metadata = metadata
            self.mode = mode
            self.name = name
            self.privacy = privacy
        }
    }

}

extension ChimeSdkMessagingClientTypes.ChannelAssociatedWithFlowSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case metadata = "Metadata"
        case mode = "Mode"
        case name = "Name"
        case privacy = "Privacy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let mode = mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let privacy = privacy {
            try encodeContainer.encode(privacy.rawValue, forKey: .privacy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let modeDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelMode.self, forKey: .mode)
        mode = modeDecoded
        let privacyDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelPrivacy.self, forKey: .privacy)
        privacy = privacyDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

extension ChimeSdkMessagingClientTypes {
    /// Summary of details of a channel associated with channel flow.
    public struct ChannelAssociatedWithFlowSummary: Swift.Equatable {
        /// The ARN of the channel.
        var channelArn: Swift.String?
        /// The channel's metadata.
        var metadata: Swift.String?
        /// The mode of the channel.
        var mode: ChimeSdkMessagingClientTypes.ChannelMode?
        /// The name of the channel flow.
        var name: Swift.String?
        /// The channel's privacy setting.
        var privacy: ChimeSdkMessagingClientTypes.ChannelPrivacy?

        public init (
            channelArn: Swift.String? = nil,
            metadata: Swift.String? = nil,
            mode: ChimeSdkMessagingClientTypes.ChannelMode? = nil,
            name: Swift.String? = nil,
            privacy: ChimeSdkMessagingClientTypes.ChannelPrivacy? = nil
        )
        {
            self.channelArn = channelArn
            self.metadata = metadata
            self.mode = mode
            self.name = name
            self.privacy = privacy
        }
    }

}

extension ChimeSdkMessagingClientTypes.ChannelBan: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case createdBy = "CreatedBy"
        case createdTimestamp = "CreatedTimestamp"
        case member = "Member"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let createdTimestamp = createdTimestamp {
            try encodeContainer.encode(createdTimestamp.timeIntervalSince1970, forKey: .createdTimestamp)
        }
        if let member = member {
            try encodeContainer.encode(member, forKey: .member)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.Identity.self, forKey: .member)
        member = memberDecoded
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.Identity.self, forKey: .createdBy)
        createdBy = createdByDecoded
    }
}

extension ChimeSdkMessagingClientTypes {
    /// The details of a channel ban.
    public struct ChannelBan: Swift.Equatable {
        /// The ARN of the channel from which a member is being banned.
        var channelArn: Swift.String?
        /// The AppInstanceUser who created the ban.
        var createdBy: ChimeSdkMessagingClientTypes.Identity?
        /// The time at which the ban was created.
        var createdTimestamp: ClientRuntime.Date?
        /// The member being banned from the channel.
        var member: ChimeSdkMessagingClientTypes.Identity?

        public init (
            channelArn: Swift.String? = nil,
            createdBy: ChimeSdkMessagingClientTypes.Identity? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            member: ChimeSdkMessagingClientTypes.Identity? = nil
        )
        {
            self.channelArn = channelArn
            self.createdBy = createdBy
            self.createdTimestamp = createdTimestamp
            self.member = member
        }
    }

}

extension ChimeSdkMessagingClientTypes.ChannelBanSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case member = "Member"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let member = member {
            try encodeContainer.encode(member, forKey: .member)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.Identity.self, forKey: .member)
        member = memberDecoded
    }
}

extension ChimeSdkMessagingClientTypes {
    /// Summary of the details of a ChannelBan.
    public struct ChannelBanSummary: Swift.Equatable {
        /// The member being banned from a channel.
        var member: ChimeSdkMessagingClientTypes.Identity?

        public init (
            member: ChimeSdkMessagingClientTypes.Identity? = nil
        )
        {
            self.member = member
        }
    }

}

extension ChimeSdkMessagingClientTypes.ChannelFlow: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelFlowArn = "ChannelFlowArn"
        case createdTimestamp = "CreatedTimestamp"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case name = "Name"
        case processors = "Processors"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelFlowArn = channelFlowArn {
            try encodeContainer.encode(channelFlowArn, forKey: .channelFlowArn)
        }
        if let createdTimestamp = createdTimestamp {
            try encodeContainer.encode(createdTimestamp.timeIntervalSince1970, forKey: .createdTimestamp)
        }
        if let lastUpdatedTimestamp = lastUpdatedTimestamp {
            try encodeContainer.encode(lastUpdatedTimestamp.timeIntervalSince1970, forKey: .lastUpdatedTimestamp)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let processors = processors {
            var processorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .processors)
            for processorlist0 in processors {
                try processorsContainer.encode(processorlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelFlowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelFlowArn)
        channelFlowArn = channelFlowArnDecoded
        let processorsContainer = try containerValues.decodeIfPresent([ChimeSdkMessagingClientTypes.Processor?].self, forKey: .processors)
        var processorsDecoded0:[ChimeSdkMessagingClientTypes.Processor]? = nil
        if let processorsContainer = processorsContainer {
            processorsDecoded0 = [ChimeSdkMessagingClientTypes.Processor]()
            for structure0 in processorsContainer {
                if let structure0 = structure0 {
                    processorsDecoded0?.append(structure0)
                }
            }
        }
        processors = processorsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
    }
}

extension ChimeSdkMessagingClientTypes {
    /// The details of a channel flow.
    public struct ChannelFlow: Swift.Equatable {
        /// The ARN of the channel flow.
        var channelFlowArn: Swift.String?
        /// The time at which the channel flow was created.
        var createdTimestamp: ClientRuntime.Date?
        /// The time at which a channel flow was updated.
        var lastUpdatedTimestamp: ClientRuntime.Date?
        /// The name of the channel flow.
        var name: Swift.String?
        /// Information about the processor Lambda functions.
        var processors: [ChimeSdkMessagingClientTypes.Processor]?

        public init (
            channelFlowArn: Swift.String? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            lastUpdatedTimestamp: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            processors: [ChimeSdkMessagingClientTypes.Processor]? = nil
        )
        {
            self.channelFlowArn = channelFlowArn
            self.createdTimestamp = createdTimestamp
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.name = name
            self.processors = processors
        }
    }

}

extension ChannelFlowCallbackInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callbackId = "CallbackId"
        case channelMessage = "ChannelMessage"
        case deleteResource = "DeleteResource"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let callbackId = callbackId {
            try encodeContainer.encode(callbackId, forKey: .callbackId)
        }
        if let channelMessage = channelMessage {
            try encodeContainer.encode(channelMessage, forKey: .channelMessage)
        }
        if deleteResource != false {
            try encodeContainer.encode(deleteResource, forKey: .deleteResource)
        }
    }
}

extension ChannelFlowCallbackInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "operation", value: "channel-flow-callback"))
        return items
    }
}

extension ChannelFlowCallbackInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())"
    }
}

public struct ChannelFlowCallbackInput: Swift.Equatable {
    /// The identifier passed to the processor by the service when invoked. Use the identifier to call back the service.
    /// This member is required.
    var callbackId: Swift.String?
    /// The ARN of the channel.
    /// This member is required.
    var channelArn: Swift.String?
    /// Stores information about the processed message.
    /// This member is required.
    var channelMessage: ChimeSdkMessagingClientTypes.ChannelMessageCallback?
    /// When a processor determines that a message needs to be DENIED, pass this parameter with a value of true.
    var deleteResource: Swift.Bool

    public init (
        callbackId: Swift.String? = nil,
        channelArn: Swift.String? = nil,
        channelMessage: ChimeSdkMessagingClientTypes.ChannelMessageCallback? = nil,
        deleteResource: Swift.Bool = false
    )
    {
        self.callbackId = callbackId
        self.channelArn = channelArn
        self.channelMessage = channelMessage
        self.deleteResource = deleteResource
    }
}

struct ChannelFlowCallbackInputBody: Swift.Equatable {
    let callbackId: Swift.String?
    let deleteResource: Swift.Bool
    let channelMessage: ChimeSdkMessagingClientTypes.ChannelMessageCallback?
}

extension ChannelFlowCallbackInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callbackId = "CallbackId"
        case channelMessage = "ChannelMessage"
        case deleteResource = "DeleteResource"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let callbackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callbackId)
        callbackId = callbackIdDecoded
        let deleteResourceDecoded = try containerValues.decode(Swift.Bool.self, forKey: .deleteResource)
        deleteResource = deleteResourceDecoded
        let channelMessageDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelMessageCallback.self, forKey: .channelMessage)
        channelMessage = channelMessageDecoded
    }
}

extension ChannelFlowCallbackOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ChannelFlowCallbackOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ChannelFlowCallbackOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ChannelFlowCallbackOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ChannelFlowCallbackOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.callbackId = output.callbackId
            self.channelArn = output.channelArn
        } else {
            self.callbackId = nil
            self.channelArn = nil
        }
    }
}

public struct ChannelFlowCallbackOutputResponse: Swift.Equatable {
    /// The call back ID passed in the request.
    var callbackId: Swift.String?
    /// The ARN of the channel.
    var channelArn: Swift.String?

    public init (
        callbackId: Swift.String? = nil,
        channelArn: Swift.String? = nil
    )
    {
        self.callbackId = callbackId
        self.channelArn = channelArn
    }
}

struct ChannelFlowCallbackOutputResponseBody: Swift.Equatable {
    let channelArn: Swift.String?
    let callbackId: Swift.String?
}

extension ChannelFlowCallbackOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callbackId = "CallbackId"
        case channelArn = "ChannelArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let callbackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callbackId)
        callbackId = callbackIdDecoded
    }
}

extension ChimeSdkMessagingClientTypes.ChannelFlowSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelFlowArn = "ChannelFlowArn"
        case name = "Name"
        case processors = "Processors"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelFlowArn = channelFlowArn {
            try encodeContainer.encode(channelFlowArn, forKey: .channelFlowArn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let processors = processors {
            var processorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .processors)
            for processorlist0 in processors {
                try processorsContainer.encode(processorlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelFlowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelFlowArn)
        channelFlowArn = channelFlowArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let processorsContainer = try containerValues.decodeIfPresent([ChimeSdkMessagingClientTypes.Processor?].self, forKey: .processors)
        var processorsDecoded0:[ChimeSdkMessagingClientTypes.Processor]? = nil
        if let processorsContainer = processorsContainer {
            processorsDecoded0 = [ChimeSdkMessagingClientTypes.Processor]()
            for structure0 in processorsContainer {
                if let structure0 = structure0 {
                    processorsDecoded0?.append(structure0)
                }
            }
        }
        processors = processorsDecoded0
    }
}

extension ChimeSdkMessagingClientTypes {
    /// Summary of details of a channel flow.
    public struct ChannelFlowSummary: Swift.Equatable {
        /// The ARN of the channel flow.
        var channelFlowArn: Swift.String?
        /// The name of the channel flow.
        var name: Swift.String?
        /// Information about the processor Lambda functions.
        var processors: [ChimeSdkMessagingClientTypes.Processor]?

        public init (
            channelFlowArn: Swift.String? = nil,
            name: Swift.String? = nil,
            processors: [ChimeSdkMessagingClientTypes.Processor]? = nil
        )
        {
            self.channelFlowArn = channelFlowArn
            self.name = name
            self.processors = processors
        }
    }

}

extension ChimeSdkMessagingClientTypes.ChannelMembership: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case createdTimestamp = "CreatedTimestamp"
        case invitedBy = "InvitedBy"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case member = "Member"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let createdTimestamp = createdTimestamp {
            try encodeContainer.encode(createdTimestamp.timeIntervalSince1970, forKey: .createdTimestamp)
        }
        if let invitedBy = invitedBy {
            try encodeContainer.encode(invitedBy, forKey: .invitedBy)
        }
        if let lastUpdatedTimestamp = lastUpdatedTimestamp {
            try encodeContainer.encode(lastUpdatedTimestamp.timeIntervalSince1970, forKey: .lastUpdatedTimestamp)
        }
        if let member = member {
            try encodeContainer.encode(member, forKey: .member)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invitedByDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.Identity.self, forKey: .invitedBy)
        invitedBy = invitedByDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelMembershipType.self, forKey: .type)
        type = typeDecoded
        let memberDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.Identity.self, forKey: .member)
        member = memberDecoded
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
    }
}

extension ChimeSdkMessagingClientTypes {
    /// The details of a channel member.
    public struct ChannelMembership: Swift.Equatable {
        /// The ARN of the member's channel.
        var channelArn: Swift.String?
        /// The time at which the channel membership was created.
        var createdTimestamp: ClientRuntime.Date?
        /// The identifier of the member who invited another member.
        var invitedBy: ChimeSdkMessagingClientTypes.Identity?
        /// The time at which a channel membership was last updated.
        var lastUpdatedTimestamp: ClientRuntime.Date?
        /// The data of the channel member.
        var member: ChimeSdkMessagingClientTypes.Identity?
        /// The membership type set for the channel member.
        var type: ChimeSdkMessagingClientTypes.ChannelMembershipType?

        public init (
            channelArn: Swift.String? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            invitedBy: ChimeSdkMessagingClientTypes.Identity? = nil,
            lastUpdatedTimestamp: ClientRuntime.Date? = nil,
            member: ChimeSdkMessagingClientTypes.Identity? = nil,
            type: ChimeSdkMessagingClientTypes.ChannelMembershipType? = nil
        )
        {
            self.channelArn = channelArn
            self.createdTimestamp = createdTimestamp
            self.invitedBy = invitedBy
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.member = member
            self.type = type
        }
    }

}

extension ChimeSdkMessagingClientTypes.ChannelMembershipForAppInstanceUserSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceUserMembershipSummary = "AppInstanceUserMembershipSummary"
        case channelSummary = "ChannelSummary"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appInstanceUserMembershipSummary = appInstanceUserMembershipSummary {
            try encodeContainer.encode(appInstanceUserMembershipSummary, forKey: .appInstanceUserMembershipSummary)
        }
        if let channelSummary = channelSummary {
            try encodeContainer.encode(channelSummary, forKey: .channelSummary)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelSummaryDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelSummary.self, forKey: .channelSummary)
        channelSummary = channelSummaryDecoded
        let appInstanceUserMembershipSummaryDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.AppInstanceUserMembershipSummary.self, forKey: .appInstanceUserMembershipSummary)
        appInstanceUserMembershipSummary = appInstanceUserMembershipSummaryDecoded
    }
}

extension ChimeSdkMessagingClientTypes {
    /// Summary of the channel membership details of an AppInstanceUser.
    public struct ChannelMembershipForAppInstanceUserSummary: Swift.Equatable {
        /// Returns the channel membership data for an AppInstance.
        var appInstanceUserMembershipSummary: ChimeSdkMessagingClientTypes.AppInstanceUserMembershipSummary?
        /// Returns the channel data for an AppInstance.
        var channelSummary: ChimeSdkMessagingClientTypes.ChannelSummary?

        public init (
            appInstanceUserMembershipSummary: ChimeSdkMessagingClientTypes.AppInstanceUserMembershipSummary? = nil,
            channelSummary: ChimeSdkMessagingClientTypes.ChannelSummary? = nil
        )
        {
            self.appInstanceUserMembershipSummary = appInstanceUserMembershipSummary
            self.channelSummary = channelSummary
        }
    }

}

extension ChimeSdkMessagingClientTypes.ChannelMembershipPreferences: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pushNotifications = "PushNotifications"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pushNotifications = pushNotifications {
            try encodeContainer.encode(pushNotifications, forKey: .pushNotifications)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pushNotificationsDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.PushNotificationPreferences.self, forKey: .pushNotifications)
        pushNotifications = pushNotificationsDecoded
    }
}

extension ChimeSdkMessagingClientTypes {
    /// The channel membership preferences for an AppInstanceUser.
    public struct ChannelMembershipPreferences: Swift.Equatable {
        /// The push notification configuration of a message.
        var pushNotifications: ChimeSdkMessagingClientTypes.PushNotificationPreferences?

        public init (
            pushNotifications: ChimeSdkMessagingClientTypes.PushNotificationPreferences? = nil
        )
        {
            self.pushNotifications = pushNotifications
        }
    }

}

extension ChimeSdkMessagingClientTypes.ChannelMembershipSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case member = "Member"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let member = member {
            try encodeContainer.encode(member, forKey: .member)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.Identity.self, forKey: .member)
        member = memberDecoded
    }
}

extension ChimeSdkMessagingClientTypes {
    /// Summary of the details of a ChannelMembership.
    public struct ChannelMembershipSummary: Swift.Equatable {
        /// A member's summary data.
        var member: ChimeSdkMessagingClientTypes.Identity?

        public init (
            member: ChimeSdkMessagingClientTypes.Identity? = nil
        )
        {
            self.member = member
        }
    }

}

extension ChimeSdkMessagingClientTypes {
    public enum ChannelMembershipType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `default`
        case hidden
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelMembershipType] {
            return [
                .default,
                .hidden,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .default: return "DEFAULT"
            case .hidden: return "HIDDEN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChannelMembershipType(rawValue: rawValue) ?? ChannelMembershipType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSdkMessagingClientTypes.ChannelMessage: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case content = "Content"
        case createdTimestamp = "CreatedTimestamp"
        case lastEditedTimestamp = "LastEditedTimestamp"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case messageAttributes = "MessageAttributes"
        case messageId = "MessageId"
        case metadata = "Metadata"
        case persistence = "Persistence"
        case redacted = "Redacted"
        case sender = "Sender"
        case status = "Status"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let createdTimestamp = createdTimestamp {
            try encodeContainer.encode(createdTimestamp.timeIntervalSince1970, forKey: .createdTimestamp)
        }
        if let lastEditedTimestamp = lastEditedTimestamp {
            try encodeContainer.encode(lastEditedTimestamp.timeIntervalSince1970, forKey: .lastEditedTimestamp)
        }
        if let lastUpdatedTimestamp = lastUpdatedTimestamp {
            try encodeContainer.encode(lastUpdatedTimestamp.timeIntervalSince1970, forKey: .lastUpdatedTimestamp)
        }
        if let messageAttributes = messageAttributes {
            var messageAttributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .messageAttributes)
            for (dictKey0, messageattributemap0) in messageAttributes {
                try messageAttributesContainer.encode(messageattributemap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let messageId = messageId {
            try encodeContainer.encode(messageId, forKey: .messageId)
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let persistence = persistence {
            try encodeContainer.encode(persistence.rawValue, forKey: .persistence)
        }
        if redacted != false {
            try encodeContainer.encode(redacted, forKey: .redacted)
        }
        if let sender = sender {
            try encodeContainer.encode(sender, forKey: .sender)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelMessageType.self, forKey: .type)
        type = typeDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastEditedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastEditedTimestamp)
        lastEditedTimestamp = lastEditedTimestampDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let senderDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.Identity.self, forKey: .sender)
        sender = senderDecoded
        let redactedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .redacted)
        redacted = redactedDecoded
        let persistenceDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelMessagePersistenceType.self, forKey: .persistence)
        persistence = persistenceDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelMessageStatusStructure.self, forKey: .status)
        status = statusDecoded
        let messageAttributesContainer = try containerValues.decodeIfPresent([Swift.String: ChimeSdkMessagingClientTypes.MessageAttributeValue?].self, forKey: .messageAttributes)
        var messageAttributesDecoded0: [Swift.String:ChimeSdkMessagingClientTypes.MessageAttributeValue]? = nil
        if let messageAttributesContainer = messageAttributesContainer {
            messageAttributesDecoded0 = [Swift.String:ChimeSdkMessagingClientTypes.MessageAttributeValue]()
            for (key0, messageattributevalue0) in messageAttributesContainer {
                if let messageattributevalue0 = messageattributevalue0 {
                    messageAttributesDecoded0?[key0] = messageattributevalue0
                }
            }
        }
        messageAttributes = messageAttributesDecoded0
    }
}

extension ChimeSdkMessagingClientTypes {
    /// The details of a message in a channel.
    public struct ChannelMessage: Swift.Equatable {
        /// The ARN of the channel.
        var channelArn: Swift.String?
        /// The message content.
        var content: Swift.String?
        /// The time at which the message was created.
        var createdTimestamp: ClientRuntime.Date?
        /// The time at which a message was edited.
        var lastEditedTimestamp: ClientRuntime.Date?
        /// The time at which a message was updated.
        var lastUpdatedTimestamp: ClientRuntime.Date?
        /// The attributes for the message, used for message filtering along with a FilterRule defined in the PushNotificationPreferences.
        var messageAttributes: [Swift.String:ChimeSdkMessagingClientTypes.MessageAttributeValue]?
        /// The ID of a message.
        var messageId: Swift.String?
        /// The message metadata.
        var metadata: Swift.String?
        /// The persistence setting for a channel message.
        var persistence: ChimeSdkMessagingClientTypes.ChannelMessagePersistenceType?
        /// Hides the content of a message.
        var redacted: Swift.Bool
        /// The message sender.
        var sender: ChimeSdkMessagingClientTypes.Identity?
        /// The status of the channel message.
        var status: ChimeSdkMessagingClientTypes.ChannelMessageStatusStructure?
        /// The message type.
        var type: ChimeSdkMessagingClientTypes.ChannelMessageType?

        public init (
            channelArn: Swift.String? = nil,
            content: Swift.String? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            lastEditedTimestamp: ClientRuntime.Date? = nil,
            lastUpdatedTimestamp: ClientRuntime.Date? = nil,
            messageAttributes: [Swift.String:ChimeSdkMessagingClientTypes.MessageAttributeValue]? = nil,
            messageId: Swift.String? = nil,
            metadata: Swift.String? = nil,
            persistence: ChimeSdkMessagingClientTypes.ChannelMessagePersistenceType? = nil,
            redacted: Swift.Bool = false,
            sender: ChimeSdkMessagingClientTypes.Identity? = nil,
            status: ChimeSdkMessagingClientTypes.ChannelMessageStatusStructure? = nil,
            type: ChimeSdkMessagingClientTypes.ChannelMessageType? = nil
        )
        {
            self.channelArn = channelArn
            self.content = content
            self.createdTimestamp = createdTimestamp
            self.lastEditedTimestamp = lastEditedTimestamp
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.messageAttributes = messageAttributes
            self.messageId = messageId
            self.metadata = metadata
            self.persistence = persistence
            self.redacted = redacted
            self.sender = sender
            self.status = status
            self.type = type
        }
    }

}

extension ChimeSdkMessagingClientTypes.ChannelMessageCallback: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
        case messageId = "MessageId"
        case metadata = "Metadata"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let messageId = messageId {
            try encodeContainer.encode(messageId, forKey: .messageId)
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

extension ChimeSdkMessagingClientTypes {
    /// Stores information about a callback.
    public struct ChannelMessageCallback: Swift.Equatable {
        /// The message content.
        var content: Swift.String?
        /// The message ID.
        /// This member is required.
        var messageId: Swift.String?
        /// The message metadata.
        var metadata: Swift.String?

        public init (
            content: Swift.String? = nil,
            messageId: Swift.String? = nil,
            metadata: Swift.String? = nil
        )
        {
            self.content = content
            self.messageId = messageId
            self.metadata = metadata
        }
    }

}

extension ChimeSdkMessagingClientTypes {
    public enum ChannelMessagePersistenceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case nonPersistent
        case persistent
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelMessagePersistenceType] {
            return [
                .nonPersistent,
                .persistent,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .nonPersistent: return "NON_PERSISTENT"
            case .persistent: return "PERSISTENT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChannelMessagePersistenceType(rawValue: rawValue) ?? ChannelMessagePersistenceType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSdkMessagingClientTypes {
    public enum ChannelMessageStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case denied
        case failed
        case pending
        case sent
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelMessageStatus] {
            return [
                .denied,
                .failed,
                .pending,
                .sent,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .denied: return "DENIED"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .sent: return "SENT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChannelMessageStatus(rawValue: rawValue) ?? ChannelMessageStatus.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSdkMessagingClientTypes.ChannelMessageStatusStructure: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detail = "Detail"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detail = detail {
            try encodeContainer.encode(detail, forKey: .detail)
        }
        if let value = value {
            try encodeContainer.encode(value.rawValue, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelMessageStatus.self, forKey: .value)
        value = valueDecoded
        let detailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detail)
        detail = detailDecoded
    }
}

extension ChimeSdkMessagingClientTypes {
    /// Stores information about a message status.
    public struct ChannelMessageStatusStructure: Swift.Equatable {
        /// Contains more details about the messasge status.
        var detail: Swift.String?
        /// The message status value.
        var value: ChimeSdkMessagingClientTypes.ChannelMessageStatus?

        public init (
            detail: Swift.String? = nil,
            value: ChimeSdkMessagingClientTypes.ChannelMessageStatus? = nil
        )
        {
            self.detail = detail
            self.value = value
        }
    }

}

extension ChimeSdkMessagingClientTypes.ChannelMessageSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
        case createdTimestamp = "CreatedTimestamp"
        case lastEditedTimestamp = "LastEditedTimestamp"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case messageAttributes = "MessageAttributes"
        case messageId = "MessageId"
        case metadata = "Metadata"
        case redacted = "Redacted"
        case sender = "Sender"
        case status = "Status"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let createdTimestamp = createdTimestamp {
            try encodeContainer.encode(createdTimestamp.timeIntervalSince1970, forKey: .createdTimestamp)
        }
        if let lastEditedTimestamp = lastEditedTimestamp {
            try encodeContainer.encode(lastEditedTimestamp.timeIntervalSince1970, forKey: .lastEditedTimestamp)
        }
        if let lastUpdatedTimestamp = lastUpdatedTimestamp {
            try encodeContainer.encode(lastUpdatedTimestamp.timeIntervalSince1970, forKey: .lastUpdatedTimestamp)
        }
        if let messageAttributes = messageAttributes {
            var messageAttributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .messageAttributes)
            for (dictKey0, messageattributemap0) in messageAttributes {
                try messageAttributesContainer.encode(messageattributemap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let messageId = messageId {
            try encodeContainer.encode(messageId, forKey: .messageId)
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if redacted != false {
            try encodeContainer.encode(redacted, forKey: .redacted)
        }
        if let sender = sender {
            try encodeContainer.encode(sender, forKey: .sender)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelMessageType.self, forKey: .type)
        type = typeDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let lastEditedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastEditedTimestamp)
        lastEditedTimestamp = lastEditedTimestampDecoded
        let senderDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.Identity.self, forKey: .sender)
        sender = senderDecoded
        let redactedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .redacted)
        redacted = redactedDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelMessageStatusStructure.self, forKey: .status)
        status = statusDecoded
        let messageAttributesContainer = try containerValues.decodeIfPresent([Swift.String: ChimeSdkMessagingClientTypes.MessageAttributeValue?].self, forKey: .messageAttributes)
        var messageAttributesDecoded0: [Swift.String:ChimeSdkMessagingClientTypes.MessageAttributeValue]? = nil
        if let messageAttributesContainer = messageAttributesContainer {
            messageAttributesDecoded0 = [Swift.String:ChimeSdkMessagingClientTypes.MessageAttributeValue]()
            for (key0, messageattributevalue0) in messageAttributesContainer {
                if let messageattributevalue0 = messageattributevalue0 {
                    messageAttributesDecoded0?[key0] = messageattributevalue0
                }
            }
        }
        messageAttributes = messageAttributesDecoded0
    }
}

extension ChimeSdkMessagingClientTypes {
    /// Summary of the messages in a Channel.
    public struct ChannelMessageSummary: Swift.Equatable {
        /// The content of the message.
        var content: Swift.String?
        /// The time at which the message summary was created.
        var createdTimestamp: ClientRuntime.Date?
        /// The time at which a message was last edited.
        var lastEditedTimestamp: ClientRuntime.Date?
        /// The time at which a message was last updated.
        var lastUpdatedTimestamp: ClientRuntime.Date?
        /// The message attribues listed in a the summary of a channel message.
        var messageAttributes: [Swift.String:ChimeSdkMessagingClientTypes.MessageAttributeValue]?
        /// The ID of the message.
        var messageId: Swift.String?
        /// The metadata of the message.
        var metadata: Swift.String?
        /// Indicates whether a message was redacted.
        var redacted: Swift.Bool
        /// The message sender.
        var sender: ChimeSdkMessagingClientTypes.Identity?
        /// The message status. The status value is SENT for messages sent to a channel without a channel flow. For channels associated with channel flow, the value determines the processing stage.
        var status: ChimeSdkMessagingClientTypes.ChannelMessageStatusStructure?
        /// The type of message.
        var type: ChimeSdkMessagingClientTypes.ChannelMessageType?

        public init (
            content: Swift.String? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            lastEditedTimestamp: ClientRuntime.Date? = nil,
            lastUpdatedTimestamp: ClientRuntime.Date? = nil,
            messageAttributes: [Swift.String:ChimeSdkMessagingClientTypes.MessageAttributeValue]? = nil,
            messageId: Swift.String? = nil,
            metadata: Swift.String? = nil,
            redacted: Swift.Bool = false,
            sender: ChimeSdkMessagingClientTypes.Identity? = nil,
            status: ChimeSdkMessagingClientTypes.ChannelMessageStatusStructure? = nil,
            type: ChimeSdkMessagingClientTypes.ChannelMessageType? = nil
        )
        {
            self.content = content
            self.createdTimestamp = createdTimestamp
            self.lastEditedTimestamp = lastEditedTimestamp
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.messageAttributes = messageAttributes
            self.messageId = messageId
            self.metadata = metadata
            self.redacted = redacted
            self.sender = sender
            self.status = status
            self.type = type
        }
    }

}

extension ChimeSdkMessagingClientTypes {
    public enum ChannelMessageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case control
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelMessageType] {
            return [
                .control,
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .control: return "CONTROL"
            case .standard: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChannelMessageType(rawValue: rawValue) ?? ChannelMessageType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSdkMessagingClientTypes {
    public enum ChannelMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case restricted
        case unrestricted
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelMode] {
            return [
                .restricted,
                .unrestricted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .restricted: return "RESTRICTED"
            case .unrestricted: return "UNRESTRICTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChannelMode(rawValue: rawValue) ?? ChannelMode.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSdkMessagingClientTypes.ChannelModeratedByAppInstanceUserSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelSummary = "ChannelSummary"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelSummary = channelSummary {
            try encodeContainer.encode(channelSummary, forKey: .channelSummary)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelSummaryDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelSummary.self, forKey: .channelSummary)
        channelSummary = channelSummaryDecoded
    }
}

extension ChimeSdkMessagingClientTypes {
    /// Summary of the details of a moderated channel.
    public struct ChannelModeratedByAppInstanceUserSummary: Swift.Equatable {
        /// Summary of the details of a Channel.
        var channelSummary: ChimeSdkMessagingClientTypes.ChannelSummary?

        public init (
            channelSummary: ChimeSdkMessagingClientTypes.ChannelSummary? = nil
        )
        {
            self.channelSummary = channelSummary
        }
    }

}

extension ChimeSdkMessagingClientTypes.ChannelModerator: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case createdBy = "CreatedBy"
        case createdTimestamp = "CreatedTimestamp"
        case moderator = "Moderator"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let createdTimestamp = createdTimestamp {
            try encodeContainer.encode(createdTimestamp.timeIntervalSince1970, forKey: .createdTimestamp)
        }
        if let moderator = moderator {
            try encodeContainer.encode(moderator, forKey: .moderator)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let moderatorDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.Identity.self, forKey: .moderator)
        moderator = moderatorDecoded
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.Identity.self, forKey: .createdBy)
        createdBy = createdByDecoded
    }
}

extension ChimeSdkMessagingClientTypes {
    /// The details of a channel moderator.
    public struct ChannelModerator: Swift.Equatable {
        /// The ARN of the moderator's channel.
        var channelArn: Swift.String?
        /// The AppInstanceUser who created the moderator.
        var createdBy: ChimeSdkMessagingClientTypes.Identity?
        /// The time at which the moderator was created.
        var createdTimestamp: ClientRuntime.Date?
        /// The moderator's data.
        var moderator: ChimeSdkMessagingClientTypes.Identity?

        public init (
            channelArn: Swift.String? = nil,
            createdBy: ChimeSdkMessagingClientTypes.Identity? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            moderator: ChimeSdkMessagingClientTypes.Identity? = nil
        )
        {
            self.channelArn = channelArn
            self.createdBy = createdBy
            self.createdTimestamp = createdTimestamp
            self.moderator = moderator
        }
    }

}

extension ChimeSdkMessagingClientTypes.ChannelModeratorSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case moderator = "Moderator"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let moderator = moderator {
            try encodeContainer.encode(moderator, forKey: .moderator)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let moderatorDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.Identity.self, forKey: .moderator)
        moderator = moderatorDecoded
    }
}

extension ChimeSdkMessagingClientTypes {
    /// Summary of the details of a ChannelModerator.
    public struct ChannelModeratorSummary: Swift.Equatable {
        /// The data for a moderator.
        var moderator: ChimeSdkMessagingClientTypes.Identity?

        public init (
            moderator: ChimeSdkMessagingClientTypes.Identity? = nil
        )
        {
            self.moderator = moderator
        }
    }

}

extension ChimeSdkMessagingClientTypes {
    public enum ChannelPrivacy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `private`
        case `public`
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelPrivacy] {
            return [
                .private,
                .public,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .private: return "PRIVATE"
            case .public: return "PUBLIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChannelPrivacy(rawValue: rawValue) ?? ChannelPrivacy.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSdkMessagingClientTypes.ChannelSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case lastMessageTimestamp = "LastMessageTimestamp"
        case metadata = "Metadata"
        case mode = "Mode"
        case name = "Name"
        case privacy = "Privacy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let lastMessageTimestamp = lastMessageTimestamp {
            try encodeContainer.encode(lastMessageTimestamp.timeIntervalSince1970, forKey: .lastMessageTimestamp)
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let mode = mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let privacy = privacy {
            try encodeContainer.encode(privacy.rawValue, forKey: .privacy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let modeDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelMode.self, forKey: .mode)
        mode = modeDecoded
        let privacyDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelPrivacy.self, forKey: .privacy)
        privacy = privacyDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let lastMessageTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastMessageTimestamp)
        lastMessageTimestamp = lastMessageTimestampDecoded
    }
}

extension ChimeSdkMessagingClientTypes {
    /// Summary of the details of a Channel.
    public struct ChannelSummary: Swift.Equatable {
        /// The ARN of the channel.
        var channelArn: Swift.String?
        /// The time at which the last message in a channel was sent.
        var lastMessageTimestamp: ClientRuntime.Date?
        /// The metadata of the channel.
        var metadata: Swift.String?
        /// The mode of the channel.
        var mode: ChimeSdkMessagingClientTypes.ChannelMode?
        /// The name of the channel.
        var name: Swift.String?
        /// The privacy setting of the channel.
        var privacy: ChimeSdkMessagingClientTypes.ChannelPrivacy?

        public init (
            channelArn: Swift.String? = nil,
            lastMessageTimestamp: ClientRuntime.Date? = nil,
            metadata: Swift.String? = nil,
            mode: ChimeSdkMessagingClientTypes.ChannelMode? = nil,
            name: Swift.String? = nil,
            privacy: ChimeSdkMessagingClientTypes.ChannelPrivacy? = nil
        )
        {
            self.channelArn = channelArn
            self.lastMessageTimestamp = lastMessageTimestamp
            self.metadata = metadata
            self.mode = mode
            self.name = name
            self.privacy = privacy
        }
    }

}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request could not be processed because of conflict in the current state of the resource.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeSdkMessagingClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeSdkMessagingClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let code: ChimeSdkMessagingClientTypes.ErrorCode?
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateChannelBanInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberArn = "MemberArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let memberArn = memberArn {
            try encodeContainer.encode(memberArn, forKey: .memberArn)
        }
    }
}

extension CreateChannelBanInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension CreateChannelBanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/bans"
    }
}

public struct CreateChannelBanInput: Swift.Equatable {
    /// The ARN of the ban request.
    /// This member is required.
    var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    var chimeBearer: Swift.String?
    /// The AppInstanceUserArn of the member being banned.
    /// This member is required.
    var memberArn: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        memberArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.memberArn = memberArn
    }
}

struct CreateChannelBanInputBody: Swift.Equatable {
    let memberArn: Swift.String?
}

extension CreateChannelBanInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberArn = "MemberArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberArn)
        memberArn = memberArnDecoded
    }
}

extension CreateChannelBanOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateChannelBanOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateChannelBanOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateChannelBanOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateChannelBanOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.member = output.member
        } else {
            self.channelArn = nil
            self.member = nil
        }
    }
}

public struct CreateChannelBanOutputResponse: Swift.Equatable {
    /// The ARN of the response to the ban request.
    var channelArn: Swift.String?
    /// The ChannelArn and BannedIdentity of the member in the ban response.
    var member: ChimeSdkMessagingClientTypes.Identity?

    public init (
        channelArn: Swift.String? = nil,
        member: ChimeSdkMessagingClientTypes.Identity? = nil
    )
    {
        self.channelArn = channelArn
        self.member = member
    }
}

struct CreateChannelBanOutputResponseBody: Swift.Equatable {
    let channelArn: Swift.String?
    let member: ChimeSdkMessagingClientTypes.Identity?
}

extension CreateChannelBanOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case member = "Member"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let memberDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.Identity.self, forKey: .member)
        member = memberDecoded
    }
}

extension CreateChannelFlowInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceArn = "AppInstanceArn"
        case clientRequestToken = "ClientRequestToken"
        case name = "Name"
        case processors = "Processors"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appInstanceArn = appInstanceArn {
            try encodeContainer.encode(appInstanceArn, forKey: .appInstanceArn)
        }
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let processors = processors {
            var processorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .processors)
            for processorlist0 in processors {
                try processorsContainer.encode(processorlist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension CreateChannelFlowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/channel-flows"
    }
}

public struct CreateChannelFlowInput: Swift.Equatable {
    /// The ARN of the channel flow request.
    /// This member is required.
    var appInstanceArn: Swift.String?
    /// The client token for the request. An Idempotency token.
    /// This member is required.
    var clientRequestToken: Swift.String?
    /// The name of the channel flow.
    /// This member is required.
    var name: Swift.String?
    /// Information about the processor Lambda functions.
    /// This member is required.
    var processors: [ChimeSdkMessagingClientTypes.Processor]?
    /// The tags for the creation request.
    var tags: [ChimeSdkMessagingClientTypes.Tag]?

    public init (
        appInstanceArn: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        name: Swift.String? = nil,
        processors: [ChimeSdkMessagingClientTypes.Processor]? = nil,
        tags: [ChimeSdkMessagingClientTypes.Tag]? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.clientRequestToken = clientRequestToken
        self.name = name
        self.processors = processors
        self.tags = tags
    }
}

struct CreateChannelFlowInputBody: Swift.Equatable {
    let appInstanceArn: Swift.String?
    let processors: [ChimeSdkMessagingClientTypes.Processor]?
    let name: Swift.String?
    let tags: [ChimeSdkMessagingClientTypes.Tag]?
    let clientRequestToken: Swift.String?
}

extension CreateChannelFlowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceArn = "AppInstanceArn"
        case clientRequestToken = "ClientRequestToken"
        case name = "Name"
        case processors = "Processors"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceArn)
        appInstanceArn = appInstanceArnDecoded
        let processorsContainer = try containerValues.decodeIfPresent([ChimeSdkMessagingClientTypes.Processor?].self, forKey: .processors)
        var processorsDecoded0:[ChimeSdkMessagingClientTypes.Processor]? = nil
        if let processorsContainer = processorsContainer {
            processorsDecoded0 = [ChimeSdkMessagingClientTypes.Processor]()
            for structure0 in processorsContainer {
                if let structure0 = structure0 {
                    processorsDecoded0?.append(structure0)
                }
            }
        }
        processors = processorsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ChimeSdkMessagingClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeSdkMessagingClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeSdkMessagingClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension CreateChannelFlowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateChannelFlowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateChannelFlowOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateChannelFlowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateChannelFlowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelFlowArn = output.channelFlowArn
        } else {
            self.channelFlowArn = nil
        }
    }
}

public struct CreateChannelFlowOutputResponse: Swift.Equatable {
    /// The ARN of the channel flow.
    var channelFlowArn: Swift.String?

    public init (
        channelFlowArn: Swift.String? = nil
    )
    {
        self.channelFlowArn = channelFlowArn
    }
}

struct CreateChannelFlowOutputResponseBody: Swift.Equatable {
    let channelFlowArn: Swift.String?
}

extension CreateChannelFlowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelFlowArn = "ChannelFlowArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelFlowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelFlowArn)
        channelFlowArn = channelFlowArnDecoded
    }
}

extension CreateChannelInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceArn = "AppInstanceArn"
        case clientRequestToken = "ClientRequestToken"
        case metadata = "Metadata"
        case mode = "Mode"
        case name = "Name"
        case privacy = "Privacy"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appInstanceArn = appInstanceArn {
            try encodeContainer.encode(appInstanceArn, forKey: .appInstanceArn)
        }
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let mode = mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let privacy = privacy {
            try encodeContainer.encode(privacy.rawValue, forKey: .privacy)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension CreateChannelInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension CreateChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/channels"
    }
}

public struct CreateChannelInput: Swift.Equatable {
    /// The ARN of the channel request.
    /// This member is required.
    var appInstanceArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    var chimeBearer: Swift.String?
    /// The client token for the request. An Idempotency token.
    /// This member is required.
    var clientRequestToken: Swift.String?
    /// The metadata of the creation request. Limited to 1KB and UTF-8.
    var metadata: Swift.String?
    /// The channel mode: UNRESTRICTED or RESTRICTED. Administrators, moderators, and channel members can add themselves and other members to unrestricted channels. Only administrators and moderators can add members to restricted channels.
    var mode: ChimeSdkMessagingClientTypes.ChannelMode?
    /// The name of the channel.
    /// This member is required.
    var name: Swift.String?
    /// The channel's privacy level: PUBLIC or PRIVATE. Private channels aren't discoverable by users outside the channel. Public channels are discoverable by anyone in the AppInstance.
    var privacy: ChimeSdkMessagingClientTypes.ChannelPrivacy?
    /// The tags for the creation request.
    var tags: [ChimeSdkMessagingClientTypes.Tag]?

    public init (
        appInstanceArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        metadata: Swift.String? = nil,
        mode: ChimeSdkMessagingClientTypes.ChannelMode? = nil,
        name: Swift.String? = nil,
        privacy: ChimeSdkMessagingClientTypes.ChannelPrivacy? = nil,
        tags: [ChimeSdkMessagingClientTypes.Tag]? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.chimeBearer = chimeBearer
        self.clientRequestToken = clientRequestToken
        self.metadata = metadata
        self.mode = mode
        self.name = name
        self.privacy = privacy
        self.tags = tags
    }
}

struct CreateChannelInputBody: Swift.Equatable {
    let appInstanceArn: Swift.String?
    let name: Swift.String?
    let mode: ChimeSdkMessagingClientTypes.ChannelMode?
    let privacy: ChimeSdkMessagingClientTypes.ChannelPrivacy?
    let metadata: Swift.String?
    let clientRequestToken: Swift.String?
    let tags: [ChimeSdkMessagingClientTypes.Tag]?
}

extension CreateChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceArn = "AppInstanceArn"
        case clientRequestToken = "ClientRequestToken"
        case metadata = "Metadata"
        case mode = "Mode"
        case name = "Name"
        case privacy = "Privacy"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceArn)
        appInstanceArn = appInstanceArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let modeDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelMode.self, forKey: .mode)
        mode = modeDecoded
        let privacyDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelPrivacy.self, forKey: .privacy)
        privacy = privacyDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ChimeSdkMessagingClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeSdkMessagingClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeSdkMessagingClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateChannelMembershipInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberArn = "MemberArn"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let memberArn = memberArn {
            try encodeContainer.encode(memberArn, forKey: .memberArn)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateChannelMembershipInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension CreateChannelMembershipInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/memberships"
    }
}

public struct CreateChannelMembershipInput: Swift.Equatable {
    /// The ARN of the channel to which you're adding users.
    /// This member is required.
    var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    var chimeBearer: Swift.String?
    /// The AppInstanceUserArn of the member you want to add to the channel.
    /// This member is required.
    var memberArn: Swift.String?
    /// The membership type of a user, DEFAULT or HIDDEN. Default members are always returned as part of ListChannelMemberships. Hidden members are only returned if the type filter in ListChannelMemberships equals HIDDEN. Otherwise hidden members are not returned. This is only supported by moderators.
    /// This member is required.
    var type: ChimeSdkMessagingClientTypes.ChannelMembershipType?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        memberArn: Swift.String? = nil,
        type: ChimeSdkMessagingClientTypes.ChannelMembershipType? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.memberArn = memberArn
        self.type = type
    }
}

struct CreateChannelMembershipInputBody: Swift.Equatable {
    let memberArn: Swift.String?
    let type: ChimeSdkMessagingClientTypes.ChannelMembershipType?
}

extension CreateChannelMembershipInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberArn = "MemberArn"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberArn)
        memberArn = memberArnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelMembershipType.self, forKey: .type)
        type = typeDecoded
    }
}

extension CreateChannelMembershipOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateChannelMembershipOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateChannelMembershipOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateChannelMembershipOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateChannelMembershipOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.member = output.member
        } else {
            self.channelArn = nil
            self.member = nil
        }
    }
}

public struct CreateChannelMembershipOutputResponse: Swift.Equatable {
    /// The ARN of the channel.
    var channelArn: Swift.String?
    /// The ARN and metadata of the member being added.
    var member: ChimeSdkMessagingClientTypes.Identity?

    public init (
        channelArn: Swift.String? = nil,
        member: ChimeSdkMessagingClientTypes.Identity? = nil
    )
    {
        self.channelArn = channelArn
        self.member = member
    }
}

struct CreateChannelMembershipOutputResponseBody: Swift.Equatable {
    let channelArn: Swift.String?
    let member: ChimeSdkMessagingClientTypes.Identity?
}

extension CreateChannelMembershipOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case member = "Member"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let memberDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.Identity.self, forKey: .member)
        member = memberDecoded
    }
}

extension CreateChannelModeratorInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelModeratorArn = "ChannelModeratorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelModeratorArn = channelModeratorArn {
            try encodeContainer.encode(channelModeratorArn, forKey: .channelModeratorArn)
        }
    }
}

extension CreateChannelModeratorInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension CreateChannelModeratorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/moderators"
    }
}

public struct CreateChannelModeratorInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    var channelArn: Swift.String?
    /// The AppInstanceUserArn of the moderator.
    /// This member is required.
    var channelModeratorArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    var chimeBearer: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        channelModeratorArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.channelModeratorArn = channelModeratorArn
        self.chimeBearer = chimeBearer
    }
}

struct CreateChannelModeratorInputBody: Swift.Equatable {
    let channelModeratorArn: Swift.String?
}

extension CreateChannelModeratorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelModeratorArn = "ChannelModeratorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelModeratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelModeratorArn)
        channelModeratorArn = channelModeratorArnDecoded
    }
}

extension CreateChannelModeratorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateChannelModeratorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateChannelModeratorOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateChannelModeratorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateChannelModeratorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.channelModerator = output.channelModerator
        } else {
            self.channelArn = nil
            self.channelModerator = nil
        }
    }
}

public struct CreateChannelModeratorOutputResponse: Swift.Equatable {
    /// The ARN of the channel.
    var channelArn: Swift.String?
    /// The ARNs of the channel and the moderator.
    var channelModerator: ChimeSdkMessagingClientTypes.Identity?

    public init (
        channelArn: Swift.String? = nil,
        channelModerator: ChimeSdkMessagingClientTypes.Identity? = nil
    )
    {
        self.channelArn = channelArn
        self.channelModerator = channelModerator
    }
}

struct CreateChannelModeratorOutputResponseBody: Swift.Equatable {
    let channelArn: Swift.String?
    let channelModerator: ChimeSdkMessagingClientTypes.Identity?
}

extension CreateChannelModeratorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case channelModerator = "ChannelModerator"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let channelModeratorDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.Identity.self, forKey: .channelModerator)
        channelModerator = channelModeratorDecoded
    }
}

extension CreateChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateChannelOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateChannelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
        } else {
            self.channelArn = nil
        }
    }
}

public struct CreateChannelOutputResponse: Swift.Equatable {
    /// The ARN of the channel.
    var channelArn: Swift.String?

    public init (
        channelArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
    }
}

struct CreateChannelOutputResponseBody: Swift.Equatable {
    let channelArn: Swift.String?
}

extension CreateChannelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
    }
}

extension DeleteChannelBanInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension DeleteChannelBanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        guard let memberArn = memberArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/bans/\(memberArn.urlPercentEncoding())"
    }
}

public struct DeleteChannelBanInput: Swift.Equatable {
    /// The ARN of the channel from which the AppInstanceUser was banned.
    /// This member is required.
    var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    var chimeBearer: Swift.String?
    /// The ARN of the AppInstanceUser that you want to reinstate.
    /// This member is required.
    var memberArn: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        memberArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.memberArn = memberArn
    }
}

extension DeleteChannelBanOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteChannelBanOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteChannelBanOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteChannelBanOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteChannelBanOutputResponse: Swift.Equatable {

}

extension DeleteChannelFlowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelFlowArn = channelFlowArn else {
            return nil
        }
        return "/channel-flows/\(channelFlowArn.urlPercentEncoding())"
    }
}

public struct DeleteChannelFlowInput: Swift.Equatable {
    /// The ARN of the channel flow.
    /// This member is required.
    var channelFlowArn: Swift.String?

    public init (
        channelFlowArn: Swift.String? = nil
    )
    {
        self.channelFlowArn = channelFlowArn
    }
}

extension DeleteChannelFlowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteChannelFlowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteChannelFlowOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteChannelFlowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteChannelFlowOutputResponse: Swift.Equatable {

}

extension DeleteChannelInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension DeleteChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())"
    }
}

public struct DeleteChannelInput: Swift.Equatable {
    /// The ARN of the channel being deleted.
    /// This member is required.
    var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    var chimeBearer: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
    }
}

extension DeleteChannelMembershipInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension DeleteChannelMembershipInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        guard let memberArn = memberArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/memberships/\(memberArn.urlPercentEncoding())"
    }
}

public struct DeleteChannelMembershipInput: Swift.Equatable {
    /// The ARN of the channel from which you want to remove the user.
    /// This member is required.
    var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    var chimeBearer: Swift.String?
    /// The AppInstanceUserArn of the member that you're removing from the channel.
    /// This member is required.
    var memberArn: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        memberArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.memberArn = memberArn
    }
}

extension DeleteChannelMembershipOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteChannelMembershipOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteChannelMembershipOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteChannelMembershipOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteChannelMembershipOutputResponse: Swift.Equatable {

}

extension DeleteChannelMessageInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension DeleteChannelMessageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        guard let messageId = messageId else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/messages/\(messageId.urlPercentEncoding())"
    }
}

public struct DeleteChannelMessageInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    var chimeBearer: Swift.String?
    /// The ID of the message being deleted.
    /// This member is required.
    var messageId: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        messageId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.messageId = messageId
    }
}

extension DeleteChannelMessageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteChannelMessageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteChannelMessageOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteChannelMessageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteChannelMessageOutputResponse: Swift.Equatable {

}

extension DeleteChannelModeratorInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension DeleteChannelModeratorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        guard let channelModeratorArn = channelModeratorArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/moderators/\(channelModeratorArn.urlPercentEncoding())"
    }
}

public struct DeleteChannelModeratorInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    var channelArn: Swift.String?
    /// The AppInstanceUserArn of the moderator being deleted.
    /// This member is required.
    var channelModeratorArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    var chimeBearer: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        channelModeratorArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.channelModeratorArn = channelModeratorArn
        self.chimeBearer = chimeBearer
    }
}

extension DeleteChannelModeratorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteChannelModeratorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteChannelModeratorOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteChannelModeratorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteChannelModeratorOutputResponse: Swift.Equatable {

}

extension DeleteChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteChannelOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteChannelOutputResponse: Swift.Equatable {

}

extension DescribeChannelBanInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension DescribeChannelBanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        guard let memberArn = memberArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/bans/\(memberArn.urlPercentEncoding())"
    }
}

public struct DescribeChannelBanInput: Swift.Equatable {
    /// The ARN of the channel from which the user is banned.
    /// This member is required.
    var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    var chimeBearer: Swift.String?
    /// The AppInstanceUserArn of the member being banned.
    /// This member is required.
    var memberArn: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        memberArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.memberArn = memberArn
    }
}

extension DescribeChannelBanOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeChannelBanOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeChannelBanOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeChannelBanOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeChannelBanOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelBan = output.channelBan
        } else {
            self.channelBan = nil
        }
    }
}

public struct DescribeChannelBanOutputResponse: Swift.Equatable {
    /// The details of the ban.
    var channelBan: ChimeSdkMessagingClientTypes.ChannelBan?

    public init (
        channelBan: ChimeSdkMessagingClientTypes.ChannelBan? = nil
    )
    {
        self.channelBan = channelBan
    }
}

struct DescribeChannelBanOutputResponseBody: Swift.Equatable {
    let channelBan: ChimeSdkMessagingClientTypes.ChannelBan?
}

extension DescribeChannelBanOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelBan = "ChannelBan"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelBanDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelBan.self, forKey: .channelBan)
        channelBan = channelBanDecoded
    }
}

extension DescribeChannelFlowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelFlowArn = channelFlowArn else {
            return nil
        }
        return "/channel-flows/\(channelFlowArn.urlPercentEncoding())"
    }
}

public struct DescribeChannelFlowInput: Swift.Equatable {
    /// The ARN of the channel flow.
    /// This member is required.
    var channelFlowArn: Swift.String?

    public init (
        channelFlowArn: Swift.String? = nil
    )
    {
        self.channelFlowArn = channelFlowArn
    }
}

extension DescribeChannelFlowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeChannelFlowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeChannelFlowOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeChannelFlowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeChannelFlowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelFlow = output.channelFlow
        } else {
            self.channelFlow = nil
        }
    }
}

public struct DescribeChannelFlowOutputResponse: Swift.Equatable {
    /// The channel flow details.
    var channelFlow: ChimeSdkMessagingClientTypes.ChannelFlow?

    public init (
        channelFlow: ChimeSdkMessagingClientTypes.ChannelFlow? = nil
    )
    {
        self.channelFlow = channelFlow
    }
}

struct DescribeChannelFlowOutputResponseBody: Swift.Equatable {
    let channelFlow: ChimeSdkMessagingClientTypes.ChannelFlow?
}

extension DescribeChannelFlowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelFlow = "ChannelFlow"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelFlowDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelFlow.self, forKey: .channelFlow)
        channelFlow = channelFlowDecoded
    }
}

extension DescribeChannelInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension DescribeChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())"
    }
}

public struct DescribeChannelInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    var chimeBearer: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
    }
}

extension DescribeChannelMembershipForAppInstanceUserInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension DescribeChannelMembershipForAppInstanceUserInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "scope", value: "app-instance-user-membership"))
        if let appInstanceUserArn = appInstanceUserArn {
            let appInstanceUserArnQueryItem = ClientRuntime.URLQueryItem(name: "app-instance-user-arn".urlPercentEncoding(), value: Swift.String(appInstanceUserArn).urlPercentEncoding())
            items.append(appInstanceUserArnQueryItem)
        }
        return items
    }
}

extension DescribeChannelMembershipForAppInstanceUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())"
    }
}

public struct DescribeChannelMembershipForAppInstanceUserInput: Swift.Equatable {
    /// The ARN of the user in a channel.
    /// This member is required.
    var appInstanceUserArn: Swift.String?
    /// The ARN of the channel to which the user belongs.
    /// This member is required.
    var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    var chimeBearer: Swift.String?

    public init (
        appInstanceUserArn: Swift.String? = nil,
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
    }
}

extension DescribeChannelMembershipForAppInstanceUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeChannelMembershipForAppInstanceUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeChannelMembershipForAppInstanceUserOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeChannelMembershipForAppInstanceUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeChannelMembershipForAppInstanceUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelMembership = output.channelMembership
        } else {
            self.channelMembership = nil
        }
    }
}

public struct DescribeChannelMembershipForAppInstanceUserOutputResponse: Swift.Equatable {
    /// The channel to which a user belongs.
    var channelMembership: ChimeSdkMessagingClientTypes.ChannelMembershipForAppInstanceUserSummary?

    public init (
        channelMembership: ChimeSdkMessagingClientTypes.ChannelMembershipForAppInstanceUserSummary? = nil
    )
    {
        self.channelMembership = channelMembership
    }
}

struct DescribeChannelMembershipForAppInstanceUserOutputResponseBody: Swift.Equatable {
    let channelMembership: ChimeSdkMessagingClientTypes.ChannelMembershipForAppInstanceUserSummary?
}

extension DescribeChannelMembershipForAppInstanceUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelMembership = "ChannelMembership"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelMembershipDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelMembershipForAppInstanceUserSummary.self, forKey: .channelMembership)
        channelMembership = channelMembershipDecoded
    }
}

extension DescribeChannelMembershipInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension DescribeChannelMembershipInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        guard let memberArn = memberArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/memberships/\(memberArn.urlPercentEncoding())"
    }
}

public struct DescribeChannelMembershipInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    var chimeBearer: Swift.String?
    /// The AppInstanceUserArn of the member.
    /// This member is required.
    var memberArn: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        memberArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.memberArn = memberArn
    }
}

extension DescribeChannelMembershipOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeChannelMembershipOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeChannelMembershipOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeChannelMembershipOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeChannelMembershipOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelMembership = output.channelMembership
        } else {
            self.channelMembership = nil
        }
    }
}

public struct DescribeChannelMembershipOutputResponse: Swift.Equatable {
    /// The details of the membership.
    var channelMembership: ChimeSdkMessagingClientTypes.ChannelMembership?

    public init (
        channelMembership: ChimeSdkMessagingClientTypes.ChannelMembership? = nil
    )
    {
        self.channelMembership = channelMembership
    }
}

struct DescribeChannelMembershipOutputResponseBody: Swift.Equatable {
    let channelMembership: ChimeSdkMessagingClientTypes.ChannelMembership?
}

extension DescribeChannelMembershipOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelMembership = "ChannelMembership"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelMembershipDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelMembership.self, forKey: .channelMembership)
        channelMembership = channelMembershipDecoded
    }
}

extension DescribeChannelModeratedByAppInstanceUserInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension DescribeChannelModeratedByAppInstanceUserInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "scope", value: "app-instance-user-moderated-channel"))
        if let appInstanceUserArn = appInstanceUserArn {
            let appInstanceUserArnQueryItem = ClientRuntime.URLQueryItem(name: "app-instance-user-arn".urlPercentEncoding(), value: Swift.String(appInstanceUserArn).urlPercentEncoding())
            items.append(appInstanceUserArnQueryItem)
        }
        return items
    }
}

extension DescribeChannelModeratedByAppInstanceUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())"
    }
}

public struct DescribeChannelModeratedByAppInstanceUserInput: Swift.Equatable {
    /// The ARN of the AppInstanceUser in the moderated channel.
    /// This member is required.
    var appInstanceUserArn: Swift.String?
    /// The ARN of the moderated channel.
    /// This member is required.
    var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    var chimeBearer: Swift.String?

    public init (
        appInstanceUserArn: Swift.String? = nil,
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
    }
}

extension DescribeChannelModeratedByAppInstanceUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeChannelModeratedByAppInstanceUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeChannelModeratedByAppInstanceUserOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeChannelModeratedByAppInstanceUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeChannelModeratedByAppInstanceUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channel = output.channel
        } else {
            self.channel = nil
        }
    }
}

public struct DescribeChannelModeratedByAppInstanceUserOutputResponse: Swift.Equatable {
    /// The moderated channel.
    var channel: ChimeSdkMessagingClientTypes.ChannelModeratedByAppInstanceUserSummary?

    public init (
        channel: ChimeSdkMessagingClientTypes.ChannelModeratedByAppInstanceUserSummary? = nil
    )
    {
        self.channel = channel
    }
}

struct DescribeChannelModeratedByAppInstanceUserOutputResponseBody: Swift.Equatable {
    let channel: ChimeSdkMessagingClientTypes.ChannelModeratedByAppInstanceUserSummary?
}

extension DescribeChannelModeratedByAppInstanceUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channel = "Channel"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelModeratedByAppInstanceUserSummary.self, forKey: .channel)
        channel = channelDecoded
    }
}

extension DescribeChannelModeratorInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension DescribeChannelModeratorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        guard let channelModeratorArn = channelModeratorArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/moderators/\(channelModeratorArn.urlPercentEncoding())"
    }
}

public struct DescribeChannelModeratorInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    var channelArn: Swift.String?
    /// The AppInstanceUserArn of the channel moderator.
    /// This member is required.
    var channelModeratorArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    var chimeBearer: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        channelModeratorArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.channelModeratorArn = channelModeratorArn
        self.chimeBearer = chimeBearer
    }
}

extension DescribeChannelModeratorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeChannelModeratorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeChannelModeratorOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeChannelModeratorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeChannelModeratorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelModerator = output.channelModerator
        } else {
            self.channelModerator = nil
        }
    }
}

public struct DescribeChannelModeratorOutputResponse: Swift.Equatable {
    /// The details of the channel moderator.
    var channelModerator: ChimeSdkMessagingClientTypes.ChannelModerator?

    public init (
        channelModerator: ChimeSdkMessagingClientTypes.ChannelModerator? = nil
    )
    {
        self.channelModerator = channelModerator
    }
}

struct DescribeChannelModeratorOutputResponseBody: Swift.Equatable {
    let channelModerator: ChimeSdkMessagingClientTypes.ChannelModerator?
}

extension DescribeChannelModeratorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelModerator = "ChannelModerator"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelModeratorDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelModerator.self, forKey: .channelModerator)
        channelModerator = channelModeratorDecoded
    }
}

extension DescribeChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeChannelOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeChannelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channel = output.channel
        } else {
            self.channel = nil
        }
    }
}

public struct DescribeChannelOutputResponse: Swift.Equatable {
    /// The channel details.
    var channel: ChimeSdkMessagingClientTypes.Channel?

    public init (
        channel: ChimeSdkMessagingClientTypes.Channel? = nil
    )
    {
        self.channel = channel
    }
}

struct DescribeChannelOutputResponseBody: Swift.Equatable {
    let channel: ChimeSdkMessagingClientTypes.Channel?
}

extension DescribeChannelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channel = "Channel"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.Channel.self, forKey: .channel)
        channel = channelDecoded
    }
}

extension DisassociateChannelFlowInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension DisassociateChannelFlowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        guard let channelFlowArn = channelFlowArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/channel-flow/\(channelFlowArn.urlPercentEncoding())"
    }
}

public struct DisassociateChannelFlowInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    var channelArn: Swift.String?
    /// The ARN of the channel flow.
    /// This member is required.
    var channelFlowArn: Swift.String?
    /// The AppInstanceUserArn of the user making the API call.
    /// This member is required.
    var chimeBearer: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        channelFlowArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.channelFlowArn = channelFlowArn
        self.chimeBearer = chimeBearer
    }
}

extension DisassociateChannelFlowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateChannelFlowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateChannelFlowOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateChannelFlowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateChannelFlowOutputResponse: Swift.Equatable {

}

extension ChimeSdkMessagingClientTypes {
    public enum ErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessdenied
        case badrequest
        case conflict
        case forbidden
        case notfound
        case phonenumberassociationsexist
        case preconditionfailed
        case resourcelimitexceeded
        case servicefailure
        case serviceunavailable
        case throttled
        case throttling
        case unauthorized
        case unprocessable
        case voiceconnectorgroupassociationsexist
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCode] {
            return [
                .accessdenied,
                .badrequest,
                .conflict,
                .forbidden,
                .notfound,
                .phonenumberassociationsexist,
                .preconditionfailed,
                .resourcelimitexceeded,
                .servicefailure,
                .serviceunavailable,
                .throttled,
                .throttling,
                .unauthorized,
                .unprocessable,
                .voiceconnectorgroupassociationsexist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessdenied: return "AccessDenied"
            case .badrequest: return "BadRequest"
            case .conflict: return "Conflict"
            case .forbidden: return "Forbidden"
            case .notfound: return "NotFound"
            case .phonenumberassociationsexist: return "PhoneNumberAssociationsExist"
            case .preconditionfailed: return "PreconditionFailed"
            case .resourcelimitexceeded: return "ResourceLimitExceeded"
            case .servicefailure: return "ServiceFailure"
            case .serviceunavailable: return "ServiceUnavailable"
            case .throttled: return "Throttled"
            case .throttling: return "Throttling"
            case .unauthorized: return "Unauthorized"
            case .unprocessable: return "Unprocessable"
            case .voiceconnectorgroupassociationsexist: return "VoiceConnectorGroupAssociationsExist"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ErrorCode(rawValue: rawValue) ?? ErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSdkMessagingClientTypes {
    public enum FallbackAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case abort
        case `continue`
        case sdkUnknown(Swift.String)

        public static var allCases: [FallbackAction] {
            return [
                .abort,
                .continue,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .abort: return "ABORT"
            case .continue: return "CONTINUE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FallbackAction(rawValue: rawValue) ?? FallbackAction.sdkUnknown(rawValue)
        }
    }
}

extension ForbiddenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ForbiddenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The client is permanently forbidden from making the request.
public struct ForbiddenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeSdkMessagingClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeSdkMessagingClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ForbiddenExceptionBody: Swift.Equatable {
    let code: ChimeSdkMessagingClientTypes.ErrorCode?
    let message: Swift.String?
}

extension ForbiddenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GetChannelMembershipPreferencesInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension GetChannelMembershipPreferencesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        guard let memberArn = memberArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/memberships/\(memberArn.urlPercentEncoding())/preferences"
    }
}

public struct GetChannelMembershipPreferencesInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    var channelArn: Swift.String?
    /// The AppInstanceUserARN of the user making the API call.
    /// This member is required.
    var chimeBearer: Swift.String?
    /// The AppInstanceUserArn of the member retrieving the preferences.
    /// This member is required.
    var memberArn: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        memberArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.memberArn = memberArn
    }
}

extension GetChannelMembershipPreferencesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetChannelMembershipPreferencesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetChannelMembershipPreferencesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetChannelMembershipPreferencesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetChannelMembershipPreferencesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.member = output.member
            self.preferences = output.preferences
        } else {
            self.channelArn = nil
            self.member = nil
            self.preferences = nil
        }
    }
}

public struct GetChannelMembershipPreferencesOutputResponse: Swift.Equatable {
    /// The ARN of the channel.
    var channelArn: Swift.String?
    /// The details of a user.
    var member: ChimeSdkMessagingClientTypes.Identity?
    /// The channel membership preferences for an AppInstanceUser .
    var preferences: ChimeSdkMessagingClientTypes.ChannelMembershipPreferences?

    public init (
        channelArn: Swift.String? = nil,
        member: ChimeSdkMessagingClientTypes.Identity? = nil,
        preferences: ChimeSdkMessagingClientTypes.ChannelMembershipPreferences? = nil
    )
    {
        self.channelArn = channelArn
        self.member = member
        self.preferences = preferences
    }
}

struct GetChannelMembershipPreferencesOutputResponseBody: Swift.Equatable {
    let channelArn: Swift.String?
    let member: ChimeSdkMessagingClientTypes.Identity?
    let preferences: ChimeSdkMessagingClientTypes.ChannelMembershipPreferences?
}

extension GetChannelMembershipPreferencesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case member = "Member"
        case preferences = "Preferences"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let memberDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.Identity.self, forKey: .member)
        member = memberDecoded
        let preferencesDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelMembershipPreferences.self, forKey: .preferences)
        preferences = preferencesDecoded
    }
}

extension GetChannelMessageInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension GetChannelMessageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        guard let messageId = messageId else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/messages/\(messageId.urlPercentEncoding())"
    }
}

public struct GetChannelMessageInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    var chimeBearer: Swift.String?
    /// The ID of the message.
    /// This member is required.
    var messageId: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        messageId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.messageId = messageId
    }
}

extension GetChannelMessageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetChannelMessageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetChannelMessageOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetChannelMessageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetChannelMessageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelMessage = output.channelMessage
        } else {
            self.channelMessage = nil
        }
    }
}

public struct GetChannelMessageOutputResponse: Swift.Equatable {
    /// The details of and content in the message.
    var channelMessage: ChimeSdkMessagingClientTypes.ChannelMessage?

    public init (
        channelMessage: ChimeSdkMessagingClientTypes.ChannelMessage? = nil
    )
    {
        self.channelMessage = channelMessage
    }
}

struct GetChannelMessageOutputResponseBody: Swift.Equatable {
    let channelMessage: ChimeSdkMessagingClientTypes.ChannelMessage?
}

extension GetChannelMessageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelMessage = "ChannelMessage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelMessageDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelMessage.self, forKey: .channelMessage)
        channelMessage = channelMessageDecoded
    }
}

extension GetChannelMessageStatusInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension GetChannelMessageStatusInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "scope", value: "message-status"))
        return items
    }
}

extension GetChannelMessageStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        guard let messageId = messageId else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/messages/\(messageId.urlPercentEncoding())"
    }
}

public struct GetChannelMessageStatusInput: Swift.Equatable {
    /// The ARN of the channel
    /// This member is required.
    var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user making the API call.
    /// This member is required.
    var chimeBearer: Swift.String?
    /// The ID of the message.
    /// This member is required.
    var messageId: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        messageId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.messageId = messageId
    }
}

extension GetChannelMessageStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetChannelMessageStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetChannelMessageStatusOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetChannelMessageStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetChannelMessageStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct GetChannelMessageStatusOutputResponse: Swift.Equatable {
    /// The message status and details.
    var status: ChimeSdkMessagingClientTypes.ChannelMessageStatusStructure?

    public init (
        status: ChimeSdkMessagingClientTypes.ChannelMessageStatusStructure? = nil
    )
    {
        self.status = status
    }
}

struct GetChannelMessageStatusOutputResponseBody: Swift.Equatable {
    let status: ChimeSdkMessagingClientTypes.ChannelMessageStatusStructure?
}

extension GetChannelMessageStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelMessageStatusStructure.self, forKey: .status)
        status = statusDecoded
    }
}

extension GetMessagingSessionEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/endpoints/messaging-session"
    }
}

public struct GetMessagingSessionEndpointInput: Swift.Equatable {

}

extension GetMessagingSessionEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMessagingSessionEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMessagingSessionEndpointOutputError: Swift.Error, Swift.Equatable {
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMessagingSessionEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetMessagingSessionEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endpoint = output.endpoint
        } else {
            self.endpoint = nil
        }
    }
}

public struct GetMessagingSessionEndpointOutputResponse: Swift.Equatable {
    /// The endpoint returned in the response.
    var endpoint: ChimeSdkMessagingClientTypes.MessagingSessionEndpoint?

    public init (
        endpoint: ChimeSdkMessagingClientTypes.MessagingSessionEndpoint? = nil
    )
    {
        self.endpoint = endpoint
    }
}

struct GetMessagingSessionEndpointOutputResponseBody: Swift.Equatable {
    let endpoint: ChimeSdkMessagingClientTypes.MessagingSessionEndpoint?
}

extension GetMessagingSessionEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoint = "Endpoint"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.MessagingSessionEndpoint.self, forKey: .endpoint)
        endpoint = endpointDecoded
    }
}

extension ChimeSdkMessagingClientTypes.Identity: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension ChimeSdkMessagingClientTypes {
    /// The details of a user.
    public struct Identity: Swift.Equatable {
        /// The ARN in an Identity.
        var arn: Swift.String?
        /// The name in an Identity.
        var name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.name = name
        }
    }

}

extension ChimeSdkMessagingClientTypes {
    public enum InvocationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case async
        case sdkUnknown(Swift.String)

        public static var allCases: [InvocationType] {
            return [
                .async,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .async: return "ASYNC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InvocationType(rawValue: rawValue) ?? InvocationType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSdkMessagingClientTypes.LambdaConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invocationType = "InvocationType"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let invocationType = invocationType {
            try encodeContainer.encode(invocationType.rawValue, forKey: .invocationType)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let invocationTypeDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.InvocationType.self, forKey: .invocationType)
        invocationType = invocationTypeDecoded
    }
}

extension ChimeSdkMessagingClientTypes {
    /// Stores metadata about a Lambda processor.
    public struct LambdaConfiguration: Swift.Equatable {
        /// Controls how the Lambda function is invoked.
        /// This member is required.
        var invocationType: ChimeSdkMessagingClientTypes.InvocationType?
        /// The ARN of the Lambda message processing function.
        /// This member is required.
        var resourceArn: Swift.String?

        public init (
            invocationType: ChimeSdkMessagingClientTypes.InvocationType? = nil,
            resourceArn: Swift.String? = nil
        )
        {
            self.invocationType = invocationType
            self.resourceArn = resourceArn
        }
    }

}

extension ListChannelBansInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension ListChannelBansInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListChannelBansInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/bans"
    }
}

public struct ListChannelBansInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    var chimeBearer: Swift.String?
    /// The maximum number of bans that you want returned.
    var maxResults: Swift.Int?
    /// The token passed by previous API calls until all requested bans are returned.
    var nextToken: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListChannelBansOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListChannelBansOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListChannelBansOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListChannelBansOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListChannelBansOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.channelBans = output.channelBans
            self.nextToken = output.nextToken
        } else {
            self.channelArn = nil
            self.channelBans = nil
            self.nextToken = nil
        }
    }
}

public struct ListChannelBansOutputResponse: Swift.Equatable {
    /// The ARN of the channel.
    var channelArn: Swift.String?
    /// The information for each requested ban.
    var channelBans: [ChimeSdkMessagingClientTypes.ChannelBanSummary]?
    /// The token passed by previous API calls until all requested bans are returned.
    var nextToken: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        channelBans: [ChimeSdkMessagingClientTypes.ChannelBanSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.channelBans = channelBans
        self.nextToken = nextToken
    }
}

struct ListChannelBansOutputResponseBody: Swift.Equatable {
    let channelArn: Swift.String?
    let nextToken: Swift.String?
    let channelBans: [ChimeSdkMessagingClientTypes.ChannelBanSummary]?
}

extension ListChannelBansOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case channelBans = "ChannelBans"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let channelBansContainer = try containerValues.decodeIfPresent([ChimeSdkMessagingClientTypes.ChannelBanSummary?].self, forKey: .channelBans)
        var channelBansDecoded0:[ChimeSdkMessagingClientTypes.ChannelBanSummary]? = nil
        if let channelBansContainer = channelBansContainer {
            channelBansDecoded0 = [ChimeSdkMessagingClientTypes.ChannelBanSummary]()
            for structure0 in channelBansContainer {
                if let structure0 = structure0 {
                    channelBansDecoded0?.append(structure0)
                }
            }
        }
        channelBans = channelBansDecoded0
    }
}

extension ListChannelFlowsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let appInstanceArn = appInstanceArn {
            let appInstanceArnQueryItem = ClientRuntime.URLQueryItem(name: "app-instance-arn".urlPercentEncoding(), value: Swift.String(appInstanceArn).urlPercentEncoding())
            items.append(appInstanceArnQueryItem)
        }
        return items
    }
}

extension ListChannelFlowsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/channel-flows"
    }
}

public struct ListChannelFlowsInput: Swift.Equatable {
    /// The ARN of the app instance.
    /// This member is required.
    var appInstanceArn: Swift.String?
    /// The maximum number of channel flows that you want to return.
    var maxResults: Swift.Int?
    /// The token passed by previous API calls until all requested channel flows are returned.
    var nextToken: Swift.String?

    public init (
        appInstanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListChannelFlowsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListChannelFlowsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListChannelFlowsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListChannelFlowsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListChannelFlowsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelFlows = output.channelFlows
            self.nextToken = output.nextToken
        } else {
            self.channelFlows = nil
            self.nextToken = nil
        }
    }
}

public struct ListChannelFlowsOutputResponse: Swift.Equatable {
    /// The information about each channel flow.
    var channelFlows: [ChimeSdkMessagingClientTypes.ChannelFlowSummary]?
    /// The token passed by previous API calls until all requested channels are returned.
    var nextToken: Swift.String?

    public init (
        channelFlows: [ChimeSdkMessagingClientTypes.ChannelFlowSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelFlows = channelFlows
        self.nextToken = nextToken
    }
}

struct ListChannelFlowsOutputResponseBody: Swift.Equatable {
    let channelFlows: [ChimeSdkMessagingClientTypes.ChannelFlowSummary]?
    let nextToken: Swift.String?
}

extension ListChannelFlowsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelFlows = "ChannelFlows"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelFlowsContainer = try containerValues.decodeIfPresent([ChimeSdkMessagingClientTypes.ChannelFlowSummary?].self, forKey: .channelFlows)
        var channelFlowsDecoded0:[ChimeSdkMessagingClientTypes.ChannelFlowSummary]? = nil
        if let channelFlowsContainer = channelFlowsContainer {
            channelFlowsDecoded0 = [ChimeSdkMessagingClientTypes.ChannelFlowSummary]()
            for structure0 in channelFlowsContainer {
                if let structure0 = structure0 {
                    channelFlowsDecoded0?.append(structure0)
                }
            }
        }
        channelFlows = channelFlowsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListChannelMembershipsForAppInstanceUserInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension ListChannelMembershipsForAppInstanceUserInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "scope", value: "app-instance-user-memberships"))
        if let appInstanceUserArn = appInstanceUserArn {
            let appInstanceUserArnQueryItem = ClientRuntime.URLQueryItem(name: "app-instance-user-arn".urlPercentEncoding(), value: Swift.String(appInstanceUserArn).urlPercentEncoding())
            items.append(appInstanceUserArnQueryItem)
        }
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListChannelMembershipsForAppInstanceUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/channels"
    }
}

public struct ListChannelMembershipsForAppInstanceUserInput: Swift.Equatable {
    /// The ARN of the AppInstanceUsers
    var appInstanceUserArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    var chimeBearer: Swift.String?
    /// The maximum number of users that you want returned.
    var maxResults: Swift.Int?
    /// The token returned from previous API requests until the number of channel memberships is reached.
    var nextToken: Swift.String?

    public init (
        appInstanceUserArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
        self.chimeBearer = chimeBearer
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListChannelMembershipsForAppInstanceUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListChannelMembershipsForAppInstanceUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListChannelMembershipsForAppInstanceUserOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListChannelMembershipsForAppInstanceUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListChannelMembershipsForAppInstanceUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelMemberships = output.channelMemberships
            self.nextToken = output.nextToken
        } else {
            self.channelMemberships = nil
            self.nextToken = nil
        }
    }
}

public struct ListChannelMembershipsForAppInstanceUserOutputResponse: Swift.Equatable {
    /// The token passed by previous API calls until all requested users are returned.
    var channelMemberships: [ChimeSdkMessagingClientTypes.ChannelMembershipForAppInstanceUserSummary]?
    /// The token passed by previous API calls until all requested users are returned.
    var nextToken: Swift.String?

    public init (
        channelMemberships: [ChimeSdkMessagingClientTypes.ChannelMembershipForAppInstanceUserSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelMemberships = channelMemberships
        self.nextToken = nextToken
    }
}

struct ListChannelMembershipsForAppInstanceUserOutputResponseBody: Swift.Equatable {
    let channelMemberships: [ChimeSdkMessagingClientTypes.ChannelMembershipForAppInstanceUserSummary]?
    let nextToken: Swift.String?
}

extension ListChannelMembershipsForAppInstanceUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelMemberships = "ChannelMemberships"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelMembershipsContainer = try containerValues.decodeIfPresent([ChimeSdkMessagingClientTypes.ChannelMembershipForAppInstanceUserSummary?].self, forKey: .channelMemberships)
        var channelMembershipsDecoded0:[ChimeSdkMessagingClientTypes.ChannelMembershipForAppInstanceUserSummary]? = nil
        if let channelMembershipsContainer = channelMembershipsContainer {
            channelMembershipsDecoded0 = [ChimeSdkMessagingClientTypes.ChannelMembershipForAppInstanceUserSummary]()
            for structure0 in channelMembershipsContainer {
                if let structure0 = structure0 {
                    channelMembershipsDecoded0?.append(structure0)
                }
            }
        }
        channelMemberships = channelMembershipsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListChannelMembershipsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension ListChannelMembershipsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let type = type {
            let typeQueryItem = ClientRuntime.URLQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
            items.append(typeQueryItem)
        }
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListChannelMembershipsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/memberships"
    }
}

public struct ListChannelMembershipsInput: Swift.Equatable {
    /// The maximum number of channel memberships that you want returned.
    /// This member is required.
    var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    var chimeBearer: Swift.String?
    /// The maximum number of channel memberships that you want returned.
    var maxResults: Swift.Int?
    /// The token passed by previous API calls until all requested channel memberships are returned.
    var nextToken: Swift.String?
    /// The membership type of a user, DEFAULT or HIDDEN. Default members are always returned as part of ListChannelMemberships. Hidden members are only returned if the type filter in ListChannelMemberships equals HIDDEN. Otherwise hidden members are not returned.
    var type: ChimeSdkMessagingClientTypes.ChannelMembershipType?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        type: ChimeSdkMessagingClientTypes.ChannelMembershipType? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.type = type
    }
}

extension ListChannelMembershipsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListChannelMembershipsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListChannelMembershipsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListChannelMembershipsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListChannelMembershipsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.channelMemberships = output.channelMemberships
            self.nextToken = output.nextToken
        } else {
            self.channelArn = nil
            self.channelMemberships = nil
            self.nextToken = nil
        }
    }
}

public struct ListChannelMembershipsOutputResponse: Swift.Equatable {
    /// The ARN of the channel.
    var channelArn: Swift.String?
    /// The information for the requested channel memberships.
    var channelMemberships: [ChimeSdkMessagingClientTypes.ChannelMembershipSummary]?
    /// The token passed by previous API calls until all requested channel memberships are returned.
    var nextToken: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        channelMemberships: [ChimeSdkMessagingClientTypes.ChannelMembershipSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.channelMemberships = channelMemberships
        self.nextToken = nextToken
    }
}

struct ListChannelMembershipsOutputResponseBody: Swift.Equatable {
    let channelArn: Swift.String?
    let channelMemberships: [ChimeSdkMessagingClientTypes.ChannelMembershipSummary]?
    let nextToken: Swift.String?
}

extension ListChannelMembershipsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case channelMemberships = "ChannelMemberships"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let channelMembershipsContainer = try containerValues.decodeIfPresent([ChimeSdkMessagingClientTypes.ChannelMembershipSummary?].self, forKey: .channelMemberships)
        var channelMembershipsDecoded0:[ChimeSdkMessagingClientTypes.ChannelMembershipSummary]? = nil
        if let channelMembershipsContainer = channelMembershipsContainer {
            channelMembershipsDecoded0 = [ChimeSdkMessagingClientTypes.ChannelMembershipSummary]()
            for structure0 in channelMembershipsContainer {
                if let structure0 = structure0 {
                    channelMembershipsDecoded0?.append(structure0)
                }
            }
        }
        channelMemberships = channelMembershipsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListChannelMessagesInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension ListChannelMessagesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let sortOrder = sortOrder {
            let sortOrderQueryItem = ClientRuntime.URLQueryItem(name: "sort-order".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
            items.append(sortOrderQueryItem)
        }
        if let notBefore = notBefore {
            let notBeforeQueryItem = ClientRuntime.URLQueryItem(name: "not-before".urlPercentEncoding(), value: Swift.String(notBefore.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            items.append(notBeforeQueryItem)
        }
        if let notAfter = notAfter {
            let notAfterQueryItem = ClientRuntime.URLQueryItem(name: "not-after".urlPercentEncoding(), value: Swift.String(notAfter.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            items.append(notAfterQueryItem)
        }
        return items
    }
}

extension ListChannelMessagesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/messages"
    }
}

public struct ListChannelMessagesInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    var chimeBearer: Swift.String?
    /// The maximum number of messages that you want returned.
    var maxResults: Swift.Int?
    /// The token passed by previous API calls until all requested messages are returned.
    var nextToken: Swift.String?
    /// The final or ending time stamp for your requested messages.
    var notAfter: ClientRuntime.Date?
    /// The initial or starting time stamp for your requested messages.
    var notBefore: ClientRuntime.Date?
    /// The order in which you want messages sorted. Default is Descending, based on time created.
    var sortOrder: ChimeSdkMessagingClientTypes.SortOrder?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        notAfter: ClientRuntime.Date? = nil,
        notBefore: ClientRuntime.Date? = nil,
        sortOrder: ChimeSdkMessagingClientTypes.SortOrder? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.notAfter = notAfter
        self.notBefore = notBefore
        self.sortOrder = sortOrder
    }
}

extension ListChannelMessagesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListChannelMessagesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListChannelMessagesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListChannelMessagesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListChannelMessagesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.channelMessages = output.channelMessages
            self.nextToken = output.nextToken
        } else {
            self.channelArn = nil
            self.channelMessages = nil
            self.nextToken = nil
        }
    }
}

public struct ListChannelMessagesOutputResponse: Swift.Equatable {
    /// The ARN of the channel containing the requested messages.
    var channelArn: Swift.String?
    /// The information about, and content of, each requested message.
    var channelMessages: [ChimeSdkMessagingClientTypes.ChannelMessageSummary]?
    /// The token passed by previous API calls until all requested messages are returned.
    var nextToken: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        channelMessages: [ChimeSdkMessagingClientTypes.ChannelMessageSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.channelMessages = channelMessages
        self.nextToken = nextToken
    }
}

struct ListChannelMessagesOutputResponseBody: Swift.Equatable {
    let channelArn: Swift.String?
    let nextToken: Swift.String?
    let channelMessages: [ChimeSdkMessagingClientTypes.ChannelMessageSummary]?
}

extension ListChannelMessagesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case channelMessages = "ChannelMessages"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let channelMessagesContainer = try containerValues.decodeIfPresent([ChimeSdkMessagingClientTypes.ChannelMessageSummary?].self, forKey: .channelMessages)
        var channelMessagesDecoded0:[ChimeSdkMessagingClientTypes.ChannelMessageSummary]? = nil
        if let channelMessagesContainer = channelMessagesContainer {
            channelMessagesDecoded0 = [ChimeSdkMessagingClientTypes.ChannelMessageSummary]()
            for structure0 in channelMessagesContainer {
                if let structure0 = structure0 {
                    channelMessagesDecoded0?.append(structure0)
                }
            }
        }
        channelMessages = channelMessagesDecoded0
    }
}

extension ListChannelModeratorsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension ListChannelModeratorsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListChannelModeratorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/moderators"
    }
}

public struct ListChannelModeratorsInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    var chimeBearer: Swift.String?
    /// The maximum number of moderators that you want returned.
    var maxResults: Swift.Int?
    /// The token passed by previous API calls until all requested moderators are returned.
    var nextToken: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListChannelModeratorsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListChannelModeratorsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListChannelModeratorsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListChannelModeratorsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListChannelModeratorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.channelModerators = output.channelModerators
            self.nextToken = output.nextToken
        } else {
            self.channelArn = nil
            self.channelModerators = nil
            self.nextToken = nil
        }
    }
}

public struct ListChannelModeratorsOutputResponse: Swift.Equatable {
    /// The ARN of the channel.
    var channelArn: Swift.String?
    /// The information about and names of each moderator.
    var channelModerators: [ChimeSdkMessagingClientTypes.ChannelModeratorSummary]?
    /// The token passed by previous API calls until all requested moderators are returned.
    var nextToken: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        channelModerators: [ChimeSdkMessagingClientTypes.ChannelModeratorSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.channelModerators = channelModerators
        self.nextToken = nextToken
    }
}

struct ListChannelModeratorsOutputResponseBody: Swift.Equatable {
    let channelArn: Swift.String?
    let nextToken: Swift.String?
    let channelModerators: [ChimeSdkMessagingClientTypes.ChannelModeratorSummary]?
}

extension ListChannelModeratorsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case channelModerators = "ChannelModerators"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let channelModeratorsContainer = try containerValues.decodeIfPresent([ChimeSdkMessagingClientTypes.ChannelModeratorSummary?].self, forKey: .channelModerators)
        var channelModeratorsDecoded0:[ChimeSdkMessagingClientTypes.ChannelModeratorSummary]? = nil
        if let channelModeratorsContainer = channelModeratorsContainer {
            channelModeratorsDecoded0 = [ChimeSdkMessagingClientTypes.ChannelModeratorSummary]()
            for structure0 in channelModeratorsContainer {
                if let structure0 = structure0 {
                    channelModeratorsDecoded0?.append(structure0)
                }
            }
        }
        channelModerators = channelModeratorsDecoded0
    }
}

extension ListChannelsAssociatedWithChannelFlowInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "scope", value: "channel-flow-associations"))
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let channelFlowArn = channelFlowArn {
            let channelFlowArnQueryItem = ClientRuntime.URLQueryItem(name: "channel-flow-arn".urlPercentEncoding(), value: Swift.String(channelFlowArn).urlPercentEncoding())
            items.append(channelFlowArnQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListChannelsAssociatedWithChannelFlowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/channels"
    }
}

public struct ListChannelsAssociatedWithChannelFlowInput: Swift.Equatable {
    /// The ARN of the channel flow.
    /// This member is required.
    var channelFlowArn: Swift.String?
    /// The maximum number of channels that you want to return.
    var maxResults: Swift.Int?
    /// The token passed by previous API calls until all requested channels are returned.
    var nextToken: Swift.String?

    public init (
        channelFlowArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelFlowArn = channelFlowArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListChannelsAssociatedWithChannelFlowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListChannelsAssociatedWithChannelFlowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListChannelsAssociatedWithChannelFlowOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListChannelsAssociatedWithChannelFlowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListChannelsAssociatedWithChannelFlowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channels = output.channels
            self.nextToken = output.nextToken
        } else {
            self.channels = nil
            self.nextToken = nil
        }
    }
}

public struct ListChannelsAssociatedWithChannelFlowOutputResponse: Swift.Equatable {
    /// The information about each channel.
    var channels: [ChimeSdkMessagingClientTypes.ChannelAssociatedWithFlowSummary]?
    /// The token passed by previous API calls until all requested channels are returned.
    var nextToken: Swift.String?

    public init (
        channels: [ChimeSdkMessagingClientTypes.ChannelAssociatedWithFlowSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channels = channels
        self.nextToken = nextToken
    }
}

struct ListChannelsAssociatedWithChannelFlowOutputResponseBody: Swift.Equatable {
    let channels: [ChimeSdkMessagingClientTypes.ChannelAssociatedWithFlowSummary]?
    let nextToken: Swift.String?
}

extension ListChannelsAssociatedWithChannelFlowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channels = "Channels"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelsContainer = try containerValues.decodeIfPresent([ChimeSdkMessagingClientTypes.ChannelAssociatedWithFlowSummary?].self, forKey: .channels)
        var channelsDecoded0:[ChimeSdkMessagingClientTypes.ChannelAssociatedWithFlowSummary]? = nil
        if let channelsContainer = channelsContainer {
            channelsDecoded0 = [ChimeSdkMessagingClientTypes.ChannelAssociatedWithFlowSummary]()
            for structure0 in channelsContainer {
                if let structure0 = structure0 {
                    channelsDecoded0?.append(structure0)
                }
            }
        }
        channels = channelsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListChannelsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension ListChannelsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let privacy = privacy {
            let privacyQueryItem = ClientRuntime.URLQueryItem(name: "privacy".urlPercentEncoding(), value: Swift.String(privacy.rawValue).urlPercentEncoding())
            items.append(privacyQueryItem)
        }
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let appInstanceArn = appInstanceArn {
            let appInstanceArnQueryItem = ClientRuntime.URLQueryItem(name: "app-instance-arn".urlPercentEncoding(), value: Swift.String(appInstanceArn).urlPercentEncoding())
            items.append(appInstanceArnQueryItem)
        }
        return items
    }
}

extension ListChannelsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/channels"
    }
}

public struct ListChannelsInput: Swift.Equatable {
    /// The ARN of the AppInstance.
    /// This member is required.
    var appInstanceArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    var chimeBearer: Swift.String?
    /// The maximum number of channels that you want to return.
    var maxResults: Swift.Int?
    /// The token passed by previous API calls until all requested channels are returned.
    var nextToken: Swift.String?
    /// The privacy setting. PUBLIC retrieves all the public channels. PRIVATE retrieves private channels. Only an AppInstanceAdmin can retrieve private channels.
    var privacy: ChimeSdkMessagingClientTypes.ChannelPrivacy?

    public init (
        appInstanceArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        privacy: ChimeSdkMessagingClientTypes.ChannelPrivacy? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.chimeBearer = chimeBearer
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.privacy = privacy
    }
}

extension ListChannelsModeratedByAppInstanceUserInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension ListChannelsModeratedByAppInstanceUserInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "scope", value: "app-instance-user-moderated-channels"))
        if let appInstanceUserArn = appInstanceUserArn {
            let appInstanceUserArnQueryItem = ClientRuntime.URLQueryItem(name: "app-instance-user-arn".urlPercentEncoding(), value: Swift.String(appInstanceUserArn).urlPercentEncoding())
            items.append(appInstanceUserArnQueryItem)
        }
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListChannelsModeratedByAppInstanceUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/channels"
    }
}

public struct ListChannelsModeratedByAppInstanceUserInput: Swift.Equatable {
    /// The ARN of the user in the moderated channel.
    var appInstanceUserArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    var chimeBearer: Swift.String?
    /// The maximum number of channels in the request.
    var maxResults: Swift.Int?
    /// The token returned from previous API requests until the number of channels moderated by the user is reached.
    var nextToken: Swift.String?

    public init (
        appInstanceUserArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
        self.chimeBearer = chimeBearer
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListChannelsModeratedByAppInstanceUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListChannelsModeratedByAppInstanceUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListChannelsModeratedByAppInstanceUserOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListChannelsModeratedByAppInstanceUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListChannelsModeratedByAppInstanceUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channels = output.channels
            self.nextToken = output.nextToken
        } else {
            self.channels = nil
            self.nextToken = nil
        }
    }
}

public struct ListChannelsModeratedByAppInstanceUserOutputResponse: Swift.Equatable {
    /// The moderated channels in the request.
    var channels: [ChimeSdkMessagingClientTypes.ChannelModeratedByAppInstanceUserSummary]?
    /// The token returned from previous API requests until the number of channels moderated by the user is reached.
    var nextToken: Swift.String?

    public init (
        channels: [ChimeSdkMessagingClientTypes.ChannelModeratedByAppInstanceUserSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channels = channels
        self.nextToken = nextToken
    }
}

struct ListChannelsModeratedByAppInstanceUserOutputResponseBody: Swift.Equatable {
    let channels: [ChimeSdkMessagingClientTypes.ChannelModeratedByAppInstanceUserSummary]?
    let nextToken: Swift.String?
}

extension ListChannelsModeratedByAppInstanceUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channels = "Channels"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelsContainer = try containerValues.decodeIfPresent([ChimeSdkMessagingClientTypes.ChannelModeratedByAppInstanceUserSummary?].self, forKey: .channels)
        var channelsDecoded0:[ChimeSdkMessagingClientTypes.ChannelModeratedByAppInstanceUserSummary]? = nil
        if let channelsContainer = channelsContainer {
            channelsDecoded0 = [ChimeSdkMessagingClientTypes.ChannelModeratedByAppInstanceUserSummary]()
            for structure0 in channelsContainer {
                if let structure0 = structure0 {
                    channelsDecoded0?.append(structure0)
                }
            }
        }
        channels = channelsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListChannelsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListChannelsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListChannelsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListChannelsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListChannelsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channels = output.channels
            self.nextToken = output.nextToken
        } else {
            self.channels = nil
            self.nextToken = nil
        }
    }
}

public struct ListChannelsOutputResponse: Swift.Equatable {
    /// The information about each channel.
    var channels: [ChimeSdkMessagingClientTypes.ChannelSummary]?
    /// The token returned from previous API requests until the number of channels is reached.
    var nextToken: Swift.String?

    public init (
        channels: [ChimeSdkMessagingClientTypes.ChannelSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channels = channels
        self.nextToken = nextToken
    }
}

struct ListChannelsOutputResponseBody: Swift.Equatable {
    let channels: [ChimeSdkMessagingClientTypes.ChannelSummary]?
    let nextToken: Swift.String?
}

extension ListChannelsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channels = "Channels"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelsContainer = try containerValues.decodeIfPresent([ChimeSdkMessagingClientTypes.ChannelSummary?].self, forKey: .channels)
        var channelsDecoded0:[ChimeSdkMessagingClientTypes.ChannelSummary]? = nil
        if let channelsContainer = channelsContainer {
            channelsDecoded0 = [ChimeSdkMessagingClientTypes.ChannelSummary]()
            for structure0 in channelsContainer {
                if let structure0 = structure0 {
                    channelsDecoded0?.append(structure0)
                }
            }
        }
        channels = channelsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let resourceARN = resourceARN {
            let resourceARNQueryItem = ClientRuntime.URLQueryItem(name: "arn".urlPercentEncoding(), value: Swift.String(resourceARN).urlPercentEncoding())
            items.append(resourceARNQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    var resourceARN: Swift.String?

    public init (
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tag key-value pairs.
    var tags: [ChimeSdkMessagingClientTypes.Tag]?

    public init (
        tags: [ChimeSdkMessagingClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [ChimeSdkMessagingClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([ChimeSdkMessagingClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeSdkMessagingClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeSdkMessagingClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ChimeSdkMessagingClientTypes.MessageAttributeValue: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stringValues = "StringValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stringValues = stringValues {
            var stringValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stringValues)
            for messageattributestringvalues0 in stringValues {
                try stringValuesContainer.encode(messageattributestringvalues0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stringValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .stringValues)
        var stringValuesDecoded0:[Swift.String]? = nil
        if let stringValuesContainer = stringValuesContainer {
            stringValuesDecoded0 = [Swift.String]()
            for string0 in stringValuesContainer {
                if let string0 = string0 {
                    stringValuesDecoded0?.append(string0)
                }
            }
        }
        stringValues = stringValuesDecoded0
    }
}

extension ChimeSdkMessagingClientTypes {
    /// A list of message attribute values.
    public struct MessageAttributeValue: Swift.Equatable {
        /// The strings in a message attribute value.
        var stringValues: [Swift.String]?

        public init (
            stringValues: [Swift.String]? = nil
        )
        {
            self.stringValues = stringValues
        }
    }

}

extension ChimeSdkMessagingClientTypes.MessagingSessionEndpoint: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case url = "Url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension ChimeSdkMessagingClientTypes {
    /// The websocket endpoint used to connect to Amazon Chime SDK messaging.
    public struct MessagingSessionEndpoint: Swift.Equatable {
        /// The endpoint to which you establish a websocket connection.
        var url: Swift.String?

        public init (
            url: Swift.String? = nil
        )
        {
            self.url = url
        }
    }

}

extension NotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more of the resources in the request does not exist in the system.
public struct NotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeSdkMessagingClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeSdkMessagingClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    let code: ChimeSdkMessagingClientTypes.ErrorCode?
    let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ChimeSdkMessagingClientTypes.Processor: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
        case executionOrder = "ExecutionOrder"
        case fallbackAction = "FallbackAction"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let executionOrder = executionOrder {
            try encodeContainer.encode(executionOrder, forKey: .executionOrder)
        }
        if let fallbackAction = fallbackAction {
            try encodeContainer.encode(fallbackAction.rawValue, forKey: .fallbackAction)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ProcessorConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let executionOrderDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .executionOrder)
        executionOrder = executionOrderDecoded
        let fallbackActionDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.FallbackAction.self, forKey: .fallbackAction)
        fallbackAction = fallbackActionDecoded
    }
}

extension ChimeSdkMessagingClientTypes {
    /// The information about a processor in a channel flow.
    public struct Processor: Swift.Equatable {
        /// The information about the type of processor and its identifier.
        /// This member is required.
        var configuration: ChimeSdkMessagingClientTypes.ProcessorConfiguration?
        /// The sequence in which processors run. If you have multiple processors in a channel flow, message processing goes through each processor in the sequence. The value determines the sequence. At this point, we support only 1 processor within a flow.
        /// This member is required.
        var executionOrder: Swift.Int?
        /// Determines whether to continue with message processing or stop it in cases where communication with a processor fails. If a processor has a fallback action of ABORT and communication with it fails, the processor sets the message status to FAILED and does not send the message to any recipients. Note that if the last processor in the channel flow sequence has a fallback action of CONTINUE and communication with the processor fails, then the message is considered processed and sent to recipients of the channel.
        /// This member is required.
        var fallbackAction: ChimeSdkMessagingClientTypes.FallbackAction?
        /// The name of the channel flow.
        /// This member is required.
        var name: Swift.String?

        public init (
            configuration: ChimeSdkMessagingClientTypes.ProcessorConfiguration? = nil,
            executionOrder: Swift.Int? = nil,
            fallbackAction: ChimeSdkMessagingClientTypes.FallbackAction? = nil,
            name: Swift.String? = nil
        )
        {
            self.configuration = configuration
            self.executionOrder = executionOrder
            self.fallbackAction = fallbackAction
            self.name = name
        }
    }

}

extension ChimeSdkMessagingClientTypes.ProcessorConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lambda = "Lambda"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lambda = lambda {
            try encodeContainer.encode(lambda, forKey: .lambda)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lambdaDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.LambdaConfiguration.self, forKey: .lambda)
        lambda = lambdaDecoded
    }
}

extension ChimeSdkMessagingClientTypes {
    /// A processor's metadata.
    public struct ProcessorConfiguration: Swift.Equatable {
        /// Indicates that the processor is of type Lambda.
        /// This member is required.
        var lambda: ChimeSdkMessagingClientTypes.LambdaConfiguration?

        public init (
            lambda: ChimeSdkMessagingClientTypes.LambdaConfiguration? = nil
        )
        {
            self.lambda = lambda
        }
    }

}

extension ChimeSdkMessagingClientTypes.PushNotificationConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body = "Body"
        case title = "Title"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let body = body {
            try encodeContainer.encode(body, forKey: .body)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let bodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .body)
        body = bodyDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.PushNotificationType.self, forKey: .type)
        type = typeDecoded
    }
}

extension ChimeSdkMessagingClientTypes {
    /// The push notification configuration of the message.
    public struct PushNotificationConfiguration: Swift.Equatable {
        /// The body of the push notification.
        /// This member is required.
        var body: Swift.String?
        /// The title of the push notification.
        /// This member is required.
        var title: Swift.String?
        /// Enum value that indicates the type of the push notification for a message. DEFAULT: Normal mobile push notification. VOIP: VOIP mobile push notification.
        /// This member is required.
        var type: ChimeSdkMessagingClientTypes.PushNotificationType?

        public init (
            body: Swift.String? = nil,
            title: Swift.String? = nil,
            type: ChimeSdkMessagingClientTypes.PushNotificationType? = nil
        )
        {
            self.body = body
            self.title = title
            self.type = type
        }
    }

}

extension ChimeSdkMessagingClientTypes.PushNotificationPreferences: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowNotifications = "AllowNotifications"
        case filterRule = "FilterRule"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowNotifications = allowNotifications {
            try encodeContainer.encode(allowNotifications.rawValue, forKey: .allowNotifications)
        }
        if let filterRule = filterRule {
            try encodeContainer.encode(filterRule, forKey: .filterRule)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowNotificationsDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.AllowNotifications.self, forKey: .allowNotifications)
        allowNotifications = allowNotificationsDecoded
        let filterRuleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterRule)
        filterRule = filterRuleDecoded
    }
}

extension ChimeSdkMessagingClientTypes {
    /// The channel membership preferences for push notification.
    public struct PushNotificationPreferences: Swift.Equatable {
        /// Enum value that indicates which push notifications to send to the requested member of a channel. ALL sends all push notifications, NONE sends no push notifications, FILTERED sends only filtered push notifications.
        /// This member is required.
        var allowNotifications: ChimeSdkMessagingClientTypes.AllowNotifications?
        /// The simple JSON object used to send a subset of a push notification to the requsted member.
        var filterRule: Swift.String?

        public init (
            allowNotifications: ChimeSdkMessagingClientTypes.AllowNotifications? = nil,
            filterRule: Swift.String? = nil
        )
        {
            self.allowNotifications = allowNotifications
            self.filterRule = filterRule
        }
    }

}

extension ChimeSdkMessagingClientTypes {
    public enum PushNotificationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `default`
        case voip
        case sdkUnknown(Swift.String)

        public static var allCases: [PushNotificationType] {
            return [
                .default,
                .voip,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .default: return "DEFAULT"
            case .voip: return "VOIP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PushNotificationType(rawValue: rawValue) ?? PushNotificationType.sdkUnknown(rawValue)
        }
    }
}

extension PutChannelMembershipPreferencesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case preferences = "Preferences"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let preferences = preferences {
            try encodeContainer.encode(preferences, forKey: .preferences)
        }
    }
}

extension PutChannelMembershipPreferencesInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension PutChannelMembershipPreferencesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        guard let memberArn = memberArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/memberships/\(memberArn.urlPercentEncoding())/preferences"
    }
}

public struct PutChannelMembershipPreferencesInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    var channelArn: Swift.String?
    /// The AppInstanceUserARN of the user making the API call.
    /// This member is required.
    var chimeBearer: Swift.String?
    /// The AppInstanceUserArn of the member setting the preferences.
    /// This member is required.
    var memberArn: Swift.String?
    /// The channel membership preferences of an AppInstanceUser .
    /// This member is required.
    var preferences: ChimeSdkMessagingClientTypes.ChannelMembershipPreferences?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        memberArn: Swift.String? = nil,
        preferences: ChimeSdkMessagingClientTypes.ChannelMembershipPreferences? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.memberArn = memberArn
        self.preferences = preferences
    }
}

struct PutChannelMembershipPreferencesInputBody: Swift.Equatable {
    let preferences: ChimeSdkMessagingClientTypes.ChannelMembershipPreferences?
}

extension PutChannelMembershipPreferencesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case preferences = "Preferences"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let preferencesDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelMembershipPreferences.self, forKey: .preferences)
        preferences = preferencesDecoded
    }
}

extension PutChannelMembershipPreferencesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutChannelMembershipPreferencesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutChannelMembershipPreferencesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutChannelMembershipPreferencesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutChannelMembershipPreferencesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.member = output.member
            self.preferences = output.preferences
        } else {
            self.channelArn = nil
            self.member = nil
            self.preferences = nil
        }
    }
}

public struct PutChannelMembershipPreferencesOutputResponse: Swift.Equatable {
    /// The ARN of the channel.
    var channelArn: Swift.String?
    /// The details of a user.
    var member: ChimeSdkMessagingClientTypes.Identity?
    /// The ARN and metadata of the member being added.
    var preferences: ChimeSdkMessagingClientTypes.ChannelMembershipPreferences?

    public init (
        channelArn: Swift.String? = nil,
        member: ChimeSdkMessagingClientTypes.Identity? = nil,
        preferences: ChimeSdkMessagingClientTypes.ChannelMembershipPreferences? = nil
    )
    {
        self.channelArn = channelArn
        self.member = member
        self.preferences = preferences
    }
}

struct PutChannelMembershipPreferencesOutputResponseBody: Swift.Equatable {
    let channelArn: Swift.String?
    let member: ChimeSdkMessagingClientTypes.Identity?
    let preferences: ChimeSdkMessagingClientTypes.ChannelMembershipPreferences?
}

extension PutChannelMembershipPreferencesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case member = "Member"
        case preferences = "Preferences"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let memberDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.Identity.self, forKey: .member)
        member = memberDecoded
        let preferencesDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelMembershipPreferences.self, forKey: .preferences)
        preferences = preferencesDecoded
    }
}

extension RedactChannelMessageInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension RedactChannelMessageInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "operation", value: "redact"))
        return items
    }
}

extension RedactChannelMessageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        guard let messageId = messageId else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/messages/\(messageId.urlPercentEncoding())"
    }
}

public struct RedactChannelMessageInput: Swift.Equatable {
    /// The ARN of the channel containing the messages that you want to redact.
    /// This member is required.
    var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    var chimeBearer: Swift.String?
    /// The ID of the message being redacted.
    /// This member is required.
    var messageId: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        messageId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.messageId = messageId
    }
}

extension RedactChannelMessageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RedactChannelMessageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RedactChannelMessageOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RedactChannelMessageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RedactChannelMessageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.messageId = output.messageId
        } else {
            self.channelArn = nil
            self.messageId = nil
        }
    }
}

public struct RedactChannelMessageOutputResponse: Swift.Equatable {
    /// The ARN of the channel containing the messages that you want to redact.
    var channelArn: Swift.String?
    /// The ID of the message being redacted.
    var messageId: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        messageId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.messageId = messageId
    }
}

struct RedactChannelMessageOutputResponseBody: Swift.Equatable {
    let channelArn: Swift.String?
    let messageId: Swift.String?
}

extension RedactChannelMessageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case messageId = "MessageId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
    }
}

extension ResourceLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request exceeds the resource limit.
public struct ResourceLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeSdkMessagingClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeSdkMessagingClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ResourceLimitExceededExceptionBody: Swift.Equatable {
    let code: ChimeSdkMessagingClientTypes.ErrorCode?
    let message: Swift.String?
}

extension ResourceLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SendChannelMessageInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case content = "Content"
        case messageAttributes = "MessageAttributes"
        case metadata = "Metadata"
        case persistence = "Persistence"
        case pushNotification = "PushNotification"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let messageAttributes = messageAttributes {
            var messageAttributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .messageAttributes)
            for (dictKey0, messageattributemap0) in messageAttributes {
                try messageAttributesContainer.encode(messageattributemap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let persistence = persistence {
            try encodeContainer.encode(persistence.rawValue, forKey: .persistence)
        }
        if let pushNotification = pushNotification {
            try encodeContainer.encode(pushNotification, forKey: .pushNotification)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension SendChannelMessageInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension SendChannelMessageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/messages"
    }
}

public struct SendChannelMessageInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    var chimeBearer: Swift.String?
    /// The Idempotency token for each client request.
    /// This member is required.
    var clientRequestToken: Swift.String?
    /// The content of the message.
    /// This member is required.
    var content: Swift.String?
    /// The attributes for the message, used for message filtering along with a FilterRule defined in the PushNotificationPreferences.
    var messageAttributes: [Swift.String:ChimeSdkMessagingClientTypes.MessageAttributeValue]?
    /// The optional metadata for each message.
    var metadata: Swift.String?
    /// Boolean that controls whether the message is persisted on the back end. Required.
    /// This member is required.
    var persistence: ChimeSdkMessagingClientTypes.ChannelMessagePersistenceType?
    /// The push notification configuration of the message.
    var pushNotification: ChimeSdkMessagingClientTypes.PushNotificationConfiguration?
    /// The type of message, STANDARD or CONTROL.
    /// This member is required.
    var type: ChimeSdkMessagingClientTypes.ChannelMessageType?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        content: Swift.String? = nil,
        messageAttributes: [Swift.String:ChimeSdkMessagingClientTypes.MessageAttributeValue]? = nil,
        metadata: Swift.String? = nil,
        persistence: ChimeSdkMessagingClientTypes.ChannelMessagePersistenceType? = nil,
        pushNotification: ChimeSdkMessagingClientTypes.PushNotificationConfiguration? = nil,
        type: ChimeSdkMessagingClientTypes.ChannelMessageType? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.clientRequestToken = clientRequestToken
        self.content = content
        self.messageAttributes = messageAttributes
        self.metadata = metadata
        self.persistence = persistence
        self.pushNotification = pushNotification
        self.type = type
    }
}

struct SendChannelMessageInputBody: Swift.Equatable {
    let content: Swift.String?
    let type: ChimeSdkMessagingClientTypes.ChannelMessageType?
    let persistence: ChimeSdkMessagingClientTypes.ChannelMessagePersistenceType?
    let metadata: Swift.String?
    let clientRequestToken: Swift.String?
    let pushNotification: ChimeSdkMessagingClientTypes.PushNotificationConfiguration?
    let messageAttributes: [Swift.String:ChimeSdkMessagingClientTypes.MessageAttributeValue]?
}

extension SendChannelMessageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case content = "Content"
        case messageAttributes = "MessageAttributes"
        case metadata = "Metadata"
        case persistence = "Persistence"
        case pushNotification = "PushNotification"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelMessageType.self, forKey: .type)
        type = typeDecoded
        let persistenceDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelMessagePersistenceType.self, forKey: .persistence)
        persistence = persistenceDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let pushNotificationDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.PushNotificationConfiguration.self, forKey: .pushNotification)
        pushNotification = pushNotificationDecoded
        let messageAttributesContainer = try containerValues.decodeIfPresent([Swift.String: ChimeSdkMessagingClientTypes.MessageAttributeValue?].self, forKey: .messageAttributes)
        var messageAttributesDecoded0: [Swift.String:ChimeSdkMessagingClientTypes.MessageAttributeValue]? = nil
        if let messageAttributesContainer = messageAttributesContainer {
            messageAttributesDecoded0 = [Swift.String:ChimeSdkMessagingClientTypes.MessageAttributeValue]()
            for (key0, messageattributevalue0) in messageAttributesContainer {
                if let messageattributevalue0 = messageattributevalue0 {
                    messageAttributesDecoded0?[key0] = messageattributevalue0
                }
            }
        }
        messageAttributes = messageAttributesDecoded0
    }
}

extension SendChannelMessageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendChannelMessageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendChannelMessageOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendChannelMessageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SendChannelMessageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.messageId = output.messageId
            self.status = output.status
        } else {
            self.channelArn = nil
            self.messageId = nil
            self.status = nil
        }
    }
}

public struct SendChannelMessageOutputResponse: Swift.Equatable {
    /// The ARN of the channel.
    var channelArn: Swift.String?
    /// The ID string assigned to each message.
    var messageId: Swift.String?
    /// The status of the channel message.
    var status: ChimeSdkMessagingClientTypes.ChannelMessageStatusStructure?

    public init (
        channelArn: Swift.String? = nil,
        messageId: Swift.String? = nil,
        status: ChimeSdkMessagingClientTypes.ChannelMessageStatusStructure? = nil
    )
    {
        self.channelArn = channelArn
        self.messageId = messageId
        self.status = status
    }
}

struct SendChannelMessageOutputResponseBody: Swift.Equatable {
    let channelArn: Swift.String?
    let messageId: Swift.String?
    let status: ChimeSdkMessagingClientTypes.ChannelMessageStatusStructure?
}

extension SendChannelMessageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case messageId = "MessageId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelMessageStatusStructure.self, forKey: .status)
        status = statusDecoded
    }
}

extension ServiceFailureException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The service encountered an unexpected error.
public struct ServiceFailureException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var code: ChimeSdkMessagingClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeSdkMessagingClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ServiceFailureExceptionBody: Swift.Equatable {
    let code: ChimeSdkMessagingClientTypes.ErrorCode?
    let message: Swift.String?
}

extension ServiceFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The service is currently unavailable.
public struct ServiceUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var code: ChimeSdkMessagingClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeSdkMessagingClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    let code: ChimeSdkMessagingClientTypes.ErrorCode?
    let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ChimeSdkMessagingClientTypes {
    public enum SortOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortOrder(rawValue: rawValue) ?? SortOrder.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSdkMessagingClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ChimeSdkMessagingClientTypes {
    /// A tag object containing a key-value pair.
    public struct Tag: Swift.Equatable {
        /// The key in a tag.
        /// This member is required.
        var key: Swift.String?
        /// The value in a tag.
        /// This member is required.
        var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "operation", value: "tag-resource"))
        return items
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The resource ARN.
    /// This member is required.
    var resourceARN: Swift.String?
    /// The tag key-value pairs.
    /// This member is required.
    var tags: [ChimeSdkMessagingClientTypes.Tag]?

    public init (
        resourceARN: Swift.String? = nil,
        tags: [ChimeSdkMessagingClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tags: [ChimeSdkMessagingClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ChimeSdkMessagingClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeSdkMessagingClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeSdkMessagingClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

}

extension ThrottledClientException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottledClientExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The client exceeded its request rate limit.
public struct ThrottledClientException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeSdkMessagingClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeSdkMessagingClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ThrottledClientExceptionBody: Swift.Equatable {
    let code: ChimeSdkMessagingClientTypes.ErrorCode?
    let message: Swift.String?
}

extension ThrottledClientExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnauthorizedClientException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnauthorizedClientExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The client is not currently authorized to make the request.
public struct UnauthorizedClientException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeSdkMessagingClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeSdkMessagingClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct UnauthorizedClientExceptionBody: Swift.Equatable {
    let code: ChimeSdkMessagingClientTypes.ErrorCode?
    let message: Swift.String?
}

extension UnauthorizedClientExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "operation", value: "untag-resource"))
        return items
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The resource ARN.
    /// This member is required.
    var resourceARN: Swift.String?
    /// The tag keys.
    /// This member is required.
    var tagKeys: [Swift.String]?

    public init (
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

}

extension UpdateChannelFlowInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case processors = "Processors"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let processors = processors {
            var processorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .processors)
            for processorlist0 in processors {
                try processorsContainer.encode(processorlist0)
            }
        }
    }
}

extension UpdateChannelFlowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelFlowArn = channelFlowArn else {
            return nil
        }
        return "/channel-flows/\(channelFlowArn.urlPercentEncoding())"
    }
}

public struct UpdateChannelFlowInput: Swift.Equatable {
    /// The ARN of the channel flow.
    /// This member is required.
    var channelFlowArn: Swift.String?
    /// The name of the channel flow.
    /// This member is required.
    var name: Swift.String?
    /// Information about the processor Lambda functions
    /// This member is required.
    var processors: [ChimeSdkMessagingClientTypes.Processor]?

    public init (
        channelFlowArn: Swift.String? = nil,
        name: Swift.String? = nil,
        processors: [ChimeSdkMessagingClientTypes.Processor]? = nil
    )
    {
        self.channelFlowArn = channelFlowArn
        self.name = name
        self.processors = processors
    }
}

struct UpdateChannelFlowInputBody: Swift.Equatable {
    let processors: [ChimeSdkMessagingClientTypes.Processor]?
    let name: Swift.String?
}

extension UpdateChannelFlowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case processors = "Processors"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let processorsContainer = try containerValues.decodeIfPresent([ChimeSdkMessagingClientTypes.Processor?].self, forKey: .processors)
        var processorsDecoded0:[ChimeSdkMessagingClientTypes.Processor]? = nil
        if let processorsContainer = processorsContainer {
            processorsDecoded0 = [ChimeSdkMessagingClientTypes.Processor]()
            for structure0 in processorsContainer {
                if let structure0 = structure0 {
                    processorsDecoded0?.append(structure0)
                }
            }
        }
        processors = processorsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateChannelFlowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateChannelFlowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateChannelFlowOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateChannelFlowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateChannelFlowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelFlowArn = output.channelFlowArn
        } else {
            self.channelFlowArn = nil
        }
    }
}

public struct UpdateChannelFlowOutputResponse: Swift.Equatable {
    /// The ARN of the channel flow.
    var channelFlowArn: Swift.String?

    public init (
        channelFlowArn: Swift.String? = nil
    )
    {
        self.channelFlowArn = channelFlowArn
    }
}

struct UpdateChannelFlowOutputResponseBody: Swift.Equatable {
    let channelFlowArn: Swift.String?
}

extension UpdateChannelFlowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelFlowArn = "ChannelFlowArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelFlowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelFlowArn)
        channelFlowArn = channelFlowArnDecoded
    }
}

extension UpdateChannelInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata = "Metadata"
        case mode = "Mode"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let mode = mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateChannelInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension UpdateChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())"
    }
}

public struct UpdateChannelInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    var chimeBearer: Swift.String?
    /// The metadata for the update request.
    var metadata: Swift.String?
    /// The mode of the update request.
    /// This member is required.
    var mode: ChimeSdkMessagingClientTypes.ChannelMode?
    /// The name of the channel.
    /// This member is required.
    var name: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        metadata: Swift.String? = nil,
        mode: ChimeSdkMessagingClientTypes.ChannelMode? = nil,
        name: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.metadata = metadata
        self.mode = mode
        self.name = name
    }
}

struct UpdateChannelInputBody: Swift.Equatable {
    let name: Swift.String?
    let mode: ChimeSdkMessagingClientTypes.ChannelMode?
    let metadata: Swift.String?
}

extension UpdateChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata = "Metadata"
        case mode = "Mode"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let modeDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelMode.self, forKey: .mode)
        mode = modeDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

extension UpdateChannelMessageInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
        case metadata = "Metadata"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
    }
}

extension UpdateChannelMessageInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension UpdateChannelMessageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        guard let messageId = messageId else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/messages/\(messageId.urlPercentEncoding())"
    }
}

public struct UpdateChannelMessageInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    var chimeBearer: Swift.String?
    /// The content of the message being updated.
    var content: Swift.String?
    /// The ID string of the message being updated.
    /// This member is required.
    var messageId: Swift.String?
    /// The metadata of the message being updated.
    var metadata: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        content: Swift.String? = nil,
        messageId: Swift.String? = nil,
        metadata: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.content = content
        self.messageId = messageId
        self.metadata = metadata
    }
}

struct UpdateChannelMessageInputBody: Swift.Equatable {
    let content: Swift.String?
    let metadata: Swift.String?
}

extension UpdateChannelMessageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
        case metadata = "Metadata"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

extension UpdateChannelMessageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateChannelMessageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateChannelMessageOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateChannelMessageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateChannelMessageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.messageId = output.messageId
            self.status = output.status
        } else {
            self.channelArn = nil
            self.messageId = nil
            self.status = nil
        }
    }
}

public struct UpdateChannelMessageOutputResponse: Swift.Equatable {
    /// The ARN of the channel.
    var channelArn: Swift.String?
    /// The ID string of the message being updated.
    var messageId: Swift.String?
    /// The status of the message update.
    var status: ChimeSdkMessagingClientTypes.ChannelMessageStatusStructure?

    public init (
        channelArn: Swift.String? = nil,
        messageId: Swift.String? = nil,
        status: ChimeSdkMessagingClientTypes.ChannelMessageStatusStructure? = nil
    )
    {
        self.channelArn = channelArn
        self.messageId = messageId
        self.status = status
    }
}

struct UpdateChannelMessageOutputResponseBody: Swift.Equatable {
    let channelArn: Swift.String?
    let messageId: Swift.String?
    let status: ChimeSdkMessagingClientTypes.ChannelMessageStatusStructure?
}

extension UpdateChannelMessageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case messageId = "MessageId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ChimeSdkMessagingClientTypes.ChannelMessageStatusStructure.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateChannelOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateChannelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
        } else {
            self.channelArn = nil
        }
    }
}

public struct UpdateChannelOutputResponse: Swift.Equatable {
    /// The ARN of the channel.
    var channelArn: Swift.String?

    public init (
        channelArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
    }
}

struct UpdateChannelOutputResponseBody: Swift.Equatable {
    let channelArn: Swift.String?
}

extension UpdateChannelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
    }
}

extension UpdateChannelReadMarkerInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension UpdateChannelReadMarkerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/readMarker"
    }
}

public struct UpdateChannelReadMarkerInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    var chimeBearer: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
    }
}

extension UpdateChannelReadMarkerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateChannelReadMarkerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateChannelReadMarkerOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateChannelReadMarkerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateChannelReadMarkerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
        } else {
            self.channelArn = nil
        }
    }
}

public struct UpdateChannelReadMarkerOutputResponse: Swift.Equatable {
    /// The ARN of the channel.
    var channelArn: Swift.String?

    public init (
        channelArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
    }
}

struct UpdateChannelReadMarkerOutputResponseBody: Swift.Equatable {
    let channelArn: Swift.String?
}

extension UpdateChannelReadMarkerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
    }
}
