// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

#if swift(>=5.5)
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, macCatalyst 15.0, *)
public extension RoboMakerClient {
    /// <p>Deletes one or more worlds in a batch operation.</p>
    func batchDeleteWorlds(input: BatchDeleteWorldsInput) async throws -> BatchDeleteWorldsOutputResponse
    {
        typealias batchDeleteWorldsContinuation = CheckedContinuation<BatchDeleteWorldsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: batchDeleteWorldsContinuation) in
            batchDeleteWorlds(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Describes one or more simulation jobs.</p>
    func batchDescribeSimulationJob(input: BatchDescribeSimulationJobInput) async throws -> BatchDescribeSimulationJobOutputResponse
    {
        typealias batchDescribeSimulationJobContinuation = CheckedContinuation<BatchDescribeSimulationJobOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: batchDescribeSimulationJobContinuation) in
            batchDescribeSimulationJob(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Cancels the specified deployment job.</p>
    func cancelDeploymentJob(input: CancelDeploymentJobInput) async throws -> CancelDeploymentJobOutputResponse
    {
        typealias cancelDeploymentJobContinuation = CheckedContinuation<CancelDeploymentJobOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: cancelDeploymentJobContinuation) in
            cancelDeploymentJob(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Cancels the specified simulation job.</p>
    func cancelSimulationJob(input: CancelSimulationJobInput) async throws -> CancelSimulationJobOutputResponse
    {
        typealias cancelSimulationJobContinuation = CheckedContinuation<CancelSimulationJobOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: cancelSimulationJobContinuation) in
            cancelSimulationJob(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Cancels a simulation job batch. When you cancel a simulation job batch, you are also
    ///          cancelling all of the active simulation jobs created as part of the batch. </p>
    func cancelSimulationJobBatch(input: CancelSimulationJobBatchInput) async throws -> CancelSimulationJobBatchOutputResponse
    {
        typealias cancelSimulationJobBatchContinuation = CheckedContinuation<CancelSimulationJobBatchOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: cancelSimulationJobBatchContinuation) in
            cancelSimulationJobBatch(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Cancels the specified export job.</p>
    func cancelWorldExportJob(input: CancelWorldExportJobInput) async throws -> CancelWorldExportJobOutputResponse
    {
        typealias cancelWorldExportJobContinuation = CheckedContinuation<CancelWorldExportJobOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: cancelWorldExportJobContinuation) in
            cancelWorldExportJob(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Cancels the specified world generator job.</p>
    func cancelWorldGenerationJob(input: CancelWorldGenerationJobInput) async throws -> CancelWorldGenerationJobOutputResponse
    {
        typealias cancelWorldGenerationJobContinuation = CheckedContinuation<CancelWorldGenerationJobOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: cancelWorldGenerationJobContinuation) in
            cancelWorldGenerationJob(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deploys a specific version of a robot application to robots in a fleet.</p>
    ///          <p>The robot application must have a numbered <code>applicationVersion</code> for
    ///          consistency reasons. To create a new version, use
    ///             <code>CreateRobotApplicationVersion</code> or see <a href="https://docs.aws.amazon.com/robomaker/latest/dg/create-robot-application-version.html">Creating a Robot Application Version</a>. </p>
    ///          <note>
    ///             <p>After 90 days, deployment jobs expire and will be deleted. They will no longer be
    ///             accessible. </p>
    ///          </note>
    func createDeploymentJob(input: CreateDeploymentJobInput) async throws -> CreateDeploymentJobOutputResponse
    {
        typealias createDeploymentJobContinuation = CheckedContinuation<CreateDeploymentJobOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createDeploymentJobContinuation) in
            createDeploymentJob(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates a fleet, a logical group of robots running the same robot application.</p>
    func createFleet(input: CreateFleetInput) async throws -> CreateFleetOutputResponse
    {
        typealias createFleetContinuation = CheckedContinuation<CreateFleetOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createFleetContinuation) in
            createFleet(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates a robot.</p>
    func createRobot(input: CreateRobotInput) async throws -> CreateRobotOutputResponse
    {
        typealias createRobotContinuation = CheckedContinuation<CreateRobotOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createRobotContinuation) in
            createRobot(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates a robot application. </p>
    func createRobotApplication(input: CreateRobotApplicationInput) async throws -> CreateRobotApplicationOutputResponse
    {
        typealias createRobotApplicationContinuation = CheckedContinuation<CreateRobotApplicationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createRobotApplicationContinuation) in
            createRobotApplication(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates a version of a robot application.</p>
    func createRobotApplicationVersion(input: CreateRobotApplicationVersionInput) async throws -> CreateRobotApplicationVersionOutputResponse
    {
        typealias createRobotApplicationVersionContinuation = CheckedContinuation<CreateRobotApplicationVersionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createRobotApplicationVersionContinuation) in
            createRobotApplicationVersion(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates a simulation application.</p>
    func createSimulationApplication(input: CreateSimulationApplicationInput) async throws -> CreateSimulationApplicationOutputResponse
    {
        typealias createSimulationApplicationContinuation = CheckedContinuation<CreateSimulationApplicationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createSimulationApplicationContinuation) in
            createSimulationApplication(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates a simulation application with a specific revision id.</p>
    func createSimulationApplicationVersion(input: CreateSimulationApplicationVersionInput) async throws -> CreateSimulationApplicationVersionOutputResponse
    {
        typealias createSimulationApplicationVersionContinuation = CheckedContinuation<CreateSimulationApplicationVersionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createSimulationApplicationVersionContinuation) in
            createSimulationApplicationVersion(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates a simulation job.</p>
    ///          <note>
    ///             <p>After 90 days, simulation jobs expire and will be deleted. They will no longer be
    ///             accessible. </p>
    ///          </note>
    func createSimulationJob(input: CreateSimulationJobInput) async throws -> CreateSimulationJobOutputResponse
    {
        typealias createSimulationJobContinuation = CheckedContinuation<CreateSimulationJobOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createSimulationJobContinuation) in
            createSimulationJob(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates a world export job.</p>
    func createWorldExportJob(input: CreateWorldExportJobInput) async throws -> CreateWorldExportJobOutputResponse
    {
        typealias createWorldExportJobContinuation = CheckedContinuation<CreateWorldExportJobOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createWorldExportJobContinuation) in
            createWorldExportJob(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates worlds using the specified template.</p>
    func createWorldGenerationJob(input: CreateWorldGenerationJobInput) async throws -> CreateWorldGenerationJobOutputResponse
    {
        typealias createWorldGenerationJobContinuation = CheckedContinuation<CreateWorldGenerationJobOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createWorldGenerationJobContinuation) in
            createWorldGenerationJob(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates a world template.</p>
    func createWorldTemplate(input: CreateWorldTemplateInput) async throws -> CreateWorldTemplateOutputResponse
    {
        typealias createWorldTemplateContinuation = CheckedContinuation<CreateWorldTemplateOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createWorldTemplateContinuation) in
            createWorldTemplate(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes a fleet.</p>
    func deleteFleet(input: DeleteFleetInput) async throws -> DeleteFleetOutputResponse
    {
        typealias deleteFleetContinuation = CheckedContinuation<DeleteFleetOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteFleetContinuation) in
            deleteFleet(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes a robot.</p>
    func deleteRobot(input: DeleteRobotInput) async throws -> DeleteRobotOutputResponse
    {
        typealias deleteRobotContinuation = CheckedContinuation<DeleteRobotOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteRobotContinuation) in
            deleteRobot(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes a robot application.</p>
    func deleteRobotApplication(input: DeleteRobotApplicationInput) async throws -> DeleteRobotApplicationOutputResponse
    {
        typealias deleteRobotApplicationContinuation = CheckedContinuation<DeleteRobotApplicationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteRobotApplicationContinuation) in
            deleteRobotApplication(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes a simulation application.</p>
    func deleteSimulationApplication(input: DeleteSimulationApplicationInput) async throws -> DeleteSimulationApplicationOutputResponse
    {
        typealias deleteSimulationApplicationContinuation = CheckedContinuation<DeleteSimulationApplicationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteSimulationApplicationContinuation) in
            deleteSimulationApplication(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes a world template.</p>
    func deleteWorldTemplate(input: DeleteWorldTemplateInput) async throws -> DeleteWorldTemplateOutputResponse
    {
        typealias deleteWorldTemplateContinuation = CheckedContinuation<DeleteWorldTemplateOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteWorldTemplateContinuation) in
            deleteWorldTemplate(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deregisters a robot.</p>
    func deregisterRobot(input: DeregisterRobotInput) async throws -> DeregisterRobotOutputResponse
    {
        typealias deregisterRobotContinuation = CheckedContinuation<DeregisterRobotOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deregisterRobotContinuation) in
            deregisterRobot(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Describes a deployment job.</p>
    func describeDeploymentJob(input: DescribeDeploymentJobInput) async throws -> DescribeDeploymentJobOutputResponse
    {
        typealias describeDeploymentJobContinuation = CheckedContinuation<DescribeDeploymentJobOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeDeploymentJobContinuation) in
            describeDeploymentJob(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Describes a fleet.</p>
    func describeFleet(input: DescribeFleetInput) async throws -> DescribeFleetOutputResponse
    {
        typealias describeFleetContinuation = CheckedContinuation<DescribeFleetOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeFleetContinuation) in
            describeFleet(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Describes a robot.</p>
    func describeRobot(input: DescribeRobotInput) async throws -> DescribeRobotOutputResponse
    {
        typealias describeRobotContinuation = CheckedContinuation<DescribeRobotOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeRobotContinuation) in
            describeRobot(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Describes a robot application.</p>
    func describeRobotApplication(input: DescribeRobotApplicationInput) async throws -> DescribeRobotApplicationOutputResponse
    {
        typealias describeRobotApplicationContinuation = CheckedContinuation<DescribeRobotApplicationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeRobotApplicationContinuation) in
            describeRobotApplication(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Describes a simulation application.</p>
    func describeSimulationApplication(input: DescribeSimulationApplicationInput) async throws -> DescribeSimulationApplicationOutputResponse
    {
        typealias describeSimulationApplicationContinuation = CheckedContinuation<DescribeSimulationApplicationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeSimulationApplicationContinuation) in
            describeSimulationApplication(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Describes a simulation job.</p>
    func describeSimulationJob(input: DescribeSimulationJobInput) async throws -> DescribeSimulationJobOutputResponse
    {
        typealias describeSimulationJobContinuation = CheckedContinuation<DescribeSimulationJobOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeSimulationJobContinuation) in
            describeSimulationJob(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Describes a simulation job batch.</p>
    func describeSimulationJobBatch(input: DescribeSimulationJobBatchInput) async throws -> DescribeSimulationJobBatchOutputResponse
    {
        typealias describeSimulationJobBatchContinuation = CheckedContinuation<DescribeSimulationJobBatchOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeSimulationJobBatchContinuation) in
            describeSimulationJobBatch(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Describes a world.</p>
    func describeWorld(input: DescribeWorldInput) async throws -> DescribeWorldOutputResponse
    {
        typealias describeWorldContinuation = CheckedContinuation<DescribeWorldOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeWorldContinuation) in
            describeWorld(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Describes a world export job.</p>
    func describeWorldExportJob(input: DescribeWorldExportJobInput) async throws -> DescribeWorldExportJobOutputResponse
    {
        typealias describeWorldExportJobContinuation = CheckedContinuation<DescribeWorldExportJobOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeWorldExportJobContinuation) in
            describeWorldExportJob(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Describes a world generation job.</p>
    func describeWorldGenerationJob(input: DescribeWorldGenerationJobInput) async throws -> DescribeWorldGenerationJobOutputResponse
    {
        typealias describeWorldGenerationJobContinuation = CheckedContinuation<DescribeWorldGenerationJobOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeWorldGenerationJobContinuation) in
            describeWorldGenerationJob(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Describes a world template.</p>
    func describeWorldTemplate(input: DescribeWorldTemplateInput) async throws -> DescribeWorldTemplateOutputResponse
    {
        typealias describeWorldTemplateContinuation = CheckedContinuation<DescribeWorldTemplateOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeWorldTemplateContinuation) in
            describeWorldTemplate(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Gets the world template body.</p>
    func getWorldTemplateBody(input: GetWorldTemplateBodyInput) async throws -> GetWorldTemplateBodyOutputResponse
    {
        typealias getWorldTemplateBodyContinuation = CheckedContinuation<GetWorldTemplateBodyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getWorldTemplateBodyContinuation) in
            getWorldTemplateBody(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns a list of deployment jobs for a fleet. You can optionally provide filters to
    ///          retrieve specific deployment jobs. </p>
    func listDeploymentJobs(input: ListDeploymentJobsInput) async throws -> ListDeploymentJobsOutputResponse
    {
        typealias listDeploymentJobsContinuation = CheckedContinuation<ListDeploymentJobsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listDeploymentJobsContinuation) in
            listDeploymentJobs(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns a list of fleets. You can optionally provide filters to retrieve specific
    ///          fleets. </p>
    func listFleets(input: ListFleetsInput) async throws -> ListFleetsOutputResponse
    {
        typealias listFleetsContinuation = CheckedContinuation<ListFleetsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listFleetsContinuation) in
            listFleets(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns a list of robot application. You can optionally provide filters to retrieve
    ///          specific robot applications.</p>
    func listRobotApplications(input: ListRobotApplicationsInput) async throws -> ListRobotApplicationsOutputResponse
    {
        typealias listRobotApplicationsContinuation = CheckedContinuation<ListRobotApplicationsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listRobotApplicationsContinuation) in
            listRobotApplications(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns a list of robots. You can optionally provide filters to retrieve specific
    ///          robots.</p>
    func listRobots(input: ListRobotsInput) async throws -> ListRobotsOutputResponse
    {
        typealias listRobotsContinuation = CheckedContinuation<ListRobotsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listRobotsContinuation) in
            listRobots(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns a list of simulation applications. You can optionally provide filters to
    ///          retrieve specific simulation applications. </p>
    func listSimulationApplications(input: ListSimulationApplicationsInput) async throws -> ListSimulationApplicationsOutputResponse
    {
        typealias listSimulationApplicationsContinuation = CheckedContinuation<ListSimulationApplicationsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listSimulationApplicationsContinuation) in
            listSimulationApplications(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns a list simulation job batches. You can optionally provide filters to retrieve
    ///          specific simulation batch jobs. </p>
    func listSimulationJobBatches(input: ListSimulationJobBatchesInput) async throws -> ListSimulationJobBatchesOutputResponse
    {
        typealias listSimulationJobBatchesContinuation = CheckedContinuation<ListSimulationJobBatchesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listSimulationJobBatchesContinuation) in
            listSimulationJobBatches(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns a list of simulation jobs. You can optionally provide filters to retrieve
    ///          specific simulation jobs. </p>
    func listSimulationJobs(input: ListSimulationJobsInput) async throws -> ListSimulationJobsOutputResponse
    {
        typealias listSimulationJobsContinuation = CheckedContinuation<ListSimulationJobsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listSimulationJobsContinuation) in
            listSimulationJobs(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Lists all tags on a AWS RoboMaker resource.</p>
    func listTagsForResource(input: ListTagsForResourceInput) async throws -> ListTagsForResourceOutputResponse
    {
        typealias listTagsForResourceContinuation = CheckedContinuation<ListTagsForResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listTagsForResourceContinuation) in
            listTagsForResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Lists world export jobs.</p>
    func listWorldExportJobs(input: ListWorldExportJobsInput) async throws -> ListWorldExportJobsOutputResponse
    {
        typealias listWorldExportJobsContinuation = CheckedContinuation<ListWorldExportJobsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listWorldExportJobsContinuation) in
            listWorldExportJobs(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Lists world generator jobs.</p>
    func listWorldGenerationJobs(input: ListWorldGenerationJobsInput) async throws -> ListWorldGenerationJobsOutputResponse
    {
        typealias listWorldGenerationJobsContinuation = CheckedContinuation<ListWorldGenerationJobsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listWorldGenerationJobsContinuation) in
            listWorldGenerationJobs(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Lists world templates.</p>
    func listWorldTemplates(input: ListWorldTemplatesInput) async throws -> ListWorldTemplatesOutputResponse
    {
        typealias listWorldTemplatesContinuation = CheckedContinuation<ListWorldTemplatesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listWorldTemplatesContinuation) in
            listWorldTemplates(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Lists worlds.</p>
    func listWorlds(input: ListWorldsInput) async throws -> ListWorldsOutputResponse
    {
        typealias listWorldsContinuation = CheckedContinuation<ListWorldsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listWorldsContinuation) in
            listWorlds(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Registers a robot with a fleet.</p>
    func registerRobot(input: RegisterRobotInput) async throws -> RegisterRobotOutputResponse
    {
        typealias registerRobotContinuation = CheckedContinuation<RegisterRobotOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: registerRobotContinuation) in
            registerRobot(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Restarts a running simulation job.</p>
    func restartSimulationJob(input: RestartSimulationJobInput) async throws -> RestartSimulationJobOutputResponse
    {
        typealias restartSimulationJobContinuation = CheckedContinuation<RestartSimulationJobOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: restartSimulationJobContinuation) in
            restartSimulationJob(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Starts a new simulation job batch. The batch is defined using one or more
    ///             <code>SimulationJobRequest</code> objects. </p>
    func startSimulationJobBatch(input: StartSimulationJobBatchInput) async throws -> StartSimulationJobBatchOutputResponse
    {
        typealias startSimulationJobBatchContinuation = CheckedContinuation<StartSimulationJobBatchOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: startSimulationJobBatchContinuation) in
            startSimulationJobBatch(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Syncrhonizes robots in a fleet to the latest deployment. This is helpful if robots were
    ///          added after a deployment.</p>
    func syncDeploymentJob(input: SyncDeploymentJobInput) async throws -> SyncDeploymentJobOutputResponse
    {
        typealias syncDeploymentJobContinuation = CheckedContinuation<SyncDeploymentJobOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: syncDeploymentJobContinuation) in
            syncDeploymentJob(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Adds or edits tags for a AWS RoboMaker resource.</p>
    ///          <p>Each tag consists of a tag key and a tag value. Tag keys and tag values are both
    ///          required, but tag values can be empty strings. </p>
    ///          <p>For information about the rules that apply to tag keys and tag values, see <a href="https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/allocation-tag-restrictions.html">User-Defined Tag Restrictions</a> in the <i>AWS Billing and Cost Management
    ///             User Guide</i>. </p>
    func tagResource(input: TagResourceInput) async throws -> TagResourceOutputResponse
    {
        typealias tagResourceContinuation = CheckedContinuation<TagResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: tagResourceContinuation) in
            tagResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Removes the specified tags from the specified AWS RoboMaker resource.</p>
    ///          <p>To remove a tag, specify the tag key. To change the tag value of an existing tag key,
    ///          use <a href="https://docs.aws.amazon.com/robomaker/latest/dg/API_TagResource.html">
    ///                <code>TagResource</code>
    ///             </a>. </p>
    func untagResource(input: UntagResourceInput) async throws -> UntagResourceOutputResponse
    {
        typealias untagResourceContinuation = CheckedContinuation<UntagResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: untagResourceContinuation) in
            untagResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Updates a robot application.</p>
    func updateRobotApplication(input: UpdateRobotApplicationInput) async throws -> UpdateRobotApplicationOutputResponse
    {
        typealias updateRobotApplicationContinuation = CheckedContinuation<UpdateRobotApplicationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateRobotApplicationContinuation) in
            updateRobotApplication(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Updates a simulation application.</p>
    func updateSimulationApplication(input: UpdateSimulationApplicationInput) async throws -> UpdateSimulationApplicationOutputResponse
    {
        typealias updateSimulationApplicationContinuation = CheckedContinuation<UpdateSimulationApplicationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateSimulationApplicationContinuation) in
            updateSimulationApplication(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Updates a world template.</p>
    func updateWorldTemplate(input: UpdateWorldTemplateInput) async throws -> UpdateWorldTemplateOutputResponse
    {
        typealias updateWorldTemplateContinuation = CheckedContinuation<UpdateWorldTemplateOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateWorldTemplateContinuation) in
            updateWorldTemplate(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

}
#endif
