// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension KendraClientTypes.AccessControlListConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyPath = "KeyPath"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyPath = keyPath {
            try encodeContainer.encode(keyPath, forKey: .keyPath)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyPath)
        keyPath = keyPathDecoded
    }
}

extension KendraClientTypes.AccessControlListConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessControlListConfiguration(keyPath: \(Swift.String(describing: keyPath)))"}
}

extension KendraClientTypes {
    /// <p>Access Control List files for the documents in a data source. For
    ///             the format of the file, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/s3-acl.html">Access control for S3 data
    ///                 sources</a>.</p>
    public struct AccessControlListConfiguration: Swift.Equatable {
        /// <p>Path to the AWS S3 bucket that contains the ACL files.</p>
        public let keyPath: Swift.String?

        public init (
            keyPath: Swift.String? = nil
        )
        {
            self.keyPath = keyPath
        }
    }

}

extension AccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessDeniedException(message: \(Swift.String(describing: message)))"}
}

extension AccessDeniedException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KendraClientTypes.AclConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedGroupsColumnName = "AllowedGroupsColumnName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedGroupsColumnName = allowedGroupsColumnName {
            try encodeContainer.encode(allowedGroupsColumnName, forKey: .allowedGroupsColumnName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowedGroupsColumnNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .allowedGroupsColumnName)
        allowedGroupsColumnName = allowedGroupsColumnNameDecoded
    }
}

extension KendraClientTypes.AclConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AclConfiguration(allowedGroupsColumnName: \(Swift.String(describing: allowedGroupsColumnName)))"}
}

extension KendraClientTypes {
    /// <p>Provides information about the column that should be used for
    ///             filtering the query response by groups.</p>
    public struct AclConfiguration: Swift.Equatable {
        /// <p>A list of groups, separated by semi-colons, that filters a query
        ///             response based on user context. The document is only returned to
        ///             users that are in one of the groups specified in the
        ///                 <code>UserContext</code> field of the <code>Query</code>
        ///             operation.</p>
        public let allowedGroupsColumnName: Swift.String?

        public init (
            allowedGroupsColumnName: Swift.String? = nil
        )
        {
            self.allowedGroupsColumnName = allowedGroupsColumnName
        }
    }

}

extension KendraClientTypes.AdditionalResultAttribute: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
        case valueType = "ValueType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
        if let valueType = valueType {
            try encodeContainer.encode(valueType.rawValue, forKey: .valueType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueTypeDecoded = try containerValues.decodeIfPresent(KendraClientTypes.AdditionalResultAttributeValueType.self, forKey: .valueType)
        valueType = valueTypeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(KendraClientTypes.AdditionalResultAttributeValue.self, forKey: .value)
        value = valueDecoded
    }
}

extension KendraClientTypes.AdditionalResultAttribute: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AdditionalResultAttribute(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)), valueType: \(Swift.String(describing: valueType)))"}
}

extension KendraClientTypes {
    /// <p>An attribute returned from an index query.</p>
    public struct AdditionalResultAttribute: Swift.Equatable {
        /// <p>The key that identifies the attribute.</p>
        public let key: Swift.String?
        /// <p>An object that contains the attribute value.</p>
        public let value: KendraClientTypes.AdditionalResultAttributeValue?
        /// <p>The data type of the <code>Value</code> property.</p>
        public let valueType: KendraClientTypes.AdditionalResultAttributeValueType?

        public init (
            key: Swift.String? = nil,
            value: KendraClientTypes.AdditionalResultAttributeValue? = nil,
            valueType: KendraClientTypes.AdditionalResultAttributeValueType? = nil
        )
        {
            self.key = key
            self.value = value
            self.valueType = valueType
        }
    }

}

extension KendraClientTypes.AdditionalResultAttributeValue: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case textWithHighlightsValue = "TextWithHighlightsValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let textWithHighlightsValue = textWithHighlightsValue {
            try encodeContainer.encode(textWithHighlightsValue, forKey: .textWithHighlightsValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textWithHighlightsValueDecoded = try containerValues.decodeIfPresent(KendraClientTypes.TextWithHighlights.self, forKey: .textWithHighlightsValue)
        textWithHighlightsValue = textWithHighlightsValueDecoded
    }
}

extension KendraClientTypes.AdditionalResultAttributeValue: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AdditionalResultAttributeValue(textWithHighlightsValue: \(Swift.String(describing: textWithHighlightsValue)))"}
}

extension KendraClientTypes {
    /// <p>An attribute returned with a document from a search.</p>
    public struct AdditionalResultAttributeValue: Swift.Equatable {
        /// <p>The text associated with the attribute and information about the
        ///             highlight to apply to the text.</p>
        public let textWithHighlightsValue: KendraClientTypes.TextWithHighlights?

        public init (
            textWithHighlightsValue: KendraClientTypes.TextWithHighlights? = nil
        )
        {
            self.textWithHighlightsValue = textWithHighlightsValue
        }
    }

}

extension KendraClientTypes {
    public enum AdditionalResultAttributeValueType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case textWithHighlightsValue
        case sdkUnknown(Swift.String)

        public static var allCases: [AdditionalResultAttributeValueType] {
            return [
                .textWithHighlightsValue,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .textWithHighlightsValue: return "TEXT_WITH_HIGHLIGHTS_VALUE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AdditionalResultAttributeValueType(rawValue: rawValue) ?? AdditionalResultAttributeValueType.sdkUnknown(rawValue)
        }
    }
}

extension KendraClientTypes.AttributeFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case andAllFilters = "AndAllFilters"
        case containsAll = "ContainsAll"
        case containsAny = "ContainsAny"
        case equalsTo = "EqualsTo"
        case greaterThan = "GreaterThan"
        case greaterThanOrEquals = "GreaterThanOrEquals"
        case lessThan = "LessThan"
        case lessThanOrEquals = "LessThanOrEquals"
        case notFilter = "NotFilter"
        case orAllFilters = "OrAllFilters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let andAllFilters = andAllFilters {
            var andAllFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .andAllFilters)
            for attributefilterlist0 in andAllFilters {
                try andAllFiltersContainer.encode(attributefilterlist0)
            }
        }
        if let containsAll = containsAll {
            try encodeContainer.encode(containsAll, forKey: .containsAll)
        }
        if let containsAny = containsAny {
            try encodeContainer.encode(containsAny, forKey: .containsAny)
        }
        if let equalsTo = equalsTo {
            try encodeContainer.encode(equalsTo, forKey: .equalsTo)
        }
        if let greaterThan = greaterThan {
            try encodeContainer.encode(greaterThan, forKey: .greaterThan)
        }
        if let greaterThanOrEquals = greaterThanOrEquals {
            try encodeContainer.encode(greaterThanOrEquals, forKey: .greaterThanOrEquals)
        }
        if let lessThan = lessThan {
            try encodeContainer.encode(lessThan, forKey: .lessThan)
        }
        if let lessThanOrEquals = lessThanOrEquals {
            try encodeContainer.encode(lessThanOrEquals, forKey: .lessThanOrEquals)
        }
        if let notFilter = notFilter {
            try encodeContainer.encode(notFilter.value, forKey: .notFilter)
        }
        if let orAllFilters = orAllFilters {
            var orAllFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .orAllFilters)
            for attributefilterlist0 in orAllFilters {
                try orAllFiltersContainer.encode(attributefilterlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let andAllFiltersContainer = try containerValues.decodeIfPresent([KendraClientTypes.AttributeFilter?].self, forKey: .andAllFilters)
        var andAllFiltersDecoded0:[KendraClientTypes.AttributeFilter]? = nil
        if let andAllFiltersContainer = andAllFiltersContainer {
            andAllFiltersDecoded0 = [KendraClientTypes.AttributeFilter]()
            for structure0 in andAllFiltersContainer {
                if let structure0 = structure0 {
                    andAllFiltersDecoded0?.append(structure0)
                }
            }
        }
        andAllFilters = andAllFiltersDecoded0
        let orAllFiltersContainer = try containerValues.decodeIfPresent([KendraClientTypes.AttributeFilter?].self, forKey: .orAllFilters)
        var orAllFiltersDecoded0:[KendraClientTypes.AttributeFilter]? = nil
        if let orAllFiltersContainer = orAllFiltersContainer {
            orAllFiltersDecoded0 = [KendraClientTypes.AttributeFilter]()
            for structure0 in orAllFiltersContainer {
                if let structure0 = structure0 {
                    orAllFiltersDecoded0?.append(structure0)
                }
            }
        }
        orAllFilters = orAllFiltersDecoded0
        let notFilterDecoded = try containerValues.decodeIfPresent(Box<KendraClientTypes.AttributeFilter>.self, forKey: .notFilter)
        notFilter = notFilterDecoded
        let equalsToDecoded = try containerValues.decodeIfPresent(KendraClientTypes.DocumentAttribute.self, forKey: .equalsTo)
        equalsTo = equalsToDecoded
        let containsAllDecoded = try containerValues.decodeIfPresent(KendraClientTypes.DocumentAttribute.self, forKey: .containsAll)
        containsAll = containsAllDecoded
        let containsAnyDecoded = try containerValues.decodeIfPresent(KendraClientTypes.DocumentAttribute.self, forKey: .containsAny)
        containsAny = containsAnyDecoded
        let greaterThanDecoded = try containerValues.decodeIfPresent(KendraClientTypes.DocumentAttribute.self, forKey: .greaterThan)
        greaterThan = greaterThanDecoded
        let greaterThanOrEqualsDecoded = try containerValues.decodeIfPresent(KendraClientTypes.DocumentAttribute.self, forKey: .greaterThanOrEquals)
        greaterThanOrEquals = greaterThanOrEqualsDecoded
        let lessThanDecoded = try containerValues.decodeIfPresent(KendraClientTypes.DocumentAttribute.self, forKey: .lessThan)
        lessThan = lessThanDecoded
        let lessThanOrEqualsDecoded = try containerValues.decodeIfPresent(KendraClientTypes.DocumentAttribute.self, forKey: .lessThanOrEquals)
        lessThanOrEquals = lessThanOrEqualsDecoded
    }
}

extension KendraClientTypes.AttributeFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AttributeFilter(andAllFilters: \(Swift.String(describing: andAllFilters)), containsAll: \(Swift.String(describing: containsAll)), containsAny: \(Swift.String(describing: containsAny)), equalsTo: \(Swift.String(describing: equalsTo)), greaterThan: \(Swift.String(describing: greaterThan)), greaterThanOrEquals: \(Swift.String(describing: greaterThanOrEquals)), lessThan: \(Swift.String(describing: lessThan)), lessThanOrEquals: \(Swift.String(describing: lessThanOrEquals)), notFilter: \(Swift.String(describing: notFilter)), orAllFilters: \(Swift.String(describing: orAllFilters)))"}
}

extension KendraClientTypes {
    /// <p>Provides filtering the query results based on document
    ///          attributes.</p>
    ///          <p>When you use the <code>AndAllFilters</code> or
    ///             <code>OrAllFilters</code>, filters you can use 2 layers under the
    ///          first attribute filter. For example, you can use:</p>
    ///          <p>
    ///             <code><AndAllFilters></code>
    ///          </p>
    ///          <ol>
    ///             <li>
    ///                <p>
    ///                   <code> <OrAllFilters></code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code> <EqualTo></code>
    ///                </p>
    ///             </li>
    ///          </ol>
    ///          <p>If you use more than 2 layers, you receive a
    ///             <code>ValidationException</code> exception with the message
    ///             "<code>AttributeFilter</code> cannot have a depth of more than
    ///          2."</p>
    public struct AttributeFilter: Swift.Equatable {
        /// <p>Performs a logical <code>AND</code> operation on all supplied
        ///          filters.</p>
        public let andAllFilters: [KendraClientTypes.AttributeFilter]?
        /// <p>Returns true when a document contains all of the specified document
        ///          attributes. This filter is only applicable to
        ///             <code>StringListValue</code> metadata.</p>
        public let containsAll: KendraClientTypes.DocumentAttribute?
        /// <p>Returns true when a document contains any of the specified document
        ///          attributes. This filter is only applicable to
        ///             <code>StringListValue</code> metadata.</p>
        public let containsAny: KendraClientTypes.DocumentAttribute?
        /// <p>Performs an equals operation on two document attributes.</p>
        public let equalsTo: KendraClientTypes.DocumentAttribute?
        /// <p>Performs a greater than operation on two document attributes. Use
        ///          with a document attribute of type <code>Integer</code> or
        ///             <code>Long</code>.</p>
        public let greaterThan: KendraClientTypes.DocumentAttribute?
        /// <p>Performs a greater or equals than operation on two document
        ///          attributes. Use with a document attribute of type <code>Integer</code>
        ///          or <code>Long</code>.</p>
        public let greaterThanOrEquals: KendraClientTypes.DocumentAttribute?
        /// <p>Performs a less than operation on two document attributes. Use with
        ///          a document attribute of type <code>Integer</code> or
        ///          <code>Long</code>.</p>
        public let lessThan: KendraClientTypes.DocumentAttribute?
        /// <p>Performs a less than or equals operation on two document attributes.
        ///          Use with a document attribute of type <code>Integer</code> or
        ///             <code>Long</code>.</p>
        public let lessThanOrEquals: KendraClientTypes.DocumentAttribute?
        /// <p>Performs a logical <code>NOT</code> operation on all supplied
        ///          filters.</p>
        public let notFilter: Box<KendraClientTypes.AttributeFilter>?
        /// <p>Performs a logical <code>OR</code> operation on all supplied
        ///          filters.</p>
        public let orAllFilters: [KendraClientTypes.AttributeFilter]?

        public init (
            andAllFilters: [KendraClientTypes.AttributeFilter]? = nil,
            containsAll: KendraClientTypes.DocumentAttribute? = nil,
            containsAny: KendraClientTypes.DocumentAttribute? = nil,
            equalsTo: KendraClientTypes.DocumentAttribute? = nil,
            greaterThan: KendraClientTypes.DocumentAttribute? = nil,
            greaterThanOrEquals: KendraClientTypes.DocumentAttribute? = nil,
            lessThan: KendraClientTypes.DocumentAttribute? = nil,
            lessThanOrEquals: KendraClientTypes.DocumentAttribute? = nil,
            notFilter: Box<KendraClientTypes.AttributeFilter>? = nil,
            orAllFilters: [KendraClientTypes.AttributeFilter]? = nil
        )
        {
            self.andAllFilters = andAllFilters
            self.containsAll = containsAll
            self.containsAny = containsAny
            self.equalsTo = equalsTo
            self.greaterThan = greaterThan
            self.greaterThanOrEquals = greaterThanOrEquals
            self.lessThan = lessThan
            self.lessThanOrEquals = lessThanOrEquals
            self.notFilter = notFilter
            self.orAllFilters = orAllFilters
        }
    }

}

public struct BatchDeleteDocumentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDeleteDocumentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchDeleteDocumentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDeleteDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchDeleteDocumentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDeleteDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDeleteDocumentOutputError>
}

extension BatchDeleteDocumentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchDeleteDocumentInput(dataSourceSyncJobMetricTarget: \(Swift.String(describing: dataSourceSyncJobMetricTarget)), documentIdList: \(Swift.String(describing: documentIdList)), indexId: \(Swift.String(describing: indexId)))"}
}

extension BatchDeleteDocumentInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceSyncJobMetricTarget = "DataSourceSyncJobMetricTarget"
        case documentIdList = "DocumentIdList"
        case indexId = "IndexId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceSyncJobMetricTarget = dataSourceSyncJobMetricTarget {
            try encodeContainer.encode(dataSourceSyncJobMetricTarget, forKey: .dataSourceSyncJobMetricTarget)
        }
        if let documentIdList = documentIdList {
            var documentIdListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .documentIdList)
            for documentidlist0 in documentIdList {
                try documentIdListContainer.encode(documentidlist0)
            }
        }
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
    }
}

public struct BatchDeleteDocumentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDeleteDocumentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchDeleteDocumentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDeleteDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchDeleteDocumentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDeleteDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDeleteDocumentOutputError>
}

public struct BatchDeleteDocumentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDeleteDocumentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchDeleteDocumentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDeleteDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchDeleteDocumentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDeleteDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDeleteDocumentOutputError>
}

public struct BatchDeleteDocumentInput: Swift.Equatable {
    /// <p>Maps a particular data source sync job to a particular data
    ///             source.</p>
    public let dataSourceSyncJobMetricTarget: KendraClientTypes.DataSourceSyncJobMetricTarget?
    /// <p>One or more identifiers for documents to delete from the index.</p>
    public let documentIdList: [Swift.String]?
    /// <p>The identifier of the index that contains the documents to
    ///       delete.</p>
    public let indexId: Swift.String?

    public init (
        dataSourceSyncJobMetricTarget: KendraClientTypes.DataSourceSyncJobMetricTarget? = nil,
        documentIdList: [Swift.String]? = nil,
        indexId: Swift.String? = nil
    )
    {
        self.dataSourceSyncJobMetricTarget = dataSourceSyncJobMetricTarget
        self.documentIdList = documentIdList
        self.indexId = indexId
    }
}

struct BatchDeleteDocumentInputBody: Swift.Equatable {
    public let indexId: Swift.String?
    public let documentIdList: [Swift.String]?
    public let dataSourceSyncJobMetricTarget: KendraClientTypes.DataSourceSyncJobMetricTarget?
}

extension BatchDeleteDocumentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceSyncJobMetricTarget = "DataSourceSyncJobMetricTarget"
        case documentIdList = "DocumentIdList"
        case indexId = "IndexId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexId)
        indexId = indexIdDecoded
        let documentIdListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .documentIdList)
        var documentIdListDecoded0:[Swift.String]? = nil
        if let documentIdListContainer = documentIdListContainer {
            documentIdListDecoded0 = [Swift.String]()
            for string0 in documentIdListContainer {
                if let string0 = string0 {
                    documentIdListDecoded0?.append(string0)
                }
            }
        }
        documentIdList = documentIdListDecoded0
        let dataSourceSyncJobMetricTargetDecoded = try containerValues.decodeIfPresent(KendraClientTypes.DataSourceSyncJobMetricTarget.self, forKey: .dataSourceSyncJobMetricTarget)
        dataSourceSyncJobMetricTarget = dataSourceSyncJobMetricTargetDecoded
    }
}

extension BatchDeleteDocumentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDeleteDocumentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchDeleteDocumentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDeleteDocumentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchDeleteDocumentOutputResponse(failedDocuments: \(Swift.String(describing: failedDocuments)))"}
}

extension BatchDeleteDocumentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchDeleteDocumentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failedDocuments = output.failedDocuments
        } else {
            self.failedDocuments = nil
        }
    }
}

public struct BatchDeleteDocumentOutputResponse: Swift.Equatable {
    /// <p>A list of documents that could not be removed from the index. Each
    ///       entry contains an error message that indicates why the document couldn't
    ///       be removed from the index.</p>
    public let failedDocuments: [KendraClientTypes.BatchDeleteDocumentResponseFailedDocument]?

    public init (
        failedDocuments: [KendraClientTypes.BatchDeleteDocumentResponseFailedDocument]? = nil
    )
    {
        self.failedDocuments = failedDocuments
    }
}

struct BatchDeleteDocumentOutputResponseBody: Swift.Equatable {
    public let failedDocuments: [KendraClientTypes.BatchDeleteDocumentResponseFailedDocument]?
}

extension BatchDeleteDocumentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedDocuments = "FailedDocuments"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedDocumentsContainer = try containerValues.decodeIfPresent([KendraClientTypes.BatchDeleteDocumentResponseFailedDocument?].self, forKey: .failedDocuments)
        var failedDocumentsDecoded0:[KendraClientTypes.BatchDeleteDocumentResponseFailedDocument]? = nil
        if let failedDocumentsContainer = failedDocumentsContainer {
            failedDocumentsDecoded0 = [KendraClientTypes.BatchDeleteDocumentResponseFailedDocument]()
            for structure0 in failedDocumentsContainer {
                if let structure0 = structure0 {
                    failedDocumentsDecoded0?.append(structure0)
                }
            }
        }
        failedDocuments = failedDocumentsDecoded0
    }
}

extension KendraClientTypes.BatchDeleteDocumentResponseFailedDocument: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(KendraClientTypes.ErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension KendraClientTypes.BatchDeleteDocumentResponseFailedDocument: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchDeleteDocumentResponseFailedDocument(errorCode: \(Swift.String(describing: errorCode)), errorMessage: \(Swift.String(describing: errorMessage)), id: \(Swift.String(describing: id)))"}
}

extension KendraClientTypes {
    /// <p>Provides information about documents that could not be removed
    ///             from an index by the <code>BatchDeleteDocument</code>
    ///             operation.</p>
    public struct BatchDeleteDocumentResponseFailedDocument: Swift.Equatable {
        /// <p>The error code for why the document couldn't be removed from the
        ///             index.</p>
        public let errorCode: KendraClientTypes.ErrorCode?
        /// <p>An explanation for why the document couldn't be removed from the
        ///             index.</p>
        public let errorMessage: Swift.String?
        /// <p>The identifier of the document that couldn't be removed from the
        ///             index.</p>
        public let id: Swift.String?

        public init (
            errorCode: KendraClientTypes.ErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            id: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.id = id
        }
    }

}

public struct BatchPutDocumentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchPutDocumentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchPutDocumentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchPutDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchPutDocumentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchPutDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchPutDocumentOutputError>
}

extension BatchPutDocumentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchPutDocumentInput(documents: \(Swift.String(describing: documents)), indexId: \(Swift.String(describing: indexId)), roleArn: \(Swift.String(describing: roleArn)))"}
}

extension BatchPutDocumentInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documents = "Documents"
        case indexId = "IndexId"
        case roleArn = "RoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documents = documents {
            var documentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .documents)
            for documentlist0 in documents {
                try documentsContainer.encode(documentlist0)
            }
        }
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

public struct BatchPutDocumentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchPutDocumentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchPutDocumentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchPutDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchPutDocumentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchPutDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchPutDocumentOutputError>
}

public struct BatchPutDocumentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchPutDocumentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchPutDocumentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchPutDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchPutDocumentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchPutDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchPutDocumentOutputError>
}

public struct BatchPutDocumentInput: Swift.Equatable {
    /// <p>One or more documents to add to the index.</p>
    ///          <p>Documents can include custom attributes. For example,
    ///       'DataSourceId' and 'DataSourceSyncJobId' are custom
    ///       attributes that provide information on the synchronization
    ///       of documents running on a data source. Note,
    ///       'DataSourceSyncJobId' could be an optional custom attribute
    ///       as Amazon Kendra will use the ID of a running sync job.</p>
    ///          <p>Documents have the following file size limits.</p>
    ///          <ul>
    ///             <li>
    ///                <p>5 MB total size for inline documents</p>
    ///             </li>
    ///             <li>
    ///                <p>50 MB total size for files from an S3 bucket</p>
    ///             </li>
    ///             <li>
    ///                <p>5 MB extracted text for any file</p>
    ///             </li>
    ///          </ul>
    ///          <p>For more information about file size and transaction per second
    ///       quotas, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/quotas.html">Quotas</a>.</p>
    public let documents: [KendraClientTypes.Document]?
    /// <p>The identifier of the index to add the documents to. You need to
    ///       create the index first using the <code>CreateIndex</code>
    ///       operation.</p>
    public let indexId: Swift.String?
    /// <p>The Amazon Resource Name (ARN) of a role that is allowed to run the
    ///         <code>BatchPutDocument</code> operation. For more information, see
    ///         <a href="https://docs.aws.amazon.com/kendra/latest/dg/iam-roles.html">IAM
    ///         Roles for Amazon Kendra</a>.</p>
    public let roleArn: Swift.String?

    public init (
        documents: [KendraClientTypes.Document]? = nil,
        indexId: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.documents = documents
        self.indexId = indexId
        self.roleArn = roleArn
    }
}

struct BatchPutDocumentInputBody: Swift.Equatable {
    public let indexId: Swift.String?
    public let roleArn: Swift.String?
    public let documents: [KendraClientTypes.Document]?
}

extension BatchPutDocumentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documents = "Documents"
        case indexId = "IndexId"
        case roleArn = "RoleArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexId)
        indexId = indexIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let documentsContainer = try containerValues.decodeIfPresent([KendraClientTypes.Document?].self, forKey: .documents)
        var documentsDecoded0:[KendraClientTypes.Document]? = nil
        if let documentsContainer = documentsContainer {
            documentsDecoded0 = [KendraClientTypes.Document]()
            for structure0 in documentsContainer {
                if let structure0 = structure0 {
                    documentsDecoded0?.append(structure0)
                }
            }
        }
        documents = documentsDecoded0
    }
}

extension BatchPutDocumentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchPutDocumentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchPutDocumentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchPutDocumentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchPutDocumentOutputResponse(failedDocuments: \(Swift.String(describing: failedDocuments)))"}
}

extension BatchPutDocumentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchPutDocumentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failedDocuments = output.failedDocuments
        } else {
            self.failedDocuments = nil
        }
    }
}

public struct BatchPutDocumentOutputResponse: Swift.Equatable {
    /// <p>A list of documents that were not added to the index because the
    ///       document failed a validation check. Each document contains an error
    ///       message that indicates why the document couldn't be added to the
    ///       index.</p>
    ///          <p>If there was an error adding a document to an index the error is
    ///       reported in your AWS CloudWatch log. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/cloudwatch-logs.html">Monitoring
    ///         Amazon Kendra with Amazon CloudWatch Logs</a>
    ///          </p>
    public let failedDocuments: [KendraClientTypes.BatchPutDocumentResponseFailedDocument]?

    public init (
        failedDocuments: [KendraClientTypes.BatchPutDocumentResponseFailedDocument]? = nil
    )
    {
        self.failedDocuments = failedDocuments
    }
}

struct BatchPutDocumentOutputResponseBody: Swift.Equatable {
    public let failedDocuments: [KendraClientTypes.BatchPutDocumentResponseFailedDocument]?
}

extension BatchPutDocumentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedDocuments = "FailedDocuments"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedDocumentsContainer = try containerValues.decodeIfPresent([KendraClientTypes.BatchPutDocumentResponseFailedDocument?].self, forKey: .failedDocuments)
        var failedDocumentsDecoded0:[KendraClientTypes.BatchPutDocumentResponseFailedDocument]? = nil
        if let failedDocumentsContainer = failedDocumentsContainer {
            failedDocumentsDecoded0 = [KendraClientTypes.BatchPutDocumentResponseFailedDocument]()
            for structure0 in failedDocumentsContainer {
                if let structure0 = structure0 {
                    failedDocumentsDecoded0?.append(structure0)
                }
            }
        }
        failedDocuments = failedDocumentsDecoded0
    }
}

extension KendraClientTypes.BatchPutDocumentResponseFailedDocument: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(KendraClientTypes.ErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension KendraClientTypes.BatchPutDocumentResponseFailedDocument: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchPutDocumentResponseFailedDocument(errorCode: \(Swift.String(describing: errorCode)), errorMessage: \(Swift.String(describing: errorMessage)), id: \(Swift.String(describing: id)))"}
}

extension KendraClientTypes {
    /// <p>Provides information about a document that could not be
    ///             indexed.</p>
    public struct BatchPutDocumentResponseFailedDocument: Swift.Equatable {
        /// <p>The type of error that caused the document to fail to be
        ///             indexed.</p>
        public let errorCode: KendraClientTypes.ErrorCode?
        /// <p>A description of the reason why the document could not be
        ///             indexed.</p>
        public let errorMessage: Swift.String?
        /// <p>The unique identifier of the document.</p>
        public let id: Swift.String?

        public init (
            errorCode: KendraClientTypes.ErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            id: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.id = id
        }
    }

}

extension KendraClientTypes.CapacityUnitsConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryCapacityUnits = "QueryCapacityUnits"
        case storageCapacityUnits = "StorageCapacityUnits"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queryCapacityUnits = queryCapacityUnits {
            try encodeContainer.encode(queryCapacityUnits, forKey: .queryCapacityUnits)
        }
        if let storageCapacityUnits = storageCapacityUnits {
            try encodeContainer.encode(storageCapacityUnits, forKey: .storageCapacityUnits)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageCapacityUnitsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .storageCapacityUnits)
        storageCapacityUnits = storageCapacityUnitsDecoded
        let queryCapacityUnitsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .queryCapacityUnits)
        queryCapacityUnits = queryCapacityUnitsDecoded
    }
}

extension KendraClientTypes.CapacityUnitsConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CapacityUnitsConfiguration(queryCapacityUnits: \(Swift.String(describing: queryCapacityUnits)), storageCapacityUnits: \(Swift.String(describing: storageCapacityUnits)))"}
}

extension KendraClientTypes {
    /// <p>Specifies capacity units configured for your index. You can add
    ///             and remove capacity units to tune an index to your
    ///             requirements.</p>
    public struct CapacityUnitsConfiguration: Swift.Equatable {
        /// <p>The amount of extra query capacity for an index. Each capacity
        ///             unit provides 0.5 queries per second and 40,000 queries per
        ///             day.</p>
        public let queryCapacityUnits: Swift.Int?
        /// <p>The amount of extra storage capacity for an index. Each capacity
        ///             unit provides 150 Gb of storage space or 500,000 documents,
        ///             whichever is reached first.</p>
        public let storageCapacityUnits: Swift.Int?

        public init (
            queryCapacityUnits: Swift.Int? = nil,
            storageCapacityUnits: Swift.Int? = nil
        )
        {
            self.queryCapacityUnits = queryCapacityUnits
            self.storageCapacityUnits = storageCapacityUnits
        }
    }

}

public struct ClearQuerySuggestionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ClearQuerySuggestionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ClearQuerySuggestionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ClearQuerySuggestionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ClearQuerySuggestionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ClearQuerySuggestionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ClearQuerySuggestionsOutputError>
}

extension ClearQuerySuggestionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ClearQuerySuggestionsInput(indexId: \(Swift.String(describing: indexId)))"}
}

extension ClearQuerySuggestionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexId = "IndexId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
    }
}

public struct ClearQuerySuggestionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ClearQuerySuggestionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ClearQuerySuggestionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ClearQuerySuggestionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ClearQuerySuggestionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ClearQuerySuggestionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ClearQuerySuggestionsOutputError>
}

public struct ClearQuerySuggestionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ClearQuerySuggestionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ClearQuerySuggestionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ClearQuerySuggestionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ClearQuerySuggestionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ClearQuerySuggestionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ClearQuerySuggestionsOutputError>
}

public struct ClearQuerySuggestionsInput: Swift.Equatable {
    /// <p>The identifier of the index you want to clear query suggestions from.</p>
    public let indexId: Swift.String?

    public init (
        indexId: Swift.String? = nil
    )
    {
        self.indexId = indexId
    }
}

struct ClearQuerySuggestionsInputBody: Swift.Equatable {
    public let indexId: Swift.String?
}

extension ClearQuerySuggestionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexId = "IndexId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexId)
        indexId = indexIdDecoded
    }
}

extension ClearQuerySuggestionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ClearQuerySuggestionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ClearQuerySuggestionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ClearQuerySuggestionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ClearQuerySuggestionsOutputResponse()"}
}

extension ClearQuerySuggestionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ClearQuerySuggestionsOutputResponse: Swift.Equatable {

    public init() {}
}

struct ClearQuerySuggestionsOutputResponseBody: Swift.Equatable {
}

extension ClearQuerySuggestionsOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension KendraClientTypes.ClickFeedback: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clickTime = "ClickTime"
        case resultId = "ResultId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clickTime = clickTime {
            try encodeContainer.encode(clickTime.timeIntervalSince1970, forKey: .clickTime)
        }
        if let resultId = resultId {
            try encodeContainer.encode(resultId, forKey: .resultId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resultId)
        resultId = resultIdDecoded
        let clickTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .clickTime)
        clickTime = clickTimeDecoded
    }
}

extension KendraClientTypes.ClickFeedback: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ClickFeedback(clickTime: \(Swift.String(describing: clickTime)), resultId: \(Swift.String(describing: resultId)))"}
}

extension KendraClientTypes {
    /// <p>Gathers information about when a particular result was clicked by
    ///             a user. Your application uses the <code>SubmitFeedback</code>
    ///             operation to provide click information.</p>
    public struct ClickFeedback: Swift.Equatable {
        /// <p>The Unix timestamp of the date and time that the result was
        ///             clicked.</p>
        public let clickTime: ClientRuntime.Date?
        /// <p>The unique identifier of the search result that was
        ///             clicked.</p>
        public let resultId: Swift.String?

        public init (
            clickTime: ClientRuntime.Date? = nil,
            resultId: Swift.String? = nil
        )
        {
            self.clickTime = clickTime
            self.resultId = resultId
        }
    }

}

extension KendraClientTypes.ColumnConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeDetectingColumns = "ChangeDetectingColumns"
        case documentDataColumnName = "DocumentDataColumnName"
        case documentIdColumnName = "DocumentIdColumnName"
        case documentTitleColumnName = "DocumentTitleColumnName"
        case fieldMappings = "FieldMappings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeDetectingColumns = changeDetectingColumns {
            var changeDetectingColumnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .changeDetectingColumns)
            for changedetectingcolumns0 in changeDetectingColumns {
                try changeDetectingColumnsContainer.encode(changedetectingcolumns0)
            }
        }
        if let documentDataColumnName = documentDataColumnName {
            try encodeContainer.encode(documentDataColumnName, forKey: .documentDataColumnName)
        }
        if let documentIdColumnName = documentIdColumnName {
            try encodeContainer.encode(documentIdColumnName, forKey: .documentIdColumnName)
        }
        if let documentTitleColumnName = documentTitleColumnName {
            try encodeContainer.encode(documentTitleColumnName, forKey: .documentTitleColumnName)
        }
        if let fieldMappings = fieldMappings {
            var fieldMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fieldMappings)
            for datasourcetoindexfieldmappinglist0 in fieldMappings {
                try fieldMappingsContainer.encode(datasourcetoindexfieldmappinglist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentIdColumnNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentIdColumnName)
        documentIdColumnName = documentIdColumnNameDecoded
        let documentDataColumnNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentDataColumnName)
        documentDataColumnName = documentDataColumnNameDecoded
        let documentTitleColumnNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentTitleColumnName)
        documentTitleColumnName = documentTitleColumnNameDecoded
        let fieldMappingsContainer = try containerValues.decodeIfPresent([KendraClientTypes.DataSourceToIndexFieldMapping?].self, forKey: .fieldMappings)
        var fieldMappingsDecoded0:[KendraClientTypes.DataSourceToIndexFieldMapping]? = nil
        if let fieldMappingsContainer = fieldMappingsContainer {
            fieldMappingsDecoded0 = [KendraClientTypes.DataSourceToIndexFieldMapping]()
            for structure0 in fieldMappingsContainer {
                if let structure0 = structure0 {
                    fieldMappingsDecoded0?.append(structure0)
                }
            }
        }
        fieldMappings = fieldMappingsDecoded0
        let changeDetectingColumnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .changeDetectingColumns)
        var changeDetectingColumnsDecoded0:[Swift.String]? = nil
        if let changeDetectingColumnsContainer = changeDetectingColumnsContainer {
            changeDetectingColumnsDecoded0 = [Swift.String]()
            for string0 in changeDetectingColumnsContainer {
                if let string0 = string0 {
                    changeDetectingColumnsDecoded0?.append(string0)
                }
            }
        }
        changeDetectingColumns = changeDetectingColumnsDecoded0
    }
}

extension KendraClientTypes.ColumnConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ColumnConfiguration(changeDetectingColumns: \(Swift.String(describing: changeDetectingColumns)), documentDataColumnName: \(Swift.String(describing: documentDataColumnName)), documentIdColumnName: \(Swift.String(describing: documentIdColumnName)), documentTitleColumnName: \(Swift.String(describing: documentTitleColumnName)), fieldMappings: \(Swift.String(describing: fieldMappings)))"}
}

extension KendraClientTypes {
    /// <p>Provides information about how Amazon Kendra should use the columns of
    ///             a database in an index.</p>
    public struct ColumnConfiguration: Swift.Equatable {
        /// <p>One to five columns that indicate when a document in the database
        ///             has changed.</p>
        public let changeDetectingColumns: [Swift.String]?
        /// <p>The column that contains the contents of the document.</p>
        public let documentDataColumnName: Swift.String?
        /// <p>The column that provides the document's unique identifier.</p>
        public let documentIdColumnName: Swift.String?
        /// <p>The column that contains the title of the document.</p>
        public let documentTitleColumnName: Swift.String?
        /// <p>An array of objects that map database column names to the
        ///             corresponding fields in an index. You must first create the fields
        ///             in the index using the <code>UpdateIndex</code> operation.</p>
        public let fieldMappings: [KendraClientTypes.DataSourceToIndexFieldMapping]?

        public init (
            changeDetectingColumns: [Swift.String]? = nil,
            documentDataColumnName: Swift.String? = nil,
            documentIdColumnName: Swift.String? = nil,
            documentTitleColumnName: Swift.String? = nil,
            fieldMappings: [KendraClientTypes.DataSourceToIndexFieldMapping]? = nil
        )
        {
            self.changeDetectingColumns = changeDetectingColumns
            self.documentDataColumnName = documentDataColumnName
            self.documentIdColumnName = documentIdColumnName
            self.documentTitleColumnName = documentTitleColumnName
            self.fieldMappings = fieldMappings
        }
    }

}

extension ConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictException(message: \(Swift.String(describing: message)))"}
}

extension ConflictException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct ConflictException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KendraClientTypes.ConfluenceAttachmentConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentFieldMappings = "AttachmentFieldMappings"
        case crawlAttachments = "CrawlAttachments"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachmentFieldMappings = attachmentFieldMappings {
            var attachmentFieldMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attachmentFieldMappings)
            for confluenceattachmentfieldmappingslist0 in attachmentFieldMappings {
                try attachmentFieldMappingsContainer.encode(confluenceattachmentfieldmappingslist0)
            }
        }
        if crawlAttachments != false {
            try encodeContainer.encode(crawlAttachments, forKey: .crawlAttachments)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let crawlAttachmentsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .crawlAttachments)
        crawlAttachments = crawlAttachmentsDecoded
        let attachmentFieldMappingsContainer = try containerValues.decodeIfPresent([KendraClientTypes.ConfluenceAttachmentToIndexFieldMapping?].self, forKey: .attachmentFieldMappings)
        var attachmentFieldMappingsDecoded0:[KendraClientTypes.ConfluenceAttachmentToIndexFieldMapping]? = nil
        if let attachmentFieldMappingsContainer = attachmentFieldMappingsContainer {
            attachmentFieldMappingsDecoded0 = [KendraClientTypes.ConfluenceAttachmentToIndexFieldMapping]()
            for structure0 in attachmentFieldMappingsContainer {
                if let structure0 = structure0 {
                    attachmentFieldMappingsDecoded0?.append(structure0)
                }
            }
        }
        attachmentFieldMappings = attachmentFieldMappingsDecoded0
    }
}

extension KendraClientTypes.ConfluenceAttachmentConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConfluenceAttachmentConfiguration(attachmentFieldMappings: \(Swift.String(describing: attachmentFieldMappings)), crawlAttachments: \(Swift.String(describing: crawlAttachments)))"}
}

extension KendraClientTypes {
    /// <p>Specifies the attachment settings for the Confluence data source.
    ///             Attachment settings are optional, if you don't specify settings
    ///             attachments, Amazon Kendra won't index them.</p>
    public struct ConfluenceAttachmentConfiguration: Swift.Equatable {
        /// <p>Defines how attachment metadata fields should be mapped to index
        ///             fields. Before you can map a field, you must first create an index
        ///             field with a matching type using the console or the
        ///                 <code>UpdateIndex</code> operation.</p>
        ///         <p>If you specify the <code>AttachentFieldMappings</code> parameter,
        ///             you must specify at least one field mapping.</p>
        public let attachmentFieldMappings: [KendraClientTypes.ConfluenceAttachmentToIndexFieldMapping]?
        /// <p>Indicates whether Amazon Kendra indexes attachments to the pages and blogs
        ///             in the Confluence data source. </p>
        public let crawlAttachments: Swift.Bool

        public init (
            attachmentFieldMappings: [KendraClientTypes.ConfluenceAttachmentToIndexFieldMapping]? = nil,
            crawlAttachments: Swift.Bool = false
        )
        {
            self.attachmentFieldMappings = attachmentFieldMappings
            self.crawlAttachments = crawlAttachments
        }
    }

}

extension KendraClientTypes {
    public enum ConfluenceAttachmentFieldName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case author
        case contentType
        case createdDate
        case displayUrl
        case fileSize
        case itemType
        case parentId
        case spaceKey
        case spaceName
        case url
        case version
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfluenceAttachmentFieldName] {
            return [
                .author,
                .contentType,
                .createdDate,
                .displayUrl,
                .fileSize,
                .itemType,
                .parentId,
                .spaceKey,
                .spaceName,
                .url,
                .version,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .author: return "AUTHOR"
            case .contentType: return "CONTENT_TYPE"
            case .createdDate: return "CREATED_DATE"
            case .displayUrl: return "DISPLAY_URL"
            case .fileSize: return "FILE_SIZE"
            case .itemType: return "ITEM_TYPE"
            case .parentId: return "PARENT_ID"
            case .spaceKey: return "SPACE_KEY"
            case .spaceName: return "SPACE_NAME"
            case .url: return "URL"
            case .version: return "VERSION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConfluenceAttachmentFieldName(rawValue: rawValue) ?? ConfluenceAttachmentFieldName.sdkUnknown(rawValue)
        }
    }
}

extension KendraClientTypes.ConfluenceAttachmentToIndexFieldMapping: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceFieldName = "DataSourceFieldName"
        case dateFieldFormat = "DateFieldFormat"
        case indexFieldName = "IndexFieldName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceFieldName = dataSourceFieldName {
            try encodeContainer.encode(dataSourceFieldName.rawValue, forKey: .dataSourceFieldName)
        }
        if let dateFieldFormat = dateFieldFormat {
            try encodeContainer.encode(dateFieldFormat, forKey: .dateFieldFormat)
        }
        if let indexFieldName = indexFieldName {
            try encodeContainer.encode(indexFieldName, forKey: .indexFieldName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceFieldNameDecoded = try containerValues.decodeIfPresent(KendraClientTypes.ConfluenceAttachmentFieldName.self, forKey: .dataSourceFieldName)
        dataSourceFieldName = dataSourceFieldNameDecoded
        let dateFieldFormatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateFieldFormat)
        dateFieldFormat = dateFieldFormatDecoded
        let indexFieldNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexFieldName)
        indexFieldName = indexFieldNameDecoded
    }
}

extension KendraClientTypes.ConfluenceAttachmentToIndexFieldMapping: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConfluenceAttachmentToIndexFieldMapping(dataSourceFieldName: \(Swift.String(describing: dataSourceFieldName)), dateFieldFormat: \(Swift.String(describing: dateFieldFormat)), indexFieldName: \(Swift.String(describing: indexFieldName)))"}
}

extension KendraClientTypes {
    /// <p>Defines the mapping between a field in the Confluence data source
    ///             to a Amazon Kendra index field.</p>
    ///         <p>You must first create the index field using the
    ///                 <code>UpdateIndex</code> operation. </p>
    public struct ConfluenceAttachmentToIndexFieldMapping: Swift.Equatable {
        /// <p>The name of the field in the data source. </p>
        ///         <p>You must first create the index field using the
        ///                 <code>UpdateIndex</code> operation. </p>
        public let dataSourceFieldName: KendraClientTypes.ConfluenceAttachmentFieldName?
        /// <p>The format for date fields in the data source. If the field
        ///             specified in <code>DataSourceFieldName</code> is a date field you
        ///             must specify the date format. If the field is not a date field, an
        ///             exception is thrown.</p>
        public let dateFieldFormat: Swift.String?
        /// <p>The name of the index field to map to the Confluence data source
        ///             field. The index field type must match the Confluence field
        ///             type.</p>
        public let indexFieldName: Swift.String?

        public init (
            dataSourceFieldName: KendraClientTypes.ConfluenceAttachmentFieldName? = nil,
            dateFieldFormat: Swift.String? = nil,
            indexFieldName: Swift.String? = nil
        )
        {
            self.dataSourceFieldName = dataSourceFieldName
            self.dateFieldFormat = dateFieldFormat
            self.indexFieldName = indexFieldName
        }
    }

}

extension KendraClientTypes.ConfluenceBlogConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blogFieldMappings = "BlogFieldMappings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let blogFieldMappings = blogFieldMappings {
            var blogFieldMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .blogFieldMappings)
            for confluenceblogfieldmappingslist0 in blogFieldMappings {
                try blogFieldMappingsContainer.encode(confluenceblogfieldmappingslist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blogFieldMappingsContainer = try containerValues.decodeIfPresent([KendraClientTypes.ConfluenceBlogToIndexFieldMapping?].self, forKey: .blogFieldMappings)
        var blogFieldMappingsDecoded0:[KendraClientTypes.ConfluenceBlogToIndexFieldMapping]? = nil
        if let blogFieldMappingsContainer = blogFieldMappingsContainer {
            blogFieldMappingsDecoded0 = [KendraClientTypes.ConfluenceBlogToIndexFieldMapping]()
            for structure0 in blogFieldMappingsContainer {
                if let structure0 = structure0 {
                    blogFieldMappingsDecoded0?.append(structure0)
                }
            }
        }
        blogFieldMappings = blogFieldMappingsDecoded0
    }
}

extension KendraClientTypes.ConfluenceBlogConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConfluenceBlogConfiguration(blogFieldMappings: \(Swift.String(describing: blogFieldMappings)))"}
}

extension KendraClientTypes {
    /// <p>Specifies the blog settings for the Confluence data source. Blogs
    ///             are always indexed unless filtered from the index by the
    ///                 <code>ExclusionPatterns</code> or <code>InclusionPatterns</code>
    ///             fields in the <code>ConfluenceConfiguration</code> type.</p>
    public struct ConfluenceBlogConfiguration: Swift.Equatable {
        /// <p>Defines how blog metadata fields should be mapped to index fields.
        ///             Before you can map a field, you must first create an index field
        ///             with a matching type using the console or the
        ///                 <code>UpdateIndex</code> operation.</p>
        ///         <p>If you specify the <code>BlogFieldMappings</code> parameter, you
        ///             must specify at least one field mapping.</p>
        public let blogFieldMappings: [KendraClientTypes.ConfluenceBlogToIndexFieldMapping]?

        public init (
            blogFieldMappings: [KendraClientTypes.ConfluenceBlogToIndexFieldMapping]? = nil
        )
        {
            self.blogFieldMappings = blogFieldMappings
        }
    }

}

extension KendraClientTypes {
    public enum ConfluenceBlogFieldName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case author
        case displayUrl
        case itemType
        case labels
        case publishDate
        case spaceKey
        case spaceName
        case url
        case version
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfluenceBlogFieldName] {
            return [
                .author,
                .displayUrl,
                .itemType,
                .labels,
                .publishDate,
                .spaceKey,
                .spaceName,
                .url,
                .version,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .author: return "AUTHOR"
            case .displayUrl: return "DISPLAY_URL"
            case .itemType: return "ITEM_TYPE"
            case .labels: return "LABELS"
            case .publishDate: return "PUBLISH_DATE"
            case .spaceKey: return "SPACE_KEY"
            case .spaceName: return "SPACE_NAME"
            case .url: return "URL"
            case .version: return "VERSION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConfluenceBlogFieldName(rawValue: rawValue) ?? ConfluenceBlogFieldName.sdkUnknown(rawValue)
        }
    }
}

extension KendraClientTypes.ConfluenceBlogToIndexFieldMapping: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceFieldName = "DataSourceFieldName"
        case dateFieldFormat = "DateFieldFormat"
        case indexFieldName = "IndexFieldName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceFieldName = dataSourceFieldName {
            try encodeContainer.encode(dataSourceFieldName.rawValue, forKey: .dataSourceFieldName)
        }
        if let dateFieldFormat = dateFieldFormat {
            try encodeContainer.encode(dateFieldFormat, forKey: .dateFieldFormat)
        }
        if let indexFieldName = indexFieldName {
            try encodeContainer.encode(indexFieldName, forKey: .indexFieldName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceFieldNameDecoded = try containerValues.decodeIfPresent(KendraClientTypes.ConfluenceBlogFieldName.self, forKey: .dataSourceFieldName)
        dataSourceFieldName = dataSourceFieldNameDecoded
        let dateFieldFormatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateFieldFormat)
        dateFieldFormat = dateFieldFormatDecoded
        let indexFieldNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexFieldName)
        indexFieldName = indexFieldNameDecoded
    }
}

extension KendraClientTypes.ConfluenceBlogToIndexFieldMapping: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConfluenceBlogToIndexFieldMapping(dataSourceFieldName: \(Swift.String(describing: dataSourceFieldName)), dateFieldFormat: \(Swift.String(describing: dateFieldFormat)), indexFieldName: \(Swift.String(describing: indexFieldName)))"}
}

extension KendraClientTypes {
    /// <p>Defines the mapping between a blog field in the Confluence data
    ///             source to a Amazon Kendra index field.</p>
    ///         <p>You must first create the index field using the
    ///                 <code>UpdateIndex</code> operation. </p>
    public struct ConfluenceBlogToIndexFieldMapping: Swift.Equatable {
        /// <p>The name of the field in the data source. </p>
        public let dataSourceFieldName: KendraClientTypes.ConfluenceBlogFieldName?
        /// <p>The format for date fields in the data source. If the field
        ///             specified in <code>DataSourceFieldName</code> is a date field you
        ///             must specify the date format. If the field is not a date field, an
        ///             exception is thrown.</p>
        public let dateFieldFormat: Swift.String?
        /// <p>The name of the index field to map to the Confluence data source
        ///             field. The index field type must match the Confluence field
        ///             type.</p>
        public let indexFieldName: Swift.String?

        public init (
            dataSourceFieldName: KendraClientTypes.ConfluenceBlogFieldName? = nil,
            dateFieldFormat: Swift.String? = nil,
            indexFieldName: Swift.String? = nil
        )
        {
            self.dataSourceFieldName = dataSourceFieldName
            self.dateFieldFormat = dateFieldFormat
            self.indexFieldName = indexFieldName
        }
    }

}

extension KendraClientTypes.ConfluenceConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentConfiguration = "AttachmentConfiguration"
        case blogConfiguration = "BlogConfiguration"
        case exclusionPatterns = "ExclusionPatterns"
        case inclusionPatterns = "InclusionPatterns"
        case pageConfiguration = "PageConfiguration"
        case secretArn = "SecretArn"
        case serverUrl = "ServerUrl"
        case spaceConfiguration = "SpaceConfiguration"
        case version = "Version"
        case vpcConfiguration = "VpcConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachmentConfiguration = attachmentConfiguration {
            try encodeContainer.encode(attachmentConfiguration, forKey: .attachmentConfiguration)
        }
        if let blogConfiguration = blogConfiguration {
            try encodeContainer.encode(blogConfiguration, forKey: .blogConfiguration)
        }
        if let exclusionPatterns = exclusionPatterns {
            var exclusionPatternsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .exclusionPatterns)
            for datasourceinclusionsexclusionsstrings0 in exclusionPatterns {
                try exclusionPatternsContainer.encode(datasourceinclusionsexclusionsstrings0)
            }
        }
        if let inclusionPatterns = inclusionPatterns {
            var inclusionPatternsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inclusionPatterns)
            for datasourceinclusionsexclusionsstrings0 in inclusionPatterns {
                try inclusionPatternsContainer.encode(datasourceinclusionsexclusionsstrings0)
            }
        }
        if let pageConfiguration = pageConfiguration {
            try encodeContainer.encode(pageConfiguration, forKey: .pageConfiguration)
        }
        if let secretArn = secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
        if let serverUrl = serverUrl {
            try encodeContainer.encode(serverUrl, forKey: .serverUrl)
        }
        if let spaceConfiguration = spaceConfiguration {
            try encodeContainer.encode(spaceConfiguration, forKey: .spaceConfiguration)
        }
        if let version = version {
            try encodeContainer.encode(version.rawValue, forKey: .version)
        }
        if let vpcConfiguration = vpcConfiguration {
            try encodeContainer.encode(vpcConfiguration, forKey: .vpcConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverUrl)
        serverUrl = serverUrlDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let versionDecoded = try containerValues.decodeIfPresent(KendraClientTypes.ConfluenceVersion.self, forKey: .version)
        version = versionDecoded
        let spaceConfigurationDecoded = try containerValues.decodeIfPresent(KendraClientTypes.ConfluenceSpaceConfiguration.self, forKey: .spaceConfiguration)
        spaceConfiguration = spaceConfigurationDecoded
        let pageConfigurationDecoded = try containerValues.decodeIfPresent(KendraClientTypes.ConfluencePageConfiguration.self, forKey: .pageConfiguration)
        pageConfiguration = pageConfigurationDecoded
        let blogConfigurationDecoded = try containerValues.decodeIfPresent(KendraClientTypes.ConfluenceBlogConfiguration.self, forKey: .blogConfiguration)
        blogConfiguration = blogConfigurationDecoded
        let attachmentConfigurationDecoded = try containerValues.decodeIfPresent(KendraClientTypes.ConfluenceAttachmentConfiguration.self, forKey: .attachmentConfiguration)
        attachmentConfiguration = attachmentConfigurationDecoded
        let vpcConfigurationDecoded = try containerValues.decodeIfPresent(KendraClientTypes.DataSourceVpcConfiguration.self, forKey: .vpcConfiguration)
        vpcConfiguration = vpcConfigurationDecoded
        let inclusionPatternsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .inclusionPatterns)
        var inclusionPatternsDecoded0:[Swift.String]? = nil
        if let inclusionPatternsContainer = inclusionPatternsContainer {
            inclusionPatternsDecoded0 = [Swift.String]()
            for string0 in inclusionPatternsContainer {
                if let string0 = string0 {
                    inclusionPatternsDecoded0?.append(string0)
                }
            }
        }
        inclusionPatterns = inclusionPatternsDecoded0
        let exclusionPatternsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .exclusionPatterns)
        var exclusionPatternsDecoded0:[Swift.String]? = nil
        if let exclusionPatternsContainer = exclusionPatternsContainer {
            exclusionPatternsDecoded0 = [Swift.String]()
            for string0 in exclusionPatternsContainer {
                if let string0 = string0 {
                    exclusionPatternsDecoded0?.append(string0)
                }
            }
        }
        exclusionPatterns = exclusionPatternsDecoded0
    }
}

extension KendraClientTypes.ConfluenceConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConfluenceConfiguration(attachmentConfiguration: \(Swift.String(describing: attachmentConfiguration)), blogConfiguration: \(Swift.String(describing: blogConfiguration)), exclusionPatterns: \(Swift.String(describing: exclusionPatterns)), inclusionPatterns: \(Swift.String(describing: inclusionPatterns)), pageConfiguration: \(Swift.String(describing: pageConfiguration)), secretArn: \(Swift.String(describing: secretArn)), serverUrl: \(Swift.String(describing: serverUrl)), spaceConfiguration: \(Swift.String(describing: spaceConfiguration)), version: \(Swift.String(describing: version)), vpcConfiguration: \(Swift.String(describing: vpcConfiguration)))"}
}

extension KendraClientTypes {
    /// <p>Provides configuration information for data sources that connect
    ///             to Confluence.</p>
    public struct ConfluenceConfiguration: Swift.Equatable {
        /// <p>Specifies configuration information for indexing attachments to
        ///             Confluence blogs and pages.</p>
        public let attachmentConfiguration: KendraClientTypes.ConfluenceAttachmentConfiguration?
        /// <p> Specifies configuration information for indexing Confluence
        ///             blogs.</p>
        public let blogConfiguration: KendraClientTypes.ConfluenceBlogConfiguration?
        /// <p>A list of regular expression patterns that apply to a URL on the
        ///             Confluence server. An exclusion pattern can apply to a blog post, a
        ///             page, a space, or an attachment. Items that match the pattern are
        ///             excluded from the index. Items that don't match the pattern are
        ///             included in the index. If a item matches both an exclusion pattern
        ///             and an inclusion pattern, the item isn't included in the
        ///             index.</p>
        public let exclusionPatterns: [Swift.String]?
        /// <p>A list of regular expression patterns that apply to a URL on the
        ///             Confluence server. An inclusion pattern can apply to a blog post, a
        ///             page, a space, or an attachment. Items that match the patterns are
        ///             included in the index. Items that don't match the pattern are
        ///             excluded from the index. If an item matches both an inclusion
        ///             pattern and an exclusion pattern, the item isn't included in the
        ///             index.</p>
        public let inclusionPatterns: [Swift.String]?
        /// <p>Specifies configuration information for indexing Confluence
        ///             pages.</p>
        public let pageConfiguration: KendraClientTypes.ConfluencePageConfiguration?
        /// <p>The Amazon Resource Name (ARN) of an AWS Secrets Manager secret
        ///             that contains the key/value pairs required to connect to your
        ///             Confluence server. The secret must contain a JSON structure with the
        ///             following keys:</p>
        ///         <ul>
        ///             <li>
        ///                 <p>username - The user name or email address of a user with
        ///                     administrative privileges for the Confluence server.</p>
        ///             </li>
        ///             <li>
        ///                 <p>password - The password associated with the user logging
        ///                     in to the Confluence server.</p>
        ///             </li>
        ///          </ul>
        public let secretArn: Swift.String?
        /// <p>The URL of your Confluence instance. Use the full URL of the
        ///             server. For example, <code>https://server.example.com:port/</code>.
        ///             You can also use an IP address, for example,
        ///                 <code>https://192.168.1.113/</code>.</p>
        public let serverUrl: Swift.String?
        /// <p>Specifies configuration information for indexing Confluence
        ///             spaces.</p>
        public let spaceConfiguration: KendraClientTypes.ConfluenceSpaceConfiguration?
        /// <p>Specifies the version of the Confluence installation that you are
        ///             connecting to.</p>
        public let version: KendraClientTypes.ConfluenceVersion?
        /// <p>Specifies the information for connecting to an Amazon VPC.</p>
        public let vpcConfiguration: KendraClientTypes.DataSourceVpcConfiguration?

        public init (
            attachmentConfiguration: KendraClientTypes.ConfluenceAttachmentConfiguration? = nil,
            blogConfiguration: KendraClientTypes.ConfluenceBlogConfiguration? = nil,
            exclusionPatterns: [Swift.String]? = nil,
            inclusionPatterns: [Swift.String]? = nil,
            pageConfiguration: KendraClientTypes.ConfluencePageConfiguration? = nil,
            secretArn: Swift.String? = nil,
            serverUrl: Swift.String? = nil,
            spaceConfiguration: KendraClientTypes.ConfluenceSpaceConfiguration? = nil,
            version: KendraClientTypes.ConfluenceVersion? = nil,
            vpcConfiguration: KendraClientTypes.DataSourceVpcConfiguration? = nil
        )
        {
            self.attachmentConfiguration = attachmentConfiguration
            self.blogConfiguration = blogConfiguration
            self.exclusionPatterns = exclusionPatterns
            self.inclusionPatterns = inclusionPatterns
            self.pageConfiguration = pageConfiguration
            self.secretArn = secretArn
            self.serverUrl = serverUrl
            self.spaceConfiguration = spaceConfiguration
            self.version = version
            self.vpcConfiguration = vpcConfiguration
        }
    }

}

extension KendraClientTypes.ConfluencePageConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pageFieldMappings = "PageFieldMappings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pageFieldMappings = pageFieldMappings {
            var pageFieldMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pageFieldMappings)
            for confluencepagefieldmappingslist0 in pageFieldMappings {
                try pageFieldMappingsContainer.encode(confluencepagefieldmappingslist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pageFieldMappingsContainer = try containerValues.decodeIfPresent([KendraClientTypes.ConfluencePageToIndexFieldMapping?].self, forKey: .pageFieldMappings)
        var pageFieldMappingsDecoded0:[KendraClientTypes.ConfluencePageToIndexFieldMapping]? = nil
        if let pageFieldMappingsContainer = pageFieldMappingsContainer {
            pageFieldMappingsDecoded0 = [KendraClientTypes.ConfluencePageToIndexFieldMapping]()
            for structure0 in pageFieldMappingsContainer {
                if let structure0 = structure0 {
                    pageFieldMappingsDecoded0?.append(structure0)
                }
            }
        }
        pageFieldMappings = pageFieldMappingsDecoded0
    }
}

extension KendraClientTypes.ConfluencePageConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConfluencePageConfiguration(pageFieldMappings: \(Swift.String(describing: pageFieldMappings)))"}
}

extension KendraClientTypes {
    /// <p>Specifies the page settings for the Confluence data source.</p>
    public struct ConfluencePageConfiguration: Swift.Equatable {
        /// <p>Defines how page metadata fields should be mapped to index fields.
        ///             Before you can map a field, you must first create an index field
        ///             with a matching type using the console or the
        ///                 <code>UpdateIndex</code> operation.</p>
        ///         <p>If you specify the <code>PageFieldMappings</code> parameter, you
        ///             must specify at least one field mapping.</p>
        public let pageFieldMappings: [KendraClientTypes.ConfluencePageToIndexFieldMapping]?

        public init (
            pageFieldMappings: [KendraClientTypes.ConfluencePageToIndexFieldMapping]? = nil
        )
        {
            self.pageFieldMappings = pageFieldMappings
        }
    }

}

extension KendraClientTypes {
    public enum ConfluencePageFieldName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case author
        case contentStatus
        case createdDate
        case displayUrl
        case itemType
        case labels
        case modifiedDate
        case parentId
        case spaceKey
        case spaceName
        case url
        case version
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfluencePageFieldName] {
            return [
                .author,
                .contentStatus,
                .createdDate,
                .displayUrl,
                .itemType,
                .labels,
                .modifiedDate,
                .parentId,
                .spaceKey,
                .spaceName,
                .url,
                .version,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .author: return "AUTHOR"
            case .contentStatus: return "CONTENT_STATUS"
            case .createdDate: return "CREATED_DATE"
            case .displayUrl: return "DISPLAY_URL"
            case .itemType: return "ITEM_TYPE"
            case .labels: return "LABELS"
            case .modifiedDate: return "MODIFIED_DATE"
            case .parentId: return "PARENT_ID"
            case .spaceKey: return "SPACE_KEY"
            case .spaceName: return "SPACE_NAME"
            case .url: return "URL"
            case .version: return "VERSION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConfluencePageFieldName(rawValue: rawValue) ?? ConfluencePageFieldName.sdkUnknown(rawValue)
        }
    }
}

extension KendraClientTypes.ConfluencePageToIndexFieldMapping: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceFieldName = "DataSourceFieldName"
        case dateFieldFormat = "DateFieldFormat"
        case indexFieldName = "IndexFieldName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceFieldName = dataSourceFieldName {
            try encodeContainer.encode(dataSourceFieldName.rawValue, forKey: .dataSourceFieldName)
        }
        if let dateFieldFormat = dateFieldFormat {
            try encodeContainer.encode(dateFieldFormat, forKey: .dateFieldFormat)
        }
        if let indexFieldName = indexFieldName {
            try encodeContainer.encode(indexFieldName, forKey: .indexFieldName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceFieldNameDecoded = try containerValues.decodeIfPresent(KendraClientTypes.ConfluencePageFieldName.self, forKey: .dataSourceFieldName)
        dataSourceFieldName = dataSourceFieldNameDecoded
        let dateFieldFormatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateFieldFormat)
        dateFieldFormat = dateFieldFormatDecoded
        let indexFieldNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexFieldName)
        indexFieldName = indexFieldNameDecoded
    }
}

extension KendraClientTypes.ConfluencePageToIndexFieldMapping: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConfluencePageToIndexFieldMapping(dataSourceFieldName: \(Swift.String(describing: dataSourceFieldName)), dateFieldFormat: \(Swift.String(describing: dateFieldFormat)), indexFieldName: \(Swift.String(describing: indexFieldName)))"}
}

extension KendraClientTypes {
    /// <p>Defines the mapping between a field in the Confluence data source
    ///             to a Amazon Kendra index field.</p>
    ///         <p>You must first create the index field using the
    ///                 <code>UpdateIndex</code> operation. </p>
    public struct ConfluencePageToIndexFieldMapping: Swift.Equatable {
        /// <p>The name of the field in the data source. </p>
        public let dataSourceFieldName: KendraClientTypes.ConfluencePageFieldName?
        /// <p>The format for date fields in the data source. If the field
        ///             specified in <code>DataSourceFieldName</code> is a date field you
        ///             must specify the date format. If the field is not a date field, an
        ///             exception is thrown.</p>
        public let dateFieldFormat: Swift.String?
        /// <p>The name of the index field to map to the Confluence data source
        ///             field. The index field type must match the Confluence field
        ///             type.</p>
        public let indexFieldName: Swift.String?

        public init (
            dataSourceFieldName: KendraClientTypes.ConfluencePageFieldName? = nil,
            dateFieldFormat: Swift.String? = nil,
            indexFieldName: Swift.String? = nil
        )
        {
            self.dataSourceFieldName = dataSourceFieldName
            self.dateFieldFormat = dateFieldFormat
            self.indexFieldName = indexFieldName
        }
    }

}

extension KendraClientTypes.ConfluenceSpaceConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crawlArchivedSpaces = "CrawlArchivedSpaces"
        case crawlPersonalSpaces = "CrawlPersonalSpaces"
        case excludeSpaces = "ExcludeSpaces"
        case includeSpaces = "IncludeSpaces"
        case spaceFieldMappings = "SpaceFieldMappings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if crawlArchivedSpaces != false {
            try encodeContainer.encode(crawlArchivedSpaces, forKey: .crawlArchivedSpaces)
        }
        if crawlPersonalSpaces != false {
            try encodeContainer.encode(crawlPersonalSpaces, forKey: .crawlPersonalSpaces)
        }
        if let excludeSpaces = excludeSpaces {
            var excludeSpacesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .excludeSpaces)
            for confluencespacelist0 in excludeSpaces {
                try excludeSpacesContainer.encode(confluencespacelist0)
            }
        }
        if let includeSpaces = includeSpaces {
            var includeSpacesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .includeSpaces)
            for confluencespacelist0 in includeSpaces {
                try includeSpacesContainer.encode(confluencespacelist0)
            }
        }
        if let spaceFieldMappings = spaceFieldMappings {
            var spaceFieldMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .spaceFieldMappings)
            for confluencespacefieldmappingslist0 in spaceFieldMappings {
                try spaceFieldMappingsContainer.encode(confluencespacefieldmappingslist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let crawlPersonalSpacesDecoded = try containerValues.decode(Swift.Bool.self, forKey: .crawlPersonalSpaces)
        crawlPersonalSpaces = crawlPersonalSpacesDecoded
        let crawlArchivedSpacesDecoded = try containerValues.decode(Swift.Bool.self, forKey: .crawlArchivedSpaces)
        crawlArchivedSpaces = crawlArchivedSpacesDecoded
        let includeSpacesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .includeSpaces)
        var includeSpacesDecoded0:[Swift.String]? = nil
        if let includeSpacesContainer = includeSpacesContainer {
            includeSpacesDecoded0 = [Swift.String]()
            for string0 in includeSpacesContainer {
                if let string0 = string0 {
                    includeSpacesDecoded0?.append(string0)
                }
            }
        }
        includeSpaces = includeSpacesDecoded0
        let excludeSpacesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .excludeSpaces)
        var excludeSpacesDecoded0:[Swift.String]? = nil
        if let excludeSpacesContainer = excludeSpacesContainer {
            excludeSpacesDecoded0 = [Swift.String]()
            for string0 in excludeSpacesContainer {
                if let string0 = string0 {
                    excludeSpacesDecoded0?.append(string0)
                }
            }
        }
        excludeSpaces = excludeSpacesDecoded0
        let spaceFieldMappingsContainer = try containerValues.decodeIfPresent([KendraClientTypes.ConfluenceSpaceToIndexFieldMapping?].self, forKey: .spaceFieldMappings)
        var spaceFieldMappingsDecoded0:[KendraClientTypes.ConfluenceSpaceToIndexFieldMapping]? = nil
        if let spaceFieldMappingsContainer = spaceFieldMappingsContainer {
            spaceFieldMappingsDecoded0 = [KendraClientTypes.ConfluenceSpaceToIndexFieldMapping]()
            for structure0 in spaceFieldMappingsContainer {
                if let structure0 = structure0 {
                    spaceFieldMappingsDecoded0?.append(structure0)
                }
            }
        }
        spaceFieldMappings = spaceFieldMappingsDecoded0
    }
}

extension KendraClientTypes.ConfluenceSpaceConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConfluenceSpaceConfiguration(crawlArchivedSpaces: \(Swift.String(describing: crawlArchivedSpaces)), crawlPersonalSpaces: \(Swift.String(describing: crawlPersonalSpaces)), excludeSpaces: \(Swift.String(describing: excludeSpaces)), includeSpaces: \(Swift.String(describing: includeSpaces)), spaceFieldMappings: \(Swift.String(describing: spaceFieldMappings)))"}
}

extension KendraClientTypes {
    /// <p>Specifies the configuration for indexing Confluence spaces.</p>
    public struct ConfluenceSpaceConfiguration: Swift.Equatable {
        /// <p>Specifies whether Amazon Kendra should index archived spaces.</p>
        public let crawlArchivedSpaces: Swift.Bool
        /// <p>Specifies whether Amazon Kendra should index personal spaces. Users can
        ///             add restrictions to items in personal spaces. If personal spaces are
        ///             indexed, queries without user context information may return
        ///             restricted items from a personal space in their results. For more
        ///             information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/user-context-filter.html">Filtering on
        ///                 user context</a>.</p>
        public let crawlPersonalSpaces: Swift.Bool
        /// <p>A list of space keys of Confluence spaces. If you include a key,
        ///             the blogs, documents, and attachments in the space are not indexed.
        ///             If a space is in both the <code>ExcludeSpaces</code> and the
        ///                 <code>IncludeSpaces</code> list, the space is excluded.</p>
        public let excludeSpaces: [Swift.String]?
        /// <p>A list of space keys for Confluence spaces. If you include a key,
        ///             the blogs, documents, and attachments in the space are indexed.
        ///             Spaces that aren't in the list aren't indexed. A space in the list
        ///             must exist. Otherwise, Amazon Kendra logs an error when the data source is
        ///             synchronized. If a space is in both the <code>IncludeSpaces</code>
        ///             and the <code>ExcludeSpaces</code> list, the space is
        ///             excluded.</p>
        public let includeSpaces: [Swift.String]?
        /// <p>Defines how space metadata fields should be mapped to index
        ///             fields. Before you can map a field, you must first create an index
        ///             field with a matching type using the console or the
        ///                 <code>UpdateIndex</code> operation.</p>
        ///         <p>If you specify the <code>SpaceFieldMappings</code> parameter, you
        ///             must specify at least one field mapping.</p>
        public let spaceFieldMappings: [KendraClientTypes.ConfluenceSpaceToIndexFieldMapping]?

        public init (
            crawlArchivedSpaces: Swift.Bool = false,
            crawlPersonalSpaces: Swift.Bool = false,
            excludeSpaces: [Swift.String]? = nil,
            includeSpaces: [Swift.String]? = nil,
            spaceFieldMappings: [KendraClientTypes.ConfluenceSpaceToIndexFieldMapping]? = nil
        )
        {
            self.crawlArchivedSpaces = crawlArchivedSpaces
            self.crawlPersonalSpaces = crawlPersonalSpaces
            self.excludeSpaces = excludeSpaces
            self.includeSpaces = includeSpaces
            self.spaceFieldMappings = spaceFieldMappings
        }
    }

}

extension KendraClientTypes {
    public enum ConfluenceSpaceFieldName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case displayUrl
        case itemType
        case spaceKey
        case url
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfluenceSpaceFieldName] {
            return [
                .displayUrl,
                .itemType,
                .spaceKey,
                .url,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .displayUrl: return "DISPLAY_URL"
            case .itemType: return "ITEM_TYPE"
            case .spaceKey: return "SPACE_KEY"
            case .url: return "URL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConfluenceSpaceFieldName(rawValue: rawValue) ?? ConfluenceSpaceFieldName.sdkUnknown(rawValue)
        }
    }
}

extension KendraClientTypes.ConfluenceSpaceToIndexFieldMapping: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceFieldName = "DataSourceFieldName"
        case dateFieldFormat = "DateFieldFormat"
        case indexFieldName = "IndexFieldName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceFieldName = dataSourceFieldName {
            try encodeContainer.encode(dataSourceFieldName.rawValue, forKey: .dataSourceFieldName)
        }
        if let dateFieldFormat = dateFieldFormat {
            try encodeContainer.encode(dateFieldFormat, forKey: .dateFieldFormat)
        }
        if let indexFieldName = indexFieldName {
            try encodeContainer.encode(indexFieldName, forKey: .indexFieldName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceFieldNameDecoded = try containerValues.decodeIfPresent(KendraClientTypes.ConfluenceSpaceFieldName.self, forKey: .dataSourceFieldName)
        dataSourceFieldName = dataSourceFieldNameDecoded
        let dateFieldFormatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateFieldFormat)
        dateFieldFormat = dateFieldFormatDecoded
        let indexFieldNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexFieldName)
        indexFieldName = indexFieldNameDecoded
    }
}

extension KendraClientTypes.ConfluenceSpaceToIndexFieldMapping: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConfluenceSpaceToIndexFieldMapping(dataSourceFieldName: \(Swift.String(describing: dataSourceFieldName)), dateFieldFormat: \(Swift.String(describing: dateFieldFormat)), indexFieldName: \(Swift.String(describing: indexFieldName)))"}
}

extension KendraClientTypes {
    /// <p>Defines the mapping between a field in the Confluence data source
    ///             to a Amazon Kendra index field.</p>
    ///         <p>You must first create the index field using the
    ///                 <code>UpdateIndex</code> operation. </p>
    public struct ConfluenceSpaceToIndexFieldMapping: Swift.Equatable {
        /// <p>The name of the field in the data source. </p>
        public let dataSourceFieldName: KendraClientTypes.ConfluenceSpaceFieldName?
        /// <p>The format for date fields in the data source. If the field
        ///             specified in <code>DataSourceFieldName</code> is a date field you
        ///             must specify the date format. If the field is not a date field, an
        ///             exception is thrown.</p>
        public let dateFieldFormat: Swift.String?
        /// <p>The name of the index field to map to the Confluence data source
        ///             field. The index field type must match the Confluence field
        ///             type.</p>
        public let indexFieldName: Swift.String?

        public init (
            dataSourceFieldName: KendraClientTypes.ConfluenceSpaceFieldName? = nil,
            dateFieldFormat: Swift.String? = nil,
            indexFieldName: Swift.String? = nil
        )
        {
            self.dataSourceFieldName = dataSourceFieldName
            self.dateFieldFormat = dateFieldFormat
            self.indexFieldName = indexFieldName
        }
    }

}

extension KendraClientTypes {
    public enum ConfluenceVersion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cloud
        case server
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfluenceVersion] {
            return [
                .cloud,
                .server,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cloud: return "CLOUD"
            case .server: return "SERVER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConfluenceVersion(rawValue: rawValue) ?? ConfluenceVersion.sdkUnknown(rawValue)
        }
    }
}

extension KendraClientTypes.ConnectionConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseHost = "DatabaseHost"
        case databaseName = "DatabaseName"
        case databasePort = "DatabasePort"
        case secretArn = "SecretArn"
        case tableName = "TableName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseHost = databaseHost {
            try encodeContainer.encode(databaseHost, forKey: .databaseHost)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let databasePort = databasePort {
            try encodeContainer.encode(databasePort, forKey: .databasePort)
        }
        if let secretArn = secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseHostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseHost)
        databaseHost = databaseHostDecoded
        let databasePortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .databasePort)
        databasePort = databasePortDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
    }
}

extension KendraClientTypes.ConnectionConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConnectionConfiguration(databaseHost: \(Swift.String(describing: databaseHost)), databaseName: \(Swift.String(describing: databaseName)), databasePort: \(Swift.String(describing: databasePort)), secretArn: \(Swift.String(describing: secretArn)), tableName: \(Swift.String(describing: tableName)))"}
}

extension KendraClientTypes {
    /// <p>Provides the information necessary to connect to a
    ///             database.</p>
    public struct ConnectionConfiguration: Swift.Equatable {
        /// <p>The name of the host for the database. Can be either a string
        ///             (host.subdomain.domain.tld) or an IPv4 or IPv6 address.</p>
        public let databaseHost: Swift.String?
        /// <p>The name of the database containing the document data.</p>
        public let databaseName: Swift.String?
        /// <p>The port that the database uses for connections.</p>
        public let databasePort: Swift.Int?
        /// <p>The Amazon Resource Name (ARN) of credentials stored in AWS
        ///             Secrets Manager. The credentials should be a user/password pair. For
        ///             more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-database.html">Using a
        ///                 Database Data Source</a>. For more information about AWS
        ///             Secrets Manager, see <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html"> What Is AWS
        ///                 Secrets Manager </a> in the <i>AWS Secrets
        ///                 Manager</i> user guide.</p>
        public let secretArn: Swift.String?
        /// <p>The name of the table that contains the document data.</p>
        public let tableName: Swift.String?

        public init (
            databaseHost: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            databasePort: Swift.Int? = nil,
            secretArn: Swift.String? = nil,
            tableName: Swift.String? = nil
        )
        {
            self.databaseHost = databaseHost
            self.databaseName = databaseName
            self.databasePort = databasePort
            self.secretArn = secretArn
            self.tableName = tableName
        }
    }

}

extension KendraClientTypes {
    public enum ContentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case html
        case msWord
        case pdf
        case plainText
        case ppt
        case sdkUnknown(Swift.String)

        public static var allCases: [ContentType] {
            return [
                .html,
                .msWord,
                .pdf,
                .plainText,
                .ppt,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .html: return "HTML"
            case .msWord: return "MS_WORD"
            case .pdf: return "PDF"
            case .plainText: return "PLAIN_TEXT"
            case .ppt: return "PPT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContentType(rawValue: rawValue) ?? ContentType.sdkUnknown(rawValue)
        }
    }
}

public struct CreateDataSourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDataSourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDataSourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDataSourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDataSourceOutputError>
}

extension CreateDataSourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDataSourceInput(clientToken: \(Swift.String(describing: clientToken)), configuration: \(Swift.String(describing: configuration)), description: \(Swift.String(describing: description)), indexId: \(Swift.String(describing: indexId)), name: \(Swift.String(describing: name)), roleArn: \(Swift.String(describing: roleArn)), schedule: \(Swift.String(describing: schedule)), tags: \(Swift.String(describing: tags)), type: \(Swift.String(describing: type)))"}
}

extension CreateDataSourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case configuration = "Configuration"
        case description = "Description"
        case indexId = "IndexId"
        case name = "Name"
        case roleArn = "RoleArn"
        case schedule = "Schedule"
        case tags = "Tags"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let schedule = schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct CreateDataSourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDataSourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDataSourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDataSourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDataSourceOutputError>
}

public struct CreateDataSourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDataSourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDataSourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDataSourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDataSourceOutputError>
}

public struct CreateDataSourceInput: Swift.Equatable {
    /// <p>A token that you provide to identify the request to create a data
    ///       source. Multiple calls to the <code>CreateDataSource</code> operation with
    ///       the same client token will create only one data source.</p>
    public var clientToken: Swift.String?
    /// <p>The connector configuration information that is required to access the
    ///       repository.</p>
    ///          <p>You can't specify the <code>Configuration</code> parameter when the
    ///         <code>Type</code> parameter is set to <code>CUSTOM</code>. If you do,
    ///       you receive a <code>ValidationException</code> exception.</p>
    ///          <p>The <code>Configuration</code> parameter is required for all other
    ///       data sources.</p>
    public let configuration: KendraClientTypes.DataSourceConfiguration?
    /// <p>A description for the data source.</p>
    public let description: Swift.String?
    /// <p>The identifier of the index that should be associated with this data
    ///       source.</p>
    public let indexId: Swift.String?
    /// <p>A unique name for the data source. A data source name can't be changed
    ///       without deleting and recreating the data source.</p>
    public let name: Swift.String?
    /// <p>The Amazon Resource Name (ARN) of a role with permission to access the
    ///       data source. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/iam-roles.html">IAM Roles for
    ///         Amazon Kendra</a>.</p>
    ///          <p>You can't specify the <code>RoleArn</code> parameter when the
    ///         <code>Type</code> parameter is set to <code>CUSTOM</code>. If you do,
    ///       you receive a <code>ValidationException</code> exception.</p>
    ///          <p>The <code>RoleArn</code> parameter is required for all other data
    ///       sources.</p>
    public let roleArn: Swift.String?
    /// <p>Sets the frequency that Amazon Kendra will check the documents in your
    ///       repository and update the index. If you don't set a schedule Amazon Kendra
    ///       will not periodically update the index. You can call the
    ///         <code>StartDataSourceSyncJob</code> operation to update the
    ///       index.</p>
    ///          <p>You can't specify the <code>Schedule</code> parameter when the
    ///         <code>Type</code> parameter is set to <code>CUSTOM</code>. If you do,
    ///       you receive a <code>ValidationException</code> exception.</p>
    public let schedule: Swift.String?
    /// <p>A list of key-value pairs that identify the data source. You can use
    ///       the tags to identify and organize your resources and to control access to
    ///       resources.</p>
    public let tags: [KendraClientTypes.Tag]?
    /// <p>The type of repository that contains the data source.</p>
    public let type: KendraClientTypes.DataSourceType?

    public init (
        clientToken: Swift.String? = nil,
        configuration: KendraClientTypes.DataSourceConfiguration? = nil,
        description: Swift.String? = nil,
        indexId: Swift.String? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        schedule: Swift.String? = nil,
        tags: [KendraClientTypes.Tag]? = nil,
        type: KendraClientTypes.DataSourceType? = nil
    )
    {
        self.clientToken = clientToken
        self.configuration = configuration
        self.description = description
        self.indexId = indexId
        self.name = name
        self.roleArn = roleArn
        self.schedule = schedule
        self.tags = tags
        self.type = type
    }
}

struct CreateDataSourceInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let indexId: Swift.String?
    public let type: KendraClientTypes.DataSourceType?
    public let configuration: KendraClientTypes.DataSourceConfiguration?
    public let description: Swift.String?
    public let schedule: Swift.String?
    public let roleArn: Swift.String?
    public let tags: [KendraClientTypes.Tag]?
    public let clientToken: Swift.String?
}

extension CreateDataSourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case configuration = "Configuration"
        case description = "Description"
        case indexId = "IndexId"
        case name = "Name"
        case roleArn = "RoleArn"
        case schedule = "Schedule"
        case tags = "Tags"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let indexIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexId)
        indexId = indexIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(KendraClientTypes.DataSourceType.self, forKey: .type)
        type = typeDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(KendraClientTypes.DataSourceConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schedule)
        schedule = scheduleDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([KendraClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[KendraClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [KendraClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateDataSourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDataSourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistException" : self = .resourceAlreadyExistException(try ResourceAlreadyExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDataSourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceAlreadyExistException(ResourceAlreadyExistException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDataSourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDataSourceOutputResponse(id: \(Swift.String(describing: id)))"}
}

extension CreateDataSourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDataSourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
        } else {
            self.id = nil
        }
    }
}

public struct CreateDataSourceOutputResponse: Swift.Equatable {
    /// <p>A unique identifier for the data source.</p>
    public let id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct CreateDataSourceOutputResponseBody: Swift.Equatable {
    public let id: Swift.String?
}

extension CreateDataSourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

public struct CreateFaqInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFaqInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFaqInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFaqOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFaqInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFaqOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFaqOutputError>
}

extension CreateFaqInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFaqInput(clientToken: \(Swift.String(describing: clientToken)), description: \(Swift.String(describing: description)), fileFormat: \(Swift.String(describing: fileFormat)), indexId: \(Swift.String(describing: indexId)), name: \(Swift.String(describing: name)), roleArn: \(Swift.String(describing: roleArn)), s3Path: \(Swift.String(describing: s3Path)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateFaqInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case fileFormat = "FileFormat"
        case indexId = "IndexId"
        case name = "Name"
        case roleArn = "RoleArn"
        case s3Path = "S3Path"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let fileFormat = fileFormat {
            try encodeContainer.encode(fileFormat.rawValue, forKey: .fileFormat)
        }
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let s3Path = s3Path {
            try encodeContainer.encode(s3Path, forKey: .s3Path)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateFaqInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFaqInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFaqInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFaqOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFaqInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFaqOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFaqOutputError>
}

public struct CreateFaqInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFaqInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFaqInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFaqOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFaqInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFaqOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFaqOutputError>
}

public struct CreateFaqInput: Swift.Equatable {
    /// <p>A token that you provide to identify the request to create a FAQ. Multiple calls to
    ///             the <code>CreateFaqRequest</code> operation with the same client token will create only
    ///             one FAQ. </p>
    public var clientToken: Swift.String?
    /// <p>A description of the FAQ.</p>
    public let description: Swift.String?
    /// <p>The format of the input file. You can choose between a basic CSV format, a CSV format
    ///             that includes customs attributes in a header, and a JSON format that includes custom
    ///             attributes.</p>
    ///         <p>The format must match the format of the file stored in the S3 bucket identified in the
    ///                 <code>S3Path</code> parameter.</p>
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/in-creating-faq.html">Adding questions and
    ///             answers</a>.</p>
    public let fileFormat: KendraClientTypes.FaqFileFormat?
    /// <p>The identifier of the index that contains the FAQ.</p>
    public let indexId: Swift.String?
    /// <p>The name that should be associated with the FAQ.</p>
    public let name: Swift.String?
    /// <p>The Amazon Resource Name (ARN) of a role with permission to access the S3 bucket that
    ///             contains the FAQs. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/iam-roles.html">IAM Roles for Amazon Kendra</a>.</p>
    public let roleArn: Swift.String?
    /// <p>The S3 location of the FAQ input data.</p>
    public let s3Path: KendraClientTypes.S3Path?
    /// <p>A list of key-value pairs that identify the FAQ. You can use the tags to identify and
    ///             organize your resources and to control access to resources.</p>
    public let tags: [KendraClientTypes.Tag]?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        fileFormat: KendraClientTypes.FaqFileFormat? = nil,
        indexId: Swift.String? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        s3Path: KendraClientTypes.S3Path? = nil,
        tags: [KendraClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.fileFormat = fileFormat
        self.indexId = indexId
        self.name = name
        self.roleArn = roleArn
        self.s3Path = s3Path
        self.tags = tags
    }
}

struct CreateFaqInputBody: Swift.Equatable {
    public let indexId: Swift.String?
    public let name: Swift.String?
    public let description: Swift.String?
    public let s3Path: KendraClientTypes.S3Path?
    public let roleArn: Swift.String?
    public let tags: [KendraClientTypes.Tag]?
    public let fileFormat: KendraClientTypes.FaqFileFormat?
    public let clientToken: Swift.String?
}

extension CreateFaqInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case fileFormat = "FileFormat"
        case indexId = "IndexId"
        case name = "Name"
        case roleArn = "RoleArn"
        case s3Path = "S3Path"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexId)
        indexId = indexIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let s3PathDecoded = try containerValues.decodeIfPresent(KendraClientTypes.S3Path.self, forKey: .s3Path)
        s3Path = s3PathDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([KendraClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[KendraClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [KendraClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let fileFormatDecoded = try containerValues.decodeIfPresent(KendraClientTypes.FaqFileFormat.self, forKey: .fileFormat)
        fileFormat = fileFormatDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateFaqOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFaqOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFaqOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFaqOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFaqOutputResponse(id: \(Swift.String(describing: id)))"}
}

extension CreateFaqOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateFaqOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
        } else {
            self.id = nil
        }
    }
}

public struct CreateFaqOutputResponse: Swift.Equatable {
    /// <p>The unique identifier of the FAQ.</p>
    public let id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct CreateFaqOutputResponseBody: Swift.Equatable {
    public let id: Swift.String?
}

extension CreateFaqOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

public struct CreateIndexInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateIndexInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateIndexInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateIndexInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateIndexOutputError>
}

extension CreateIndexInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateIndexInput(clientToken: \(Swift.String(describing: clientToken)), description: \(Swift.String(describing: description)), edition: \(Swift.String(describing: edition)), name: \(Swift.String(describing: name)), roleArn: \(Swift.String(describing: roleArn)), serverSideEncryptionConfiguration: \(Swift.String(describing: serverSideEncryptionConfiguration)), tags: \(Swift.String(describing: tags)), userContextPolicy: \(Swift.String(describing: userContextPolicy)), userTokenConfigurations: \(Swift.String(describing: userTokenConfigurations)))"}
}

extension CreateIndexInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case edition = "Edition"
        case name = "Name"
        case roleArn = "RoleArn"
        case serverSideEncryptionConfiguration = "ServerSideEncryptionConfiguration"
        case tags = "Tags"
        case userContextPolicy = "UserContextPolicy"
        case userTokenConfigurations = "UserTokenConfigurations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let edition = edition {
            try encodeContainer.encode(edition.rawValue, forKey: .edition)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let serverSideEncryptionConfiguration = serverSideEncryptionConfiguration {
            try encodeContainer.encode(serverSideEncryptionConfiguration, forKey: .serverSideEncryptionConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let userContextPolicy = userContextPolicy {
            try encodeContainer.encode(userContextPolicy.rawValue, forKey: .userContextPolicy)
        }
        if let userTokenConfigurations = userTokenConfigurations {
            var userTokenConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userTokenConfigurations)
            for usertokenconfigurationlist0 in userTokenConfigurations {
                try userTokenConfigurationsContainer.encode(usertokenconfigurationlist0)
            }
        }
    }
}

public struct CreateIndexInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateIndexInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateIndexInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateIndexInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateIndexOutputError>
}

public struct CreateIndexInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateIndexInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateIndexInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateIndexInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateIndexOutputError>
}

public struct CreateIndexInput: Swift.Equatable {
    /// <p>A token that you provide to identify the request to create an index.
    ///       Multiple calls to the <code>CreateIndex</code> operation with the same
    ///       client token will create only one index.</p>
    public var clientToken: Swift.String?
    /// <p>A description for the index.</p>
    public let description: Swift.String?
    /// <p>The Amazon Kendra edition to use for the index. Choose
    ///         <code>DEVELOPER_EDITION</code> for indexes intended for development,
    ///       testing, or proof of concept. Use <code>ENTERPRISE_EDITION</code> for your
    ///       production databases. Once you set the edition for an index, it can't be
    ///       changed. </p>
    ///          <p>The <code>Edition</code> parameter is optional. If you don't supply a
    ///       value, the default is <code>ENTERPRISE_EDITION</code>.</p>
    public let edition: KendraClientTypes.IndexEdition?
    /// <p>The name for the new index.</p>
    public let name: Swift.String?
    /// <p>An AWS Identity and Access Management (IAM) role that gives
    ///       Amazon Kendra permissions to access your Amazon CloudWatch logs and
    ///       metrics. This is also the role used when you use the
    ///         <code>BatchPutDocument</code> operation to index documents from an
    ///       Amazon S3 bucket.</p>
    public let roleArn: Swift.String?
    /// <p>The identifier of the AWS KMS customer managed key (CMK) to use to
    ///       encrypt data indexed by Amazon Kendra. Amazon Kendra doesn't support
    ///       asymmetric CMKs.</p>
    public let serverSideEncryptionConfiguration: KendraClientTypes.ServerSideEncryptionConfiguration?
    /// <p>A list of key-value pairs that identify the index. You can use the
    ///       tags to identify and organize your resources and to control access to
    ///       resources.</p>
    public let tags: [KendraClientTypes.Tag]?
    /// <p>The user context policy.</p>
    ///          <dl>
    ///             <dt>ATTRIBUTE_FILTER</dt>
    ///             <dd>
    ///                <p>All indexed content is searchable and displayable
    ///                   for all users. If there is an access control list, it
    ///                   is ignored. You can filter on user and group attributes.
    ///                </p>
    ///             </dd>
    ///             <dt>USER_TOKEN</dt>
    ///             <dd>
    ///                <p>Enables SSO and token-based user access control.
    ///                All documents with no access control and all documents
    ///                accessible to the user will be searchable and
    ///                displayable.
    ///                </p>
    ///             </dd>
    ///          </dl>
    public let userContextPolicy: KendraClientTypes.UserContextPolicy?
    /// <p>The user token configuration.</p>
    public let userTokenConfigurations: [KendraClientTypes.UserTokenConfiguration]?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        edition: KendraClientTypes.IndexEdition? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        serverSideEncryptionConfiguration: KendraClientTypes.ServerSideEncryptionConfiguration? = nil,
        tags: [KendraClientTypes.Tag]? = nil,
        userContextPolicy: KendraClientTypes.UserContextPolicy? = nil,
        userTokenConfigurations: [KendraClientTypes.UserTokenConfiguration]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.edition = edition
        self.name = name
        self.roleArn = roleArn
        self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
        self.tags = tags
        self.userContextPolicy = userContextPolicy
        self.userTokenConfigurations = userTokenConfigurations
    }
}

struct CreateIndexInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let edition: KendraClientTypes.IndexEdition?
    public let roleArn: Swift.String?
    public let serverSideEncryptionConfiguration: KendraClientTypes.ServerSideEncryptionConfiguration?
    public let description: Swift.String?
    public let clientToken: Swift.String?
    public let tags: [KendraClientTypes.Tag]?
    public let userTokenConfigurations: [KendraClientTypes.UserTokenConfiguration]?
    public let userContextPolicy: KendraClientTypes.UserContextPolicy?
}

extension CreateIndexInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case edition = "Edition"
        case name = "Name"
        case roleArn = "RoleArn"
        case serverSideEncryptionConfiguration = "ServerSideEncryptionConfiguration"
        case tags = "Tags"
        case userContextPolicy = "UserContextPolicy"
        case userTokenConfigurations = "UserTokenConfigurations"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let editionDecoded = try containerValues.decodeIfPresent(KendraClientTypes.IndexEdition.self, forKey: .edition)
        edition = editionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let serverSideEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(KendraClientTypes.ServerSideEncryptionConfiguration.self, forKey: .serverSideEncryptionConfiguration)
        serverSideEncryptionConfiguration = serverSideEncryptionConfigurationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([KendraClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[KendraClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [KendraClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let userTokenConfigurationsContainer = try containerValues.decodeIfPresent([KendraClientTypes.UserTokenConfiguration?].self, forKey: .userTokenConfigurations)
        var userTokenConfigurationsDecoded0:[KendraClientTypes.UserTokenConfiguration]? = nil
        if let userTokenConfigurationsContainer = userTokenConfigurationsContainer {
            userTokenConfigurationsDecoded0 = [KendraClientTypes.UserTokenConfiguration]()
            for structure0 in userTokenConfigurationsContainer {
                if let structure0 = structure0 {
                    userTokenConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        userTokenConfigurations = userTokenConfigurationsDecoded0
        let userContextPolicyDecoded = try containerValues.decodeIfPresent(KendraClientTypes.UserContextPolicy.self, forKey: .userContextPolicy)
        userContextPolicy = userContextPolicyDecoded
    }
}

extension CreateIndexOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateIndexOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistException" : self = .resourceAlreadyExistException(try ResourceAlreadyExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateIndexOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceAlreadyExistException(ResourceAlreadyExistException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateIndexOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateIndexOutputResponse(id: \(Swift.String(describing: id)))"}
}

extension CreateIndexOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateIndexOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
        } else {
            self.id = nil
        }
    }
}

public struct CreateIndexOutputResponse: Swift.Equatable {
    /// <p>The unique identifier of the index. Use this identifier when you query
    ///       an index, set up a data source, or index a document.</p>
    public let id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct CreateIndexOutputResponseBody: Swift.Equatable {
    public let id: Swift.String?
}

extension CreateIndexOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

public struct CreateQuerySuggestionsBlockListInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateQuerySuggestionsBlockListInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateQuerySuggestionsBlockListInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateQuerySuggestionsBlockListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateQuerySuggestionsBlockListInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateQuerySuggestionsBlockListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateQuerySuggestionsBlockListOutputError>
}

extension CreateQuerySuggestionsBlockListInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateQuerySuggestionsBlockListInput(clientToken: \(Swift.String(describing: clientToken)), description: \(Swift.String(describing: description)), indexId: \(Swift.String(describing: indexId)), name: \(Swift.String(describing: name)), roleArn: \(Swift.String(describing: roleArn)), sourceS3Path: \(Swift.String(describing: sourceS3Path)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateQuerySuggestionsBlockListInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case indexId = "IndexId"
        case name = "Name"
        case roleArn = "RoleArn"
        case sourceS3Path = "SourceS3Path"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let sourceS3Path = sourceS3Path {
            try encodeContainer.encode(sourceS3Path, forKey: .sourceS3Path)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateQuerySuggestionsBlockListInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateQuerySuggestionsBlockListInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateQuerySuggestionsBlockListInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateQuerySuggestionsBlockListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateQuerySuggestionsBlockListInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateQuerySuggestionsBlockListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateQuerySuggestionsBlockListOutputError>
}

public struct CreateQuerySuggestionsBlockListInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateQuerySuggestionsBlockListInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateQuerySuggestionsBlockListInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateQuerySuggestionsBlockListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateQuerySuggestionsBlockListInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateQuerySuggestionsBlockListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateQuerySuggestionsBlockListOutputError>
}

public struct CreateQuerySuggestionsBlockListInput: Swift.Equatable {
    /// <p>A token that you provide to identify the request to create a
    ///             query suggestions block list.</p>
    public var clientToken: Swift.String?
    /// <p>A user-friendly description for the block list.</p>
    ///         <p>For example, the description "List of all offensive words that can
    ///             appear in user queries and need to be blocked from suggestions."</p>
    public let description: Swift.String?
    /// <p>The identifier of the index you want to create a query suggestions block list for.</p>
    public let indexId: Swift.String?
    /// <p>A user friendly name for the block list.</p>
    ///         <p>For example, the block list named 'offensive-words' includes all
    ///             offensive words that could appear in user queries and need to be
    ///             blocked from suggestions.</p>
    public let name: Swift.String?
    /// <p>The IAM (Identity and Access Management) role used by Amazon Kendra to
    ///             access the block list text file in your S3 bucket.</p>
    ///         <p>You need permissions to the role ARN (Amazon Resource Name).
    ///             The role needs S3 read permissions to your file in S3 and needs
    ///             to give STS (Security Token Service) assume role permissions
    ///             to Amazon Kendra.</p>
    public let roleArn: Swift.String?
    /// <p>The S3 path to your block list text file in your S3 bucket.</p>
    ///         <p>Each block word or phrase should be on a separate line in a text file.</p>
    ///             <p>For information on the current quota limits for block lists, see
    ///                 <a href="https://docs.aws.amazon.com/kendra/latest/dg/quotas.html">Quotas
    ///                     for Amazon Kendra</a>.</p>
    public let sourceS3Path: KendraClientTypes.S3Path?
    /// <p>A tag that you can assign to a block list that categorizes
    ///             the block list.</p>
    public let tags: [KendraClientTypes.Tag]?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        indexId: Swift.String? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        sourceS3Path: KendraClientTypes.S3Path? = nil,
        tags: [KendraClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.indexId = indexId
        self.name = name
        self.roleArn = roleArn
        self.sourceS3Path = sourceS3Path
        self.tags = tags
    }
}

struct CreateQuerySuggestionsBlockListInputBody: Swift.Equatable {
    public let indexId: Swift.String?
    public let name: Swift.String?
    public let description: Swift.String?
    public let sourceS3Path: KendraClientTypes.S3Path?
    public let clientToken: Swift.String?
    public let roleArn: Swift.String?
    public let tags: [KendraClientTypes.Tag]?
}

extension CreateQuerySuggestionsBlockListInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case indexId = "IndexId"
        case name = "Name"
        case roleArn = "RoleArn"
        case sourceS3Path = "SourceS3Path"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexId)
        indexId = indexIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sourceS3PathDecoded = try containerValues.decodeIfPresent(KendraClientTypes.S3Path.self, forKey: .sourceS3Path)
        sourceS3Path = sourceS3PathDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([KendraClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[KendraClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [KendraClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateQuerySuggestionsBlockListOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateQuerySuggestionsBlockListOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateQuerySuggestionsBlockListOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateQuerySuggestionsBlockListOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateQuerySuggestionsBlockListOutputResponse(id: \(Swift.String(describing: id)))"}
}

extension CreateQuerySuggestionsBlockListOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateQuerySuggestionsBlockListOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
        } else {
            self.id = nil
        }
    }
}

public struct CreateQuerySuggestionsBlockListOutputResponse: Swift.Equatable {
    /// <p>The unique identifier of the created block list.</p>
    public let id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct CreateQuerySuggestionsBlockListOutputResponseBody: Swift.Equatable {
    public let id: Swift.String?
}

extension CreateQuerySuggestionsBlockListOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

public struct CreateThesaurusInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateThesaurusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateThesaurusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateThesaurusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateThesaurusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateThesaurusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateThesaurusOutputError>
}

extension CreateThesaurusInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateThesaurusInput(clientToken: \(Swift.String(describing: clientToken)), description: \(Swift.String(describing: description)), indexId: \(Swift.String(describing: indexId)), name: \(Swift.String(describing: name)), roleArn: \(Swift.String(describing: roleArn)), sourceS3Path: \(Swift.String(describing: sourceS3Path)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateThesaurusInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case indexId = "IndexId"
        case name = "Name"
        case roleArn = "RoleArn"
        case sourceS3Path = "SourceS3Path"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let sourceS3Path = sourceS3Path {
            try encodeContainer.encode(sourceS3Path, forKey: .sourceS3Path)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateThesaurusInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateThesaurusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateThesaurusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateThesaurusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateThesaurusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateThesaurusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateThesaurusOutputError>
}

public struct CreateThesaurusInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateThesaurusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateThesaurusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateThesaurusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateThesaurusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateThesaurusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateThesaurusOutputError>
}

public struct CreateThesaurusInput: Swift.Equatable {
    /// <p>A token that you provide to identify the request to create a
    ///          thesaurus. Multiple calls to the <code>CreateThesaurus</code> operation
    ///          with the same client token will create only one index.
    ///       </p>
    public var clientToken: Swift.String?
    /// <p>The description for the new thesaurus.</p>
    public let description: Swift.String?
    /// <p>The unique identifier of the index for the new thesaurus.
    ///       </p>
    public let indexId: Swift.String?
    /// <p>The name for the new thesaurus.</p>
    public let name: Swift.String?
    /// <p>An AWS Identity and Access Management (IAM) role that gives Amazon Kendra permissions
    ///          to access thesaurus file specified in <code>SourceS3Path</code>.
    ///       </p>
    public let roleArn: Swift.String?
    /// <p>The thesaurus file Amazon S3 source path.
    ///       </p>
    public let sourceS3Path: KendraClientTypes.S3Path?
    /// <p>A list of key-value pairs that identify the thesaurus. You can use
    ///          the tags to identify and organize your resources and to control
    ///          access to resources.
    ///       </p>
    public let tags: [KendraClientTypes.Tag]?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        indexId: Swift.String? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        sourceS3Path: KendraClientTypes.S3Path? = nil,
        tags: [KendraClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.indexId = indexId
        self.name = name
        self.roleArn = roleArn
        self.sourceS3Path = sourceS3Path
        self.tags = tags
    }
}

struct CreateThesaurusInputBody: Swift.Equatable {
    public let indexId: Swift.String?
    public let name: Swift.String?
    public let description: Swift.String?
    public let roleArn: Swift.String?
    public let tags: [KendraClientTypes.Tag]?
    public let sourceS3Path: KendraClientTypes.S3Path?
    public let clientToken: Swift.String?
}

extension CreateThesaurusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case indexId = "IndexId"
        case name = "Name"
        case roleArn = "RoleArn"
        case sourceS3Path = "SourceS3Path"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexId)
        indexId = indexIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([KendraClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[KendraClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [KendraClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let sourceS3PathDecoded = try containerValues.decodeIfPresent(KendraClientTypes.S3Path.self, forKey: .sourceS3Path)
        sourceS3Path = sourceS3PathDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateThesaurusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateThesaurusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateThesaurusOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateThesaurusOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateThesaurusOutputResponse(id: \(Swift.String(describing: id)))"}
}

extension CreateThesaurusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateThesaurusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
        } else {
            self.id = nil
        }
    }
}

public struct CreateThesaurusOutputResponse: Swift.Equatable {
    /// <p>The unique identifier of the thesaurus.
    ///       </p>
    public let id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct CreateThesaurusOutputResponseBody: Swift.Equatable {
    public let id: Swift.String?
}

extension CreateThesaurusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension KendraClientTypes.DataSourceConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case confluenceConfiguration = "ConfluenceConfiguration"
        case databaseConfiguration = "DatabaseConfiguration"
        case googleDriveConfiguration = "GoogleDriveConfiguration"
        case oneDriveConfiguration = "OneDriveConfiguration"
        case s3Configuration = "S3Configuration"
        case salesforceConfiguration = "SalesforceConfiguration"
        case serviceNowConfiguration = "ServiceNowConfiguration"
        case sharePointConfiguration = "SharePointConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let confluenceConfiguration = confluenceConfiguration {
            try encodeContainer.encode(confluenceConfiguration, forKey: .confluenceConfiguration)
        }
        if let databaseConfiguration = databaseConfiguration {
            try encodeContainer.encode(databaseConfiguration, forKey: .databaseConfiguration)
        }
        if let googleDriveConfiguration = googleDriveConfiguration {
            try encodeContainer.encode(googleDriveConfiguration, forKey: .googleDriveConfiguration)
        }
        if let oneDriveConfiguration = oneDriveConfiguration {
            try encodeContainer.encode(oneDriveConfiguration, forKey: .oneDriveConfiguration)
        }
        if let s3Configuration = s3Configuration {
            try encodeContainer.encode(s3Configuration, forKey: .s3Configuration)
        }
        if let salesforceConfiguration = salesforceConfiguration {
            try encodeContainer.encode(salesforceConfiguration, forKey: .salesforceConfiguration)
        }
        if let serviceNowConfiguration = serviceNowConfiguration {
            try encodeContainer.encode(serviceNowConfiguration, forKey: .serviceNowConfiguration)
        }
        if let sharePointConfiguration = sharePointConfiguration {
            try encodeContainer.encode(sharePointConfiguration, forKey: .sharePointConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3ConfigurationDecoded = try containerValues.decodeIfPresent(KendraClientTypes.S3DataSourceConfiguration.self, forKey: .s3Configuration)
        s3Configuration = s3ConfigurationDecoded
        let sharePointConfigurationDecoded = try containerValues.decodeIfPresent(KendraClientTypes.SharePointConfiguration.self, forKey: .sharePointConfiguration)
        sharePointConfiguration = sharePointConfigurationDecoded
        let databaseConfigurationDecoded = try containerValues.decodeIfPresent(KendraClientTypes.DatabaseConfiguration.self, forKey: .databaseConfiguration)
        databaseConfiguration = databaseConfigurationDecoded
        let salesforceConfigurationDecoded = try containerValues.decodeIfPresent(KendraClientTypes.SalesforceConfiguration.self, forKey: .salesforceConfiguration)
        salesforceConfiguration = salesforceConfigurationDecoded
        let oneDriveConfigurationDecoded = try containerValues.decodeIfPresent(KendraClientTypes.OneDriveConfiguration.self, forKey: .oneDriveConfiguration)
        oneDriveConfiguration = oneDriveConfigurationDecoded
        let serviceNowConfigurationDecoded = try containerValues.decodeIfPresent(KendraClientTypes.ServiceNowConfiguration.self, forKey: .serviceNowConfiguration)
        serviceNowConfiguration = serviceNowConfigurationDecoded
        let confluenceConfigurationDecoded = try containerValues.decodeIfPresent(KendraClientTypes.ConfluenceConfiguration.self, forKey: .confluenceConfiguration)
        confluenceConfiguration = confluenceConfigurationDecoded
        let googleDriveConfigurationDecoded = try containerValues.decodeIfPresent(KendraClientTypes.GoogleDriveConfiguration.self, forKey: .googleDriveConfiguration)
        googleDriveConfiguration = googleDriveConfigurationDecoded
    }
}

extension KendraClientTypes.DataSourceConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataSourceConfiguration(confluenceConfiguration: \(Swift.String(describing: confluenceConfiguration)), databaseConfiguration: \(Swift.String(describing: databaseConfiguration)), googleDriveConfiguration: \(Swift.String(describing: googleDriveConfiguration)), oneDriveConfiguration: \(Swift.String(describing: oneDriveConfiguration)), s3Configuration: \(Swift.String(describing: s3Configuration)), salesforceConfiguration: \(Swift.String(describing: salesforceConfiguration)), serviceNowConfiguration: \(Swift.String(describing: serviceNowConfiguration)), sharePointConfiguration: \(Swift.String(describing: sharePointConfiguration)))"}
}

extension KendraClientTypes {
    /// <p>Configuration information for a Amazon Kendra data source.</p>
    public struct DataSourceConfiguration: Swift.Equatable {
        /// <p>Provides configuration information for connecting to a Confluence
        ///             data source.</p>
        public let confluenceConfiguration: KendraClientTypes.ConfluenceConfiguration?
        /// <p>Provides information necessary to create a data source connector
        ///             for a database.</p>
        public let databaseConfiguration: KendraClientTypes.DatabaseConfiguration?
        /// <p>Provides configuration for data sources that connect to Google
        ///             Drive. </p>
        public let googleDriveConfiguration: KendraClientTypes.GoogleDriveConfiguration?
        /// <p>Provides configuration for data sources that connect to Microsoft
        ///             OneDrive.</p>
        public let oneDriveConfiguration: KendraClientTypes.OneDriveConfiguration?
        /// <p>Provides information to create a data source connector for a
        ///             document repository in an Amazon S3 bucket.</p>
        public let s3Configuration: KendraClientTypes.S3DataSourceConfiguration?
        /// <p>Provides configuration information for data sources that connect
        ///             to a Salesforce site.</p>
        public let salesforceConfiguration: KendraClientTypes.SalesforceConfiguration?
        /// <p>Provides configuration for data sources that connect to ServiceNow
        ///             instances.</p>
        public let serviceNowConfiguration: KendraClientTypes.ServiceNowConfiguration?
        /// <p>Provides information necessary to create a data source connector
        ///             for a Microsoft SharePoint site.</p>
        public let sharePointConfiguration: KendraClientTypes.SharePointConfiguration?

        public init (
            confluenceConfiguration: KendraClientTypes.ConfluenceConfiguration? = nil,
            databaseConfiguration: KendraClientTypes.DatabaseConfiguration? = nil,
            googleDriveConfiguration: KendraClientTypes.GoogleDriveConfiguration? = nil,
            oneDriveConfiguration: KendraClientTypes.OneDriveConfiguration? = nil,
            s3Configuration: KendraClientTypes.S3DataSourceConfiguration? = nil,
            salesforceConfiguration: KendraClientTypes.SalesforceConfiguration? = nil,
            serviceNowConfiguration: KendraClientTypes.ServiceNowConfiguration? = nil,
            sharePointConfiguration: KendraClientTypes.SharePointConfiguration? = nil
        )
        {
            self.confluenceConfiguration = confluenceConfiguration
            self.databaseConfiguration = databaseConfiguration
            self.googleDriveConfiguration = googleDriveConfiguration
            self.oneDriveConfiguration = oneDriveConfiguration
            self.s3Configuration = s3Configuration
            self.salesforceConfiguration = salesforceConfiguration
            self.serviceNowConfiguration = serviceNowConfiguration
            self.sharePointConfiguration = sharePointConfiguration
        }
    }

}

extension KendraClientTypes {
    public enum DataSourceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleting
        case failed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSourceStatus] {
            return [
                .active,
                .creating,
                .deleting,
                .failed,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataSourceStatus(rawValue: rawValue) ?? DataSourceStatus.sdkUnknown(rawValue)
        }
    }
}

extension KendraClientTypes.DataSourceSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case id = "Id"
        case name = "Name"
        case status = "Status"
        case type = "Type"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(KendraClientTypes.DataSourceType.self, forKey: .type)
        type = typeDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(KendraClientTypes.DataSourceStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension KendraClientTypes.DataSourceSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataSourceSummary(createdAt: \(Swift.String(describing: createdAt)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)), type: \(Swift.String(describing: type)), updatedAt: \(Swift.String(describing: updatedAt)))"}
}

extension KendraClientTypes {
    /// <p>Summary information for a Amazon Kendra data source. Returned in a call
    ///             to the <code>DescribeDataSource</code> operation.</p>
    public struct DataSourceSummary: Swift.Equatable {
        /// <p>The UNIX datetime that the data source was created.</p>
        public let createdAt: ClientRuntime.Date?
        /// <p>The unique identifier for the data source.</p>
        public let id: Swift.String?
        /// <p>The name of the data source.</p>
        public let name: Swift.String?
        /// <p>The status of the data source. When the status is
        ///                 <code>ACTIVE</code> the data source is ready to use.</p>
        public let status: KendraClientTypes.DataSourceStatus?
        /// <p>The type of the data source.</p>
        public let type: KendraClientTypes.DataSourceType?
        /// <p>The UNIX datetime that the data source was lasted updated. </p>
        public let updatedAt: ClientRuntime.Date?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            status: KendraClientTypes.DataSourceStatus? = nil,
            type: KendraClientTypes.DataSourceType? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.id = id
            self.name = name
            self.status = status
            self.type = type
            self.updatedAt = updatedAt
        }
    }

}

extension KendraClientTypes.DataSourceSyncJob: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceErrorCode = "DataSourceErrorCode"
        case endTime = "EndTime"
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case executionId = "ExecutionId"
        case metrics = "Metrics"
        case startTime = "StartTime"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceErrorCode = dataSourceErrorCode {
            try encodeContainer.encode(dataSourceErrorCode, forKey: .dataSourceErrorCode)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let executionId = executionId {
            try encodeContainer.encode(executionId, forKey: .executionId)
        }
        if let metrics = metrics {
            try encodeContainer.encode(metrics, forKey: .metrics)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionId)
        executionId = executionIdDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(KendraClientTypes.DataSourceSyncJobStatus.self, forKey: .status)
        status = statusDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(KendraClientTypes.ErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let dataSourceErrorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceErrorCode)
        dataSourceErrorCode = dataSourceErrorCodeDecoded
        let metricsDecoded = try containerValues.decodeIfPresent(KendraClientTypes.DataSourceSyncJobMetrics.self, forKey: .metrics)
        metrics = metricsDecoded
    }
}

extension KendraClientTypes.DataSourceSyncJob: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataSourceSyncJob(dataSourceErrorCode: \(Swift.String(describing: dataSourceErrorCode)), endTime: \(Swift.String(describing: endTime)), errorCode: \(Swift.String(describing: errorCode)), errorMessage: \(Swift.String(describing: errorMessage)), executionId: \(Swift.String(describing: executionId)), metrics: \(Swift.String(describing: metrics)), startTime: \(Swift.String(describing: startTime)), status: \(Swift.String(describing: status)))"}
}

extension KendraClientTypes {
    /// <p>Provides information about a synchronization job.</p>
    public struct DataSourceSyncJob: Swift.Equatable {
        /// <p>If the reason that the synchronization failed is due to an error
        ///             with the underlying data source, this field contains a code that
        ///             identifies the error.</p>
        public let dataSourceErrorCode: Swift.String?
        /// <p>The UNIX datetime that the synchronization job was
        ///             completed.</p>
        public let endTime: ClientRuntime.Date?
        /// <p>If the <code>Status</code> field is set to <code>FAILED</code>,
        ///             the <code>ErrorCode</code> field contains a the reason that the
        ///             synchronization failed.</p>
        public let errorCode: KendraClientTypes.ErrorCode?
        /// <p>If the <code>Status</code> field is set to <code>ERROR</code>, the
        ///                 <code>ErrorMessage</code> field contains a description of the
        ///             error that caused the synchronization to fail.</p>
        public let errorMessage: Swift.String?
        /// <p>A unique identifier for the synchronization job.</p>
        public let executionId: Swift.String?
        /// <p>Maps a batch delete document request to a specific data source
        ///             sync job. This is optional and should only be supplied when
        ///             documents are deleted by a data source connector.</p>
        public let metrics: KendraClientTypes.DataSourceSyncJobMetrics?
        /// <p>The UNIX datetime that the synchronization job was started.</p>
        public let startTime: ClientRuntime.Date?
        /// <p>The execution status of the synchronization job. When the
        ///                 <code>Status</code> field is set to <code>SUCCEEDED</code>, the
        ///             synchronization job is done. If the status code is set to
        ///                 <code>FAILED</code>, the <code>ErrorCode</code> and
        ///                 <code>ErrorMessage</code> fields give you the reason for the
        ///             failure.</p>
        public let status: KendraClientTypes.DataSourceSyncJobStatus?

        public init (
            dataSourceErrorCode: Swift.String? = nil,
            endTime: ClientRuntime.Date? = nil,
            errorCode: KendraClientTypes.ErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            executionId: Swift.String? = nil,
            metrics: KendraClientTypes.DataSourceSyncJobMetrics? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: KendraClientTypes.DataSourceSyncJobStatus? = nil
        )
        {
            self.dataSourceErrorCode = dataSourceErrorCode
            self.endTime = endTime
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.executionId = executionId
            self.metrics = metrics
            self.startTime = startTime
            self.status = status
        }
    }

}

extension KendraClientTypes.DataSourceSyncJobMetricTarget: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceId = "DataSourceId"
        case dataSourceSyncJobId = "DataSourceSyncJobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceId = dataSourceId {
            try encodeContainer.encode(dataSourceId, forKey: .dataSourceId)
        }
        if let dataSourceSyncJobId = dataSourceSyncJobId {
            try encodeContainer.encode(dataSourceSyncJobId, forKey: .dataSourceSyncJobId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceId)
        dataSourceId = dataSourceIdDecoded
        let dataSourceSyncJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceSyncJobId)
        dataSourceSyncJobId = dataSourceSyncJobIdDecoded
    }
}

extension KendraClientTypes.DataSourceSyncJobMetricTarget: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataSourceSyncJobMetricTarget(dataSourceId: \(Swift.String(describing: dataSourceId)), dataSourceSyncJobId: \(Swift.String(describing: dataSourceSyncJobId)))"}
}

extension KendraClientTypes {
    /// <p>Maps a particular data source sync job to a particular data
    ///             source.</p>
    public struct DataSourceSyncJobMetricTarget: Swift.Equatable {
        /// <p>The ID of the data source that is running the sync job.</p>
        public let dataSourceId: Swift.String?
        /// <p>The ID of the sync job that is running on the data source.</p>
        ///         <p>If the ID of a sync job is not provided and there is a sync job
        ///             running, then the ID of this sync job is used and metrics are
        ///             generated for this sync job.</p>
        ///         <p>If the ID of a sync job is not provided and there is no sync job
        ///             running, then no metrics are generated and documents are
        ///             indexed/deleted at the index level without sync job metrics included.</p>
        public let dataSourceSyncJobId: Swift.String?

        public init (
            dataSourceId: Swift.String? = nil,
            dataSourceSyncJobId: Swift.String? = nil
        )
        {
            self.dataSourceId = dataSourceId
            self.dataSourceSyncJobId = dataSourceSyncJobId
        }
    }

}

extension KendraClientTypes.DataSourceSyncJobMetrics: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentsAdded = "DocumentsAdded"
        case documentsDeleted = "DocumentsDeleted"
        case documentsFailed = "DocumentsFailed"
        case documentsModified = "DocumentsModified"
        case documentsScanned = "DocumentsScanned"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentsAdded = documentsAdded {
            try encodeContainer.encode(documentsAdded, forKey: .documentsAdded)
        }
        if let documentsDeleted = documentsDeleted {
            try encodeContainer.encode(documentsDeleted, forKey: .documentsDeleted)
        }
        if let documentsFailed = documentsFailed {
            try encodeContainer.encode(documentsFailed, forKey: .documentsFailed)
        }
        if let documentsModified = documentsModified {
            try encodeContainer.encode(documentsModified, forKey: .documentsModified)
        }
        if let documentsScanned = documentsScanned {
            try encodeContainer.encode(documentsScanned, forKey: .documentsScanned)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentsAddedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentsAdded)
        documentsAdded = documentsAddedDecoded
        let documentsModifiedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentsModified)
        documentsModified = documentsModifiedDecoded
        let documentsDeletedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentsDeleted)
        documentsDeleted = documentsDeletedDecoded
        let documentsFailedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentsFailed)
        documentsFailed = documentsFailedDecoded
        let documentsScannedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentsScanned)
        documentsScanned = documentsScannedDecoded
    }
}

extension KendraClientTypes.DataSourceSyncJobMetrics: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataSourceSyncJobMetrics(documentsAdded: \(Swift.String(describing: documentsAdded)), documentsDeleted: \(Swift.String(describing: documentsDeleted)), documentsFailed: \(Swift.String(describing: documentsFailed)), documentsModified: \(Swift.String(describing: documentsModified)), documentsScanned: \(Swift.String(describing: documentsScanned)))"}
}

extension KendraClientTypes {
    /// <p>Maps a batch delete document request to a specific data source
    ///             sync job. This is optional and should only be supplied when
    ///             documents are deleted by a data source connector.</p>
    public struct DataSourceSyncJobMetrics: Swift.Equatable {
        /// <p>The number of documents added from the data source up to now in
        ///             the data source sync.</p>
        public let documentsAdded: Swift.String?
        /// <p>The number of documents deleted from the data source up to now in
        ///             the data source sync run.</p>
        public let documentsDeleted: Swift.String?
        /// <p>The number of documents that failed to sync from the data source
        ///             up to now in the data source sync run.</p>
        public let documentsFailed: Swift.String?
        /// <p>The number of documents modified in the data source up to now in
        ///             the data source sync run.</p>
        public let documentsModified: Swift.String?
        /// <p>The current number of documents crawled by the current sync job in
        ///             the data source.</p>
        public let documentsScanned: Swift.String?

        public init (
            documentsAdded: Swift.String? = nil,
            documentsDeleted: Swift.String? = nil,
            documentsFailed: Swift.String? = nil,
            documentsModified: Swift.String? = nil,
            documentsScanned: Swift.String? = nil
        )
        {
            self.documentsAdded = documentsAdded
            self.documentsDeleted = documentsDeleted
            self.documentsFailed = documentsFailed
            self.documentsModified = documentsModified
            self.documentsScanned = documentsScanned
        }
    }

}

extension KendraClientTypes {
    public enum DataSourceSyncJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aborted
        case failed
        case incomplete
        case stopping
        case succeeded
        case syncing
        case syncingIndexing
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSourceSyncJobStatus] {
            return [
                .aborted,
                .failed,
                .incomplete,
                .stopping,
                .succeeded,
                .syncing,
                .syncingIndexing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aborted: return "ABORTED"
            case .failed: return "FAILED"
            case .incomplete: return "INCOMPLETE"
            case .stopping: return "STOPPING"
            case .succeeded: return "SUCCEEDED"
            case .syncing: return "SYNCING"
            case .syncingIndexing: return "SYNCING_INDEXING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataSourceSyncJobStatus(rawValue: rawValue) ?? DataSourceSyncJobStatus.sdkUnknown(rawValue)
        }
    }
}

extension KendraClientTypes.DataSourceToIndexFieldMapping: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceFieldName = "DataSourceFieldName"
        case dateFieldFormat = "DateFieldFormat"
        case indexFieldName = "IndexFieldName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceFieldName = dataSourceFieldName {
            try encodeContainer.encode(dataSourceFieldName, forKey: .dataSourceFieldName)
        }
        if let dateFieldFormat = dateFieldFormat {
            try encodeContainer.encode(dateFieldFormat, forKey: .dateFieldFormat)
        }
        if let indexFieldName = indexFieldName {
            try encodeContainer.encode(indexFieldName, forKey: .indexFieldName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceFieldNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceFieldName)
        dataSourceFieldName = dataSourceFieldNameDecoded
        let dateFieldFormatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateFieldFormat)
        dateFieldFormat = dateFieldFormatDecoded
        let indexFieldNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexFieldName)
        indexFieldName = indexFieldNameDecoded
    }
}

extension KendraClientTypes.DataSourceToIndexFieldMapping: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataSourceToIndexFieldMapping(dataSourceFieldName: \(Swift.String(describing: dataSourceFieldName)), dateFieldFormat: \(Swift.String(describing: dateFieldFormat)), indexFieldName: \(Swift.String(describing: indexFieldName)))"}
}

extension KendraClientTypes {
    /// <p>Maps a column or attribute in the data source to an index field.
    ///             You must first create the fields in the index using the
    ///                 <code>UpdateIndex</code> operation.</p>
    public struct DataSourceToIndexFieldMapping: Swift.Equatable {
        /// <p>The name of the column or attribute in the data source.</p>
        public let dataSourceFieldName: Swift.String?
        /// <p>The type of data stored in the column or attribute.</p>
        public let dateFieldFormat: Swift.String?
        /// <p>The name of the field in the index.</p>
        public let indexFieldName: Swift.String?

        public init (
            dataSourceFieldName: Swift.String? = nil,
            dateFieldFormat: Swift.String? = nil,
            indexFieldName: Swift.String? = nil
        )
        {
            self.dataSourceFieldName = dataSourceFieldName
            self.dateFieldFormat = dateFieldFormat
            self.indexFieldName = indexFieldName
        }
    }

}

extension KendraClientTypes {
    public enum DataSourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case confluence
        case custom
        case database
        case googledrive
        case onedrive
        case s3
        case salesforce
        case servicenow
        case sharepoint
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSourceType] {
            return [
                .confluence,
                .custom,
                .database,
                .googledrive,
                .onedrive,
                .s3,
                .salesforce,
                .servicenow,
                .sharepoint,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .confluence: return "CONFLUENCE"
            case .custom: return "CUSTOM"
            case .database: return "DATABASE"
            case .googledrive: return "GOOGLEDRIVE"
            case .onedrive: return "ONEDRIVE"
            case .s3: return "S3"
            case .salesforce: return "SALESFORCE"
            case .servicenow: return "SERVICENOW"
            case .sharepoint: return "SHAREPOINT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataSourceType(rawValue: rawValue) ?? DataSourceType.sdkUnknown(rawValue)
        }
    }
}

extension KendraClientTypes.DataSourceVpcConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroupIds = "SecurityGroupIds"
        case subnetIds = "SubnetIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupidlist0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupidlist0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetidlist0 in subnetIds {
                try subnetIdsContainer.encode(subnetidlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

extension KendraClientTypes.DataSourceVpcConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataSourceVpcConfiguration(securityGroupIds: \(Swift.String(describing: securityGroupIds)), subnetIds: \(Swift.String(describing: subnetIds)))"}
}

extension KendraClientTypes {
    /// <p>Provides information for connecting to an Amazon VPC.</p>
    public struct DataSourceVpcConfiguration: Swift.Equatable {
        /// <p>A list of identifiers of security groups within your Amazon VPC.
        ///             The security groups should enable Amazon Kendra to connect to the data
        ///             source.</p>
        public let securityGroupIds: [Swift.String]?
        /// <p>A list of identifiers for subnets within your Amazon VPC. The
        ///             subnets should be able to connect to each other in the VPC, and they
        ///             should have outgoing access to the Internet through a NAT
        ///             device.</p>
        public let subnetIds: [Swift.String]?

        public init (
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil
        )
        {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }
    }

}

extension KendraClientTypes.DatabaseConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aclConfiguration = "AclConfiguration"
        case columnConfiguration = "ColumnConfiguration"
        case connectionConfiguration = "ConnectionConfiguration"
        case databaseEngineType = "DatabaseEngineType"
        case sqlConfiguration = "SqlConfiguration"
        case vpcConfiguration = "VpcConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aclConfiguration = aclConfiguration {
            try encodeContainer.encode(aclConfiguration, forKey: .aclConfiguration)
        }
        if let columnConfiguration = columnConfiguration {
            try encodeContainer.encode(columnConfiguration, forKey: .columnConfiguration)
        }
        if let connectionConfiguration = connectionConfiguration {
            try encodeContainer.encode(connectionConfiguration, forKey: .connectionConfiguration)
        }
        if let databaseEngineType = databaseEngineType {
            try encodeContainer.encode(databaseEngineType.rawValue, forKey: .databaseEngineType)
        }
        if let sqlConfiguration = sqlConfiguration {
            try encodeContainer.encode(sqlConfiguration, forKey: .sqlConfiguration)
        }
        if let vpcConfiguration = vpcConfiguration {
            try encodeContainer.encode(vpcConfiguration, forKey: .vpcConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseEngineTypeDecoded = try containerValues.decodeIfPresent(KendraClientTypes.DatabaseEngineType.self, forKey: .databaseEngineType)
        databaseEngineType = databaseEngineTypeDecoded
        let connectionConfigurationDecoded = try containerValues.decodeIfPresent(KendraClientTypes.ConnectionConfiguration.self, forKey: .connectionConfiguration)
        connectionConfiguration = connectionConfigurationDecoded
        let vpcConfigurationDecoded = try containerValues.decodeIfPresent(KendraClientTypes.DataSourceVpcConfiguration.self, forKey: .vpcConfiguration)
        vpcConfiguration = vpcConfigurationDecoded
        let columnConfigurationDecoded = try containerValues.decodeIfPresent(KendraClientTypes.ColumnConfiguration.self, forKey: .columnConfiguration)
        columnConfiguration = columnConfigurationDecoded
        let aclConfigurationDecoded = try containerValues.decodeIfPresent(KendraClientTypes.AclConfiguration.self, forKey: .aclConfiguration)
        aclConfiguration = aclConfigurationDecoded
        let sqlConfigurationDecoded = try containerValues.decodeIfPresent(KendraClientTypes.SqlConfiguration.self, forKey: .sqlConfiguration)
        sqlConfiguration = sqlConfigurationDecoded
    }
}

extension KendraClientTypes.DatabaseConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DatabaseConfiguration(aclConfiguration: \(Swift.String(describing: aclConfiguration)), columnConfiguration: \(Swift.String(describing: columnConfiguration)), connectionConfiguration: \(Swift.String(describing: connectionConfiguration)), databaseEngineType: \(Swift.String(describing: databaseEngineType)), sqlConfiguration: \(Swift.String(describing: sqlConfiguration)), vpcConfiguration: \(Swift.String(describing: vpcConfiguration)))"}
}

extension KendraClientTypes {
    /// <p>Provides the information necessary to connect a database to an
    ///             index. </p>
    public struct DatabaseConfiguration: Swift.Equatable {
        /// <p>Information about the database column that provides information
        ///             for user context filtering.</p>
        public let aclConfiguration: KendraClientTypes.AclConfiguration?
        /// <p>Information about where the index should get the document
        ///             information from the database.</p>
        public let columnConfiguration: KendraClientTypes.ColumnConfiguration?
        /// <p>The information necessary to connect to a database.</p>
        public let connectionConfiguration: KendraClientTypes.ConnectionConfiguration?
        /// <p>The type of database engine that runs the database.</p>
        public let databaseEngineType: KendraClientTypes.DatabaseEngineType?
        /// <p>Provides information about how Amazon Kendra uses quote marks around SQL
        ///             identifiers when querying a database data source.</p>
        public let sqlConfiguration: KendraClientTypes.SqlConfiguration?
        /// <p>Provides information for connecting to an Amazon VPC.</p>
        public let vpcConfiguration: KendraClientTypes.DataSourceVpcConfiguration?

        public init (
            aclConfiguration: KendraClientTypes.AclConfiguration? = nil,
            columnConfiguration: KendraClientTypes.ColumnConfiguration? = nil,
            connectionConfiguration: KendraClientTypes.ConnectionConfiguration? = nil,
            databaseEngineType: KendraClientTypes.DatabaseEngineType? = nil,
            sqlConfiguration: KendraClientTypes.SqlConfiguration? = nil,
            vpcConfiguration: KendraClientTypes.DataSourceVpcConfiguration? = nil
        )
        {
            self.aclConfiguration = aclConfiguration
            self.columnConfiguration = columnConfiguration
            self.connectionConfiguration = connectionConfiguration
            self.databaseEngineType = databaseEngineType
            self.sqlConfiguration = sqlConfiguration
            self.vpcConfiguration = vpcConfiguration
        }
    }

}

extension KendraClientTypes {
    public enum DatabaseEngineType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case rdsAuroraMysql
        case rdsAuroraPostgresql
        case rdsMysql
        case rdsPostgresql
        case sdkUnknown(Swift.String)

        public static var allCases: [DatabaseEngineType] {
            return [
                .rdsAuroraMysql,
                .rdsAuroraPostgresql,
                .rdsMysql,
                .rdsPostgresql,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .rdsAuroraMysql: return "RDS_AURORA_MYSQL"
            case .rdsAuroraPostgresql: return "RDS_AURORA_POSTGRESQL"
            case .rdsMysql: return "RDS_MYSQL"
            case .rdsPostgresql: return "RDS_POSTGRESQL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DatabaseEngineType(rawValue: rawValue) ?? DatabaseEngineType.sdkUnknown(rawValue)
        }
    }
}

public struct DeleteDataSourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDataSourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDataSourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDataSourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDataSourceOutputError>
}

extension DeleteDataSourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDataSourceInput(id: \(Swift.String(describing: id)), indexId: \(Swift.String(describing: indexId)))"}
}

extension DeleteDataSourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case indexId = "IndexId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
    }
}

public struct DeleteDataSourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDataSourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDataSourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDataSourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDataSourceOutputError>
}

public struct DeleteDataSourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDataSourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDataSourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDataSourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDataSourceOutputError>
}

public struct DeleteDataSourceInput: Swift.Equatable {
    /// <p>The unique identifier of the data source to delete.</p>
    public let id: Swift.String?
    /// <p>The unique identifier of the index associated with the data
    ///       source.</p>
    public let indexId: Swift.String?

    public init (
        id: Swift.String? = nil,
        indexId: Swift.String? = nil
    )
    {
        self.id = id
        self.indexId = indexId
    }
}

struct DeleteDataSourceInputBody: Swift.Equatable {
    public let id: Swift.String?
    public let indexId: Swift.String?
}

extension DeleteDataSourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case indexId = "IndexId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let indexIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexId)
        indexId = indexIdDecoded
    }
}

extension DeleteDataSourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDataSourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDataSourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDataSourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDataSourceOutputResponse()"}
}

extension DeleteDataSourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDataSourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteDataSourceOutputResponseBody: Swift.Equatable {
}

extension DeleteDataSourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteFaqInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFaqInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFaqInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFaqOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFaqInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFaqOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFaqOutputError>
}

extension DeleteFaqInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFaqInput(id: \(Swift.String(describing: id)), indexId: \(Swift.String(describing: indexId)))"}
}

extension DeleteFaqInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case indexId = "IndexId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
    }
}

public struct DeleteFaqInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFaqInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFaqInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFaqOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFaqInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFaqOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFaqOutputError>
}

public struct DeleteFaqInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFaqInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFaqInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFaqOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFaqInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFaqOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFaqOutputError>
}

public struct DeleteFaqInput: Swift.Equatable {
    /// <p>The identifier of the FAQ to remove.</p>
    public let id: Swift.String?
    /// <p>The index to remove the FAQ from.</p>
    public let indexId: Swift.String?

    public init (
        id: Swift.String? = nil,
        indexId: Swift.String? = nil
    )
    {
        self.id = id
        self.indexId = indexId
    }
}

struct DeleteFaqInputBody: Swift.Equatable {
    public let id: Swift.String?
    public let indexId: Swift.String?
}

extension DeleteFaqInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case indexId = "IndexId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let indexIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexId)
        indexId = indexIdDecoded
    }
}

extension DeleteFaqOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFaqOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFaqOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFaqOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFaqOutputResponse()"}
}

extension DeleteFaqOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFaqOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteFaqOutputResponseBody: Swift.Equatable {
}

extension DeleteFaqOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteIndexInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteIndexInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteIndexInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteIndexInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteIndexOutputError>
}

extension DeleteIndexInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteIndexInput(id: \(Swift.String(describing: id)))"}
}

extension DeleteIndexInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

public struct DeleteIndexInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteIndexInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteIndexInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteIndexInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteIndexOutputError>
}

public struct DeleteIndexInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteIndexInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteIndexInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteIndexInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteIndexOutputError>
}

public struct DeleteIndexInput: Swift.Equatable {
    /// <p>The identifier of the index to delete.</p>
    public let id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteIndexInputBody: Swift.Equatable {
    public let id: Swift.String?
}

extension DeleteIndexInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeleteIndexOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteIndexOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteIndexOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteIndexOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteIndexOutputResponse()"}
}

extension DeleteIndexOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteIndexOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteIndexOutputResponseBody: Swift.Equatable {
}

extension DeleteIndexOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteQuerySuggestionsBlockListInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteQuerySuggestionsBlockListInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteQuerySuggestionsBlockListInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteQuerySuggestionsBlockListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteQuerySuggestionsBlockListInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteQuerySuggestionsBlockListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteQuerySuggestionsBlockListOutputError>
}

extension DeleteQuerySuggestionsBlockListInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteQuerySuggestionsBlockListInput(id: \(Swift.String(describing: id)), indexId: \(Swift.String(describing: indexId)))"}
}

extension DeleteQuerySuggestionsBlockListInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case indexId = "IndexId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
    }
}

public struct DeleteQuerySuggestionsBlockListInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteQuerySuggestionsBlockListInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteQuerySuggestionsBlockListInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteQuerySuggestionsBlockListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteQuerySuggestionsBlockListInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteQuerySuggestionsBlockListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteQuerySuggestionsBlockListOutputError>
}

public struct DeleteQuerySuggestionsBlockListInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteQuerySuggestionsBlockListInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteQuerySuggestionsBlockListInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteQuerySuggestionsBlockListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteQuerySuggestionsBlockListInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteQuerySuggestionsBlockListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteQuerySuggestionsBlockListOutputError>
}

public struct DeleteQuerySuggestionsBlockListInput: Swift.Equatable {
    /// <p>The unique identifier of the block list that needs to be deleted.</p>
    public let id: Swift.String?
    /// <p>The identifier of the you want to delete a block list from.</p>
    public let indexId: Swift.String?

    public init (
        id: Swift.String? = nil,
        indexId: Swift.String? = nil
    )
    {
        self.id = id
        self.indexId = indexId
    }
}

struct DeleteQuerySuggestionsBlockListInputBody: Swift.Equatable {
    public let indexId: Swift.String?
    public let id: Swift.String?
}

extension DeleteQuerySuggestionsBlockListInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case indexId = "IndexId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexId)
        indexId = indexIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeleteQuerySuggestionsBlockListOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteQuerySuggestionsBlockListOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteQuerySuggestionsBlockListOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteQuerySuggestionsBlockListOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteQuerySuggestionsBlockListOutputResponse()"}
}

extension DeleteQuerySuggestionsBlockListOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteQuerySuggestionsBlockListOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteQuerySuggestionsBlockListOutputResponseBody: Swift.Equatable {
}

extension DeleteQuerySuggestionsBlockListOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteThesaurusInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteThesaurusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteThesaurusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteThesaurusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteThesaurusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteThesaurusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteThesaurusOutputError>
}

extension DeleteThesaurusInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteThesaurusInput(id: \(Swift.String(describing: id)), indexId: \(Swift.String(describing: indexId)))"}
}

extension DeleteThesaurusInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case indexId = "IndexId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
    }
}

public struct DeleteThesaurusInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteThesaurusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteThesaurusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteThesaurusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteThesaurusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteThesaurusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteThesaurusOutputError>
}

public struct DeleteThesaurusInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteThesaurusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteThesaurusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteThesaurusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteThesaurusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteThesaurusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteThesaurusOutputError>
}

public struct DeleteThesaurusInput: Swift.Equatable {
    /// <p>The identifier of the thesaurus to delete.</p>
    public let id: Swift.String?
    /// <p>The identifier of the index associated with the thesaurus to delete.</p>
    public let indexId: Swift.String?

    public init (
        id: Swift.String? = nil,
        indexId: Swift.String? = nil
    )
    {
        self.id = id
        self.indexId = indexId
    }
}

struct DeleteThesaurusInputBody: Swift.Equatable {
    public let id: Swift.String?
    public let indexId: Swift.String?
}

extension DeleteThesaurusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case indexId = "IndexId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let indexIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexId)
        indexId = indexIdDecoded
    }
}

extension DeleteThesaurusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteThesaurusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteThesaurusOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteThesaurusOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteThesaurusOutputResponse()"}
}

extension DeleteThesaurusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteThesaurusOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteThesaurusOutputResponseBody: Swift.Equatable {
}

extension DeleteThesaurusOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DescribeDataSourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDataSourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDataSourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDataSourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDataSourceOutputError>
}

extension DescribeDataSourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDataSourceInput(id: \(Swift.String(describing: id)), indexId: \(Swift.String(describing: indexId)))"}
}

extension DescribeDataSourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case indexId = "IndexId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
    }
}

public struct DescribeDataSourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDataSourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDataSourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDataSourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDataSourceOutputError>
}

public struct DescribeDataSourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDataSourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDataSourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDataSourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDataSourceOutputError>
}

public struct DescribeDataSourceInput: Swift.Equatable {
    /// <p>The unique identifier of the data source to describe.</p>
    public let id: Swift.String?
    /// <p>The identifier of the index that contains the data source.</p>
    public let indexId: Swift.String?

    public init (
        id: Swift.String? = nil,
        indexId: Swift.String? = nil
    )
    {
        self.id = id
        self.indexId = indexId
    }
}

struct DescribeDataSourceInputBody: Swift.Equatable {
    public let id: Swift.String?
    public let indexId: Swift.String?
}

extension DescribeDataSourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case indexId = "IndexId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let indexIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexId)
        indexId = indexIdDecoded
    }
}

extension DescribeDataSourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDataSourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDataSourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDataSourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDataSourceOutputResponse(configuration: \(Swift.String(describing: configuration)), createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), errorMessage: \(Swift.String(describing: errorMessage)), id: \(Swift.String(describing: id)), indexId: \(Swift.String(describing: indexId)), name: \(Swift.String(describing: name)), roleArn: \(Swift.String(describing: roleArn)), schedule: \(Swift.String(describing: schedule)), status: \(Swift.String(describing: status)), type: \(Swift.String(describing: type)), updatedAt: \(Swift.String(describing: updatedAt)))"}
}

extension DescribeDataSourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDataSourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.configuration = output.configuration
            self.createdAt = output.createdAt
            self.description = output.description
            self.errorMessage = output.errorMessage
            self.id = output.id
            self.indexId = output.indexId
            self.name = output.name
            self.roleArn = output.roleArn
            self.schedule = output.schedule
            self.status = output.status
            self.type = output.type
            self.updatedAt = output.updatedAt
        } else {
            self.configuration = nil
            self.createdAt = nil
            self.description = nil
            self.errorMessage = nil
            self.id = nil
            self.indexId = nil
            self.name = nil
            self.roleArn = nil
            self.schedule = nil
            self.status = nil
            self.type = nil
            self.updatedAt = nil
        }
    }
}

public struct DescribeDataSourceOutputResponse: Swift.Equatable {
    /// <p>Information that describes where the data source is located and how
    ///       the data source is configured. The specific information in the description
    ///       depends on the data source provider.</p>
    public let configuration: KendraClientTypes.DataSourceConfiguration?
    /// <p>The Unix timestamp of when the data source was created.</p>
    public let createdAt: ClientRuntime.Date?
    /// <p>The description of the data source.</p>
    public let description: Swift.String?
    /// <p>When the <code>Status</code> field value is <code>FAILED</code>, the
    ///         <code>ErrorMessage</code> field contains a description of the error that
    ///       caused the data source to fail.</p>
    public let errorMessage: Swift.String?
    /// <p>The identifier of the data source.</p>
    public let id: Swift.String?
    /// <p>The identifier of the index that contains the data source.</p>
    public let indexId: Swift.String?
    /// <p>The name that you gave the data source when it was created.</p>
    public let name: Swift.String?
    /// <p>The Amazon Resource Name (ARN) of the role that enables the data
    ///       source to access its resources.</p>
    public let roleArn: Swift.String?
    /// <p>The schedule that Amazon Kendra will update the data source.</p>
    public let schedule: Swift.String?
    /// <p>The current status of the data source. When the status is
    ///         <code>ACTIVE</code> the data source is ready to use. When the status is
    ///         <code>FAILED</code>, the <code>ErrorMessage</code> field contains the
    ///       reason that the data source failed.</p>
    public let status: KendraClientTypes.DataSourceStatus?
    /// <p>The type of the data source.</p>
    public let type: KendraClientTypes.DataSourceType?
    /// <p>The Unix timestamp of when the data source was last updated.</p>
    public let updatedAt: ClientRuntime.Date?

    public init (
        configuration: KendraClientTypes.DataSourceConfiguration? = nil,
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        errorMessage: Swift.String? = nil,
        id: Swift.String? = nil,
        indexId: Swift.String? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        schedule: Swift.String? = nil,
        status: KendraClientTypes.DataSourceStatus? = nil,
        type: KendraClientTypes.DataSourceType? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.configuration = configuration
        self.createdAt = createdAt
        self.description = description
        self.errorMessage = errorMessage
        self.id = id
        self.indexId = indexId
        self.name = name
        self.roleArn = roleArn
        self.schedule = schedule
        self.status = status
        self.type = type
        self.updatedAt = updatedAt
    }
}

struct DescribeDataSourceOutputResponseBody: Swift.Equatable {
    public let id: Swift.String?
    public let indexId: Swift.String?
    public let name: Swift.String?
    public let type: KendraClientTypes.DataSourceType?
    public let configuration: KendraClientTypes.DataSourceConfiguration?
    public let createdAt: ClientRuntime.Date?
    public let updatedAt: ClientRuntime.Date?
    public let description: Swift.String?
    public let status: KendraClientTypes.DataSourceStatus?
    public let schedule: Swift.String?
    public let roleArn: Swift.String?
    public let errorMessage: Swift.String?
}

extension DescribeDataSourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
        case createdAt = "CreatedAt"
        case description = "Description"
        case errorMessage = "ErrorMessage"
        case id = "Id"
        case indexId = "IndexId"
        case name = "Name"
        case roleArn = "RoleArn"
        case schedule = "Schedule"
        case status = "Status"
        case type = "Type"
        case updatedAt = "UpdatedAt"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let indexIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexId)
        indexId = indexIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(KendraClientTypes.DataSourceType.self, forKey: .type)
        type = typeDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(KendraClientTypes.DataSourceConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(KendraClientTypes.DataSourceStatus.self, forKey: .status)
        status = statusDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schedule)
        schedule = scheduleDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

public struct DescribeFaqInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFaqInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFaqInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFaqOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFaqInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFaqOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFaqOutputError>
}

extension DescribeFaqInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeFaqInput(id: \(Swift.String(describing: id)), indexId: \(Swift.String(describing: indexId)))"}
}

extension DescribeFaqInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case indexId = "IndexId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
    }
}

public struct DescribeFaqInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFaqInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFaqInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFaqOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFaqInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFaqOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFaqOutputError>
}

public struct DescribeFaqInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFaqInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFaqInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFaqOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFaqInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFaqOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFaqOutputError>
}

public struct DescribeFaqInput: Swift.Equatable {
    /// <p>The unique identifier of the FAQ.</p>
    public let id: Swift.String?
    /// <p>The identifier of the index that contains the FAQ.</p>
    public let indexId: Swift.String?

    public init (
        id: Swift.String? = nil,
        indexId: Swift.String? = nil
    )
    {
        self.id = id
        self.indexId = indexId
    }
}

struct DescribeFaqInputBody: Swift.Equatable {
    public let id: Swift.String?
    public let indexId: Swift.String?
}

extension DescribeFaqInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case indexId = "IndexId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let indexIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexId)
        indexId = indexIdDecoded
    }
}

extension DescribeFaqOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFaqOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFaqOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFaqOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeFaqOutputResponse(createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), errorMessage: \(Swift.String(describing: errorMessage)), fileFormat: \(Swift.String(describing: fileFormat)), id: \(Swift.String(describing: id)), indexId: \(Swift.String(describing: indexId)), name: \(Swift.String(describing: name)), roleArn: \(Swift.String(describing: roleArn)), s3Path: \(Swift.String(describing: s3Path)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)))"}
}

extension DescribeFaqOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeFaqOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.description = output.description
            self.errorMessage = output.errorMessage
            self.fileFormat = output.fileFormat
            self.id = output.id
            self.indexId = output.indexId
            self.name = output.name
            self.roleArn = output.roleArn
            self.s3Path = output.s3Path
            self.status = output.status
            self.updatedAt = output.updatedAt
        } else {
            self.createdAt = nil
            self.description = nil
            self.errorMessage = nil
            self.fileFormat = nil
            self.id = nil
            self.indexId = nil
            self.name = nil
            self.roleArn = nil
            self.s3Path = nil
            self.status = nil
            self.updatedAt = nil
        }
    }
}

public struct DescribeFaqOutputResponse: Swift.Equatable {
    /// <p>The date and time that the FAQ was created.</p>
    public let createdAt: ClientRuntime.Date?
    /// <p>The description of the FAQ that you provided when it was created.</p>
    public let description: Swift.String?
    /// <p>If the <code>Status</code> field is <code>FAILED</code>, the <code>ErrorMessage</code>
    ///             field contains the reason why the FAQ failed.</p>
    public let errorMessage: Swift.String?
    /// <p>The file format used by the input files for the FAQ.</p>
    public let fileFormat: KendraClientTypes.FaqFileFormat?
    /// <p>The identifier of the FAQ.</p>
    public let id: Swift.String?
    /// <p>The identifier of the index that contains the FAQ.</p>
    public let indexId: Swift.String?
    /// <p>The name that you gave the FAQ when it was created.</p>
    public let name: Swift.String?
    /// <p>The Amazon Resource Name (ARN) of the role that provides access to the S3 bucket
    ///             containing the input files for the FAQ.</p>
    public let roleArn: Swift.String?
    /// <p>Information required to find a specific file in an Amazon S3
    ///             bucket.</p>
    public let s3Path: KendraClientTypes.S3Path?
    /// <p>The status of the FAQ. It is ready to use when the status is
    ///             <code>ACTIVE</code>.</p>
    public let status: KendraClientTypes.FaqStatus?
    /// <p>The date and time that the FAQ was last updated.</p>
    public let updatedAt: ClientRuntime.Date?

    public init (
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        errorMessage: Swift.String? = nil,
        fileFormat: KendraClientTypes.FaqFileFormat? = nil,
        id: Swift.String? = nil,
        indexId: Swift.String? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        s3Path: KendraClientTypes.S3Path? = nil,
        status: KendraClientTypes.FaqStatus? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.createdAt = createdAt
        self.description = description
        self.errorMessage = errorMessage
        self.fileFormat = fileFormat
        self.id = id
        self.indexId = indexId
        self.name = name
        self.roleArn = roleArn
        self.s3Path = s3Path
        self.status = status
        self.updatedAt = updatedAt
    }
}

struct DescribeFaqOutputResponseBody: Swift.Equatable {
    public let id: Swift.String?
    public let indexId: Swift.String?
    public let name: Swift.String?
    public let description: Swift.String?
    public let createdAt: ClientRuntime.Date?
    public let updatedAt: ClientRuntime.Date?
    public let s3Path: KendraClientTypes.S3Path?
    public let status: KendraClientTypes.FaqStatus?
    public let roleArn: Swift.String?
    public let errorMessage: Swift.String?
    public let fileFormat: KendraClientTypes.FaqFileFormat?
}

extension DescribeFaqOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case description = "Description"
        case errorMessage = "ErrorMessage"
        case fileFormat = "FileFormat"
        case id = "Id"
        case indexId = "IndexId"
        case name = "Name"
        case roleArn = "RoleArn"
        case s3Path = "S3Path"
        case status = "Status"
        case updatedAt = "UpdatedAt"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let indexIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexId)
        indexId = indexIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let s3PathDecoded = try containerValues.decodeIfPresent(KendraClientTypes.S3Path.self, forKey: .s3Path)
        s3Path = s3PathDecoded
        let statusDecoded = try containerValues.decodeIfPresent(KendraClientTypes.FaqStatus.self, forKey: .status)
        status = statusDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let fileFormatDecoded = try containerValues.decodeIfPresent(KendraClientTypes.FaqFileFormat.self, forKey: .fileFormat)
        fileFormat = fileFormatDecoded
    }
}

public struct DescribeIndexInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeIndexInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeIndexInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeIndexInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeIndexOutputError>
}

extension DescribeIndexInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeIndexInput(id: \(Swift.String(describing: id)))"}
}

extension DescribeIndexInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

public struct DescribeIndexInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeIndexInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeIndexInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeIndexInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeIndexOutputError>
}

public struct DescribeIndexInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeIndexInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeIndexInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeIndexInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeIndexOutputError>
}

public struct DescribeIndexInput: Swift.Equatable {
    /// <p>The name of the index to describe.</p>
    public let id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DescribeIndexInputBody: Swift.Equatable {
    public let id: Swift.String?
}

extension DescribeIndexInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DescribeIndexOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeIndexOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeIndexOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeIndexOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeIndexOutputResponse(capacityUnits: \(Swift.String(describing: capacityUnits)), createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), documentMetadataConfigurations: \(Swift.String(describing: documentMetadataConfigurations)), edition: \(Swift.String(describing: edition)), errorMessage: \(Swift.String(describing: errorMessage)), id: \(Swift.String(describing: id)), indexStatistics: \(Swift.String(describing: indexStatistics)), name: \(Swift.String(describing: name)), roleArn: \(Swift.String(describing: roleArn)), serverSideEncryptionConfiguration: \(Swift.String(describing: serverSideEncryptionConfiguration)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)), userContextPolicy: \(Swift.String(describing: userContextPolicy)), userTokenConfigurations: \(Swift.String(describing: userTokenConfigurations)))"}
}

extension DescribeIndexOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeIndexOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.capacityUnits = output.capacityUnits
            self.createdAt = output.createdAt
            self.description = output.description
            self.documentMetadataConfigurations = output.documentMetadataConfigurations
            self.edition = output.edition
            self.errorMessage = output.errorMessage
            self.id = output.id
            self.indexStatistics = output.indexStatistics
            self.name = output.name
            self.roleArn = output.roleArn
            self.serverSideEncryptionConfiguration = output.serverSideEncryptionConfiguration
            self.status = output.status
            self.updatedAt = output.updatedAt
            self.userContextPolicy = output.userContextPolicy
            self.userTokenConfigurations = output.userTokenConfigurations
        } else {
            self.capacityUnits = nil
            self.createdAt = nil
            self.description = nil
            self.documentMetadataConfigurations = nil
            self.edition = nil
            self.errorMessage = nil
            self.id = nil
            self.indexStatistics = nil
            self.name = nil
            self.roleArn = nil
            self.serverSideEncryptionConfiguration = nil
            self.status = nil
            self.updatedAt = nil
            self.userContextPolicy = nil
            self.userTokenConfigurations = nil
        }
    }
}

public struct DescribeIndexOutputResponse: Swift.Equatable {
    /// <p>For Enterprise edition indexes, you can choose to use additional
    ///       capacity to meet the needs of your application. This contains the capacity
    ///       units used for the index. A 0 for the query capacity or the storage
    ///       capacity indicates that the index is using the default capacity for the
    ///       index.</p>
    public let capacityUnits: KendraClientTypes.CapacityUnitsConfiguration?
    /// <p>The Unix datetime that the index was created.</p>
    public let createdAt: ClientRuntime.Date?
    /// <p>The description of the index.</p>
    public let description: Swift.String?
    /// <p>Configuration settings for any metadata applied to the documents in
    ///       the index.</p>
    public let documentMetadataConfigurations: [KendraClientTypes.DocumentMetadataConfiguration]?
    /// <p>The Amazon Kendra edition used for the index. You decide the edition
    ///       when you create the index.</p>
    public let edition: KendraClientTypes.IndexEdition?
    /// <p>When th e<code>Status</code> field value is <code>FAILED</code>, the
    ///         <code>ErrorMessage</code> field contains a message that explains
    ///       why.</p>
    public let errorMessage: Swift.String?
    /// <p>The name of the index.</p>
    public let id: Swift.String?
    /// <p>Provides information about the number of FAQ questions and answers and
    ///       the number of text documents indexed.</p>
    public let indexStatistics: KendraClientTypes.IndexStatistics?
    /// <p>The name of the index.</p>
    public let name: Swift.String?
    /// <p>The Amazon Resource Name (ARN) of the IAM role that gives Amazon Kendra
    ///       permission to write to your Amazon Cloudwatch logs.</p>
    public let roleArn: Swift.String?
    /// <p>The identifier of the AWS KMS customer master key (CMK) used to
    ///       encrypt your data. Amazon Kendra doesn't support asymmetric CMKs.</p>
    public let serverSideEncryptionConfiguration: KendraClientTypes.ServerSideEncryptionConfiguration?
    /// <p>The current status of the index. When the value is
    ///       <code>ACTIVE</code>, the index is ready for use. If the
    ///         <code>Status</code> field value is <code>FAILED</code>, the
    ///         <code>ErrorMessage</code> field contains a message that explains
    ///       why.</p>
    public let status: KendraClientTypes.IndexStatus?
    /// <p>The Unix datetime that the index was last updated.</p>
    public let updatedAt: ClientRuntime.Date?
    /// <p>The user context policy for the Amazon Kendra index.</p>
    public let userContextPolicy: KendraClientTypes.UserContextPolicy?
    /// <p>The user token configuration for the Amazon Kendra index.</p>
    public let userTokenConfigurations: [KendraClientTypes.UserTokenConfiguration]?

    public init (
        capacityUnits: KendraClientTypes.CapacityUnitsConfiguration? = nil,
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        documentMetadataConfigurations: [KendraClientTypes.DocumentMetadataConfiguration]? = nil,
        edition: KendraClientTypes.IndexEdition? = nil,
        errorMessage: Swift.String? = nil,
        id: Swift.String? = nil,
        indexStatistics: KendraClientTypes.IndexStatistics? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        serverSideEncryptionConfiguration: KendraClientTypes.ServerSideEncryptionConfiguration? = nil,
        status: KendraClientTypes.IndexStatus? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        userContextPolicy: KendraClientTypes.UserContextPolicy? = nil,
        userTokenConfigurations: [KendraClientTypes.UserTokenConfiguration]? = nil
    )
    {
        self.capacityUnits = capacityUnits
        self.createdAt = createdAt
        self.description = description
        self.documentMetadataConfigurations = documentMetadataConfigurations
        self.edition = edition
        self.errorMessage = errorMessage
        self.id = id
        self.indexStatistics = indexStatistics
        self.name = name
        self.roleArn = roleArn
        self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
        self.status = status
        self.updatedAt = updatedAt
        self.userContextPolicy = userContextPolicy
        self.userTokenConfigurations = userTokenConfigurations
    }
}

struct DescribeIndexOutputResponseBody: Swift.Equatable {
    public let name: Swift.String?
    public let id: Swift.String?
    public let edition: KendraClientTypes.IndexEdition?
    public let roleArn: Swift.String?
    public let serverSideEncryptionConfiguration: KendraClientTypes.ServerSideEncryptionConfiguration?
    public let status: KendraClientTypes.IndexStatus?
    public let description: Swift.String?
    public let createdAt: ClientRuntime.Date?
    public let updatedAt: ClientRuntime.Date?
    public let documentMetadataConfigurations: [KendraClientTypes.DocumentMetadataConfiguration]?
    public let indexStatistics: KendraClientTypes.IndexStatistics?
    public let errorMessage: Swift.String?
    public let capacityUnits: KendraClientTypes.CapacityUnitsConfiguration?
    public let userTokenConfigurations: [KendraClientTypes.UserTokenConfiguration]?
    public let userContextPolicy: KendraClientTypes.UserContextPolicy?
}

extension DescribeIndexOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capacityUnits = "CapacityUnits"
        case createdAt = "CreatedAt"
        case description = "Description"
        case documentMetadataConfigurations = "DocumentMetadataConfigurations"
        case edition = "Edition"
        case errorMessage = "ErrorMessage"
        case id = "Id"
        case indexStatistics = "IndexStatistics"
        case name = "Name"
        case roleArn = "RoleArn"
        case serverSideEncryptionConfiguration = "ServerSideEncryptionConfiguration"
        case status = "Status"
        case updatedAt = "UpdatedAt"
        case userContextPolicy = "UserContextPolicy"
        case userTokenConfigurations = "UserTokenConfigurations"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let editionDecoded = try containerValues.decodeIfPresent(KendraClientTypes.IndexEdition.self, forKey: .edition)
        edition = editionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let serverSideEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(KendraClientTypes.ServerSideEncryptionConfiguration.self, forKey: .serverSideEncryptionConfiguration)
        serverSideEncryptionConfiguration = serverSideEncryptionConfigurationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(KendraClientTypes.IndexStatus.self, forKey: .status)
        status = statusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let documentMetadataConfigurationsContainer = try containerValues.decodeIfPresent([KendraClientTypes.DocumentMetadataConfiguration?].self, forKey: .documentMetadataConfigurations)
        var documentMetadataConfigurationsDecoded0:[KendraClientTypes.DocumentMetadataConfiguration]? = nil
        if let documentMetadataConfigurationsContainer = documentMetadataConfigurationsContainer {
            documentMetadataConfigurationsDecoded0 = [KendraClientTypes.DocumentMetadataConfiguration]()
            for structure0 in documentMetadataConfigurationsContainer {
                if let structure0 = structure0 {
                    documentMetadataConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        documentMetadataConfigurations = documentMetadataConfigurationsDecoded0
        let indexStatisticsDecoded = try containerValues.decodeIfPresent(KendraClientTypes.IndexStatistics.self, forKey: .indexStatistics)
        indexStatistics = indexStatisticsDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let capacityUnitsDecoded = try containerValues.decodeIfPresent(KendraClientTypes.CapacityUnitsConfiguration.self, forKey: .capacityUnits)
        capacityUnits = capacityUnitsDecoded
        let userTokenConfigurationsContainer = try containerValues.decodeIfPresent([KendraClientTypes.UserTokenConfiguration?].self, forKey: .userTokenConfigurations)
        var userTokenConfigurationsDecoded0:[KendraClientTypes.UserTokenConfiguration]? = nil
        if let userTokenConfigurationsContainer = userTokenConfigurationsContainer {
            userTokenConfigurationsDecoded0 = [KendraClientTypes.UserTokenConfiguration]()
            for structure0 in userTokenConfigurationsContainer {
                if let structure0 = structure0 {
                    userTokenConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        userTokenConfigurations = userTokenConfigurationsDecoded0
        let userContextPolicyDecoded = try containerValues.decodeIfPresent(KendraClientTypes.UserContextPolicy.self, forKey: .userContextPolicy)
        userContextPolicy = userContextPolicyDecoded
    }
}

public struct DescribeQuerySuggestionsBlockListInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeQuerySuggestionsBlockListInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeQuerySuggestionsBlockListInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeQuerySuggestionsBlockListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeQuerySuggestionsBlockListInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeQuerySuggestionsBlockListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeQuerySuggestionsBlockListOutputError>
}

extension DescribeQuerySuggestionsBlockListInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeQuerySuggestionsBlockListInput(id: \(Swift.String(describing: id)), indexId: \(Swift.String(describing: indexId)))"}
}

extension DescribeQuerySuggestionsBlockListInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case indexId = "IndexId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
    }
}

public struct DescribeQuerySuggestionsBlockListInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeQuerySuggestionsBlockListInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeQuerySuggestionsBlockListInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeQuerySuggestionsBlockListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeQuerySuggestionsBlockListInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeQuerySuggestionsBlockListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeQuerySuggestionsBlockListOutputError>
}

public struct DescribeQuerySuggestionsBlockListInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeQuerySuggestionsBlockListInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeQuerySuggestionsBlockListInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeQuerySuggestionsBlockListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeQuerySuggestionsBlockListInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeQuerySuggestionsBlockListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeQuerySuggestionsBlockListOutputError>
}

public struct DescribeQuerySuggestionsBlockListInput: Swift.Equatable {
    /// <p>The unique identifier of the block list.</p>
    public let id: Swift.String?
    /// <p>The identifier of the index for the block list.</p>
    public let indexId: Swift.String?

    public init (
        id: Swift.String? = nil,
        indexId: Swift.String? = nil
    )
    {
        self.id = id
        self.indexId = indexId
    }
}

struct DescribeQuerySuggestionsBlockListInputBody: Swift.Equatable {
    public let indexId: Swift.String?
    public let id: Swift.String?
}

extension DescribeQuerySuggestionsBlockListInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case indexId = "IndexId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexId)
        indexId = indexIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DescribeQuerySuggestionsBlockListOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeQuerySuggestionsBlockListOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeQuerySuggestionsBlockListOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeQuerySuggestionsBlockListOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeQuerySuggestionsBlockListOutputResponse(createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), errorMessage: \(Swift.String(describing: errorMessage)), fileSizeBytes: \(Swift.String(describing: fileSizeBytes)), id: \(Swift.String(describing: id)), indexId: \(Swift.String(describing: indexId)), itemCount: \(Swift.String(describing: itemCount)), name: \(Swift.String(describing: name)), roleArn: \(Swift.String(describing: roleArn)), sourceS3Path: \(Swift.String(describing: sourceS3Path)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)))"}
}

extension DescribeQuerySuggestionsBlockListOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeQuerySuggestionsBlockListOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.description = output.description
            self.errorMessage = output.errorMessage
            self.fileSizeBytes = output.fileSizeBytes
            self.id = output.id
            self.indexId = output.indexId
            self.itemCount = output.itemCount
            self.name = output.name
            self.roleArn = output.roleArn
            self.sourceS3Path = output.sourceS3Path
            self.status = output.status
            self.updatedAt = output.updatedAt
        } else {
            self.createdAt = nil
            self.description = nil
            self.errorMessage = nil
            self.fileSizeBytes = nil
            self.id = nil
            self.indexId = nil
            self.itemCount = nil
            self.name = nil
            self.roleArn = nil
            self.sourceS3Path = nil
            self.status = nil
            self.updatedAt = nil
        }
    }
}

public struct DescribeQuerySuggestionsBlockListOutputResponse: Swift.Equatable {
    /// <p>Shows the date-time a block list for query suggestions was last created.</p>
    public let createdAt: ClientRuntime.Date?
    /// <p>Shows the description for the block list.</p>
    public let description: Swift.String?
    /// <p>Shows the error message with details when there are issues in
    ///             processing the block list.</p>
    public let errorMessage: Swift.String?
    /// <p>Shows the current size of the block list text file in S3.</p>
    public let fileSizeBytes: Swift.Int?
    /// <p>Shows the unique identifier of the block list.</p>
    public let id: Swift.String?
    /// <p>Shows the identifier of the index for the block list.</p>
    public let indexId: Swift.String?
    /// <p>Shows the current number of valid, non-empty words or phrases in
    ///             the block list text file.</p>
    public let itemCount: Swift.Int?
    /// <p>Shows the name of the block list.</p>
    public let name: Swift.String?
    /// <p>Shows the current IAM (Identity and Access Management) role used by
    ///             Amazon Kendra to access the block list text file in S3.</p>
    ///         <p>The role needs S3 read permissions to your file in S3 and needs to
    ///             give STS (Security Token Service) assume role permissions to
    ///             Amazon Kendra.</p>
    public let roleArn: Swift.String?
    /// <p>Shows the current S3 path to your block list text file in your S3 bucket.</p>
    ///         <p>Each block word or phrase should be on a separate line in a text file.</p>
    ///         <p>For information on the current quota limits for block lists, see
    ///             <a href="https://docs.aws.amazon.com/kendra/latest/dg/quotas.html">Quotas
    ///                 for Amazon Kendra</a>.</p>
    public let sourceS3Path: KendraClientTypes.S3Path?
    /// <p>Shows whether the current status of the block list is
    ///             <code>ACTIVE</code> or <code>INACTIVE</code>.</p>
    public let status: KendraClientTypes.QuerySuggestionsBlockListStatus?
    /// <p>Shows the date-time a block list for query suggestions was last updated.</p>
    public let updatedAt: ClientRuntime.Date?

    public init (
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        errorMessage: Swift.String? = nil,
        fileSizeBytes: Swift.Int? = nil,
        id: Swift.String? = nil,
        indexId: Swift.String? = nil,
        itemCount: Swift.Int? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        sourceS3Path: KendraClientTypes.S3Path? = nil,
        status: KendraClientTypes.QuerySuggestionsBlockListStatus? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.createdAt = createdAt
        self.description = description
        self.errorMessage = errorMessage
        self.fileSizeBytes = fileSizeBytes
        self.id = id
        self.indexId = indexId
        self.itemCount = itemCount
        self.name = name
        self.roleArn = roleArn
        self.sourceS3Path = sourceS3Path
        self.status = status
        self.updatedAt = updatedAt
    }
}

struct DescribeQuerySuggestionsBlockListOutputResponseBody: Swift.Equatable {
    public let indexId: Swift.String?
    public let id: Swift.String?
    public let name: Swift.String?
    public let description: Swift.String?
    public let status: KendraClientTypes.QuerySuggestionsBlockListStatus?
    public let errorMessage: Swift.String?
    public let createdAt: ClientRuntime.Date?
    public let updatedAt: ClientRuntime.Date?
    public let sourceS3Path: KendraClientTypes.S3Path?
    public let itemCount: Swift.Int?
    public let fileSizeBytes: Swift.Int?
    public let roleArn: Swift.String?
}

extension DescribeQuerySuggestionsBlockListOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case description = "Description"
        case errorMessage = "ErrorMessage"
        case fileSizeBytes = "FileSizeBytes"
        case id = "Id"
        case indexId = "IndexId"
        case itemCount = "ItemCount"
        case name = "Name"
        case roleArn = "RoleArn"
        case sourceS3Path = "SourceS3Path"
        case status = "Status"
        case updatedAt = "UpdatedAt"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexId)
        indexId = indexIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(KendraClientTypes.QuerySuggestionsBlockListStatus.self, forKey: .status)
        status = statusDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let sourceS3PathDecoded = try containerValues.decodeIfPresent(KendraClientTypes.S3Path.self, forKey: .sourceS3Path)
        sourceS3Path = sourceS3PathDecoded
        let itemCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .itemCount)
        itemCount = itemCountDecoded
        let fileSizeBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fileSizeBytes)
        fileSizeBytes = fileSizeBytesDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

public struct DescribeQuerySuggestionsConfigInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeQuerySuggestionsConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeQuerySuggestionsConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeQuerySuggestionsConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeQuerySuggestionsConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeQuerySuggestionsConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeQuerySuggestionsConfigOutputError>
}

extension DescribeQuerySuggestionsConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeQuerySuggestionsConfigInput(indexId: \(Swift.String(describing: indexId)))"}
}

extension DescribeQuerySuggestionsConfigInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexId = "IndexId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
    }
}

public struct DescribeQuerySuggestionsConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeQuerySuggestionsConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeQuerySuggestionsConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeQuerySuggestionsConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeQuerySuggestionsConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeQuerySuggestionsConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeQuerySuggestionsConfigOutputError>
}

public struct DescribeQuerySuggestionsConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeQuerySuggestionsConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeQuerySuggestionsConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeQuerySuggestionsConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeQuerySuggestionsConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeQuerySuggestionsConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeQuerySuggestionsConfigOutputError>
}

public struct DescribeQuerySuggestionsConfigInput: Swift.Equatable {
    /// <p>The identifier of the index you want to describe query suggestions
    ///             settings for.</p>
    public let indexId: Swift.String?

    public init (
        indexId: Swift.String? = nil
    )
    {
        self.indexId = indexId
    }
}

struct DescribeQuerySuggestionsConfigInputBody: Swift.Equatable {
    public let indexId: Swift.String?
}

extension DescribeQuerySuggestionsConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexId = "IndexId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexId)
        indexId = indexIdDecoded
    }
}

extension DescribeQuerySuggestionsConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeQuerySuggestionsConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeQuerySuggestionsConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeQuerySuggestionsConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeQuerySuggestionsConfigOutputResponse(includeQueriesWithoutUserInformation: \(Swift.String(describing: includeQueriesWithoutUserInformation)), lastClearTime: \(Swift.String(describing: lastClearTime)), lastSuggestionsBuildTime: \(Swift.String(describing: lastSuggestionsBuildTime)), minimumNumberOfQueryingUsers: \(Swift.String(describing: minimumNumberOfQueryingUsers)), minimumQueryCount: \(Swift.String(describing: minimumQueryCount)), mode: \(Swift.String(describing: mode)), queryLogLookBackWindowInDays: \(Swift.String(describing: queryLogLookBackWindowInDays)), status: \(Swift.String(describing: status)), totalSuggestionsCount: \(Swift.String(describing: totalSuggestionsCount)))"}
}

extension DescribeQuerySuggestionsConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeQuerySuggestionsConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.includeQueriesWithoutUserInformation = output.includeQueriesWithoutUserInformation
            self.lastClearTime = output.lastClearTime
            self.lastSuggestionsBuildTime = output.lastSuggestionsBuildTime
            self.minimumNumberOfQueryingUsers = output.minimumNumberOfQueryingUsers
            self.minimumQueryCount = output.minimumQueryCount
            self.mode = output.mode
            self.queryLogLookBackWindowInDays = output.queryLogLookBackWindowInDays
            self.status = output.status
            self.totalSuggestionsCount = output.totalSuggestionsCount
        } else {
            self.includeQueriesWithoutUserInformation = nil
            self.lastClearTime = nil
            self.lastSuggestionsBuildTime = nil
            self.minimumNumberOfQueryingUsers = nil
            self.minimumQueryCount = nil
            self.mode = nil
            self.queryLogLookBackWindowInDays = nil
            self.status = nil
            self.totalSuggestionsCount = nil
        }
    }
}

public struct DescribeQuerySuggestionsConfigOutputResponse: Swift.Equatable {
    /// <p>Shows whether Amazon Kendra uses all queries or only uses queries that
    ///             include user information to generate query suggestions.</p>
    public let includeQueriesWithoutUserInformation: Swift.Bool?
    /// <p>Shows the date-time query suggestions for an index was last cleared.</p>
    ///         <p>After you clear suggestions, Amazon Kendra learns new suggestions based
    ///             on new queries added to the query log from the time you cleared suggestions.
    ///             Amazon Kendra only considers re-occurences of a query from the time you cleared
    ///             suggestions. </p>
    public let lastClearTime: ClientRuntime.Date?
    /// <p>Shows the date-time query suggestions for an index was last updated.</p>
    public let lastSuggestionsBuildTime: ClientRuntime.Date?
    /// <p>Shows the minimum number of unique users who must search a query in
    ///             order for the query to be eligible to suggest to your users.</p>
    public let minimumNumberOfQueryingUsers: Swift.Int?
    /// <p>Shows the minimum number of times a query must be searched in order for
    ///             the query to be eligible to suggest to your users.</p>
    public let minimumQueryCount: Swift.Int?
    /// <p>Shows whether query suggestions are currently in
    ///             <code>ENABLED</code> mode or <code>LEARN_ONLY</code> mode.</p>
    ///         <p>By default, Amazon Kendra enables query suggestions.<code>LEARN_ONLY</code>
    ///             turns off query suggestions for your users. You can change the mode using
    ///             the <a href="https://docs.aws.amazon.com/kendra/latest/dg/API_UpdateQuerySuggestionsConfig.html">UpdateQuerySuggestionsConfig</a>
    ///             operation.</p>
    public let mode: KendraClientTypes.Mode?
    /// <p>Shows how recent your queries are in your query log time
    ///             window (in days).</p>
    public let queryLogLookBackWindowInDays: Swift.Int?
    /// <p>Shows whether the status of query suggestions settings is currently
    ///             Active or Updating.</p>
    ///         <p>Active means the current settings apply and Updating means your
    ///             changed settings are in the process of applying.</p>
    public let status: KendraClientTypes.QuerySuggestionsStatus?
    /// <p>Shows the current total count of query suggestions for an index.</p>
    ///         <p>This count can change when you update your query suggestions settings,
    ///             if you filter out certain queries from suggestions using a block list,
    ///             and as the query log accumulates more queries for Amazon Kendra to learn from.</p>
    public let totalSuggestionsCount: Swift.Int?

    public init (
        includeQueriesWithoutUserInformation: Swift.Bool? = nil,
        lastClearTime: ClientRuntime.Date? = nil,
        lastSuggestionsBuildTime: ClientRuntime.Date? = nil,
        minimumNumberOfQueryingUsers: Swift.Int? = nil,
        minimumQueryCount: Swift.Int? = nil,
        mode: KendraClientTypes.Mode? = nil,
        queryLogLookBackWindowInDays: Swift.Int? = nil,
        status: KendraClientTypes.QuerySuggestionsStatus? = nil,
        totalSuggestionsCount: Swift.Int? = nil
    )
    {
        self.includeQueriesWithoutUserInformation = includeQueriesWithoutUserInformation
        self.lastClearTime = lastClearTime
        self.lastSuggestionsBuildTime = lastSuggestionsBuildTime
        self.minimumNumberOfQueryingUsers = minimumNumberOfQueryingUsers
        self.minimumQueryCount = minimumQueryCount
        self.mode = mode
        self.queryLogLookBackWindowInDays = queryLogLookBackWindowInDays
        self.status = status
        self.totalSuggestionsCount = totalSuggestionsCount
    }
}

struct DescribeQuerySuggestionsConfigOutputResponseBody: Swift.Equatable {
    public let mode: KendraClientTypes.Mode?
    public let status: KendraClientTypes.QuerySuggestionsStatus?
    public let queryLogLookBackWindowInDays: Swift.Int?
    public let includeQueriesWithoutUserInformation: Swift.Bool?
    public let minimumNumberOfQueryingUsers: Swift.Int?
    public let minimumQueryCount: Swift.Int?
    public let lastSuggestionsBuildTime: ClientRuntime.Date?
    public let lastClearTime: ClientRuntime.Date?
    public let totalSuggestionsCount: Swift.Int?
}

extension DescribeQuerySuggestionsConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case includeQueriesWithoutUserInformation = "IncludeQueriesWithoutUserInformation"
        case lastClearTime = "LastClearTime"
        case lastSuggestionsBuildTime = "LastSuggestionsBuildTime"
        case minimumNumberOfQueryingUsers = "MinimumNumberOfQueryingUsers"
        case minimumQueryCount = "MinimumQueryCount"
        case mode = "Mode"
        case queryLogLookBackWindowInDays = "QueryLogLookBackWindowInDays"
        case status = "Status"
        case totalSuggestionsCount = "TotalSuggestionsCount"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modeDecoded = try containerValues.decodeIfPresent(KendraClientTypes.Mode.self, forKey: .mode)
        mode = modeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(KendraClientTypes.QuerySuggestionsStatus.self, forKey: .status)
        status = statusDecoded
        let queryLogLookBackWindowInDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .queryLogLookBackWindowInDays)
        queryLogLookBackWindowInDays = queryLogLookBackWindowInDaysDecoded
        let includeQueriesWithoutUserInformationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeQueriesWithoutUserInformation)
        includeQueriesWithoutUserInformation = includeQueriesWithoutUserInformationDecoded
        let minimumNumberOfQueryingUsersDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minimumNumberOfQueryingUsers)
        minimumNumberOfQueryingUsers = minimumNumberOfQueryingUsersDecoded
        let minimumQueryCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minimumQueryCount)
        minimumQueryCount = minimumQueryCountDecoded
        let lastSuggestionsBuildTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastSuggestionsBuildTime)
        lastSuggestionsBuildTime = lastSuggestionsBuildTimeDecoded
        let lastClearTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastClearTime)
        lastClearTime = lastClearTimeDecoded
        let totalSuggestionsCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalSuggestionsCount)
        totalSuggestionsCount = totalSuggestionsCountDecoded
    }
}

public struct DescribeThesaurusInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeThesaurusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeThesaurusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeThesaurusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeThesaurusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeThesaurusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeThesaurusOutputError>
}

extension DescribeThesaurusInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeThesaurusInput(id: \(Swift.String(describing: id)), indexId: \(Swift.String(describing: indexId)))"}
}

extension DescribeThesaurusInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case indexId = "IndexId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
    }
}

public struct DescribeThesaurusInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeThesaurusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeThesaurusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeThesaurusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeThesaurusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeThesaurusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeThesaurusOutputError>
}

public struct DescribeThesaurusInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeThesaurusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeThesaurusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeThesaurusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeThesaurusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeThesaurusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeThesaurusOutputError>
}

public struct DescribeThesaurusInput: Swift.Equatable {
    /// <p>The identifier of the thesaurus to describe.</p>
    public let id: Swift.String?
    /// <p>The identifier of the index associated with the thesaurus to describe.</p>
    public let indexId: Swift.String?

    public init (
        id: Swift.String? = nil,
        indexId: Swift.String? = nil
    )
    {
        self.id = id
        self.indexId = indexId
    }
}

struct DescribeThesaurusInputBody: Swift.Equatable {
    public let id: Swift.String?
    public let indexId: Swift.String?
}

extension DescribeThesaurusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case indexId = "IndexId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let indexIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexId)
        indexId = indexIdDecoded
    }
}

extension DescribeThesaurusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeThesaurusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeThesaurusOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeThesaurusOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeThesaurusOutputResponse(createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), errorMessage: \(Swift.String(describing: errorMessage)), fileSizeBytes: \(Swift.String(describing: fileSizeBytes)), id: \(Swift.String(describing: id)), indexId: \(Swift.String(describing: indexId)), name: \(Swift.String(describing: name)), roleArn: \(Swift.String(describing: roleArn)), sourceS3Path: \(Swift.String(describing: sourceS3Path)), status: \(Swift.String(describing: status)), synonymRuleCount: \(Swift.String(describing: synonymRuleCount)), termCount: \(Swift.String(describing: termCount)), updatedAt: \(Swift.String(describing: updatedAt)))"}
}

extension DescribeThesaurusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeThesaurusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.description = output.description
            self.errorMessage = output.errorMessage
            self.fileSizeBytes = output.fileSizeBytes
            self.id = output.id
            self.indexId = output.indexId
            self.name = output.name
            self.roleArn = output.roleArn
            self.sourceS3Path = output.sourceS3Path
            self.status = output.status
            self.synonymRuleCount = output.synonymRuleCount
            self.termCount = output.termCount
            self.updatedAt = output.updatedAt
        } else {
            self.createdAt = nil
            self.description = nil
            self.errorMessage = nil
            self.fileSizeBytes = nil
            self.id = nil
            self.indexId = nil
            self.name = nil
            self.roleArn = nil
            self.sourceS3Path = nil
            self.status = nil
            self.synonymRuleCount = nil
            self.termCount = nil
            self.updatedAt = nil
        }
    }
}

public struct DescribeThesaurusOutputResponse: Swift.Equatable {
    /// <p>The Unix datetime that the thesaurus was created.</p>
    public let createdAt: ClientRuntime.Date?
    /// <p>The thesaurus description.</p>
    public let description: Swift.String?
    /// <p>When the <code>Status</code> field value is <code>FAILED</code>, the
    ///          <code>ErrorMessage</code> field provides more information.
    ///       </p>
    public let errorMessage: Swift.String?
    /// <p>The size of the thesaurus file in bytes.</p>
    public let fileSizeBytes: Swift.Int?
    /// <p>The identifier of the thesaurus.</p>
    public let id: Swift.String?
    /// <p>The identifier of the index associated with the thesaurus to describe.</p>
    public let indexId: Swift.String?
    /// <p>The thesaurus name.</p>
    public let name: Swift.String?
    /// <p>An AWS Identity and Access Management (IAM) role that gives Amazon Kendra permissions
    ///          to access thesaurus file specified in <code>SourceS3Path</code>.
    ///       </p>
    public let roleArn: Swift.String?
    /// <p>Information required to find a specific file in an Amazon S3
    ///             bucket.</p>
    public let sourceS3Path: KendraClientTypes.S3Path?
    /// <p>The current status of the thesaurus. When the value is <code>ACTIVE</code>,
    ///          queries are able to use the thesaurus. If the <code>Status</code> field value
    ///          is <code>FAILED</code>, the <code>ErrorMessage</code> field provides
    ///          more information.
    ///       </p>
    ///          <p>If the status is <code>ACTIVE_BUT_UPDATE_FAILED</code>, it means
    ///       that Amazon Kendra could not ingest the new thesaurus file. The old
    ///       thesaurus file is still active.
    ///       </p>
    public let status: KendraClientTypes.ThesaurusStatus?
    /// <p>The number of synonym rules in the thesaurus file.</p>
    public let synonymRuleCount: Swift.Int?
    /// <p>The number of unique terms in the thesaurus file. For example, the
    ///         synonyms <code>a,b,c</code> and <code>a=>d</code>, the term
    ///         count would be 4.
    ///       </p>
    public let termCount: Swift.Int?
    /// <p>The Unix datetime that the thesaurus was last updated.</p>
    public let updatedAt: ClientRuntime.Date?

    public init (
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        errorMessage: Swift.String? = nil,
        fileSizeBytes: Swift.Int? = nil,
        id: Swift.String? = nil,
        indexId: Swift.String? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        sourceS3Path: KendraClientTypes.S3Path? = nil,
        status: KendraClientTypes.ThesaurusStatus? = nil,
        synonymRuleCount: Swift.Int? = nil,
        termCount: Swift.Int? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.createdAt = createdAt
        self.description = description
        self.errorMessage = errorMessage
        self.fileSizeBytes = fileSizeBytes
        self.id = id
        self.indexId = indexId
        self.name = name
        self.roleArn = roleArn
        self.sourceS3Path = sourceS3Path
        self.status = status
        self.synonymRuleCount = synonymRuleCount
        self.termCount = termCount
        self.updatedAt = updatedAt
    }
}

struct DescribeThesaurusOutputResponseBody: Swift.Equatable {
    public let id: Swift.String?
    public let indexId: Swift.String?
    public let name: Swift.String?
    public let description: Swift.String?
    public let status: KendraClientTypes.ThesaurusStatus?
    public let errorMessage: Swift.String?
    public let createdAt: ClientRuntime.Date?
    public let updatedAt: ClientRuntime.Date?
    public let roleArn: Swift.String?
    public let sourceS3Path: KendraClientTypes.S3Path?
    public let fileSizeBytes: Swift.Int?
    public let termCount: Swift.Int?
    public let synonymRuleCount: Swift.Int?
}

extension DescribeThesaurusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case description = "Description"
        case errorMessage = "ErrorMessage"
        case fileSizeBytes = "FileSizeBytes"
        case id = "Id"
        case indexId = "IndexId"
        case name = "Name"
        case roleArn = "RoleArn"
        case sourceS3Path = "SourceS3Path"
        case status = "Status"
        case synonymRuleCount = "SynonymRuleCount"
        case termCount = "TermCount"
        case updatedAt = "UpdatedAt"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let indexIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexId)
        indexId = indexIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(KendraClientTypes.ThesaurusStatus.self, forKey: .status)
        status = statusDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let sourceS3PathDecoded = try containerValues.decodeIfPresent(KendraClientTypes.S3Path.self, forKey: .sourceS3Path)
        sourceS3Path = sourceS3PathDecoded
        let fileSizeBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fileSizeBytes)
        fileSizeBytes = fileSizeBytesDecoded
        let termCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .termCount)
        termCount = termCountDecoded
        let synonymRuleCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .synonymRuleCount)
        synonymRuleCount = synonymRuleCountDecoded
    }
}

extension KendraClientTypes.Document: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessControlList = "AccessControlList"
        case attributes = "Attributes"
        case blob = "Blob"
        case contentType = "ContentType"
        case id = "Id"
        case s3Path = "S3Path"
        case title = "Title"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessControlList = accessControlList {
            var accessControlListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accessControlList)
            for principallist0 in accessControlList {
                try accessControlListContainer.encode(principallist0)
            }
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for documentattributelist0 in attributes {
                try attributesContainer.encode(documentattributelist0)
            }
        }
        if let blob = blob {
            try encodeContainer.encode(blob.base64EncodedString(), forKey: .blob)
        }
        if let contentType = contentType {
            try encodeContainer.encode(contentType.rawValue, forKey: .contentType)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let s3Path = s3Path {
            try encodeContainer.encode(s3Path, forKey: .s3Path)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let blobDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .blob)
        blob = blobDecoded
        let s3PathDecoded = try containerValues.decodeIfPresent(KendraClientTypes.S3Path.self, forKey: .s3Path)
        s3Path = s3PathDecoded
        let attributesContainer = try containerValues.decodeIfPresent([KendraClientTypes.DocumentAttribute?].self, forKey: .attributes)
        var attributesDecoded0:[KendraClientTypes.DocumentAttribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [KendraClientTypes.DocumentAttribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
        let accessControlListContainer = try containerValues.decodeIfPresent([KendraClientTypes.Principal?].self, forKey: .accessControlList)
        var accessControlListDecoded0:[KendraClientTypes.Principal]? = nil
        if let accessControlListContainer = accessControlListContainer {
            accessControlListDecoded0 = [KendraClientTypes.Principal]()
            for structure0 in accessControlListContainer {
                if let structure0 = structure0 {
                    accessControlListDecoded0?.append(structure0)
                }
            }
        }
        accessControlList = accessControlListDecoded0
        let contentTypeDecoded = try containerValues.decodeIfPresent(KendraClientTypes.ContentType.self, forKey: .contentType)
        contentType = contentTypeDecoded
    }
}

extension KendraClientTypes.Document: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Document(accessControlList: \(Swift.String(describing: accessControlList)), attributes: \(Swift.String(describing: attributes)), blob: \(Swift.String(describing: blob)), contentType: \(Swift.String(describing: contentType)), id: \(Swift.String(describing: id)), s3Path: \(Swift.String(describing: s3Path)), title: \(Swift.String(describing: title)))"}
}

extension KendraClientTypes {
    /// <p>A document in an index.</p>
    public struct Document: Swift.Equatable {
        /// <p>Information to use for user context filtering.</p>
        public let accessControlList: [KendraClientTypes.Principal]?
        /// <p>Custom attributes to apply to the document. Use the custom
        ///             attributes to provide additional information for searching, to
        ///             provide facets for refining searches, and to provide additional
        ///             information in the query response.</p>
        public let attributes: [KendraClientTypes.DocumentAttribute]?
        /// <p>The contents of the document. </p>
        ///         <p>Documents passed to the <code>Blob</code> parameter must be base64
        ///             encoded. Your code might not need to encode the document file bytes
        ///             if you're using an AWS SDK to call Amazon Kendra operations. If you are
        ///             calling the Amazon Kendra endpoint directly using REST, you must base64
        ///             encode the contents before sending.</p>
        public let blob: ClientRuntime.Data?
        /// <p>The file type of the document in the <code>Blob</code>
        ///             field.</p>
        public let contentType: KendraClientTypes.ContentType?
        /// <p>A unique identifier of the document in the index.</p>
        public let id: Swift.String?
        /// <p>Information required to find a specific file in an Amazon S3
        ///             bucket.</p>
        public let s3Path: KendraClientTypes.S3Path?
        /// <p>The title of the document.</p>
        public let title: Swift.String?

        public init (
            accessControlList: [KendraClientTypes.Principal]? = nil,
            attributes: [KendraClientTypes.DocumentAttribute]? = nil,
            blob: ClientRuntime.Data? = nil,
            contentType: KendraClientTypes.ContentType? = nil,
            id: Swift.String? = nil,
            s3Path: KendraClientTypes.S3Path? = nil,
            title: Swift.String? = nil
        )
        {
            self.accessControlList = accessControlList
            self.attributes = attributes
            self.blob = blob
            self.contentType = contentType
            self.id = id
            self.s3Path = s3Path
            self.title = title
        }
    }

}

extension KendraClientTypes.DocumentAttribute: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(KendraClientTypes.DocumentAttributeValue.self, forKey: .value)
        value = valueDecoded
    }
}

extension KendraClientTypes.DocumentAttribute: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DocumentAttribute(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension KendraClientTypes {
    /// <p>A custom attribute value assigned to a document. </p>
    public struct DocumentAttribute: Swift.Equatable {
        /// <p>The identifier for the attribute.</p>
        public let key: Swift.String?
        /// <p>The value of the attribute.</p>
        public let value: KendraClientTypes.DocumentAttributeValue?

        public init (
            key: Swift.String? = nil,
            value: KendraClientTypes.DocumentAttributeValue? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension KendraClientTypes.DocumentAttributeValue: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datevalue = "DateValue"
        case longvalue = "LongValue"
        case stringlistvalue = "StringListValue"
        case stringvalue = "StringValue"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .datevalue(datevalue):
                try container.encode(datevalue.timeIntervalSince1970, forKey: .datevalue)
            case let .longvalue(longvalue):
                try container.encode(longvalue, forKey: .longvalue)
            case let .stringlistvalue(stringlistvalue):
                var stringlistvalueContainer = container.nestedUnkeyedContainer(forKey: .stringlistvalue)
                for documentattributestringlistvalue0 in stringlistvalue {
                    try stringlistvalueContainer.encode(documentattributestringlistvalue0)
                }
            case let .stringvalue(stringvalue):
                try container.encode(stringvalue, forKey: .stringvalue)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let stringvalueDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .stringvalue)
        if let stringvalue = stringvalueDecoded {
            self = .stringvalue(stringvalue)
            return
        }
        let stringlistvalueContainer = try values.decodeIfPresent([Swift.String?].self, forKey: .stringlistvalue)
        var stringlistvalueDecoded0:[Swift.String]? = nil
        if let stringlistvalueContainer = stringlistvalueContainer {
            stringlistvalueDecoded0 = [Swift.String]()
            for string0 in stringlistvalueContainer {
                if let string0 = string0 {
                    stringlistvalueDecoded0?.append(string0)
                }
            }
        }
        if let stringlistvalue = stringlistvalueDecoded0 {
            self = .stringlistvalue(stringlistvalue)
            return
        }
        let longvalueDecoded = try values.decodeIfPresent(Swift.Int.self, forKey: .longvalue)
        if let longvalue = longvalueDecoded {
            self = .longvalue(longvalue)
            return
        }
        let datevalueDecoded = try values.decodeIfPresent(ClientRuntime.Date.self, forKey: .datevalue)
        if let datevalue = datevalueDecoded {
            self = .datevalue(datevalue)
            return
        }
        self = .sdkUnknown("")
    }
}

extension KendraClientTypes {
    /// <p>The value of a custom document attribute. You can only provide one
    ///             value for a custom attribute.</p>
    public enum DocumentAttributeValue: Swift.Equatable {
        /// <p>A string, such as "department".</p>
        case stringvalue(Swift.String)
        /// <p>A list of strings. </p>
        case stringlistvalue([Swift.String])
        /// <p>A long integer value.</p>
        case longvalue(Swift.Int)
        /// <p>A date expressed as an ISO 8601 string.</p>
        case datevalue(ClientRuntime.Date)
        case sdkUnknown(Swift.String)
    }

}

extension KendraClientTypes.DocumentAttributeValueCountPair: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case count = "Count"
        case documentAttributeValue = "DocumentAttributeValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let count = count {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let documentAttributeValue = documentAttributeValue {
            try encodeContainer.encode(documentAttributeValue, forKey: .documentAttributeValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentAttributeValueDecoded = try containerValues.decodeIfPresent(KendraClientTypes.DocumentAttributeValue.self, forKey: .documentAttributeValue)
        documentAttributeValue = documentAttributeValueDecoded
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count)
        count = countDecoded
    }
}

extension KendraClientTypes.DocumentAttributeValueCountPair: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DocumentAttributeValueCountPair(count: \(Swift.String(describing: count)), documentAttributeValue: \(Swift.String(describing: documentAttributeValue)))"}
}

extension KendraClientTypes {
    /// <p>Provides the count of documents that match a particular attribute
    ///             when doing a faceted search.</p>
    public struct DocumentAttributeValueCountPair: Swift.Equatable {
        /// <p>The number of documents in the response that have the attribute
        ///             value for the key.</p>
        public let count: Swift.Int?
        /// <p>The value of the attribute. For example, "HR."</p>
        public let documentAttributeValue: KendraClientTypes.DocumentAttributeValue?

        public init (
            count: Swift.Int? = nil,
            documentAttributeValue: KendraClientTypes.DocumentAttributeValue? = nil
        )
        {
            self.count = count
            self.documentAttributeValue = documentAttributeValue
        }
    }

}

extension KendraClientTypes {
    public enum DocumentAttributeValueType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dateValue
        case longValue
        case stringListValue
        case stringValue
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentAttributeValueType] {
            return [
                .dateValue,
                .longValue,
                .stringListValue,
                .stringValue,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dateValue: return "DATE_VALUE"
            case .longValue: return "LONG_VALUE"
            case .stringListValue: return "STRING_LIST_VALUE"
            case .stringValue: return "STRING_VALUE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DocumentAttributeValueType(rawValue: rawValue) ?? DocumentAttributeValueType.sdkUnknown(rawValue)
        }
    }
}

extension KendraClientTypes.DocumentMetadataConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case relevance = "Relevance"
        case search = "Search"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let relevance = relevance {
            try encodeContainer.encode(relevance, forKey: .relevance)
        }
        if let search = search {
            try encodeContainer.encode(search, forKey: .search)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(KendraClientTypes.DocumentAttributeValueType.self, forKey: .type)
        type = typeDecoded
        let relevanceDecoded = try containerValues.decodeIfPresent(KendraClientTypes.Relevance.self, forKey: .relevance)
        relevance = relevanceDecoded
        let searchDecoded = try containerValues.decodeIfPresent(KendraClientTypes.Search.self, forKey: .search)
        search = searchDecoded
    }
}

extension KendraClientTypes.DocumentMetadataConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DocumentMetadataConfiguration(name: \(Swift.String(describing: name)), relevance: \(Swift.String(describing: relevance)), search: \(Swift.String(describing: search)), type: \(Swift.String(describing: type)))"}
}

extension KendraClientTypes {
    /// <p>Specifies the properties of a custom index field.</p>
    public struct DocumentMetadataConfiguration: Swift.Equatable {
        /// <p>The name of the index field.</p>
        public let name: Swift.String?
        /// <p>Provides manual tuning parameters to determine how the field
        ///             affects the search results.</p>
        public let relevance: KendraClientTypes.Relevance?
        /// <p>Provides information about how the field is used during a
        ///             search.</p>
        public let search: KendraClientTypes.Search?
        /// <p>The data type of the index field. </p>
        public let type: KendraClientTypes.DocumentAttributeValueType?

        public init (
            name: Swift.String? = nil,
            relevance: KendraClientTypes.Relevance? = nil,
            search: KendraClientTypes.Search? = nil,
            type: KendraClientTypes.DocumentAttributeValueType? = nil
        )
        {
            self.name = name
            self.relevance = relevance
            self.search = search
            self.type = type
        }
    }

}

extension KendraClientTypes.DocumentRelevanceConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case relevance = "Relevance"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let relevance = relevance {
            try encodeContainer.encode(relevance, forKey: .relevance)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let relevanceDecoded = try containerValues.decodeIfPresent(KendraClientTypes.Relevance.self, forKey: .relevance)
        relevance = relevanceDecoded
    }
}

extension KendraClientTypes.DocumentRelevanceConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DocumentRelevanceConfiguration(name: \(Swift.String(describing: name)), relevance: \(Swift.String(describing: relevance)))"}
}

extension KendraClientTypes {
    /// <p>Overrides the document relevance properties of a custom index field.</p>
    public struct DocumentRelevanceConfiguration: Swift.Equatable {
        /// <p>The name of the tuning configuration to override document relevance
        ///          at the index level.</p>
        public let name: Swift.String?
        /// <p>Provides information for manually tuning the relevance of a field
        ///             in a search. When a query includes terms that match the field, the
        ///             results are given a boost in the response based on these tuning
        ///             parameters.</p>
        public let relevance: KendraClientTypes.Relevance?

        public init (
            name: Swift.String? = nil,
            relevance: KendraClientTypes.Relevance? = nil
        )
        {
            self.name = name
            self.relevance = relevance
        }
    }

}

extension KendraClientTypes.DocumentsMetadataConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Prefix = "S3Prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Prefix = s3Prefix {
            try encodeContainer.encode(s3Prefix, forKey: .s3Prefix)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3PrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Prefix)
        s3Prefix = s3PrefixDecoded
    }
}

extension KendraClientTypes.DocumentsMetadataConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DocumentsMetadataConfiguration(s3Prefix: \(Swift.String(describing: s3Prefix)))"}
}

extension KendraClientTypes {
    /// <p>Document metadata files that contain information such as the
    ///             document access control information, source URI, document author,
    ///             and custom attributes. Each metadata file contains metadata about a
    ///             single document.</p>
    public struct DocumentsMetadataConfiguration: Swift.Equatable {
        /// <p>A prefix used to filter metadata configuration files in the AWS S3
        ///             bucket. The S3 bucket might contain multiple metadata files. Use
        ///                 <code>S3Prefix</code> to include only the desired metadata
        ///             files.</p>
        public let s3Prefix: Swift.String?

        public init (
            s3Prefix: Swift.String? = nil
        )
        {
            self.s3Prefix = s3Prefix
        }
    }

}

extension KendraClientTypes {
    public enum ErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case internalError
        case invalidRequest
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCode] {
            return [
                .internalError,
                .invalidRequest,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .internalError: return "InternalError"
            case .invalidRequest: return "InvalidRequest"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ErrorCode(rawValue: rawValue) ?? ErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension KendraClientTypes.Facet: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentAttributeKey = "DocumentAttributeKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentAttributeKey = documentAttributeKey {
            try encodeContainer.encode(documentAttributeKey, forKey: .documentAttributeKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentAttributeKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentAttributeKey)
        documentAttributeKey = documentAttributeKeyDecoded
    }
}

extension KendraClientTypes.Facet: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Facet(documentAttributeKey: \(Swift.String(describing: documentAttributeKey)))"}
}

extension KendraClientTypes {
    /// <p>Information about a document attribute</p>
    public struct Facet: Swift.Equatable {
        /// <p>The unique key for the document attribute.</p>
        public let documentAttributeKey: Swift.String?

        public init (
            documentAttributeKey: Swift.String? = nil
        )
        {
            self.documentAttributeKey = documentAttributeKey
        }
    }

}

extension KendraClientTypes.FacetResult: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentAttributeKey = "DocumentAttributeKey"
        case documentAttributeValueCountPairs = "DocumentAttributeValueCountPairs"
        case documentAttributeValueType = "DocumentAttributeValueType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentAttributeKey = documentAttributeKey {
            try encodeContainer.encode(documentAttributeKey, forKey: .documentAttributeKey)
        }
        if let documentAttributeValueCountPairs = documentAttributeValueCountPairs {
            var documentAttributeValueCountPairsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .documentAttributeValueCountPairs)
            for documentattributevaluecountpairlist0 in documentAttributeValueCountPairs {
                try documentAttributeValueCountPairsContainer.encode(documentattributevaluecountpairlist0)
            }
        }
        if let documentAttributeValueType = documentAttributeValueType {
            try encodeContainer.encode(documentAttributeValueType.rawValue, forKey: .documentAttributeValueType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentAttributeKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentAttributeKey)
        documentAttributeKey = documentAttributeKeyDecoded
        let documentAttributeValueTypeDecoded = try containerValues.decodeIfPresent(KendraClientTypes.DocumentAttributeValueType.self, forKey: .documentAttributeValueType)
        documentAttributeValueType = documentAttributeValueTypeDecoded
        let documentAttributeValueCountPairsContainer = try containerValues.decodeIfPresent([KendraClientTypes.DocumentAttributeValueCountPair?].self, forKey: .documentAttributeValueCountPairs)
        var documentAttributeValueCountPairsDecoded0:[KendraClientTypes.DocumentAttributeValueCountPair]? = nil
        if let documentAttributeValueCountPairsContainer = documentAttributeValueCountPairsContainer {
            documentAttributeValueCountPairsDecoded0 = [KendraClientTypes.DocumentAttributeValueCountPair]()
            for structure0 in documentAttributeValueCountPairsContainer {
                if let structure0 = structure0 {
                    documentAttributeValueCountPairsDecoded0?.append(structure0)
                }
            }
        }
        documentAttributeValueCountPairs = documentAttributeValueCountPairsDecoded0
    }
}

extension KendraClientTypes.FacetResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FacetResult(documentAttributeKey: \(Swift.String(describing: documentAttributeKey)), documentAttributeValueCountPairs: \(Swift.String(describing: documentAttributeValueCountPairs)), documentAttributeValueType: \(Swift.String(describing: documentAttributeValueType)))"}
}

extension KendraClientTypes {
    /// <p>The facet values for the documents in the response.</p>
    public struct FacetResult: Swift.Equatable {
        /// <p>The key for the facet values. This is the same as the
        ///             <code>DocumentAttributeKey</code> provided in the query.</p>
        public let documentAttributeKey: Swift.String?
        /// <p>An array of key/value pairs, where the key is the value of the
        ///          attribute and the count is the number of documents that share the key
        ///          value.</p>
        public let documentAttributeValueCountPairs: [KendraClientTypes.DocumentAttributeValueCountPair]?
        /// <p>The data type of the facet value. This is the same as the type
        ///          defined for the index field when it was created.</p>
        public let documentAttributeValueType: KendraClientTypes.DocumentAttributeValueType?

        public init (
            documentAttributeKey: Swift.String? = nil,
            documentAttributeValueCountPairs: [KendraClientTypes.DocumentAttributeValueCountPair]? = nil,
            documentAttributeValueType: KendraClientTypes.DocumentAttributeValueType? = nil
        )
        {
            self.documentAttributeKey = documentAttributeKey
            self.documentAttributeValueCountPairs = documentAttributeValueCountPairs
            self.documentAttributeValueType = documentAttributeValueType
        }
    }

}

extension KendraClientTypes {
    public enum FaqFileFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case csv
        case csvWithHeader
        case json
        case sdkUnknown(Swift.String)

        public static var allCases: [FaqFileFormat] {
            return [
                .csv,
                .csvWithHeader,
                .json,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .csv: return "CSV"
            case .csvWithHeader: return "CSV_WITH_HEADER"
            case .json: return "JSON"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FaqFileFormat(rawValue: rawValue) ?? FaqFileFormat.sdkUnknown(rawValue)
        }
    }
}

extension KendraClientTypes.FaqStatistics: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexedQuestionAnswersCount = "IndexedQuestionAnswersCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if indexedQuestionAnswersCount != 0 {
            try encodeContainer.encode(indexedQuestionAnswersCount, forKey: .indexedQuestionAnswersCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexedQuestionAnswersCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .indexedQuestionAnswersCount)
        indexedQuestionAnswersCount = indexedQuestionAnswersCountDecoded
    }
}

extension KendraClientTypes.FaqStatistics: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FaqStatistics(indexedQuestionAnswersCount: \(Swift.String(describing: indexedQuestionAnswersCount)))"}
}

extension KendraClientTypes {
    /// <p>Provides statistical information about the FAQ questions and
    ///             answers contained in an index.</p>
    public struct FaqStatistics: Swift.Equatable {
        /// <p>The total number of FAQ questions and answers contained in the
        ///             index.</p>
        public let indexedQuestionAnswersCount: Swift.Int

        public init (
            indexedQuestionAnswersCount: Swift.Int = 0
        )
        {
            self.indexedQuestionAnswersCount = indexedQuestionAnswersCount
        }
    }

}

extension KendraClientTypes {
    public enum FaqStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleting
        case failed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [FaqStatus] {
            return [
                .active,
                .creating,
                .deleting,
                .failed,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FaqStatus(rawValue: rawValue) ?? FaqStatus.sdkUnknown(rawValue)
        }
    }
}

extension KendraClientTypes.FaqSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case fileFormat = "FileFormat"
        case id = "Id"
        case name = "Name"
        case status = "Status"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let fileFormat = fileFormat {
            try encodeContainer.encode(fileFormat.rawValue, forKey: .fileFormat)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(KendraClientTypes.FaqStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let fileFormatDecoded = try containerValues.decodeIfPresent(KendraClientTypes.FaqFileFormat.self, forKey: .fileFormat)
        fileFormat = fileFormatDecoded
    }
}

extension KendraClientTypes.FaqSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FaqSummary(createdAt: \(Swift.String(describing: createdAt)), fileFormat: \(Swift.String(describing: fileFormat)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)))"}
}

extension KendraClientTypes {
    /// <p>Provides information about a frequently asked questions and answer
    ///             contained in an index.</p>
    public struct FaqSummary: Swift.Equatable {
        /// <p>The UNIX datetime that the FAQ was added to the index.</p>
        public let createdAt: ClientRuntime.Date?
        /// <p>The file type used to create the FAQ. </p>
        public let fileFormat: KendraClientTypes.FaqFileFormat?
        /// <p>The unique identifier of the FAQ.</p>
        public let id: Swift.String?
        /// <p>The name that you assigned the FAQ when you created or updated the
        ///             FAQ.</p>
        public let name: Swift.String?
        /// <p>The current status of the FAQ. When the status is
        ///                 <code>ACTIVE</code> the FAQ is ready for use.</p>
        public let status: KendraClientTypes.FaqStatus?
        /// <p>The UNIX datetime that the FAQ was last updated.</p>
        public let updatedAt: ClientRuntime.Date?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            fileFormat: KendraClientTypes.FaqFileFormat? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            status: KendraClientTypes.FaqStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.fileFormat = fileFormat
            self.id = id
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
        }
    }

}

public struct GetQuerySuggestionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetQuerySuggestionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetQuerySuggestionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetQuerySuggestionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetQuerySuggestionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetQuerySuggestionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetQuerySuggestionsOutputError>
}

extension GetQuerySuggestionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetQuerySuggestionsInput(indexId: \(Swift.String(describing: indexId)), maxSuggestionsCount: \(Swift.String(describing: maxSuggestionsCount)), queryText: \(Swift.String(describing: queryText)))"}
}

extension GetQuerySuggestionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexId = "IndexId"
        case maxSuggestionsCount = "MaxSuggestionsCount"
        case queryText = "QueryText"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
        if let maxSuggestionsCount = maxSuggestionsCount {
            try encodeContainer.encode(maxSuggestionsCount, forKey: .maxSuggestionsCount)
        }
        if let queryText = queryText {
            try encodeContainer.encode(queryText, forKey: .queryText)
        }
    }
}

public struct GetQuerySuggestionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetQuerySuggestionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetQuerySuggestionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetQuerySuggestionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetQuerySuggestionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetQuerySuggestionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetQuerySuggestionsOutputError>
}

public struct GetQuerySuggestionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetQuerySuggestionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetQuerySuggestionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetQuerySuggestionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetQuerySuggestionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetQuerySuggestionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetQuerySuggestionsOutputError>
}

public struct GetQuerySuggestionsInput: Swift.Equatable {
    /// <p>The identifier of the index you want to get query suggestions from.</p>
    public let indexId: Swift.String?
    /// <p>The maximum number of query suggestions you want to show
    ///             to your users.</p>
    public let maxSuggestionsCount: Swift.Int?
    /// <p>The text of a user's query to generate query suggestions.</p>
    ///         <p>A query is suggested if the query prefix matches
    ///             what a user starts to type as their query.</p>
    ///         <p>Amazon Kendra does not show any suggestions if a user
    ///             types fewer than two characters or more than 60 characters.
    ///             A query must also have at least one search result and contain
    ///             at least one word of more than four characters.</p>
    public let queryText: Swift.String?

    public init (
        indexId: Swift.String? = nil,
        maxSuggestionsCount: Swift.Int? = nil,
        queryText: Swift.String? = nil
    )
    {
        self.indexId = indexId
        self.maxSuggestionsCount = maxSuggestionsCount
        self.queryText = queryText
    }
}

struct GetQuerySuggestionsInputBody: Swift.Equatable {
    public let indexId: Swift.String?
    public let queryText: Swift.String?
    public let maxSuggestionsCount: Swift.Int?
}

extension GetQuerySuggestionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexId = "IndexId"
        case maxSuggestionsCount = "MaxSuggestionsCount"
        case queryText = "QueryText"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexId)
        indexId = indexIdDecoded
        let queryTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryText)
        queryText = queryTextDecoded
        let maxSuggestionsCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxSuggestionsCount)
        maxSuggestionsCount = maxSuggestionsCountDecoded
    }
}

extension GetQuerySuggestionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetQuerySuggestionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetQuerySuggestionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetQuerySuggestionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetQuerySuggestionsOutputResponse(querySuggestionsId: \(Swift.String(describing: querySuggestionsId)), suggestions: \(Swift.String(describing: suggestions)))"}
}

extension GetQuerySuggestionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetQuerySuggestionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.querySuggestionsId = output.querySuggestionsId
            self.suggestions = output.suggestions
        } else {
            self.querySuggestionsId = nil
            self.suggestions = nil
        }
    }
}

public struct GetQuerySuggestionsOutputResponse: Swift.Equatable {
    /// <p>The unique identifier for a list of query suggestions for an index.</p>
    public let querySuggestionsId: Swift.String?
    /// <p>A list of query suggestions for an index.</p>
    public let suggestions: [KendraClientTypes.Suggestion]?

    public init (
        querySuggestionsId: Swift.String? = nil,
        suggestions: [KendraClientTypes.Suggestion]? = nil
    )
    {
        self.querySuggestionsId = querySuggestionsId
        self.suggestions = suggestions
    }
}

struct GetQuerySuggestionsOutputResponseBody: Swift.Equatable {
    public let querySuggestionsId: Swift.String?
    public let suggestions: [KendraClientTypes.Suggestion]?
}

extension GetQuerySuggestionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case querySuggestionsId = "QuerySuggestionsId"
        case suggestions = "Suggestions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let querySuggestionsIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .querySuggestionsId)
        querySuggestionsId = querySuggestionsIdDecoded
        let suggestionsContainer = try containerValues.decodeIfPresent([KendraClientTypes.Suggestion?].self, forKey: .suggestions)
        var suggestionsDecoded0:[KendraClientTypes.Suggestion]? = nil
        if let suggestionsContainer = suggestionsContainer {
            suggestionsDecoded0 = [KendraClientTypes.Suggestion]()
            for structure0 in suggestionsContainer {
                if let structure0 = structure0 {
                    suggestionsDecoded0?.append(structure0)
                }
            }
        }
        suggestions = suggestionsDecoded0
    }
}

extension KendraClientTypes.GoogleDriveConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case excludeMimeTypes = "ExcludeMimeTypes"
        case excludeSharedDrives = "ExcludeSharedDrives"
        case excludeUserAccounts = "ExcludeUserAccounts"
        case exclusionPatterns = "ExclusionPatterns"
        case fieldMappings = "FieldMappings"
        case inclusionPatterns = "InclusionPatterns"
        case secretArn = "SecretArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let excludeMimeTypes = excludeMimeTypes {
            var excludeMimeTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .excludeMimeTypes)
            for excludemimetypeslist0 in excludeMimeTypes {
                try excludeMimeTypesContainer.encode(excludemimetypeslist0)
            }
        }
        if let excludeSharedDrives = excludeSharedDrives {
            var excludeSharedDrivesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .excludeSharedDrives)
            for excludeshareddriveslist0 in excludeSharedDrives {
                try excludeSharedDrivesContainer.encode(excludeshareddriveslist0)
            }
        }
        if let excludeUserAccounts = excludeUserAccounts {
            var excludeUserAccountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .excludeUserAccounts)
            for excludeuseraccountslist0 in excludeUserAccounts {
                try excludeUserAccountsContainer.encode(excludeuseraccountslist0)
            }
        }
        if let exclusionPatterns = exclusionPatterns {
            var exclusionPatternsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .exclusionPatterns)
            for datasourceinclusionsexclusionsstrings0 in exclusionPatterns {
                try exclusionPatternsContainer.encode(datasourceinclusionsexclusionsstrings0)
            }
        }
        if let fieldMappings = fieldMappings {
            var fieldMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fieldMappings)
            for datasourcetoindexfieldmappinglist0 in fieldMappings {
                try fieldMappingsContainer.encode(datasourcetoindexfieldmappinglist0)
            }
        }
        if let inclusionPatterns = inclusionPatterns {
            var inclusionPatternsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inclusionPatterns)
            for datasourceinclusionsexclusionsstrings0 in inclusionPatterns {
                try inclusionPatternsContainer.encode(datasourceinclusionsexclusionsstrings0)
            }
        }
        if let secretArn = secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let inclusionPatternsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .inclusionPatterns)
        var inclusionPatternsDecoded0:[Swift.String]? = nil
        if let inclusionPatternsContainer = inclusionPatternsContainer {
            inclusionPatternsDecoded0 = [Swift.String]()
            for string0 in inclusionPatternsContainer {
                if let string0 = string0 {
                    inclusionPatternsDecoded0?.append(string0)
                }
            }
        }
        inclusionPatterns = inclusionPatternsDecoded0
        let exclusionPatternsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .exclusionPatterns)
        var exclusionPatternsDecoded0:[Swift.String]? = nil
        if let exclusionPatternsContainer = exclusionPatternsContainer {
            exclusionPatternsDecoded0 = [Swift.String]()
            for string0 in exclusionPatternsContainer {
                if let string0 = string0 {
                    exclusionPatternsDecoded0?.append(string0)
                }
            }
        }
        exclusionPatterns = exclusionPatternsDecoded0
        let fieldMappingsContainer = try containerValues.decodeIfPresent([KendraClientTypes.DataSourceToIndexFieldMapping?].self, forKey: .fieldMappings)
        var fieldMappingsDecoded0:[KendraClientTypes.DataSourceToIndexFieldMapping]? = nil
        if let fieldMappingsContainer = fieldMappingsContainer {
            fieldMappingsDecoded0 = [KendraClientTypes.DataSourceToIndexFieldMapping]()
            for structure0 in fieldMappingsContainer {
                if let structure0 = structure0 {
                    fieldMappingsDecoded0?.append(structure0)
                }
            }
        }
        fieldMappings = fieldMappingsDecoded0
        let excludeMimeTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .excludeMimeTypes)
        var excludeMimeTypesDecoded0:[Swift.String]? = nil
        if let excludeMimeTypesContainer = excludeMimeTypesContainer {
            excludeMimeTypesDecoded0 = [Swift.String]()
            for string0 in excludeMimeTypesContainer {
                if let string0 = string0 {
                    excludeMimeTypesDecoded0?.append(string0)
                }
            }
        }
        excludeMimeTypes = excludeMimeTypesDecoded0
        let excludeUserAccountsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .excludeUserAccounts)
        var excludeUserAccountsDecoded0:[Swift.String]? = nil
        if let excludeUserAccountsContainer = excludeUserAccountsContainer {
            excludeUserAccountsDecoded0 = [Swift.String]()
            for string0 in excludeUserAccountsContainer {
                if let string0 = string0 {
                    excludeUserAccountsDecoded0?.append(string0)
                }
            }
        }
        excludeUserAccounts = excludeUserAccountsDecoded0
        let excludeSharedDrivesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .excludeSharedDrives)
        var excludeSharedDrivesDecoded0:[Swift.String]? = nil
        if let excludeSharedDrivesContainer = excludeSharedDrivesContainer {
            excludeSharedDrivesDecoded0 = [Swift.String]()
            for string0 in excludeSharedDrivesContainer {
                if let string0 = string0 {
                    excludeSharedDrivesDecoded0?.append(string0)
                }
            }
        }
        excludeSharedDrives = excludeSharedDrivesDecoded0
    }
}

extension KendraClientTypes.GoogleDriveConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GoogleDriveConfiguration(excludeMimeTypes: \(Swift.String(describing: excludeMimeTypes)), excludeSharedDrives: \(Swift.String(describing: excludeSharedDrives)), excludeUserAccounts: \(Swift.String(describing: excludeUserAccounts)), exclusionPatterns: \(Swift.String(describing: exclusionPatterns)), fieldMappings: \(Swift.String(describing: fieldMappings)), inclusionPatterns: \(Swift.String(describing: inclusionPatterns)), secretArn: \(Swift.String(describing: secretArn)))"}
}

extension KendraClientTypes {
    /// <p>Provides configuration information for data sources that connect
    ///             to Google Drive.</p>
    public struct GoogleDriveConfiguration: Swift.Equatable {
        /// <p>A list of MIME types to exclude from the index. All documents
        ///             matching the specified MIME type are excluded. </p>
        ///         <p>For a list of MIME types, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-google-drive.html">Using a Google Workspace Drive data
        ///                 source</a>.</p>
        public let excludeMimeTypes: [Swift.String]?
        /// <p>A list of identifiers or shared drives to exclude from the index.
        ///             All files and folders stored on the shared drive are
        ///             excluded.</p>
        public let excludeSharedDrives: [Swift.String]?
        /// <p>A list of email addresses of the users. Documents owned by these
        ///             users are excluded from the index. Documents shared with excluded
        ///             users are indexed unless they are excluded in another way.</p>
        public let excludeUserAccounts: [Swift.String]?
        /// <p>A list of regular expression patterns that apply to the path on
        ///             Google Drive. Items that match the pattern are excluded from the
        ///             index from both shared drives and users' My Drives. Items that don't
        ///             match the pattern are included in the index. If an item matches both
        ///             an exclusion pattern and an inclusion pattern, it is excluded from
        ///             the index.</p>
        public let exclusionPatterns: [Swift.String]?
        /// <p>Defines mapping between a field in the Google Drive and a Amazon Kendra
        ///             index field.</p>
        ///         <p>If you are using the console, you can define index fields when
        ///             creating the mapping. If you are using the API, you must first
        ///             create the field using the <code>UpdateIndex</code>
        ///             operation.</p>
        public let fieldMappings: [KendraClientTypes.DataSourceToIndexFieldMapping]?
        /// <p>A list of regular expression patterns that apply to path on Google
        ///             Drive. Items that match the pattern are included in the index from
        ///             both shared drives and users' My Drives. Items that don't match the
        ///             pattern are excluded from the index. If an item matches both an
        ///             inclusion pattern and an exclusion pattern, it is excluded from the
        ///             index.</p>
        public let inclusionPatterns: [Swift.String]?
        /// <p>The Amazon Resource Name (ARN) of a AWS Secrets Manager secret
        ///             that contains the credentials required to connect to Google Drive.
        ///             For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-google-drive.html">Using a Google Workspace Drive data
        ///                 source</a>.</p>
        public let secretArn: Swift.String?

        public init (
            excludeMimeTypes: [Swift.String]? = nil,
            excludeSharedDrives: [Swift.String]? = nil,
            excludeUserAccounts: [Swift.String]? = nil,
            exclusionPatterns: [Swift.String]? = nil,
            fieldMappings: [KendraClientTypes.DataSourceToIndexFieldMapping]? = nil,
            inclusionPatterns: [Swift.String]? = nil,
            secretArn: Swift.String? = nil
        )
        {
            self.excludeMimeTypes = excludeMimeTypes
            self.excludeSharedDrives = excludeSharedDrives
            self.excludeUserAccounts = excludeUserAccounts
            self.exclusionPatterns = exclusionPatterns
            self.fieldMappings = fieldMappings
            self.inclusionPatterns = inclusionPatterns
            self.secretArn = secretArn
        }
    }

}

extension KendraClientTypes.Highlight: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case beginOffset = "BeginOffset"
        case endOffset = "EndOffset"
        case topAnswer = "TopAnswer"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let beginOffset = beginOffset {
            try encodeContainer.encode(beginOffset, forKey: .beginOffset)
        }
        if let endOffset = endOffset {
            try encodeContainer.encode(endOffset, forKey: .endOffset)
        }
        if topAnswer != false {
            try encodeContainer.encode(topAnswer, forKey: .topAnswer)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let beginOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .beginOffset)
        beginOffset = beginOffsetDecoded
        let endOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .endOffset)
        endOffset = endOffsetDecoded
        let topAnswerDecoded = try containerValues.decode(Swift.Bool.self, forKey: .topAnswer)
        topAnswer = topAnswerDecoded
        let typeDecoded = try containerValues.decodeIfPresent(KendraClientTypes.HighlightType.self, forKey: .type)
        type = typeDecoded
    }
}

extension KendraClientTypes.Highlight: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Highlight(beginOffset: \(Swift.String(describing: beginOffset)), endOffset: \(Swift.String(describing: endOffset)), topAnswer: \(Swift.String(describing: topAnswer)), type: \(Swift.String(describing: type)))"}
}

extension KendraClientTypes {
    /// <p>Provides information that you can use to highlight a search result
    ///             so that your users can quickly identify terms in the
    ///             response.</p>
    public struct Highlight: Swift.Equatable {
        /// <p>The zero-based location in the response string where the highlight
        ///             starts.</p>
        public let beginOffset: Swift.Int?
        /// <p>The zero-based location in the response string where the highlight
        ///             ends.</p>
        public let endOffset: Swift.Int?
        /// <p>Indicates whether the response is the best response. True if this
        ///             is the best response; otherwise, false.</p>
        public let topAnswer: Swift.Bool
        /// <p>The highlight type. </p>
        public let type: KendraClientTypes.HighlightType?

        public init (
            beginOffset: Swift.Int? = nil,
            endOffset: Swift.Int? = nil,
            topAnswer: Swift.Bool = false,
            type: KendraClientTypes.HighlightType? = nil
        )
        {
            self.beginOffset = beginOffset
            self.endOffset = endOffset
            self.topAnswer = topAnswer
            self.type = type
        }
    }

}

extension KendraClientTypes {
    public enum HighlightType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case standard
        case thesaurusSynonym
        case sdkUnknown(Swift.String)

        public static var allCases: [HighlightType] {
            return [
                .standard,
                .thesaurusSynonym,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .standard: return "STANDARD"
            case .thesaurusSynonym: return "THESAURUS_SYNONYM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HighlightType(rawValue: rawValue) ?? HighlightType.sdkUnknown(rawValue)
        }
    }
}

extension KendraClientTypes.IndexConfigurationSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case edition = "Edition"
        case id = "Id"
        case name = "Name"
        case status = "Status"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let edition = edition {
            try encodeContainer.encode(edition.rawValue, forKey: .edition)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let editionDecoded = try containerValues.decodeIfPresent(KendraClientTypes.IndexEdition.self, forKey: .edition)
        edition = editionDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(KendraClientTypes.IndexStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension KendraClientTypes.IndexConfigurationSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IndexConfigurationSummary(createdAt: \(Swift.String(describing: createdAt)), edition: \(Swift.String(describing: edition)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)))"}
}

extension KendraClientTypes {
    /// <p>A summary of information about an index.</p>
    public struct IndexConfigurationSummary: Swift.Equatable {
        /// <p>The Unix timestamp when the index was created.</p>
        public let createdAt: ClientRuntime.Date?
        /// <p>Indicates whether the index is a enterprise edition index or a
        ///             developer edition index. </p>
        public let edition: KendraClientTypes.IndexEdition?
        /// <p>A unique identifier for the index. Use this to identify the index
        ///             when you are using operations such as <code>Query</code>,
        ///                 <code>DescribeIndex</code>, <code>UpdateIndex</code>, and
        ///                 <code>DeleteIndex</code>.</p>
        public let id: Swift.String?
        /// <p>The name of the index.</p>
        public let name: Swift.String?
        /// <p>The current status of the index. When the status is
        ///                 <code>ACTIVE</code>, the index is ready to search.</p>
        public let status: KendraClientTypes.IndexStatus?
        /// <p>The Unix timestamp when the index was last updated by the
        ///                 <code>UpdateIndex</code> operation.</p>
        public let updatedAt: ClientRuntime.Date?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            edition: KendraClientTypes.IndexEdition? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            status: KendraClientTypes.IndexStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.edition = edition
            self.id = id
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
        }
    }

}

extension KendraClientTypes {
    public enum IndexEdition: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case developerEdition
        case enterpriseEdition
        case sdkUnknown(Swift.String)

        public static var allCases: [IndexEdition] {
            return [
                .developerEdition,
                .enterpriseEdition,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .developerEdition: return "DEVELOPER_EDITION"
            case .enterpriseEdition: return "ENTERPRISE_EDITION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IndexEdition(rawValue: rawValue) ?? IndexEdition.sdkUnknown(rawValue)
        }
    }
}

extension KendraClientTypes.IndexStatistics: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case faqStatistics = "FaqStatistics"
        case textDocumentStatistics = "TextDocumentStatistics"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let faqStatistics = faqStatistics {
            try encodeContainer.encode(faqStatistics, forKey: .faqStatistics)
        }
        if let textDocumentStatistics = textDocumentStatistics {
            try encodeContainer.encode(textDocumentStatistics, forKey: .textDocumentStatistics)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let faqStatisticsDecoded = try containerValues.decodeIfPresent(KendraClientTypes.FaqStatistics.self, forKey: .faqStatistics)
        faqStatistics = faqStatisticsDecoded
        let textDocumentStatisticsDecoded = try containerValues.decodeIfPresent(KendraClientTypes.TextDocumentStatistics.self, forKey: .textDocumentStatistics)
        textDocumentStatistics = textDocumentStatisticsDecoded
    }
}

extension KendraClientTypes.IndexStatistics: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IndexStatistics(faqStatistics: \(Swift.String(describing: faqStatistics)), textDocumentStatistics: \(Swift.String(describing: textDocumentStatistics)))"}
}

extension KendraClientTypes {
    /// <p>Provides information about the number of documents and the number
    ///             of questions and answers in an index.</p>
    public struct IndexStatistics: Swift.Equatable {
        /// <p>The number of question and answer topics in the index.</p>
        public let faqStatistics: KendraClientTypes.FaqStatistics?
        /// <p>The number of text documents indexed.</p>
        public let textDocumentStatistics: KendraClientTypes.TextDocumentStatistics?

        public init (
            faqStatistics: KendraClientTypes.FaqStatistics? = nil,
            textDocumentStatistics: KendraClientTypes.TextDocumentStatistics? = nil
        )
        {
            self.faqStatistics = faqStatistics
            self.textDocumentStatistics = textDocumentStatistics
        }
    }

}

extension KendraClientTypes {
    public enum IndexStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleting
        case failed
        case systemUpdating
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [IndexStatus] {
            return [
                .active,
                .creating,
                .deleting,
                .failed,
                .systemUpdating,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .systemUpdating: return "SYSTEM_UPDATING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IndexStatus(rawValue: rawValue) ?? IndexStatus.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerException(message: \(Swift.String(describing: message)))"}
}

extension InternalServerException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct InternalServerException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KendraClientTypes.JsonTokenTypeConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupAttributeField = "GroupAttributeField"
        case userNameAttributeField = "UserNameAttributeField"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupAttributeField = groupAttributeField {
            try encodeContainer.encode(groupAttributeField, forKey: .groupAttributeField)
        }
        if let userNameAttributeField = userNameAttributeField {
            try encodeContainer.encode(userNameAttributeField, forKey: .userNameAttributeField)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameAttributeFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userNameAttributeField)
        userNameAttributeField = userNameAttributeFieldDecoded
        let groupAttributeFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupAttributeField)
        groupAttributeField = groupAttributeFieldDecoded
    }
}

extension KendraClientTypes.JsonTokenTypeConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "JsonTokenTypeConfiguration(groupAttributeField: \(Swift.String(describing: groupAttributeField)), userNameAttributeField: \(Swift.String(describing: userNameAttributeField)))"}
}

extension KendraClientTypes {
    /// <p>Configuration information for the JSON token type.</p>
    public struct JsonTokenTypeConfiguration: Swift.Equatable {
        /// <p>The group attribute field.</p>
        public let groupAttributeField: Swift.String?
        /// <p>The user name attribute field.</p>
        public let userNameAttributeField: Swift.String?

        public init (
            groupAttributeField: Swift.String? = nil,
            userNameAttributeField: Swift.String? = nil
        )
        {
            self.groupAttributeField = groupAttributeField
            self.userNameAttributeField = userNameAttributeField
        }
    }

}

extension KendraClientTypes.JwtTokenTypeConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case claimRegex = "ClaimRegex"
        case groupAttributeField = "GroupAttributeField"
        case issuer = "Issuer"
        case keyLocation = "KeyLocation"
        case secretManagerArn = "SecretManagerArn"
        case uRL = "URL"
        case userNameAttributeField = "UserNameAttributeField"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let claimRegex = claimRegex {
            try encodeContainer.encode(claimRegex, forKey: .claimRegex)
        }
        if let groupAttributeField = groupAttributeField {
            try encodeContainer.encode(groupAttributeField, forKey: .groupAttributeField)
        }
        if let issuer = issuer {
            try encodeContainer.encode(issuer, forKey: .issuer)
        }
        if let keyLocation = keyLocation {
            try encodeContainer.encode(keyLocation.rawValue, forKey: .keyLocation)
        }
        if let secretManagerArn = secretManagerArn {
            try encodeContainer.encode(secretManagerArn, forKey: .secretManagerArn)
        }
        if let uRL = uRL {
            try encodeContainer.encode(uRL, forKey: .uRL)
        }
        if let userNameAttributeField = userNameAttributeField {
            try encodeContainer.encode(userNameAttributeField, forKey: .userNameAttributeField)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyLocationDecoded = try containerValues.decodeIfPresent(KendraClientTypes.KeyLocation.self, forKey: .keyLocation)
        keyLocation = keyLocationDecoded
        let uRLDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uRL)
        uRL = uRLDecoded
        let secretManagerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretManagerArn)
        secretManagerArn = secretManagerArnDecoded
        let userNameAttributeFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userNameAttributeField)
        userNameAttributeField = userNameAttributeFieldDecoded
        let groupAttributeFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupAttributeField)
        groupAttributeField = groupAttributeFieldDecoded
        let issuerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .issuer)
        issuer = issuerDecoded
        let claimRegexDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .claimRegex)
        claimRegex = claimRegexDecoded
    }
}

extension KendraClientTypes.JwtTokenTypeConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "JwtTokenTypeConfiguration(claimRegex: \(Swift.String(describing: claimRegex)), groupAttributeField: \(Swift.String(describing: groupAttributeField)), issuer: \(Swift.String(describing: issuer)), keyLocation: \(Swift.String(describing: keyLocation)), secretManagerArn: \(Swift.String(describing: secretManagerArn)), uRL: \(Swift.String(describing: uRL)), userNameAttributeField: \(Swift.String(describing: userNameAttributeField)))"}
}

extension KendraClientTypes {
    /// <p>Configuration information for the JWT token type.</p>
    public struct JwtTokenTypeConfiguration: Swift.Equatable {
        /// <p>The regular expression that identifies the claim.</p>
        public let claimRegex: Swift.String?
        /// <p>The group attribute field.</p>
        public let groupAttributeField: Swift.String?
        /// <p>The issuer of the token.</p>
        public let issuer: Swift.String?
        /// <p>The location of the key.</p>
        public let keyLocation: KendraClientTypes.KeyLocation?
        /// <p>The Amazon Resource Name (arn) of the secret.</p>
        public let secretManagerArn: Swift.String?
        /// <p>The signing key URL.</p>
        public let uRL: Swift.String?
        /// <p>The user name attribute field.</p>
        public let userNameAttributeField: Swift.String?

        public init (
            claimRegex: Swift.String? = nil,
            groupAttributeField: Swift.String? = nil,
            issuer: Swift.String? = nil,
            keyLocation: KendraClientTypes.KeyLocation? = nil,
            secretManagerArn: Swift.String? = nil,
            uRL: Swift.String? = nil,
            userNameAttributeField: Swift.String? = nil
        )
        {
            self.claimRegex = claimRegex
            self.groupAttributeField = groupAttributeField
            self.issuer = issuer
            self.keyLocation = keyLocation
            self.secretManagerArn = secretManagerArn
            self.uRL = uRL
            self.userNameAttributeField = userNameAttributeField
        }
    }

}

extension KendraClientTypes {
    public enum KeyLocation: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case secretManager
        case url
        case sdkUnknown(Swift.String)

        public static var allCases: [KeyLocation] {
            return [
                .secretManager,
                .url,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .secretManager: return "SECRET_MANAGER"
            case .url: return "URL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = KeyLocation(rawValue: rawValue) ?? KeyLocation.sdkUnknown(rawValue)
        }
    }
}

public struct ListDataSourceSyncJobsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDataSourceSyncJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDataSourceSyncJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDataSourceSyncJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDataSourceSyncJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDataSourceSyncJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDataSourceSyncJobsOutputError>
}

extension ListDataSourceSyncJobsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDataSourceSyncJobsInput(id: \(Swift.String(describing: id)), indexId: \(Swift.String(describing: indexId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), startTimeFilter: \(Swift.String(describing: startTimeFilter)), statusFilter: \(Swift.String(describing: statusFilter)))"}
}

extension ListDataSourceSyncJobsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case indexId = "IndexId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case startTimeFilter = "StartTimeFilter"
        case statusFilter = "StatusFilter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let startTimeFilter = startTimeFilter {
            try encodeContainer.encode(startTimeFilter, forKey: .startTimeFilter)
        }
        if let statusFilter = statusFilter {
            try encodeContainer.encode(statusFilter.rawValue, forKey: .statusFilter)
        }
    }
}

public struct ListDataSourceSyncJobsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDataSourceSyncJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDataSourceSyncJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDataSourceSyncJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDataSourceSyncJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDataSourceSyncJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDataSourceSyncJobsOutputError>
}

public struct ListDataSourceSyncJobsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDataSourceSyncJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDataSourceSyncJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDataSourceSyncJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDataSourceSyncJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDataSourceSyncJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDataSourceSyncJobsOutputError>
}

public struct ListDataSourceSyncJobsInput: Swift.Equatable {
    /// <p>The identifier of the data source.</p>
    public let id: Swift.String?
    /// <p>The identifier of the index that contains the data source.</p>
    public let indexId: Swift.String?
    /// <p>The maximum number of synchronization jobs to return in the response.
    ///       If there are fewer results in the list, this response contains only the
    ///       actual results.</p>
    public let maxResults: Swift.Int?
    /// <p>If the result of the previous request to
    ///         <code>GetDataSourceSyncJobHistory</code> was truncated, include the
    ///         <code>NextToken</code> to fetch the next set of jobs.</p>
    public let nextToken: Swift.String?
    /// <p>When specified, the synchronization jobs returned in the list are
    ///       limited to jobs between the specified dates. </p>
    public let startTimeFilter: KendraClientTypes.TimeRange?
    /// <p>When specified, only returns synchronization jobs with the
    ///         <code>Status</code> field equal to the specified status.</p>
    public let statusFilter: KendraClientTypes.DataSourceSyncJobStatus?

    public init (
        id: Swift.String? = nil,
        indexId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        startTimeFilter: KendraClientTypes.TimeRange? = nil,
        statusFilter: KendraClientTypes.DataSourceSyncJobStatus? = nil
    )
    {
        self.id = id
        self.indexId = indexId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startTimeFilter = startTimeFilter
        self.statusFilter = statusFilter
    }
}

struct ListDataSourceSyncJobsInputBody: Swift.Equatable {
    public let id: Swift.String?
    public let indexId: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
    public let startTimeFilter: KendraClientTypes.TimeRange?
    public let statusFilter: KendraClientTypes.DataSourceSyncJobStatus?
}

extension ListDataSourceSyncJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case indexId = "IndexId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case startTimeFilter = "StartTimeFilter"
        case statusFilter = "StatusFilter"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let indexIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexId)
        indexId = indexIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let startTimeFilterDecoded = try containerValues.decodeIfPresent(KendraClientTypes.TimeRange.self, forKey: .startTimeFilter)
        startTimeFilter = startTimeFilterDecoded
        let statusFilterDecoded = try containerValues.decodeIfPresent(KendraClientTypes.DataSourceSyncJobStatus.self, forKey: .statusFilter)
        statusFilter = statusFilterDecoded
    }
}

extension ListDataSourceSyncJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDataSourceSyncJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDataSourceSyncJobsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDataSourceSyncJobsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDataSourceSyncJobsOutputResponse(history: \(Swift.String(describing: history)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDataSourceSyncJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDataSourceSyncJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.history = output.history
            self.nextToken = output.nextToken
        } else {
            self.history = nil
            self.nextToken = nil
        }
    }
}

public struct ListDataSourceSyncJobsOutputResponse: Swift.Equatable {
    /// <p>A history of synchronization jobs for the data source.</p>
    public let history: [KendraClientTypes.DataSourceSyncJob]?
    /// <p>The <code>GetDataSourceSyncJobHistory</code> operation returns a page
    ///       of vocabularies at a time. The maximum size of the page is set by the
    ///         <code>MaxResults</code> parameter. If there are more jobs in the list
    ///       than the page size, Amazon Kendra returns the NextPage token. Include the
    ///       token in the next request to the <code>GetDataSourceSyncJobHistory</code>
    ///       operation to return in the next page of jobs.</p>
    public let nextToken: Swift.String?

    public init (
        history: [KendraClientTypes.DataSourceSyncJob]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.history = history
        self.nextToken = nextToken
    }
}

struct ListDataSourceSyncJobsOutputResponseBody: Swift.Equatable {
    public let history: [KendraClientTypes.DataSourceSyncJob]?
    public let nextToken: Swift.String?
}

extension ListDataSourceSyncJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case history = "History"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let historyContainer = try containerValues.decodeIfPresent([KendraClientTypes.DataSourceSyncJob?].self, forKey: .history)
        var historyDecoded0:[KendraClientTypes.DataSourceSyncJob]? = nil
        if let historyContainer = historyContainer {
            historyDecoded0 = [KendraClientTypes.DataSourceSyncJob]()
            for structure0 in historyContainer {
                if let structure0 = structure0 {
                    historyDecoded0?.append(structure0)
                }
            }
        }
        history = historyDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListDataSourcesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDataSourcesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDataSourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDataSourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDataSourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDataSourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDataSourcesOutputError>
}

extension ListDataSourcesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDataSourcesInput(indexId: \(Swift.String(describing: indexId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDataSourcesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexId = "IndexId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListDataSourcesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDataSourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDataSourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDataSourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDataSourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDataSourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDataSourcesOutputError>
}

public struct ListDataSourcesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDataSourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDataSourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDataSourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDataSourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDataSourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDataSourcesOutputError>
}

public struct ListDataSourcesInput: Swift.Equatable {
    /// <p>The identifier of the index that contains the data source.</p>
    public let indexId: Swift.String?
    /// <p>The maximum number of data sources to return.</p>
    public let maxResults: Swift.Int?
    /// <p>If the previous response was incomplete (because there is more data to
    ///       retrieve), Amazon Kendra returns a pagination token in the response. You
    ///       can use this pagination token to retrieve the next set of data sources
    ///         (<code>DataSourceSummaryItems</code>). </p>
    public let nextToken: Swift.String?

    public init (
        indexId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.indexId = indexId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDataSourcesInputBody: Swift.Equatable {
    public let indexId: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListDataSourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexId = "IndexId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexId)
        indexId = indexIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDataSourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDataSourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDataSourcesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDataSourcesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDataSourcesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), summaryItems: \(Swift.String(describing: summaryItems)))"}
}

extension ListDataSourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDataSourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.summaryItems = output.summaryItems
        } else {
            self.nextToken = nil
            self.summaryItems = nil
        }
    }
}

public struct ListDataSourcesOutputResponse: Swift.Equatable {
    /// <p>If the response is truncated, Amazon Kendra returns this token that you
    ///       can use in the subsequent request to retrieve the next set of data
    ///       sources. </p>
    public let nextToken: Swift.String?
    /// <p>An array of summary information for one or more data sources.</p>
    public let summaryItems: [KendraClientTypes.DataSourceSummary]?

    public init (
        nextToken: Swift.String? = nil,
        summaryItems: [KendraClientTypes.DataSourceSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.summaryItems = summaryItems
    }
}

struct ListDataSourcesOutputResponseBody: Swift.Equatable {
    public let summaryItems: [KendraClientTypes.DataSourceSummary]?
    public let nextToken: Swift.String?
}

extension ListDataSourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case summaryItems = "SummaryItems"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summaryItemsContainer = try containerValues.decodeIfPresent([KendraClientTypes.DataSourceSummary?].self, forKey: .summaryItems)
        var summaryItemsDecoded0:[KendraClientTypes.DataSourceSummary]? = nil
        if let summaryItemsContainer = summaryItemsContainer {
            summaryItemsDecoded0 = [KendraClientTypes.DataSourceSummary]()
            for structure0 in summaryItemsContainer {
                if let structure0 = structure0 {
                    summaryItemsDecoded0?.append(structure0)
                }
            }
        }
        summaryItems = summaryItemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListFaqsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFaqsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFaqsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFaqsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFaqsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFaqsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFaqsOutputError>
}

extension ListFaqsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListFaqsInput(indexId: \(Swift.String(describing: indexId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListFaqsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexId = "IndexId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListFaqsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFaqsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFaqsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFaqsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFaqsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFaqsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFaqsOutputError>
}

public struct ListFaqsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFaqsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFaqsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFaqsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFaqsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFaqsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFaqsOutputError>
}

public struct ListFaqsInput: Swift.Equatable {
    /// <p>The index that contains the FAQ lists.</p>
    public let indexId: Swift.String?
    /// <p>The maximum number of FAQs to return in the response. If there are fewer results in
    ///             the list, this response contains only the actual results.</p>
    public let maxResults: Swift.Int?
    /// <p>If the result of the previous request to <code>ListFaqs</code> was truncated, include
    ///             the <code>NextToken</code> to fetch the next set of FAQs.</p>
    public let nextToken: Swift.String?

    public init (
        indexId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.indexId = indexId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFaqsInputBody: Swift.Equatable {
    public let indexId: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListFaqsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexId = "IndexId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexId)
        indexId = indexIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListFaqsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFaqsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFaqsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFaqsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListFaqsOutputResponse(faqSummaryItems: \(Swift.String(describing: faqSummaryItems)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListFaqsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListFaqsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.faqSummaryItems = output.faqSummaryItems
            self.nextToken = output.nextToken
        } else {
            self.faqSummaryItems = nil
            self.nextToken = nil
        }
    }
}

public struct ListFaqsOutputResponse: Swift.Equatable {
    /// <p>information about the FAQs associated with the specified index.</p>
    public let faqSummaryItems: [KendraClientTypes.FaqSummary]?
    /// <p>The <code>ListFaqs</code> operation returns a page of FAQs at a time. The maximum size
    ///             of the page is set by the <code>MaxResults</code> parameter. If there are more jobs in
    ///             the list than the page size, Amazon Kendra returns the <code>NextPage</code> token.
    ///             Include the token in the next request to the <code>ListFaqs</code> operation to return
    ///             the next page of FAQs.</p>
    public let nextToken: Swift.String?

    public init (
        faqSummaryItems: [KendraClientTypes.FaqSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.faqSummaryItems = faqSummaryItems
        self.nextToken = nextToken
    }
}

struct ListFaqsOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let faqSummaryItems: [KendraClientTypes.FaqSummary]?
}

extension ListFaqsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case faqSummaryItems = "FaqSummaryItems"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let faqSummaryItemsContainer = try containerValues.decodeIfPresent([KendraClientTypes.FaqSummary?].self, forKey: .faqSummaryItems)
        var faqSummaryItemsDecoded0:[KendraClientTypes.FaqSummary]? = nil
        if let faqSummaryItemsContainer = faqSummaryItemsContainer {
            faqSummaryItemsDecoded0 = [KendraClientTypes.FaqSummary]()
            for structure0 in faqSummaryItemsContainer {
                if let structure0 = structure0 {
                    faqSummaryItemsDecoded0?.append(structure0)
                }
            }
        }
        faqSummaryItems = faqSummaryItemsDecoded0
    }
}

public struct ListIndicesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListIndicesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListIndicesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListIndicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListIndicesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListIndicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListIndicesOutputError>
}

extension ListIndicesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListIndicesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListIndicesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListIndicesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListIndicesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListIndicesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListIndicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListIndicesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListIndicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListIndicesOutputError>
}

public struct ListIndicesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListIndicesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListIndicesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListIndicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListIndicesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListIndicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListIndicesOutputError>
}

public struct ListIndicesInput: Swift.Equatable {
    /// <p>The maximum number of data sources to return.</p>
    public let maxResults: Swift.Int?
    /// <p>If the previous response was incomplete (because there is more data to
    ///       retrieve), Amazon Kendra returns a pagination token in the response. You
    ///       can use this pagination token to retrieve the next set of indexes
    ///         (<code>DataSourceSummaryItems</code>). </p>
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListIndicesInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListIndicesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListIndicesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListIndicesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListIndicesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListIndicesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListIndicesOutputResponse(indexConfigurationSummaryItems: \(Swift.String(describing: indexConfigurationSummaryItems)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListIndicesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListIndicesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.indexConfigurationSummaryItems = output.indexConfigurationSummaryItems
            self.nextToken = output.nextToken
        } else {
            self.indexConfigurationSummaryItems = nil
            self.nextToken = nil
        }
    }
}

public struct ListIndicesOutputResponse: Swift.Equatable {
    /// <p>An array of summary information for one or more indexes.</p>
    public let indexConfigurationSummaryItems: [KendraClientTypes.IndexConfigurationSummary]?
    /// <p>If the response is truncated, Amazon Kendra returns this token that you
    ///       can use in the subsequent request to retrieve the next set of
    ///       indexes.</p>
    public let nextToken: Swift.String?

    public init (
        indexConfigurationSummaryItems: [KendraClientTypes.IndexConfigurationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.indexConfigurationSummaryItems = indexConfigurationSummaryItems
        self.nextToken = nextToken
    }
}

struct ListIndicesOutputResponseBody: Swift.Equatable {
    public let indexConfigurationSummaryItems: [KendraClientTypes.IndexConfigurationSummary]?
    public let nextToken: Swift.String?
}

extension ListIndicesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexConfigurationSummaryItems = "IndexConfigurationSummaryItems"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexConfigurationSummaryItemsContainer = try containerValues.decodeIfPresent([KendraClientTypes.IndexConfigurationSummary?].self, forKey: .indexConfigurationSummaryItems)
        var indexConfigurationSummaryItemsDecoded0:[KendraClientTypes.IndexConfigurationSummary]? = nil
        if let indexConfigurationSummaryItemsContainer = indexConfigurationSummaryItemsContainer {
            indexConfigurationSummaryItemsDecoded0 = [KendraClientTypes.IndexConfigurationSummary]()
            for structure0 in indexConfigurationSummaryItemsContainer {
                if let structure0 = structure0 {
                    indexConfigurationSummaryItemsDecoded0?.append(structure0)
                }
            }
        }
        indexConfigurationSummaryItems = indexConfigurationSummaryItemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListQuerySuggestionsBlockListsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListQuerySuggestionsBlockListsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListQuerySuggestionsBlockListsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListQuerySuggestionsBlockListsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListQuerySuggestionsBlockListsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListQuerySuggestionsBlockListsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListQuerySuggestionsBlockListsOutputError>
}

extension ListQuerySuggestionsBlockListsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListQuerySuggestionsBlockListsInput(indexId: \(Swift.String(describing: indexId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListQuerySuggestionsBlockListsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexId = "IndexId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListQuerySuggestionsBlockListsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListQuerySuggestionsBlockListsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListQuerySuggestionsBlockListsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListQuerySuggestionsBlockListsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListQuerySuggestionsBlockListsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListQuerySuggestionsBlockListsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListQuerySuggestionsBlockListsOutputError>
}

public struct ListQuerySuggestionsBlockListsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListQuerySuggestionsBlockListsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListQuerySuggestionsBlockListsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListQuerySuggestionsBlockListsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListQuerySuggestionsBlockListsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListQuerySuggestionsBlockListsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListQuerySuggestionsBlockListsOutputError>
}

public struct ListQuerySuggestionsBlockListsInput: Swift.Equatable {
    /// <p>The identifier of the index for a list of all block lists that exist for
    ///             that index.</p>
    ///         <p>For information on the current quota limits for block lists, see
    ///             <a href="https://docs.aws.amazon.com/kendra/latest/dg/quotas.html">Quotas
    ///                 for Amazon Kendra</a>.</p>
    public let indexId: Swift.String?
    /// <p>The maximum number of block lists to return.</p>
    public let maxResults: Swift.Int?
    /// <p>If the previous response was incomplete (because there is more data to retrieve),
    ///             Amazon Kendra returns a pagination token in the response. You can use this pagination
    ///             token to retrieve the next set of block lists (<code>BlockListSummaryItems</code>).</p>
    public let nextToken: Swift.String?

    public init (
        indexId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.indexId = indexId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListQuerySuggestionsBlockListsInputBody: Swift.Equatable {
    public let indexId: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListQuerySuggestionsBlockListsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexId = "IndexId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexId)
        indexId = indexIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListQuerySuggestionsBlockListsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListQuerySuggestionsBlockListsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListQuerySuggestionsBlockListsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListQuerySuggestionsBlockListsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListQuerySuggestionsBlockListsOutputResponse(blockListSummaryItems: \(Swift.String(describing: blockListSummaryItems)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListQuerySuggestionsBlockListsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListQuerySuggestionsBlockListsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.blockListSummaryItems = output.blockListSummaryItems
            self.nextToken = output.nextToken
        } else {
            self.blockListSummaryItems = nil
            self.nextToken = nil
        }
    }
}

public struct ListQuerySuggestionsBlockListsOutputResponse: Swift.Equatable {
    /// <p>Summary items for a block list.</p>
    ///         <p>This includes summary items on the block list ID, block list name, when the
    ///             block list was created, when the block list was last updated, and the count
    ///             of block words/phrases in the block list.</p>
    ///         <p>For information on the current quota limits for block lists, see
    ///             <a href="https://docs.aws.amazon.com/kendra/latest/dg/quotas.html">Quotas
    ///                 for Amazon Kendra</a>.</p>
    public let blockListSummaryItems: [KendraClientTypes.QuerySuggestionsBlockListSummary]?
    /// <p>If the response is truncated, Amazon Kendra returns this token that you can use
    ///             in the subsequent request to retrieve the next set of block lists.</p>
    public let nextToken: Swift.String?

    public init (
        blockListSummaryItems: [KendraClientTypes.QuerySuggestionsBlockListSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.blockListSummaryItems = blockListSummaryItems
        self.nextToken = nextToken
    }
}

struct ListQuerySuggestionsBlockListsOutputResponseBody: Swift.Equatable {
    public let blockListSummaryItems: [KendraClientTypes.QuerySuggestionsBlockListSummary]?
    public let nextToken: Swift.String?
}

extension ListQuerySuggestionsBlockListsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blockListSummaryItems = "BlockListSummaryItems"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blockListSummaryItemsContainer = try containerValues.decodeIfPresent([KendraClientTypes.QuerySuggestionsBlockListSummary?].self, forKey: .blockListSummaryItems)
        var blockListSummaryItemsDecoded0:[KendraClientTypes.QuerySuggestionsBlockListSummary]? = nil
        if let blockListSummaryItemsContainer = blockListSummaryItemsContainer {
            blockListSummaryItemsDecoded0 = [KendraClientTypes.QuerySuggestionsBlockListSummary]()
            for structure0 in blockListSummaryItemsContainer {
                if let structure0 = structure0 {
                    blockListSummaryItemsDecoded0?.append(structure0)
                }
            }
        }
        blockListSummaryItems = blockListSummaryItemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceARN: \(Swift.String(describing: resourceARN)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the index, FAQ, or data source to
    ///       get a list of tags for.</p>
    public let resourceARN: Swift.String?

    public init (
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    public let resourceARN: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// <p>A list of tags associated with the index, FAQ, or data source.</p>
    public let tags: [KendraClientTypes.Tag]?

    public init (
        tags: [KendraClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [KendraClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([KendraClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[KendraClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [KendraClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct ListThesauriInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListThesauriInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListThesauriInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListThesauriOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListThesauriInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListThesauriOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListThesauriOutputError>
}

extension ListThesauriInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListThesauriInput(indexId: \(Swift.String(describing: indexId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListThesauriInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexId = "IndexId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListThesauriInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListThesauriInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListThesauriInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListThesauriOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListThesauriInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListThesauriOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListThesauriOutputError>
}

public struct ListThesauriInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListThesauriInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListThesauriInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListThesauriOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListThesauriInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListThesauriOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListThesauriOutputError>
}

public struct ListThesauriInput: Swift.Equatable {
    /// <p>The identifier of the index associated with the thesaurus to list.</p>
    public let indexId: Swift.String?
    /// <p>The maximum number of thesauri to return.</p>
    public let maxResults: Swift.Int?
    /// <p>If the previous response was incomplete (because there is more data to retrieve),
    ///          Amazon Kendra returns a pagination token in the response. You can use this pagination token to
    ///          retrieve the next set of thesauri (<code>ThesaurusSummaryItems</code>).
    ///       </p>
    public let nextToken: Swift.String?

    public init (
        indexId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.indexId = indexId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListThesauriInputBody: Swift.Equatable {
    public let indexId: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListThesauriInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexId = "IndexId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexId)
        indexId = indexIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListThesauriOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListThesauriOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListThesauriOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListThesauriOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListThesauriOutputResponse(nextToken: \(Swift.String(describing: nextToken)), thesaurusSummaryItems: \(Swift.String(describing: thesaurusSummaryItems)))"}
}

extension ListThesauriOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListThesauriOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.thesaurusSummaryItems = output.thesaurusSummaryItems
        } else {
            self.nextToken = nil
            self.thesaurusSummaryItems = nil
        }
    }
}

public struct ListThesauriOutputResponse: Swift.Equatable {
    /// <p>If the response is truncated, Amazon Kendra returns this
    ///          token that you can use in the subsequent request to
    ///          retrieve the next set of thesauri.
    ///       </p>
    public let nextToken: Swift.String?
    /// <p>An array of summary information for one or more thesauruses.</p>
    public let thesaurusSummaryItems: [KendraClientTypes.ThesaurusSummary]?

    public init (
        nextToken: Swift.String? = nil,
        thesaurusSummaryItems: [KendraClientTypes.ThesaurusSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.thesaurusSummaryItems = thesaurusSummaryItems
    }
}

struct ListThesauriOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let thesaurusSummaryItems: [KendraClientTypes.ThesaurusSummary]?
}

extension ListThesauriOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case thesaurusSummaryItems = "ThesaurusSummaryItems"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let thesaurusSummaryItemsContainer = try containerValues.decodeIfPresent([KendraClientTypes.ThesaurusSummary?].self, forKey: .thesaurusSummaryItems)
        var thesaurusSummaryItemsDecoded0:[KendraClientTypes.ThesaurusSummary]? = nil
        if let thesaurusSummaryItemsContainer = thesaurusSummaryItemsContainer {
            thesaurusSummaryItemsDecoded0 = [KendraClientTypes.ThesaurusSummary]()
            for structure0 in thesaurusSummaryItemsContainer {
                if let structure0 = structure0 {
                    thesaurusSummaryItemsDecoded0?.append(structure0)
                }
            }
        }
        thesaurusSummaryItems = thesaurusSummaryItemsDecoded0
    }
}

extension KendraClientTypes {
    public enum Mode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case enabled
        case learnOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [Mode] {
            return [
                .enabled,
                .learnOnly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .enabled: return "ENABLED"
            case .learnOnly: return "LEARN_ONLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Mode(rawValue: rawValue) ?? Mode.sdkUnknown(rawValue)
        }
    }
}

extension KendraClientTypes.OneDriveConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disableLocalGroups = "DisableLocalGroups"
        case exclusionPatterns = "ExclusionPatterns"
        case fieldMappings = "FieldMappings"
        case inclusionPatterns = "InclusionPatterns"
        case oneDriveUsers = "OneDriveUsers"
        case secretArn = "SecretArn"
        case tenantDomain = "TenantDomain"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if disableLocalGroups != false {
            try encodeContainer.encode(disableLocalGroups, forKey: .disableLocalGroups)
        }
        if let exclusionPatterns = exclusionPatterns {
            var exclusionPatternsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .exclusionPatterns)
            for datasourceinclusionsexclusionsstrings0 in exclusionPatterns {
                try exclusionPatternsContainer.encode(datasourceinclusionsexclusionsstrings0)
            }
        }
        if let fieldMappings = fieldMappings {
            var fieldMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fieldMappings)
            for datasourcetoindexfieldmappinglist0 in fieldMappings {
                try fieldMappingsContainer.encode(datasourcetoindexfieldmappinglist0)
            }
        }
        if let inclusionPatterns = inclusionPatterns {
            var inclusionPatternsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inclusionPatterns)
            for datasourceinclusionsexclusionsstrings0 in inclusionPatterns {
                try inclusionPatternsContainer.encode(datasourceinclusionsexclusionsstrings0)
            }
        }
        if let oneDriveUsers = oneDriveUsers {
            try encodeContainer.encode(oneDriveUsers, forKey: .oneDriveUsers)
        }
        if let secretArn = secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
        if let tenantDomain = tenantDomain {
            try encodeContainer.encode(tenantDomain, forKey: .tenantDomain)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tenantDomainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tenantDomain)
        tenantDomain = tenantDomainDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let oneDriveUsersDecoded = try containerValues.decodeIfPresent(KendraClientTypes.OneDriveUsers.self, forKey: .oneDriveUsers)
        oneDriveUsers = oneDriveUsersDecoded
        let inclusionPatternsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .inclusionPatterns)
        var inclusionPatternsDecoded0:[Swift.String]? = nil
        if let inclusionPatternsContainer = inclusionPatternsContainer {
            inclusionPatternsDecoded0 = [Swift.String]()
            for string0 in inclusionPatternsContainer {
                if let string0 = string0 {
                    inclusionPatternsDecoded0?.append(string0)
                }
            }
        }
        inclusionPatterns = inclusionPatternsDecoded0
        let exclusionPatternsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .exclusionPatterns)
        var exclusionPatternsDecoded0:[Swift.String]? = nil
        if let exclusionPatternsContainer = exclusionPatternsContainer {
            exclusionPatternsDecoded0 = [Swift.String]()
            for string0 in exclusionPatternsContainer {
                if let string0 = string0 {
                    exclusionPatternsDecoded0?.append(string0)
                }
            }
        }
        exclusionPatterns = exclusionPatternsDecoded0
        let fieldMappingsContainer = try containerValues.decodeIfPresent([KendraClientTypes.DataSourceToIndexFieldMapping?].self, forKey: .fieldMappings)
        var fieldMappingsDecoded0:[KendraClientTypes.DataSourceToIndexFieldMapping]? = nil
        if let fieldMappingsContainer = fieldMappingsContainer {
            fieldMappingsDecoded0 = [KendraClientTypes.DataSourceToIndexFieldMapping]()
            for structure0 in fieldMappingsContainer {
                if let structure0 = structure0 {
                    fieldMappingsDecoded0?.append(structure0)
                }
            }
        }
        fieldMappings = fieldMappingsDecoded0
        let disableLocalGroupsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .disableLocalGroups)
        disableLocalGroups = disableLocalGroupsDecoded
    }
}

extension KendraClientTypes.OneDriveConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OneDriveConfiguration(disableLocalGroups: \(Swift.String(describing: disableLocalGroups)), exclusionPatterns: \(Swift.String(describing: exclusionPatterns)), fieldMappings: \(Swift.String(describing: fieldMappings)), inclusionPatterns: \(Swift.String(describing: inclusionPatterns)), oneDriveUsers: \(Swift.String(describing: oneDriveUsers)), secretArn: \(Swift.String(describing: secretArn)), tenantDomain: \(Swift.String(describing: tenantDomain)))"}
}

extension KendraClientTypes {
    /// <p>Provides configuration information for data sources that connect
    ///             to OneDrive.</p>
    public struct OneDriveConfiguration: Swift.Equatable {
        /// <p>A Boolean value that specifies whether local
        ///       groups are disabled (<code>True</code>) or enabled (<code>False</code>).
        ///       </p>
        public let disableLocalGroups: Swift.Bool
        /// <p>List of regular expressions applied to documents. Items that match
        ///             the exclusion pattern are not indexed. If you provide both an
        ///             inclusion pattern and an exclusion pattern, any item that matches
        ///             the exclusion pattern isn't indexed. </p>
        ///         <p>The exclusion pattern is applied to the file name.</p>
        public let exclusionPatterns: [Swift.String]?
        /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that
        ///             map Microsoft OneDrive fields to custom fields in the Amazon Kendra
        ///             index. You must first create the index fields before you map
        ///             OneDrive fields.</p>
        public let fieldMappings: [KendraClientTypes.DataSourceToIndexFieldMapping]?
        /// <p>A list of regular expression patterns. Documents that match the
        ///             pattern are included in the index. Documents that don't match the
        ///             pattern are excluded from the index. If a document matches both an
        ///             inclusion pattern and an exclusion pattern, the document is not
        ///             included in the index. </p>
        ///         <p>The exclusion pattern is applied to the file name.</p>
        public let inclusionPatterns: [Swift.String]?
        /// <p>A list of user accounts whose documents should be indexed.</p>
        public let oneDriveUsers: KendraClientTypes.OneDriveUsers?
        /// <p>The Amazon Resource Name (ARN) of an AWS Secrets Manager secret
        ///             that contains the user name and password to connect to OneDrive. The
        ///             user namd should be the application ID for the OneDrive application,
        ///             and the password is the application key for the OneDrive
        ///             application.</p>
        public let secretArn: Swift.String?
        /// <p>The Azure Active Directory domain of the organization. </p>
        public let tenantDomain: Swift.String?

        public init (
            disableLocalGroups: Swift.Bool = false,
            exclusionPatterns: [Swift.String]? = nil,
            fieldMappings: [KendraClientTypes.DataSourceToIndexFieldMapping]? = nil,
            inclusionPatterns: [Swift.String]? = nil,
            oneDriveUsers: KendraClientTypes.OneDriveUsers? = nil,
            secretArn: Swift.String? = nil,
            tenantDomain: Swift.String? = nil
        )
        {
            self.disableLocalGroups = disableLocalGroups
            self.exclusionPatterns = exclusionPatterns
            self.fieldMappings = fieldMappings
            self.inclusionPatterns = inclusionPatterns
            self.oneDriveUsers = oneDriveUsers
            self.secretArn = secretArn
            self.tenantDomain = tenantDomain
        }
    }

}

extension KendraClientTypes.OneDriveUsers: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case oneDriveUserList = "OneDriveUserList"
        case oneDriveUserS3Path = "OneDriveUserS3Path"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let oneDriveUserList = oneDriveUserList {
            var oneDriveUserListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .oneDriveUserList)
            for onedriveuserlist0 in oneDriveUserList {
                try oneDriveUserListContainer.encode(onedriveuserlist0)
            }
        }
        if let oneDriveUserS3Path = oneDriveUserS3Path {
            try encodeContainer.encode(oneDriveUserS3Path, forKey: .oneDriveUserS3Path)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let oneDriveUserListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .oneDriveUserList)
        var oneDriveUserListDecoded0:[Swift.String]? = nil
        if let oneDriveUserListContainer = oneDriveUserListContainer {
            oneDriveUserListDecoded0 = [Swift.String]()
            for string0 in oneDriveUserListContainer {
                if let string0 = string0 {
                    oneDriveUserListDecoded0?.append(string0)
                }
            }
        }
        oneDriveUserList = oneDriveUserListDecoded0
        let oneDriveUserS3PathDecoded = try containerValues.decodeIfPresent(KendraClientTypes.S3Path.self, forKey: .oneDriveUserS3Path)
        oneDriveUserS3Path = oneDriveUserS3PathDecoded
    }
}

extension KendraClientTypes.OneDriveUsers: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OneDriveUsers(oneDriveUserList: \(Swift.String(describing: oneDriveUserList)), oneDriveUserS3Path: \(Swift.String(describing: oneDriveUserS3Path)))"}
}

extension KendraClientTypes {
    /// <p>User accounts whose documents should be indexed.</p>
    public struct OneDriveUsers: Swift.Equatable {
        /// <p>A list of users whose documents should be indexed. Specify the
        ///             user names in email format, for example,
        ///                 <code>username@tenantdomain</code>. If you need to index the
        ///             documents of more than 100 users, use the
        ///                 <code>OneDriveUserS3Path</code> field to specify the location of
        ///             a file containing a list of users.</p>
        public let oneDriveUserList: [Swift.String]?
        /// <p>The S3 bucket location of a file containing a list of users whose
        ///             documents should be indexed.</p>
        public let oneDriveUserS3Path: KendraClientTypes.S3Path?

        public init (
            oneDriveUserList: [Swift.String]? = nil,
            oneDriveUserS3Path: KendraClientTypes.S3Path? = nil
        )
        {
            self.oneDriveUserList = oneDriveUserList
            self.oneDriveUserS3Path = oneDriveUserS3Path
        }
    }

}

extension KendraClientTypes {
    public enum Order: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [Order] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Order(rawValue: rawValue) ?? Order.sdkUnknown(rawValue)
        }
    }
}

extension KendraClientTypes.Principal: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case access = "Access"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let access = access {
            try encodeContainer.encode(access.rawValue, forKey: .access)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(KendraClientTypes.PrincipalType.self, forKey: .type)
        type = typeDecoded
        let accessDecoded = try containerValues.decodeIfPresent(KendraClientTypes.ReadAccessType.self, forKey: .access)
        access = accessDecoded
    }
}

extension KendraClientTypes.Principal: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Principal(access: \(Swift.String(describing: access)), name: \(Swift.String(describing: name)), type: \(Swift.String(describing: type)))"}
}

extension KendraClientTypes {
    /// <p>Provides user and group information for document access
    ///             filtering.</p>
    public struct Principal: Swift.Equatable {
        /// <p>Whether to allow or deny access to the principal.</p>
        public let access: KendraClientTypes.ReadAccessType?
        /// <p>The name of the user or group.</p>
        public let name: Swift.String?
        /// <p>The type of principal.</p>
        public let type: KendraClientTypes.PrincipalType?

        public init (
            access: KendraClientTypes.ReadAccessType? = nil,
            name: Swift.String? = nil,
            type: KendraClientTypes.PrincipalType? = nil
        )
        {
            self.access = access
            self.name = name
            self.type = type
        }
    }

}

extension KendraClientTypes {
    public enum PrincipalType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case group
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [PrincipalType] {
            return [
                .group,
                .user,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .group: return "GROUP"
            case .user: return "USER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PrincipalType(rawValue: rawValue) ?? PrincipalType.sdkUnknown(rawValue)
        }
    }
}

extension KendraClientTypes {
    public enum QueryIdentifiersEnclosingOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case doubleQuotes
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [QueryIdentifiersEnclosingOption] {
            return [
                .doubleQuotes,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .doubleQuotes: return "DOUBLE_QUOTES"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = QueryIdentifiersEnclosingOption(rawValue: rawValue) ?? QueryIdentifiersEnclosingOption.sdkUnknown(rawValue)
        }
    }
}

public struct QueryInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "QueryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<QueryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<QueryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<QueryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<QueryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<QueryOutputError>
}

extension QueryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "QueryInput(attributeFilter: \(Swift.String(describing: attributeFilter)), documentRelevanceOverrideConfigurations: \(Swift.String(describing: documentRelevanceOverrideConfigurations)), facets: \(Swift.String(describing: facets)), indexId: \(Swift.String(describing: indexId)), pageNumber: \(Swift.String(describing: pageNumber)), pageSize: \(Swift.String(describing: pageSize)), queryResultTypeFilter: \(Swift.String(describing: queryResultTypeFilter)), queryText: \(Swift.String(describing: queryText)), requestedDocumentAttributes: \(Swift.String(describing: requestedDocumentAttributes)), sortingConfiguration: \(Swift.String(describing: sortingConfiguration)), userContext: \(Swift.String(describing: userContext)), visitorId: \(Swift.String(describing: visitorId)))"}
}

extension QueryInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeFilter = "AttributeFilter"
        case documentRelevanceOverrideConfigurations = "DocumentRelevanceOverrideConfigurations"
        case facets = "Facets"
        case indexId = "IndexId"
        case pageNumber = "PageNumber"
        case pageSize = "PageSize"
        case queryResultTypeFilter = "QueryResultTypeFilter"
        case queryText = "QueryText"
        case requestedDocumentAttributes = "RequestedDocumentAttributes"
        case sortingConfiguration = "SortingConfiguration"
        case userContext = "UserContext"
        case visitorId = "VisitorId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeFilter = attributeFilter {
            try encodeContainer.encode(attributeFilter, forKey: .attributeFilter)
        }
        if let documentRelevanceOverrideConfigurations = documentRelevanceOverrideConfigurations {
            var documentRelevanceOverrideConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .documentRelevanceOverrideConfigurations)
            for documentrelevanceoverrideconfigurationlist0 in documentRelevanceOverrideConfigurations {
                try documentRelevanceOverrideConfigurationsContainer.encode(documentrelevanceoverrideconfigurationlist0)
            }
        }
        if let facets = facets {
            var facetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .facets)
            for facetlist0 in facets {
                try facetsContainer.encode(facetlist0)
            }
        }
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
        if let pageNumber = pageNumber {
            try encodeContainer.encode(pageNumber, forKey: .pageNumber)
        }
        if let pageSize = pageSize {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let queryResultTypeFilter = queryResultTypeFilter {
            try encodeContainer.encode(queryResultTypeFilter.rawValue, forKey: .queryResultTypeFilter)
        }
        if let queryText = queryText {
            try encodeContainer.encode(queryText, forKey: .queryText)
        }
        if let requestedDocumentAttributes = requestedDocumentAttributes {
            var requestedDocumentAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .requestedDocumentAttributes)
            for documentattributekeylist0 in requestedDocumentAttributes {
                try requestedDocumentAttributesContainer.encode(documentattributekeylist0)
            }
        }
        if let sortingConfiguration = sortingConfiguration {
            try encodeContainer.encode(sortingConfiguration, forKey: .sortingConfiguration)
        }
        if let userContext = userContext {
            try encodeContainer.encode(userContext, forKey: .userContext)
        }
        if let visitorId = visitorId {
            try encodeContainer.encode(visitorId, forKey: .visitorId)
        }
    }
}

public struct QueryInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "QueryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<QueryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<QueryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<QueryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<QueryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<QueryOutputError>
}

public struct QueryInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "QueryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<QueryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<QueryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<QueryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<QueryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<QueryOutputError>
}

public struct QueryInput: Swift.Equatable {
    /// <p>Enables filtered searches based on document attributes. You can only
    ///          provide one attribute filter; however, the <code>AndAllFilters</code>,
    ///             <code>NotFilter</code>, and <code>OrAllFilters</code> parameters
    ///          contain a list of other filters.</p>
    ///          <p>The <code>AttributeFilter</code> parameter enables you to create a
    ///          set of filtering rules that a document must satisfy to be included in
    ///          the query results.</p>
    public let attributeFilter: KendraClientTypes.AttributeFilter?
    /// <p>Overrides relevance tuning configurations of fields or attributes set at the index level.</p>
    ///          <p>If you use this API to override the relevance tuning configured at the index
    ///          level, but there is no relevance tuning configured at the index level, then Amazon Kendra does not apply any relevance tuning.</p>
    ///          <p>If there is relevance tuning configured at the index level, but you do not use this API
    ///          to override any relevance tuning in the index, then Amazon Kendra uses the relevance tuning that is configured at the index level.</p>
    ///          <p>If there is relevance tuning configured for fields at the index level,
    ///          but you use this API to override only some of these fields, then for the fields you did not override,
    ///          the importance is set to 1.</p>
    public let documentRelevanceOverrideConfigurations: [KendraClientTypes.DocumentRelevanceConfiguration]?
    /// <p>An array of documents attributes. Amazon Kendra returns a count for
    ///          each attribute key specified. You can use this information to help
    ///          narrow the search for your user.</p>
    public let facets: [KendraClientTypes.Facet]?
    /// <p>The unique identifier of the index to search. The identifier is
    ///          returned in the response from the <code>CreateIndex</code>
    ///          operation.</p>
    public let indexId: Swift.String?
    /// <p>Query results are returned in pages the size of the
    ///             <code>PageSize</code> parameter. By default, Amazon Kendra returns
    ///          the first page of results. Use this parameter to get result pages after
    ///          the first one.</p>
    public let pageNumber: Swift.Int?
    /// <p>Sets the number of results that are returned in each page of
    ///          results. The default page size is 10. The maximum number of results
    ///          returned is 100. If you ask for more than 100 results, only 100 are
    ///          returned.</p>
    public let pageSize: Swift.Int?
    /// <p>Sets the type of query. Only results for the specified query type
    ///          are returned.</p>
    public let queryResultTypeFilter: KendraClientTypes.QueryResultType?
    /// <p>The text to search for.</p>
    public let queryText: Swift.String?
    /// <p>An array of document attributes to include in the response. No other
    ///          document attributes are included in the response. By default all
    ///          document attributes are included in the response. </p>
    public let requestedDocumentAttributes: [Swift.String]?
    /// <p>Provides information that determines how the results of the query
    ///          are sorted. You can set the field that Amazon Kendra should sort the results
    ///          on, and specify whether the results should be sorted in ascending or
    ///          descending order. In the case of ties in sorting the results, the
    ///          results are sorted by relevance.</p>
    ///          <p>If you don't provide sorting configuration, the results are sorted
    ///          by the relevance that Amazon Kendra determines for the result.</p>
    public let sortingConfiguration: KendraClientTypes.SortingConfiguration?
    /// <p>The user context token.</p>
    public let userContext: KendraClientTypes.UserContext?
    /// <p>Provides an identifier for a specific user. The
    ///             <code>VisitorId</code> should be a unique identifier, such as a
    ///          GUID. Don't use personally identifiable information, such as the user's
    ///          email address, as the <code>VisitorId</code>.</p>
    public let visitorId: Swift.String?

    public init (
        attributeFilter: KendraClientTypes.AttributeFilter? = nil,
        documentRelevanceOverrideConfigurations: [KendraClientTypes.DocumentRelevanceConfiguration]? = nil,
        facets: [KendraClientTypes.Facet]? = nil,
        indexId: Swift.String? = nil,
        pageNumber: Swift.Int? = nil,
        pageSize: Swift.Int? = nil,
        queryResultTypeFilter: KendraClientTypes.QueryResultType? = nil,
        queryText: Swift.String? = nil,
        requestedDocumentAttributes: [Swift.String]? = nil,
        sortingConfiguration: KendraClientTypes.SortingConfiguration? = nil,
        userContext: KendraClientTypes.UserContext? = nil,
        visitorId: Swift.String? = nil
    )
    {
        self.attributeFilter = attributeFilter
        self.documentRelevanceOverrideConfigurations = documentRelevanceOverrideConfigurations
        self.facets = facets
        self.indexId = indexId
        self.pageNumber = pageNumber
        self.pageSize = pageSize
        self.queryResultTypeFilter = queryResultTypeFilter
        self.queryText = queryText
        self.requestedDocumentAttributes = requestedDocumentAttributes
        self.sortingConfiguration = sortingConfiguration
        self.userContext = userContext
        self.visitorId = visitorId
    }
}

struct QueryInputBody: Swift.Equatable {
    public let indexId: Swift.String?
    public let queryText: Swift.String?
    public let attributeFilter: KendraClientTypes.AttributeFilter?
    public let facets: [KendraClientTypes.Facet]?
    public let requestedDocumentAttributes: [Swift.String]?
    public let queryResultTypeFilter: KendraClientTypes.QueryResultType?
    public let documentRelevanceOverrideConfigurations: [KendraClientTypes.DocumentRelevanceConfiguration]?
    public let pageNumber: Swift.Int?
    public let pageSize: Swift.Int?
    public let sortingConfiguration: KendraClientTypes.SortingConfiguration?
    public let userContext: KendraClientTypes.UserContext?
    public let visitorId: Swift.String?
}

extension QueryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeFilter = "AttributeFilter"
        case documentRelevanceOverrideConfigurations = "DocumentRelevanceOverrideConfigurations"
        case facets = "Facets"
        case indexId = "IndexId"
        case pageNumber = "PageNumber"
        case pageSize = "PageSize"
        case queryResultTypeFilter = "QueryResultTypeFilter"
        case queryText = "QueryText"
        case requestedDocumentAttributes = "RequestedDocumentAttributes"
        case sortingConfiguration = "SortingConfiguration"
        case userContext = "UserContext"
        case visitorId = "VisitorId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexId)
        indexId = indexIdDecoded
        let queryTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryText)
        queryText = queryTextDecoded
        let attributeFilterDecoded = try containerValues.decodeIfPresent(KendraClientTypes.AttributeFilter.self, forKey: .attributeFilter)
        attributeFilter = attributeFilterDecoded
        let facetsContainer = try containerValues.decodeIfPresent([KendraClientTypes.Facet?].self, forKey: .facets)
        var facetsDecoded0:[KendraClientTypes.Facet]? = nil
        if let facetsContainer = facetsContainer {
            facetsDecoded0 = [KendraClientTypes.Facet]()
            for structure0 in facetsContainer {
                if let structure0 = structure0 {
                    facetsDecoded0?.append(structure0)
                }
            }
        }
        facets = facetsDecoded0
        let requestedDocumentAttributesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .requestedDocumentAttributes)
        var requestedDocumentAttributesDecoded0:[Swift.String]? = nil
        if let requestedDocumentAttributesContainer = requestedDocumentAttributesContainer {
            requestedDocumentAttributesDecoded0 = [Swift.String]()
            for string0 in requestedDocumentAttributesContainer {
                if let string0 = string0 {
                    requestedDocumentAttributesDecoded0?.append(string0)
                }
            }
        }
        requestedDocumentAttributes = requestedDocumentAttributesDecoded0
        let queryResultTypeFilterDecoded = try containerValues.decodeIfPresent(KendraClientTypes.QueryResultType.self, forKey: .queryResultTypeFilter)
        queryResultTypeFilter = queryResultTypeFilterDecoded
        let documentRelevanceOverrideConfigurationsContainer = try containerValues.decodeIfPresent([KendraClientTypes.DocumentRelevanceConfiguration?].self, forKey: .documentRelevanceOverrideConfigurations)
        var documentRelevanceOverrideConfigurationsDecoded0:[KendraClientTypes.DocumentRelevanceConfiguration]? = nil
        if let documentRelevanceOverrideConfigurationsContainer = documentRelevanceOverrideConfigurationsContainer {
            documentRelevanceOverrideConfigurationsDecoded0 = [KendraClientTypes.DocumentRelevanceConfiguration]()
            for structure0 in documentRelevanceOverrideConfigurationsContainer {
                if let structure0 = structure0 {
                    documentRelevanceOverrideConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        documentRelevanceOverrideConfigurations = documentRelevanceOverrideConfigurationsDecoded0
        let pageNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pageNumber)
        pageNumber = pageNumberDecoded
        let pageSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let sortingConfigurationDecoded = try containerValues.decodeIfPresent(KendraClientTypes.SortingConfiguration.self, forKey: .sortingConfiguration)
        sortingConfiguration = sortingConfigurationDecoded
        let userContextDecoded = try containerValues.decodeIfPresent(KendraClientTypes.UserContext.self, forKey: .userContext)
        userContext = userContextDecoded
        let visitorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .visitorId)
        visitorId = visitorIdDecoded
    }
}

extension QueryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension QueryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum QueryOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension QueryOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "QueryOutputResponse(facetResults: \(Swift.String(describing: facetResults)), queryId: \(Swift.String(describing: queryId)), resultItems: \(Swift.String(describing: resultItems)), totalNumberOfResults: \(Swift.String(describing: totalNumberOfResults)))"}
}

extension QueryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: QueryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.facetResults = output.facetResults
            self.queryId = output.queryId
            self.resultItems = output.resultItems
            self.totalNumberOfResults = output.totalNumberOfResults
        } else {
            self.facetResults = nil
            self.queryId = nil
            self.resultItems = nil
            self.totalNumberOfResults = nil
        }
    }
}

public struct QueryOutputResponse: Swift.Equatable {
    /// <p>Contains the facet results. A <code>FacetResult</code> contains the
    ///          counts for each attribute key that was specified in the
    ///             <code>Facets</code> input parameter.</p>
    public let facetResults: [KendraClientTypes.FacetResult]?
    /// <p>The unique identifier for the search. You use <code>QueryId</code>
    ///          to identify the search when using the feedback API.</p>
    public let queryId: Swift.String?
    /// <p>The results of the search.</p>
    public let resultItems: [KendraClientTypes.QueryResultItem]?
    /// <p>The total number of items found by the search; however, you can only
    ///          retrieve up to 100 items. For example, if the search found 192 items,
    ///          you can only retrieve the first 100 of the items.</p>
    public let totalNumberOfResults: Swift.Int?

    public init (
        facetResults: [KendraClientTypes.FacetResult]? = nil,
        queryId: Swift.String? = nil,
        resultItems: [KendraClientTypes.QueryResultItem]? = nil,
        totalNumberOfResults: Swift.Int? = nil
    )
    {
        self.facetResults = facetResults
        self.queryId = queryId
        self.resultItems = resultItems
        self.totalNumberOfResults = totalNumberOfResults
    }
}

struct QueryOutputResponseBody: Swift.Equatable {
    public let queryId: Swift.String?
    public let resultItems: [KendraClientTypes.QueryResultItem]?
    public let facetResults: [KendraClientTypes.FacetResult]?
    public let totalNumberOfResults: Swift.Int?
}

extension QueryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case facetResults = "FacetResults"
        case queryId = "QueryId"
        case resultItems = "ResultItems"
        case totalNumberOfResults = "TotalNumberOfResults"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryId)
        queryId = queryIdDecoded
        let resultItemsContainer = try containerValues.decodeIfPresent([KendraClientTypes.QueryResultItem?].self, forKey: .resultItems)
        var resultItemsDecoded0:[KendraClientTypes.QueryResultItem]? = nil
        if let resultItemsContainer = resultItemsContainer {
            resultItemsDecoded0 = [KendraClientTypes.QueryResultItem]()
            for structure0 in resultItemsContainer {
                if let structure0 = structure0 {
                    resultItemsDecoded0?.append(structure0)
                }
            }
        }
        resultItems = resultItemsDecoded0
        let facetResultsContainer = try containerValues.decodeIfPresent([KendraClientTypes.FacetResult?].self, forKey: .facetResults)
        var facetResultsDecoded0:[KendraClientTypes.FacetResult]? = nil
        if let facetResultsContainer = facetResultsContainer {
            facetResultsDecoded0 = [KendraClientTypes.FacetResult]()
            for structure0 in facetResultsContainer {
                if let structure0 = structure0 {
                    facetResultsDecoded0?.append(structure0)
                }
            }
        }
        facetResults = facetResultsDecoded0
        let totalNumberOfResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalNumberOfResults)
        totalNumberOfResults = totalNumberOfResultsDecoded
    }
}

extension KendraClientTypes.QueryResultItem: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalAttributes = "AdditionalAttributes"
        case documentAttributes = "DocumentAttributes"
        case documentExcerpt = "DocumentExcerpt"
        case documentId = "DocumentId"
        case documentTitle = "DocumentTitle"
        case documentURI = "DocumentURI"
        case feedbackToken = "FeedbackToken"
        case id = "Id"
        case scoreAttributes = "ScoreAttributes"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalAttributes = additionalAttributes {
            var additionalAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalAttributes)
            for additionalresultattributelist0 in additionalAttributes {
                try additionalAttributesContainer.encode(additionalresultattributelist0)
            }
        }
        if let documentAttributes = documentAttributes {
            var documentAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .documentAttributes)
            for documentattributelist0 in documentAttributes {
                try documentAttributesContainer.encode(documentattributelist0)
            }
        }
        if let documentExcerpt = documentExcerpt {
            try encodeContainer.encode(documentExcerpt, forKey: .documentExcerpt)
        }
        if let documentId = documentId {
            try encodeContainer.encode(documentId, forKey: .documentId)
        }
        if let documentTitle = documentTitle {
            try encodeContainer.encode(documentTitle, forKey: .documentTitle)
        }
        if let documentURI = documentURI {
            try encodeContainer.encode(documentURI, forKey: .documentURI)
        }
        if let feedbackToken = feedbackToken {
            try encodeContainer.encode(feedbackToken, forKey: .feedbackToken)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let scoreAttributes = scoreAttributes {
            try encodeContainer.encode(scoreAttributes, forKey: .scoreAttributes)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(KendraClientTypes.QueryResultType.self, forKey: .type)
        type = typeDecoded
        let additionalAttributesContainer = try containerValues.decodeIfPresent([KendraClientTypes.AdditionalResultAttribute?].self, forKey: .additionalAttributes)
        var additionalAttributesDecoded0:[KendraClientTypes.AdditionalResultAttribute]? = nil
        if let additionalAttributesContainer = additionalAttributesContainer {
            additionalAttributesDecoded0 = [KendraClientTypes.AdditionalResultAttribute]()
            for structure0 in additionalAttributesContainer {
                if let structure0 = structure0 {
                    additionalAttributesDecoded0?.append(structure0)
                }
            }
        }
        additionalAttributes = additionalAttributesDecoded0
        let documentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentId)
        documentId = documentIdDecoded
        let documentTitleDecoded = try containerValues.decodeIfPresent(KendraClientTypes.TextWithHighlights.self, forKey: .documentTitle)
        documentTitle = documentTitleDecoded
        let documentExcerptDecoded = try containerValues.decodeIfPresent(KendraClientTypes.TextWithHighlights.self, forKey: .documentExcerpt)
        documentExcerpt = documentExcerptDecoded
        let documentURIDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentURI)
        documentURI = documentURIDecoded
        let documentAttributesContainer = try containerValues.decodeIfPresent([KendraClientTypes.DocumentAttribute?].self, forKey: .documentAttributes)
        var documentAttributesDecoded0:[KendraClientTypes.DocumentAttribute]? = nil
        if let documentAttributesContainer = documentAttributesContainer {
            documentAttributesDecoded0 = [KendraClientTypes.DocumentAttribute]()
            for structure0 in documentAttributesContainer {
                if let structure0 = structure0 {
                    documentAttributesDecoded0?.append(structure0)
                }
            }
        }
        documentAttributes = documentAttributesDecoded0
        let scoreAttributesDecoded = try containerValues.decodeIfPresent(KendraClientTypes.ScoreAttributes.self, forKey: .scoreAttributes)
        scoreAttributes = scoreAttributesDecoded
        let feedbackTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .feedbackToken)
        feedbackToken = feedbackTokenDecoded
    }
}

extension KendraClientTypes.QueryResultItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "QueryResultItem(additionalAttributes: \(Swift.String(describing: additionalAttributes)), documentAttributes: \(Swift.String(describing: documentAttributes)), documentExcerpt: \(Swift.String(describing: documentExcerpt)), documentId: \(Swift.String(describing: documentId)), documentTitle: \(Swift.String(describing: documentTitle)), documentURI: \(Swift.String(describing: documentURI)), feedbackToken: \(Swift.String(describing: feedbackToken)), id: \(Swift.String(describing: id)), scoreAttributes: \(Swift.String(describing: scoreAttributes)), type: \(Swift.String(describing: type)))"}
}

extension KendraClientTypes {
    /// <p>A single query result.</p>
    ///          <p>A query result contains information about a document returned by the
    ///          query. This includes the original location of the document, a list of
    ///          attributes assigned to the document, and relevant text from the
    ///          document that satisfies the query.</p>
    public struct QueryResultItem: Swift.Equatable {
        /// <p>One or more additional attributes associated with the query
        ///          result.</p>
        public let additionalAttributes: [KendraClientTypes.AdditionalResultAttribute]?
        /// <p>An array of document attributes for the document that the query
        ///          result maps to. For example, the document author (Author) or the source
        ///          URI (SourceUri) of the document.</p>
        public let documentAttributes: [KendraClientTypes.DocumentAttribute]?
        /// <p>An extract of the text in the document. Contains information about
        ///          highlighting the relevant terms in the excerpt.</p>
        public let documentExcerpt: KendraClientTypes.TextWithHighlights?
        /// <p>The unique identifier for the document.</p>
        public let documentId: Swift.String?
        /// <p>The title of the document. Contains the text of the title and
        ///          information for highlighting the relevant terms in the title.</p>
        public let documentTitle: KendraClientTypes.TextWithHighlights?
        /// <p>The URI of the original location of the document.</p>
        public let documentURI: Swift.String?
        /// <p>A token that identifies a particular result from a particular query.
        ///          Use this token to provide click-through feedback for the result. For
        ///          more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/submitting-feedback.html"> Submitting feedback
        ///          </a>.</p>
        public let feedbackToken: Swift.String?
        /// <p>The unique identifier for the query result.</p>
        public let id: Swift.String?
        /// <p>Indicates the confidence that Amazon Kendra has that a result matches the
        ///          query that you provided. Each result is placed into a bin that
        ///          indicates the confidence, <code>VERY_HIGH</code>, <code>HIGH</code>,
        ///             <code>MEDIUM</code> and <code>LOW</code>. You can use the score to
        ///          determine if a response meets the confidence needed for your
        ///          application.</p>
        ///          <p>The field is only set to <code>LOW</code> when the <code>Type</code>
        ///          field is set to <code>DOCUMENT</code> and Amazon Kendra is not confident that
        ///          the result matches the query.</p>
        public let scoreAttributes: KendraClientTypes.ScoreAttributes?
        /// <p>The type of document. </p>
        public let type: KendraClientTypes.QueryResultType?

        public init (
            additionalAttributes: [KendraClientTypes.AdditionalResultAttribute]? = nil,
            documentAttributes: [KendraClientTypes.DocumentAttribute]? = nil,
            documentExcerpt: KendraClientTypes.TextWithHighlights? = nil,
            documentId: Swift.String? = nil,
            documentTitle: KendraClientTypes.TextWithHighlights? = nil,
            documentURI: Swift.String? = nil,
            feedbackToken: Swift.String? = nil,
            id: Swift.String? = nil,
            scoreAttributes: KendraClientTypes.ScoreAttributes? = nil,
            type: KendraClientTypes.QueryResultType? = nil
        )
        {
            self.additionalAttributes = additionalAttributes
            self.documentAttributes = documentAttributes
            self.documentExcerpt = documentExcerpt
            self.documentId = documentId
            self.documentTitle = documentTitle
            self.documentURI = documentURI
            self.feedbackToken = feedbackToken
            self.id = id
            self.scoreAttributes = scoreAttributes
            self.type = type
        }
    }

}

extension KendraClientTypes {
    public enum QueryResultType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case answer
        case document
        case questionAnswer
        case sdkUnknown(Swift.String)

        public static var allCases: [QueryResultType] {
            return [
                .answer,
                .document,
                .questionAnswer,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .answer: return "ANSWER"
            case .document: return "DOCUMENT"
            case .questionAnswer: return "QUESTION_ANSWER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = QueryResultType(rawValue: rawValue) ?? QueryResultType.sdkUnknown(rawValue)
        }
    }
}

extension KendraClientTypes {
    public enum QuerySuggestionsBlockListStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case activeButUpdateFailed
        case creating
        case deleting
        case failed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [QuerySuggestionsBlockListStatus] {
            return [
                .active,
                .activeButUpdateFailed,
                .creating,
                .deleting,
                .failed,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .activeButUpdateFailed: return "ACTIVE_BUT_UPDATE_FAILED"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = QuerySuggestionsBlockListStatus(rawValue: rawValue) ?? QuerySuggestionsBlockListStatus.sdkUnknown(rawValue)
        }
    }
}

extension KendraClientTypes.QuerySuggestionsBlockListSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case id = "Id"
        case itemCount = "ItemCount"
        case name = "Name"
        case status = "Status"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let itemCount = itemCount {
            try encodeContainer.encode(itemCount, forKey: .itemCount)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(KendraClientTypes.QuerySuggestionsBlockListStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let itemCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .itemCount)
        itemCount = itemCountDecoded
    }
}

extension KendraClientTypes.QuerySuggestionsBlockListSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "QuerySuggestionsBlockListSummary(createdAt: \(Swift.String(describing: createdAt)), id: \(Swift.String(describing: id)), itemCount: \(Swift.String(describing: itemCount)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)))"}
}

extension KendraClientTypes {
    /// <p>Summary information on a query suggestions block list.</p>
    ///         <p>This includes information on the block list ID, block list name, when the
    ///             block list was created, when the block list was last updated, and the count
    ///             of block words/phrases in the block list.</p>
    ///         <p>For information on the current quota limits for block lists, see
    ///             <a href="https://docs.aws.amazon.com/kendra/latest/dg/quotas.html">Quotas
    ///                 for Amazon Kendra</a>.</p>
    public struct QuerySuggestionsBlockListSummary: Swift.Equatable {
        /// <p>The date-time summary information for a query suggestions
        ///             block list was last created.</p>
        public let createdAt: ClientRuntime.Date?
        /// <p>The identifier of a block list.</p>
        public let id: Swift.String?
        /// <p>The number of items in the block list file.</p>
        public let itemCount: Swift.Int?
        /// <p>The name of the block list.</p>
        public let name: Swift.String?
        /// <p>The status of the block list.</p>
        public let status: KendraClientTypes.QuerySuggestionsBlockListStatus?
        /// <p>The date-time the block list was last updated.</p>
        public let updatedAt: ClientRuntime.Date?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            itemCount: Swift.Int? = nil,
            name: Swift.String? = nil,
            status: KendraClientTypes.QuerySuggestionsBlockListStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.id = id
            self.itemCount = itemCount
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
        }
    }

}

extension KendraClientTypes {
    public enum QuerySuggestionsStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [QuerySuggestionsStatus] {
            return [
                .active,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = QuerySuggestionsStatus(rawValue: rawValue) ?? QuerySuggestionsStatus.sdkUnknown(rawValue)
        }
    }
}

extension KendraClientTypes {
    public enum ReadAccessType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allow
        case deny
        case sdkUnknown(Swift.String)

        public static var allCases: [ReadAccessType] {
            return [
                .allow,
                .deny,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allow: return "ALLOW"
            case .deny: return "DENY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReadAccessType(rawValue: rawValue) ?? ReadAccessType.sdkUnknown(rawValue)
        }
    }
}

extension KendraClientTypes.Relevance: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case duration = "Duration"
        case freshness = "Freshness"
        case importance = "Importance"
        case rankOrder = "RankOrder"
        case valueImportanceMap = "ValueImportanceMap"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let duration = duration {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if let freshness = freshness {
            try encodeContainer.encode(freshness, forKey: .freshness)
        }
        if let importance = importance {
            try encodeContainer.encode(importance, forKey: .importance)
        }
        if let rankOrder = rankOrder {
            try encodeContainer.encode(rankOrder.rawValue, forKey: .rankOrder)
        }
        if let valueImportanceMap = valueImportanceMap {
            var valueImportanceMapContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .valueImportanceMap)
            for (dictKey0, valueimportancemap0) in valueImportanceMap {
                try valueImportanceMapContainer.encode(valueimportancemap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let freshnessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .freshness)
        freshness = freshnessDecoded
        let importanceDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .importance)
        importance = importanceDecoded
        let durationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .duration)
        duration = durationDecoded
        let rankOrderDecoded = try containerValues.decodeIfPresent(KendraClientTypes.Order.self, forKey: .rankOrder)
        rankOrder = rankOrderDecoded
        let valueImportanceMapContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .valueImportanceMap)
        var valueImportanceMapDecoded0: [Swift.String:Swift.Int]? = nil
        if let valueImportanceMapContainer = valueImportanceMapContainer {
            valueImportanceMapDecoded0 = [Swift.String:Swift.Int]()
            for (key0, importance0) in valueImportanceMapContainer {
                if let importance0 = importance0 {
                    valueImportanceMapDecoded0?[key0] = importance0
                }
            }
        }
        valueImportanceMap = valueImportanceMapDecoded0
    }
}

extension KendraClientTypes.Relevance: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Relevance(duration: \(Swift.String(describing: duration)), freshness: \(Swift.String(describing: freshness)), importance: \(Swift.String(describing: importance)), rankOrder: \(Swift.String(describing: rankOrder)), valueImportanceMap: \(Swift.String(describing: valueImportanceMap)))"}
}

extension KendraClientTypes {
    /// <p>Provides information for manually tuning the relevance of a field
    ///             in a search. When a query includes terms that match the field, the
    ///             results are given a boost in the response based on these tuning
    ///             parameters.</p>
    public struct Relevance: Swift.Equatable {
        /// <p>Specifies the time period that the boost applies to. For example,
        ///             to make the boost apply to documents with the field value within the
        ///             last month, you would use "2628000s". Once the field value is beyond
        ///             the specified range, the effect of the boost drops off. The higher
        ///             the importance, the faster the effect drops off. If you don't
        ///             specify a value, the default is 3 months. The value of the field is
        ///             a numeric string followed by the character "s", for example "86400s"
        ///             for one day, or "604800s" for one week. </p>
        ///         <p>Only applies to <code>DATE</code> fields.</p>
        public let duration: Swift.String?
        /// <p>Indicates that this field determines how "fresh" a document is.
        ///             For example, if document 1 was created on November 5, and document 2
        ///             was created on October 31, document 1 is "fresher" than document 2.
        ///             You can only set the <code>Freshness</code> field on one
        ///                 <code>DATE</code> type field. Only applies to <code>DATE</code>
        ///             fields.</p>
        public let freshness: Swift.Bool?
        /// <p>The relative importance of the field in the search. Larger numbers
        ///             provide more of a boost than smaller numbers.</p>
        public let importance: Swift.Int?
        /// <p>Determines how values should be interpreted.</p>
        ///         <p>When the <code>RankOrder</code> field is <code>ASCENDING</code>,
        ///             higher numbers are better. For example, a document with a rating
        ///             score of 10 is higher ranking than a document with a rating score of
        ///             1.</p>
        ///         <p>When the <code>RankOrder</code> field is <code>DESCENDING</code>,
        ///             lower numbers are better. For example, in a task tracking
        ///             application, a priority 1 task is more important than a priority 5
        ///             task.</p>
        ///         <p>Only applies to <code>LONG</code> and <code>DOUBLE</code>
        ///             fields.</p>
        public let rankOrder: KendraClientTypes.Order?
        /// <p>A list of values that should be given a different boost when they
        ///             appear in the result list. For example, if you are boosting a field
        ///             called "department," query terms that match the department field are
        ///             boosted in the result. However, you can add entries from the
        ///             department field to boost documents with those values higher. </p>
        ///         <p>For example, you can add entries to the map with names of
        ///             departments. If you add "HR",5 and "Legal",3 those departments are
        ///             given special attention when they appear in the metadata of a
        ///             document. When those terms appear they are given the specified
        ///             importance instead of the regular importance for the boost.</p>
        public let valueImportanceMap: [Swift.String:Swift.Int]?

        public init (
            duration: Swift.String? = nil,
            freshness: Swift.Bool? = nil,
            importance: Swift.Int? = nil,
            rankOrder: KendraClientTypes.Order? = nil,
            valueImportanceMap: [Swift.String:Swift.Int]? = nil
        )
        {
            self.duration = duration
            self.freshness = freshness
            self.importance = importance
            self.rankOrder = rankOrder
            self.valueImportanceMap = valueImportanceMap
        }
    }

}

extension KendraClientTypes.RelevanceFeedback: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case relevanceValue = "RelevanceValue"
        case resultId = "ResultId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let relevanceValue = relevanceValue {
            try encodeContainer.encode(relevanceValue.rawValue, forKey: .relevanceValue)
        }
        if let resultId = resultId {
            try encodeContainer.encode(resultId, forKey: .resultId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resultId)
        resultId = resultIdDecoded
        let relevanceValueDecoded = try containerValues.decodeIfPresent(KendraClientTypes.RelevanceType.self, forKey: .relevanceValue)
        relevanceValue = relevanceValueDecoded
    }
}

extension KendraClientTypes.RelevanceFeedback: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RelevanceFeedback(relevanceValue: \(Swift.String(describing: relevanceValue)), resultId: \(Swift.String(describing: resultId)))"}
}

extension KendraClientTypes {
    /// <p>Provides feedback on how relevant a document is to a search. Your
    ///             application uses the <code>SubmitFeedback</code> operation to
    ///             provide relevance information.</p>
    public struct RelevanceFeedback: Swift.Equatable {
        /// <p>Whether to document was relevant or not relevant to the
        ///             search.</p>
        public let relevanceValue: KendraClientTypes.RelevanceType?
        /// <p>The unique identifier of the search result that the user provided
        ///             relevance feedback for.</p>
        public let resultId: Swift.String?

        public init (
            relevanceValue: KendraClientTypes.RelevanceType? = nil,
            resultId: Swift.String? = nil
        )
        {
            self.relevanceValue = relevanceValue
            self.resultId = resultId
        }
    }

}

extension KendraClientTypes {
    public enum RelevanceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case notRelevant
        case relevant
        case sdkUnknown(Swift.String)

        public static var allCases: [RelevanceType] {
            return [
                .notRelevant,
                .relevant,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .notRelevant: return "NOT_RELEVANT"
            case .relevant: return "RELEVANT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RelevanceType(rawValue: rawValue) ?? RelevanceType.sdkUnknown(rawValue)
        }
    }
}

extension ResourceAlreadyExistException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceAlreadyExistException(message: \(Swift.String(describing: message)))"}
}

extension ResourceAlreadyExistException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceAlreadyExistExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct ResourceAlreadyExistException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceAlreadyExistExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceAlreadyExistExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceInUseException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceInUseException(message: \(Swift.String(describing: message)))"}
}

extension ResourceInUseException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct ResourceInUseException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceUnavailableException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceUnavailableException(message: \(Swift.String(describing: message)))"}
}

extension ResourceUnavailableException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct ResourceUnavailableException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceUnavailableExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KendraClientTypes.S3DataSourceConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessControlListConfiguration = "AccessControlListConfiguration"
        case bucketName = "BucketName"
        case documentsMetadataConfiguration = "DocumentsMetadataConfiguration"
        case exclusionPatterns = "ExclusionPatterns"
        case inclusionPatterns = "InclusionPatterns"
        case inclusionPrefixes = "InclusionPrefixes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessControlListConfiguration = accessControlListConfiguration {
            try encodeContainer.encode(accessControlListConfiguration, forKey: .accessControlListConfiguration)
        }
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let documentsMetadataConfiguration = documentsMetadataConfiguration {
            try encodeContainer.encode(documentsMetadataConfiguration, forKey: .documentsMetadataConfiguration)
        }
        if let exclusionPatterns = exclusionPatterns {
            var exclusionPatternsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .exclusionPatterns)
            for datasourceinclusionsexclusionsstrings0 in exclusionPatterns {
                try exclusionPatternsContainer.encode(datasourceinclusionsexclusionsstrings0)
            }
        }
        if let inclusionPatterns = inclusionPatterns {
            var inclusionPatternsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inclusionPatterns)
            for datasourceinclusionsexclusionsstrings0 in inclusionPatterns {
                try inclusionPatternsContainer.encode(datasourceinclusionsexclusionsstrings0)
            }
        }
        if let inclusionPrefixes = inclusionPrefixes {
            var inclusionPrefixesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inclusionPrefixes)
            for datasourceinclusionsexclusionsstrings0 in inclusionPrefixes {
                try inclusionPrefixesContainer.encode(datasourceinclusionsexclusionsstrings0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let inclusionPrefixesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .inclusionPrefixes)
        var inclusionPrefixesDecoded0:[Swift.String]? = nil
        if let inclusionPrefixesContainer = inclusionPrefixesContainer {
            inclusionPrefixesDecoded0 = [Swift.String]()
            for string0 in inclusionPrefixesContainer {
                if let string0 = string0 {
                    inclusionPrefixesDecoded0?.append(string0)
                }
            }
        }
        inclusionPrefixes = inclusionPrefixesDecoded0
        let inclusionPatternsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .inclusionPatterns)
        var inclusionPatternsDecoded0:[Swift.String]? = nil
        if let inclusionPatternsContainer = inclusionPatternsContainer {
            inclusionPatternsDecoded0 = [Swift.String]()
            for string0 in inclusionPatternsContainer {
                if let string0 = string0 {
                    inclusionPatternsDecoded0?.append(string0)
                }
            }
        }
        inclusionPatterns = inclusionPatternsDecoded0
        let exclusionPatternsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .exclusionPatterns)
        var exclusionPatternsDecoded0:[Swift.String]? = nil
        if let exclusionPatternsContainer = exclusionPatternsContainer {
            exclusionPatternsDecoded0 = [Swift.String]()
            for string0 in exclusionPatternsContainer {
                if let string0 = string0 {
                    exclusionPatternsDecoded0?.append(string0)
                }
            }
        }
        exclusionPatterns = exclusionPatternsDecoded0
        let documentsMetadataConfigurationDecoded = try containerValues.decodeIfPresent(KendraClientTypes.DocumentsMetadataConfiguration.self, forKey: .documentsMetadataConfiguration)
        documentsMetadataConfiguration = documentsMetadataConfigurationDecoded
        let accessControlListConfigurationDecoded = try containerValues.decodeIfPresent(KendraClientTypes.AccessControlListConfiguration.self, forKey: .accessControlListConfiguration)
        accessControlListConfiguration = accessControlListConfigurationDecoded
    }
}

extension KendraClientTypes.S3DataSourceConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "S3DataSourceConfiguration(accessControlListConfiguration: \(Swift.String(describing: accessControlListConfiguration)), bucketName: \(Swift.String(describing: bucketName)), documentsMetadataConfiguration: \(Swift.String(describing: documentsMetadataConfiguration)), exclusionPatterns: \(Swift.String(describing: exclusionPatterns)), inclusionPatterns: \(Swift.String(describing: inclusionPatterns)), inclusionPrefixes: \(Swift.String(describing: inclusionPrefixes)))"}
}

extension KendraClientTypes {
    /// <p>Provides configuration information for a data source to index
    ///             documents in an Amazon S3 bucket.</p>
    public struct S3DataSourceConfiguration: Swift.Equatable {
        /// <p>Provides the path to the S3 bucket that contains the user context
        ///             filtering files for the data source. For the format of the file, see
        ///                 <a href="https://docs.aws.amazon.com/kendra/latest/dg/s3-acl.html">Access control for S3 data sources</a>.</p>
        public let accessControlListConfiguration: KendraClientTypes.AccessControlListConfiguration?
        /// <p>The name of the bucket that contains the documents.</p>
        public let bucketName: Swift.String?
        /// <p>Document metadata files that contain information such as the
        ///             document access control information, source URI, document author,
        ///             and custom attributes. Each metadata file contains metadata about a
        ///             single document.</p>
        public let documentsMetadataConfiguration: KendraClientTypes.DocumentsMetadataConfiguration?
        /// <p>A list of glob patterns for documents that should not be indexed.
        ///             If a document that matches an inclusion prefix or inclusion pattern
        ///             also matches an exclusion pattern, the document is not
        ///             indexed.</p>
        ///         <p>Some <a href="https://docs.aws.amazon.com/cli/latest/reference/s3/#use-of-exclude-and-include-filters">examples</a>
        ///             are:</p>
        ///         <ul>
        ///             <li>
        ///                 <p>
        ///                   <i>*.png , *.jpg</i> will exclude
        ///                     all PNG and JPEG image files in a directory
        ///                     (files with the extensions .png and .jpg).</p>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                   <i>*internal*</i> will exclude all
        ///                     files in a directory that contain 'internal' in the file name,
        ///                     such as 'internal', 'internal_only', 'company_internal'.</p>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                   <i>**/*internal*</i> will exclude
        ///                     all internal-related files in a directory and its subdirectories.</p>
        ///             </li>
        ///          </ul>
        public let exclusionPatterns: [Swift.String]?
        /// <p>A list of glob patterns for documents that should be indexed. If a
        ///             document that matches an inclusion pattern also matches an exclusion
        ///             pattern, the document is not indexed.</p>
        ///         <p>Some <a href="https://docs.aws.amazon.com/cli/latest/reference/s3/#use-of-exclude-and-include-filters">examples</a>
        ///             are:</p>
        ///         <ul>
        ///             <li>
        ///                 <p>
        ///                   <i>*.txt</i> will include all text files
        ///                     in a directory (files with the extension .txt).</p>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                   <i>**/*.txt</i> will include all text
        ///                     files in a directory and its subdirectories.</p>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                   <i>*tax*</i> will include all files in
        ///                     a directory that contain 'tax' in the file name, such as 'tax',
        ///                     'taxes', 'income_tax'.</p>
        ///             </li>
        ///          </ul>
        public let inclusionPatterns: [Swift.String]?
        /// <p>A list of S3 prefixes for the documents that should be included in
        ///             the index.</p>
        public let inclusionPrefixes: [Swift.String]?

        public init (
            accessControlListConfiguration: KendraClientTypes.AccessControlListConfiguration? = nil,
            bucketName: Swift.String? = nil,
            documentsMetadataConfiguration: KendraClientTypes.DocumentsMetadataConfiguration? = nil,
            exclusionPatterns: [Swift.String]? = nil,
            inclusionPatterns: [Swift.String]? = nil,
            inclusionPrefixes: [Swift.String]? = nil
        )
        {
            self.accessControlListConfiguration = accessControlListConfiguration
            self.bucketName = bucketName
            self.documentsMetadataConfiguration = documentsMetadataConfiguration
            self.exclusionPatterns = exclusionPatterns
            self.inclusionPatterns = inclusionPatterns
            self.inclusionPrefixes = inclusionPrefixes
        }
    }

}

extension KendraClientTypes.S3Path: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case key = "Key"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
    }
}

extension KendraClientTypes.S3Path: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "S3Path(bucket: \(Swift.String(describing: bucket)), key: \(Swift.String(describing: key)))"}
}

extension KendraClientTypes {
    /// <p>Information required to find a specific file in an Amazon S3
    ///             bucket.</p>
    public struct S3Path: Swift.Equatable {
        /// <p>The name of the S3 bucket that contains the file.</p>
        public let bucket: Swift.String?
        /// <p>The name of the file.</p>
        public let key: Swift.String?

        public init (
            bucket: Swift.String? = nil,
            key: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.key = key
        }
    }

}

extension KendraClientTypes.SalesforceChatterFeedConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentDataFieldName = "DocumentDataFieldName"
        case documentTitleFieldName = "DocumentTitleFieldName"
        case fieldMappings = "FieldMappings"
        case includeFilterTypes = "IncludeFilterTypes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentDataFieldName = documentDataFieldName {
            try encodeContainer.encode(documentDataFieldName, forKey: .documentDataFieldName)
        }
        if let documentTitleFieldName = documentTitleFieldName {
            try encodeContainer.encode(documentTitleFieldName, forKey: .documentTitleFieldName)
        }
        if let fieldMappings = fieldMappings {
            var fieldMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fieldMappings)
            for datasourcetoindexfieldmappinglist0 in fieldMappings {
                try fieldMappingsContainer.encode(datasourcetoindexfieldmappinglist0)
            }
        }
        if let includeFilterTypes = includeFilterTypes {
            var includeFilterTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .includeFilterTypes)
            for salesforcechatterfeedincludefiltertypes0 in includeFilterTypes {
                try includeFilterTypesContainer.encode(salesforcechatterfeedincludefiltertypes0.rawValue)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentDataFieldNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentDataFieldName)
        documentDataFieldName = documentDataFieldNameDecoded
        let documentTitleFieldNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentTitleFieldName)
        documentTitleFieldName = documentTitleFieldNameDecoded
        let fieldMappingsContainer = try containerValues.decodeIfPresent([KendraClientTypes.DataSourceToIndexFieldMapping?].self, forKey: .fieldMappings)
        var fieldMappingsDecoded0:[KendraClientTypes.DataSourceToIndexFieldMapping]? = nil
        if let fieldMappingsContainer = fieldMappingsContainer {
            fieldMappingsDecoded0 = [KendraClientTypes.DataSourceToIndexFieldMapping]()
            for structure0 in fieldMappingsContainer {
                if let structure0 = structure0 {
                    fieldMappingsDecoded0?.append(structure0)
                }
            }
        }
        fieldMappings = fieldMappingsDecoded0
        let includeFilterTypesContainer = try containerValues.decodeIfPresent([KendraClientTypes.SalesforceChatterFeedIncludeFilterType?].self, forKey: .includeFilterTypes)
        var includeFilterTypesDecoded0:[KendraClientTypes.SalesforceChatterFeedIncludeFilterType]? = nil
        if let includeFilterTypesContainer = includeFilterTypesContainer {
            includeFilterTypesDecoded0 = [KendraClientTypes.SalesforceChatterFeedIncludeFilterType]()
            for string0 in includeFilterTypesContainer {
                if let string0 = string0 {
                    includeFilterTypesDecoded0?.append(string0)
                }
            }
        }
        includeFilterTypes = includeFilterTypesDecoded0
    }
}

extension KendraClientTypes.SalesforceChatterFeedConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SalesforceChatterFeedConfiguration(documentDataFieldName: \(Swift.String(describing: documentDataFieldName)), documentTitleFieldName: \(Swift.String(describing: documentTitleFieldName)), fieldMappings: \(Swift.String(describing: fieldMappings)), includeFilterTypes: \(Swift.String(describing: includeFilterTypes)))"}
}

extension KendraClientTypes {
    /// <p>Defines configuration for syncing a Salesforce chatter feed. The
    ///             contents of the object comes from the Salesforce FeedItem
    ///             table.</p>
    public struct SalesforceChatterFeedConfiguration: Swift.Equatable {
        /// <p>The name of the column in the Salesforce FeedItem table that
        ///             contains the content to index. Typically this is the
        ///                 <code>Body</code> column.</p>
        public let documentDataFieldName: Swift.String?
        /// <p>The name of the column in the Salesforce FeedItem table that
        ///             contains the title of the document. This is typically the
        ///                 <code>Title</code> column.</p>
        public let documentTitleFieldName: Swift.String?
        /// <p>Maps fields from a Salesforce chatter feed into Amazon Kendra index
        ///             fields.</p>
        public let fieldMappings: [KendraClientTypes.DataSourceToIndexFieldMapping]?
        /// <p>Filters the documents in the feed based on status of the user.
        ///             When you specify <code>ACTIVE_USERS</code> only documents from users
        ///             who have an active account are indexed. When you specify
        ///                 <code>STANDARD_USER</code> only documents for Salesforce
        ///             standard users are documented. You can specify both.</p>
        public let includeFilterTypes: [KendraClientTypes.SalesforceChatterFeedIncludeFilterType]?

        public init (
            documentDataFieldName: Swift.String? = nil,
            documentTitleFieldName: Swift.String? = nil,
            fieldMappings: [KendraClientTypes.DataSourceToIndexFieldMapping]? = nil,
            includeFilterTypes: [KendraClientTypes.SalesforceChatterFeedIncludeFilterType]? = nil
        )
        {
            self.documentDataFieldName = documentDataFieldName
            self.documentTitleFieldName = documentTitleFieldName
            self.fieldMappings = fieldMappings
            self.includeFilterTypes = includeFilterTypes
        }
    }

}

extension KendraClientTypes {
    public enum SalesforceChatterFeedIncludeFilterType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case activeUser
        case standardUser
        case sdkUnknown(Swift.String)

        public static var allCases: [SalesforceChatterFeedIncludeFilterType] {
            return [
                .activeUser,
                .standardUser,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .activeUser: return "ACTIVE_USER"
            case .standardUser: return "STANDARD_USER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SalesforceChatterFeedIncludeFilterType(rawValue: rawValue) ?? SalesforceChatterFeedIncludeFilterType.sdkUnknown(rawValue)
        }
    }
}

extension KendraClientTypes.SalesforceConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chatterFeedConfiguration = "ChatterFeedConfiguration"
        case crawlAttachments = "CrawlAttachments"
        case excludeAttachmentFilePatterns = "ExcludeAttachmentFilePatterns"
        case includeAttachmentFilePatterns = "IncludeAttachmentFilePatterns"
        case knowledgeArticleConfiguration = "KnowledgeArticleConfiguration"
        case secretArn = "SecretArn"
        case serverUrl = "ServerUrl"
        case standardObjectAttachmentConfiguration = "StandardObjectAttachmentConfiguration"
        case standardObjectConfigurations = "StandardObjectConfigurations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let chatterFeedConfiguration = chatterFeedConfiguration {
            try encodeContainer.encode(chatterFeedConfiguration, forKey: .chatterFeedConfiguration)
        }
        if crawlAttachments != false {
            try encodeContainer.encode(crawlAttachments, forKey: .crawlAttachments)
        }
        if let excludeAttachmentFilePatterns = excludeAttachmentFilePatterns {
            var excludeAttachmentFilePatternsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .excludeAttachmentFilePatterns)
            for datasourceinclusionsexclusionsstrings0 in excludeAttachmentFilePatterns {
                try excludeAttachmentFilePatternsContainer.encode(datasourceinclusionsexclusionsstrings0)
            }
        }
        if let includeAttachmentFilePatterns = includeAttachmentFilePatterns {
            var includeAttachmentFilePatternsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .includeAttachmentFilePatterns)
            for datasourceinclusionsexclusionsstrings0 in includeAttachmentFilePatterns {
                try includeAttachmentFilePatternsContainer.encode(datasourceinclusionsexclusionsstrings0)
            }
        }
        if let knowledgeArticleConfiguration = knowledgeArticleConfiguration {
            try encodeContainer.encode(knowledgeArticleConfiguration, forKey: .knowledgeArticleConfiguration)
        }
        if let secretArn = secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
        if let serverUrl = serverUrl {
            try encodeContainer.encode(serverUrl, forKey: .serverUrl)
        }
        if let standardObjectAttachmentConfiguration = standardObjectAttachmentConfiguration {
            try encodeContainer.encode(standardObjectAttachmentConfiguration, forKey: .standardObjectAttachmentConfiguration)
        }
        if let standardObjectConfigurations = standardObjectConfigurations {
            var standardObjectConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .standardObjectConfigurations)
            for salesforcestandardobjectconfigurationlist0 in standardObjectConfigurations {
                try standardObjectConfigurationsContainer.encode(salesforcestandardobjectconfigurationlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverUrl)
        serverUrl = serverUrlDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let standardObjectConfigurationsContainer = try containerValues.decodeIfPresent([KendraClientTypes.SalesforceStandardObjectConfiguration?].self, forKey: .standardObjectConfigurations)
        var standardObjectConfigurationsDecoded0:[KendraClientTypes.SalesforceStandardObjectConfiguration]? = nil
        if let standardObjectConfigurationsContainer = standardObjectConfigurationsContainer {
            standardObjectConfigurationsDecoded0 = [KendraClientTypes.SalesforceStandardObjectConfiguration]()
            for structure0 in standardObjectConfigurationsContainer {
                if let structure0 = structure0 {
                    standardObjectConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        standardObjectConfigurations = standardObjectConfigurationsDecoded0
        let knowledgeArticleConfigurationDecoded = try containerValues.decodeIfPresent(KendraClientTypes.SalesforceKnowledgeArticleConfiguration.self, forKey: .knowledgeArticleConfiguration)
        knowledgeArticleConfiguration = knowledgeArticleConfigurationDecoded
        let chatterFeedConfigurationDecoded = try containerValues.decodeIfPresent(KendraClientTypes.SalesforceChatterFeedConfiguration.self, forKey: .chatterFeedConfiguration)
        chatterFeedConfiguration = chatterFeedConfigurationDecoded
        let crawlAttachmentsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .crawlAttachments)
        crawlAttachments = crawlAttachmentsDecoded
        let standardObjectAttachmentConfigurationDecoded = try containerValues.decodeIfPresent(KendraClientTypes.SalesforceStandardObjectAttachmentConfiguration.self, forKey: .standardObjectAttachmentConfiguration)
        standardObjectAttachmentConfiguration = standardObjectAttachmentConfigurationDecoded
        let includeAttachmentFilePatternsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .includeAttachmentFilePatterns)
        var includeAttachmentFilePatternsDecoded0:[Swift.String]? = nil
        if let includeAttachmentFilePatternsContainer = includeAttachmentFilePatternsContainer {
            includeAttachmentFilePatternsDecoded0 = [Swift.String]()
            for string0 in includeAttachmentFilePatternsContainer {
                if let string0 = string0 {
                    includeAttachmentFilePatternsDecoded0?.append(string0)
                }
            }
        }
        includeAttachmentFilePatterns = includeAttachmentFilePatternsDecoded0
        let excludeAttachmentFilePatternsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .excludeAttachmentFilePatterns)
        var excludeAttachmentFilePatternsDecoded0:[Swift.String]? = nil
        if let excludeAttachmentFilePatternsContainer = excludeAttachmentFilePatternsContainer {
            excludeAttachmentFilePatternsDecoded0 = [Swift.String]()
            for string0 in excludeAttachmentFilePatternsContainer {
                if let string0 = string0 {
                    excludeAttachmentFilePatternsDecoded0?.append(string0)
                }
            }
        }
        excludeAttachmentFilePatterns = excludeAttachmentFilePatternsDecoded0
    }
}

extension KendraClientTypes.SalesforceConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SalesforceConfiguration(chatterFeedConfiguration: \(Swift.String(describing: chatterFeedConfiguration)), crawlAttachments: \(Swift.String(describing: crawlAttachments)), excludeAttachmentFilePatterns: \(Swift.String(describing: excludeAttachmentFilePatterns)), includeAttachmentFilePatterns: \(Swift.String(describing: includeAttachmentFilePatterns)), knowledgeArticleConfiguration: \(Swift.String(describing: knowledgeArticleConfiguration)), secretArn: \(Swift.String(describing: secretArn)), serverUrl: \(Swift.String(describing: serverUrl)), standardObjectAttachmentConfiguration: \(Swift.String(describing: standardObjectAttachmentConfiguration)), standardObjectConfigurations: \(Swift.String(describing: standardObjectConfigurations)))"}
}

extension KendraClientTypes {
    /// <p>Provides configuration information for connecting to a Salesforce
    ///             data source.</p>
    public struct SalesforceConfiguration: Swift.Equatable {
        /// <p>Specifies configuration information for Salesforce chatter
        ///             feeds.</p>
        public let chatterFeedConfiguration: KendraClientTypes.SalesforceChatterFeedConfiguration?
        /// <p>Indicates whether Amazon Kendra should index attachments to Salesforce
        ///             objects.</p>
        public let crawlAttachments: Swift.Bool
        /// <p>A list of regular expression patterns. Documents that match the
        ///             patterns are excluded from the index. Documents that don't match the
        ///             patterns are included in the index. If a document matches both an
        ///             exclusion pattern and an inclusion pattern, the document is not
        ///             included in the index.</p>
        ///         <p>The regex is applied to the name of the attached file.</p>
        public let excludeAttachmentFilePatterns: [Swift.String]?
        /// <p>A list of regular expression patterns. Documents that match the
        ///             patterns are included in the index. Documents that don't match the
        ///             patterns are excluded from the index. If a document matches both an
        ///             inclusion pattern and an exclusion pattern, the document is not
        ///             included in the index.</p>
        ///         <p>The regex is applied to the name of the attached file.</p>
        public let includeAttachmentFilePatterns: [Swift.String]?
        /// <p>Specifies configuration information for the knowledge article
        ///             types that Amazon Kendra indexes. Amazon Kendra indexes standard knowledge
        ///             articles and the standard fields of knowledge articles, or the
        ///             custom fields of custom knowledge articles, but not both.</p>
        public let knowledgeArticleConfiguration: KendraClientTypes.SalesforceKnowledgeArticleConfiguration?
        /// <p>The Amazon Resource Name (ARN) of an AWS Secrets Manager secret
        ///             that contains the key/value pairs required to connect to your
        ///             Salesforce instance. The secret must contain a JSON structure with
        ///             the following keys:</p>
        ///         <ul>
        ///             <li>
        ///                 <p>authenticationUrl - The OAUTH endpoint that Amazon Kendra
        ///                     connects to get an OAUTH token. </p>
        ///             </li>
        ///             <li>
        ///                 <p>consumerKey - The application public key generated when
        ///                     you created your Salesforce application.</p>
        ///             </li>
        ///             <li>
        ///                 <p>consumerSecret - The application private key generated
        ///                     when you created your Salesforce application.</p>
        ///             </li>
        ///             <li>
        ///                 <p>password - The password associated with the user logging
        ///                     in to the Salesforce instance.</p>
        ///             </li>
        ///             <li>
        ///                 <p>securityToken - The token associated with the user account
        ///                     logging in to the Salesforce instance.</p>
        ///             </li>
        ///             <li>
        ///                 <p>username - The user name of the user logging in to the
        ///                     Salesforce instance.</p>
        ///             </li>
        ///          </ul>
        public let secretArn: Swift.String?
        /// <p>The instance URL for the Salesforce site that you want to
        ///             index.</p>
        public let serverUrl: Swift.String?
        /// <p>Provides configuration information for processing attachments to
        ///             Salesforce standard objects. </p>
        public let standardObjectAttachmentConfiguration: KendraClientTypes.SalesforceStandardObjectAttachmentConfiguration?
        /// <p>Specifies the Salesforce standard objects that Amazon Kendra
        ///             indexes.</p>
        public let standardObjectConfigurations: [KendraClientTypes.SalesforceStandardObjectConfiguration]?

        public init (
            chatterFeedConfiguration: KendraClientTypes.SalesforceChatterFeedConfiguration? = nil,
            crawlAttachments: Swift.Bool = false,
            excludeAttachmentFilePatterns: [Swift.String]? = nil,
            includeAttachmentFilePatterns: [Swift.String]? = nil,
            knowledgeArticleConfiguration: KendraClientTypes.SalesforceKnowledgeArticleConfiguration? = nil,
            secretArn: Swift.String? = nil,
            serverUrl: Swift.String? = nil,
            standardObjectAttachmentConfiguration: KendraClientTypes.SalesforceStandardObjectAttachmentConfiguration? = nil,
            standardObjectConfigurations: [KendraClientTypes.SalesforceStandardObjectConfiguration]? = nil
        )
        {
            self.chatterFeedConfiguration = chatterFeedConfiguration
            self.crawlAttachments = crawlAttachments
            self.excludeAttachmentFilePatterns = excludeAttachmentFilePatterns
            self.includeAttachmentFilePatterns = includeAttachmentFilePatterns
            self.knowledgeArticleConfiguration = knowledgeArticleConfiguration
            self.secretArn = secretArn
            self.serverUrl = serverUrl
            self.standardObjectAttachmentConfiguration = standardObjectAttachmentConfiguration
            self.standardObjectConfigurations = standardObjectConfigurations
        }
    }

}

extension KendraClientTypes.SalesforceCustomKnowledgeArticleTypeConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentDataFieldName = "DocumentDataFieldName"
        case documentTitleFieldName = "DocumentTitleFieldName"
        case fieldMappings = "FieldMappings"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentDataFieldName = documentDataFieldName {
            try encodeContainer.encode(documentDataFieldName, forKey: .documentDataFieldName)
        }
        if let documentTitleFieldName = documentTitleFieldName {
            try encodeContainer.encode(documentTitleFieldName, forKey: .documentTitleFieldName)
        }
        if let fieldMappings = fieldMappings {
            var fieldMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fieldMappings)
            for datasourcetoindexfieldmappinglist0 in fieldMappings {
                try fieldMappingsContainer.encode(datasourcetoindexfieldmappinglist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let documentDataFieldNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentDataFieldName)
        documentDataFieldName = documentDataFieldNameDecoded
        let documentTitleFieldNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentTitleFieldName)
        documentTitleFieldName = documentTitleFieldNameDecoded
        let fieldMappingsContainer = try containerValues.decodeIfPresent([KendraClientTypes.DataSourceToIndexFieldMapping?].self, forKey: .fieldMappings)
        var fieldMappingsDecoded0:[KendraClientTypes.DataSourceToIndexFieldMapping]? = nil
        if let fieldMappingsContainer = fieldMappingsContainer {
            fieldMappingsDecoded0 = [KendraClientTypes.DataSourceToIndexFieldMapping]()
            for structure0 in fieldMappingsContainer {
                if let structure0 = structure0 {
                    fieldMappingsDecoded0?.append(structure0)
                }
            }
        }
        fieldMappings = fieldMappingsDecoded0
    }
}

extension KendraClientTypes.SalesforceCustomKnowledgeArticleTypeConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SalesforceCustomKnowledgeArticleTypeConfiguration(documentDataFieldName: \(Swift.String(describing: documentDataFieldName)), documentTitleFieldName: \(Swift.String(describing: documentTitleFieldName)), fieldMappings: \(Swift.String(describing: fieldMappings)), name: \(Swift.String(describing: name)))"}
}

extension KendraClientTypes {
    /// <p>Provides configuration information for indexing Salesforce custom
    ///             articles.</p>
    public struct SalesforceCustomKnowledgeArticleTypeConfiguration: Swift.Equatable {
        /// <p>The name of the field in the custom knowledge article that
        ///             contains the document data to index.</p>
        public let documentDataFieldName: Swift.String?
        /// <p>The name of the field in the custom knowledge article that
        ///             contains the document title.</p>
        public let documentTitleFieldName: Swift.String?
        /// <p>One or more objects that map fields in the custom knowledge
        ///             article to fields in the Amazon Kendra index.</p>
        public let fieldMappings: [KendraClientTypes.DataSourceToIndexFieldMapping]?
        /// <p>The name of the configuration.</p>
        public let name: Swift.String?

        public init (
            documentDataFieldName: Swift.String? = nil,
            documentTitleFieldName: Swift.String? = nil,
            fieldMappings: [KendraClientTypes.DataSourceToIndexFieldMapping]? = nil,
            name: Swift.String? = nil
        )
        {
            self.documentDataFieldName = documentDataFieldName
            self.documentTitleFieldName = documentTitleFieldName
            self.fieldMappings = fieldMappings
            self.name = name
        }
    }

}

extension KendraClientTypes.SalesforceKnowledgeArticleConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customKnowledgeArticleTypeConfigurations = "CustomKnowledgeArticleTypeConfigurations"
        case includedStates = "IncludedStates"
        case standardKnowledgeArticleTypeConfiguration = "StandardKnowledgeArticleTypeConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customKnowledgeArticleTypeConfigurations = customKnowledgeArticleTypeConfigurations {
            var customKnowledgeArticleTypeConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .customKnowledgeArticleTypeConfigurations)
            for salesforcecustomknowledgearticletypeconfigurationlist0 in customKnowledgeArticleTypeConfigurations {
                try customKnowledgeArticleTypeConfigurationsContainer.encode(salesforcecustomknowledgearticletypeconfigurationlist0)
            }
        }
        if let includedStates = includedStates {
            var includedStatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .includedStates)
            for salesforceknowledgearticlestatelist0 in includedStates {
                try includedStatesContainer.encode(salesforceknowledgearticlestatelist0.rawValue)
            }
        }
        if let standardKnowledgeArticleTypeConfiguration = standardKnowledgeArticleTypeConfiguration {
            try encodeContainer.encode(standardKnowledgeArticleTypeConfiguration, forKey: .standardKnowledgeArticleTypeConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let includedStatesContainer = try containerValues.decodeIfPresent([KendraClientTypes.SalesforceKnowledgeArticleState?].self, forKey: .includedStates)
        var includedStatesDecoded0:[KendraClientTypes.SalesforceKnowledgeArticleState]? = nil
        if let includedStatesContainer = includedStatesContainer {
            includedStatesDecoded0 = [KendraClientTypes.SalesforceKnowledgeArticleState]()
            for string0 in includedStatesContainer {
                if let string0 = string0 {
                    includedStatesDecoded0?.append(string0)
                }
            }
        }
        includedStates = includedStatesDecoded0
        let standardKnowledgeArticleTypeConfigurationDecoded = try containerValues.decodeIfPresent(KendraClientTypes.SalesforceStandardKnowledgeArticleTypeConfiguration.self, forKey: .standardKnowledgeArticleTypeConfiguration)
        standardKnowledgeArticleTypeConfiguration = standardKnowledgeArticleTypeConfigurationDecoded
        let customKnowledgeArticleTypeConfigurationsContainer = try containerValues.decodeIfPresent([KendraClientTypes.SalesforceCustomKnowledgeArticleTypeConfiguration?].self, forKey: .customKnowledgeArticleTypeConfigurations)
        var customKnowledgeArticleTypeConfigurationsDecoded0:[KendraClientTypes.SalesforceCustomKnowledgeArticleTypeConfiguration]? = nil
        if let customKnowledgeArticleTypeConfigurationsContainer = customKnowledgeArticleTypeConfigurationsContainer {
            customKnowledgeArticleTypeConfigurationsDecoded0 = [KendraClientTypes.SalesforceCustomKnowledgeArticleTypeConfiguration]()
            for structure0 in customKnowledgeArticleTypeConfigurationsContainer {
                if let structure0 = structure0 {
                    customKnowledgeArticleTypeConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        customKnowledgeArticleTypeConfigurations = customKnowledgeArticleTypeConfigurationsDecoded0
    }
}

extension KendraClientTypes.SalesforceKnowledgeArticleConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SalesforceKnowledgeArticleConfiguration(customKnowledgeArticleTypeConfigurations: \(Swift.String(describing: customKnowledgeArticleTypeConfigurations)), includedStates: \(Swift.String(describing: includedStates)), standardKnowledgeArticleTypeConfiguration: \(Swift.String(describing: standardKnowledgeArticleTypeConfiguration)))"}
}

extension KendraClientTypes {
    /// <p>Specifies configuration information for the knowledge article
    ///             types that Amazon Kendra indexes. Amazon Kendra indexes standard knowledge
    ///             articles and the standard fields of knowledge articles, or the
    ///             custom fields of custom knowledge articles, but not both </p>
    public struct SalesforceKnowledgeArticleConfiguration: Swift.Equatable {
        /// <p>Provides configuration information for custom Salesforce knowledge
        ///             articles.</p>
        public let customKnowledgeArticleTypeConfigurations: [KendraClientTypes.SalesforceCustomKnowledgeArticleTypeConfiguration]?
        /// <p>Specifies the document states that should be included when
        ///             Amazon Kendra indexes knowledge articles. You must specify at least one
        ///             state.</p>
        public let includedStates: [KendraClientTypes.SalesforceKnowledgeArticleState]?
        /// <p>Provides configuration information for standard Salesforce
        ///             knowledge articles.</p>
        public let standardKnowledgeArticleTypeConfiguration: KendraClientTypes.SalesforceStandardKnowledgeArticleTypeConfiguration?

        public init (
            customKnowledgeArticleTypeConfigurations: [KendraClientTypes.SalesforceCustomKnowledgeArticleTypeConfiguration]? = nil,
            includedStates: [KendraClientTypes.SalesforceKnowledgeArticleState]? = nil,
            standardKnowledgeArticleTypeConfiguration: KendraClientTypes.SalesforceStandardKnowledgeArticleTypeConfiguration? = nil
        )
        {
            self.customKnowledgeArticleTypeConfigurations = customKnowledgeArticleTypeConfigurations
            self.includedStates = includedStates
            self.standardKnowledgeArticleTypeConfiguration = standardKnowledgeArticleTypeConfiguration
        }
    }

}

extension KendraClientTypes {
    public enum SalesforceKnowledgeArticleState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case archived
        case draft
        case published
        case sdkUnknown(Swift.String)

        public static var allCases: [SalesforceKnowledgeArticleState] {
            return [
                .archived,
                .draft,
                .published,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .archived: return "ARCHIVED"
            case .draft: return "DRAFT"
            case .published: return "PUBLISHED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SalesforceKnowledgeArticleState(rawValue: rawValue) ?? SalesforceKnowledgeArticleState.sdkUnknown(rawValue)
        }
    }
}

extension KendraClientTypes.SalesforceStandardKnowledgeArticleTypeConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentDataFieldName = "DocumentDataFieldName"
        case documentTitleFieldName = "DocumentTitleFieldName"
        case fieldMappings = "FieldMappings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentDataFieldName = documentDataFieldName {
            try encodeContainer.encode(documentDataFieldName, forKey: .documentDataFieldName)
        }
        if let documentTitleFieldName = documentTitleFieldName {
            try encodeContainer.encode(documentTitleFieldName, forKey: .documentTitleFieldName)
        }
        if let fieldMappings = fieldMappings {
            var fieldMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fieldMappings)
            for datasourcetoindexfieldmappinglist0 in fieldMappings {
                try fieldMappingsContainer.encode(datasourcetoindexfieldmappinglist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentDataFieldNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentDataFieldName)
        documentDataFieldName = documentDataFieldNameDecoded
        let documentTitleFieldNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentTitleFieldName)
        documentTitleFieldName = documentTitleFieldNameDecoded
        let fieldMappingsContainer = try containerValues.decodeIfPresent([KendraClientTypes.DataSourceToIndexFieldMapping?].self, forKey: .fieldMappings)
        var fieldMappingsDecoded0:[KendraClientTypes.DataSourceToIndexFieldMapping]? = nil
        if let fieldMappingsContainer = fieldMappingsContainer {
            fieldMappingsDecoded0 = [KendraClientTypes.DataSourceToIndexFieldMapping]()
            for structure0 in fieldMappingsContainer {
                if let structure0 = structure0 {
                    fieldMappingsDecoded0?.append(structure0)
                }
            }
        }
        fieldMappings = fieldMappingsDecoded0
    }
}

extension KendraClientTypes.SalesforceStandardKnowledgeArticleTypeConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SalesforceStandardKnowledgeArticleTypeConfiguration(documentDataFieldName: \(Swift.String(describing: documentDataFieldName)), documentTitleFieldName: \(Swift.String(describing: documentTitleFieldName)), fieldMappings: \(Swift.String(describing: fieldMappings)))"}
}

extension KendraClientTypes {
    /// <p>Provides configuration information for standard Salesforce
    ///             knowledge articles.</p>
    public struct SalesforceStandardKnowledgeArticleTypeConfiguration: Swift.Equatable {
        /// <p>The name of the field that contains the document data to
        ///             index.</p>
        public let documentDataFieldName: Swift.String?
        /// <p>The name of the field that contains the document title.</p>
        public let documentTitleFieldName: Swift.String?
        /// <p>One or more objects that map fields in the knowledge article to
        ///             Amazon Kendra index fields. The index field must exist before you can map
        ///             a Salesforce field to it.</p>
        public let fieldMappings: [KendraClientTypes.DataSourceToIndexFieldMapping]?

        public init (
            documentDataFieldName: Swift.String? = nil,
            documentTitleFieldName: Swift.String? = nil,
            fieldMappings: [KendraClientTypes.DataSourceToIndexFieldMapping]? = nil
        )
        {
            self.documentDataFieldName = documentDataFieldName
            self.documentTitleFieldName = documentTitleFieldName
            self.fieldMappings = fieldMappings
        }
    }

}

extension KendraClientTypes.SalesforceStandardObjectAttachmentConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentTitleFieldName = "DocumentTitleFieldName"
        case fieldMappings = "FieldMappings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentTitleFieldName = documentTitleFieldName {
            try encodeContainer.encode(documentTitleFieldName, forKey: .documentTitleFieldName)
        }
        if let fieldMappings = fieldMappings {
            var fieldMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fieldMappings)
            for datasourcetoindexfieldmappinglist0 in fieldMappings {
                try fieldMappingsContainer.encode(datasourcetoindexfieldmappinglist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentTitleFieldNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentTitleFieldName)
        documentTitleFieldName = documentTitleFieldNameDecoded
        let fieldMappingsContainer = try containerValues.decodeIfPresent([KendraClientTypes.DataSourceToIndexFieldMapping?].self, forKey: .fieldMappings)
        var fieldMappingsDecoded0:[KendraClientTypes.DataSourceToIndexFieldMapping]? = nil
        if let fieldMappingsContainer = fieldMappingsContainer {
            fieldMappingsDecoded0 = [KendraClientTypes.DataSourceToIndexFieldMapping]()
            for structure0 in fieldMappingsContainer {
                if let structure0 = structure0 {
                    fieldMappingsDecoded0?.append(structure0)
                }
            }
        }
        fieldMappings = fieldMappingsDecoded0
    }
}

extension KendraClientTypes.SalesforceStandardObjectAttachmentConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SalesforceStandardObjectAttachmentConfiguration(documentTitleFieldName: \(Swift.String(describing: documentTitleFieldName)), fieldMappings: \(Swift.String(describing: fieldMappings)))"}
}

extension KendraClientTypes {
    /// <p>Provides configuration information for processing attachments to
    ///             Salesforce standard objects. </p>
    public struct SalesforceStandardObjectAttachmentConfiguration: Swift.Equatable {
        /// <p>The name of the field used for the document title.</p>
        public let documentTitleFieldName: Swift.String?
        /// <p>One or more objects that map fields in attachments to Amazon Kendra
        ///             index fields.</p>
        public let fieldMappings: [KendraClientTypes.DataSourceToIndexFieldMapping]?

        public init (
            documentTitleFieldName: Swift.String? = nil,
            fieldMappings: [KendraClientTypes.DataSourceToIndexFieldMapping]? = nil
        )
        {
            self.documentTitleFieldName = documentTitleFieldName
            self.fieldMappings = fieldMappings
        }
    }

}

extension KendraClientTypes.SalesforceStandardObjectConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentDataFieldName = "DocumentDataFieldName"
        case documentTitleFieldName = "DocumentTitleFieldName"
        case fieldMappings = "FieldMappings"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentDataFieldName = documentDataFieldName {
            try encodeContainer.encode(documentDataFieldName, forKey: .documentDataFieldName)
        }
        if let documentTitleFieldName = documentTitleFieldName {
            try encodeContainer.encode(documentTitleFieldName, forKey: .documentTitleFieldName)
        }
        if let fieldMappings = fieldMappings {
            var fieldMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fieldMappings)
            for datasourcetoindexfieldmappinglist0 in fieldMappings {
                try fieldMappingsContainer.encode(datasourcetoindexfieldmappinglist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(KendraClientTypes.SalesforceStandardObjectName.self, forKey: .name)
        name = nameDecoded
        let documentDataFieldNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentDataFieldName)
        documentDataFieldName = documentDataFieldNameDecoded
        let documentTitleFieldNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentTitleFieldName)
        documentTitleFieldName = documentTitleFieldNameDecoded
        let fieldMappingsContainer = try containerValues.decodeIfPresent([KendraClientTypes.DataSourceToIndexFieldMapping?].self, forKey: .fieldMappings)
        var fieldMappingsDecoded0:[KendraClientTypes.DataSourceToIndexFieldMapping]? = nil
        if let fieldMappingsContainer = fieldMappingsContainer {
            fieldMappingsDecoded0 = [KendraClientTypes.DataSourceToIndexFieldMapping]()
            for structure0 in fieldMappingsContainer {
                if let structure0 = structure0 {
                    fieldMappingsDecoded0?.append(structure0)
                }
            }
        }
        fieldMappings = fieldMappingsDecoded0
    }
}

extension KendraClientTypes.SalesforceStandardObjectConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SalesforceStandardObjectConfiguration(documentDataFieldName: \(Swift.String(describing: documentDataFieldName)), documentTitleFieldName: \(Swift.String(describing: documentTitleFieldName)), fieldMappings: \(Swift.String(describing: fieldMappings)), name: \(Swift.String(describing: name)))"}
}

extension KendraClientTypes {
    /// <p>Specifies configuration information for indexing a single standard
    ///             object.</p>
    public struct SalesforceStandardObjectConfiguration: Swift.Equatable {
        /// <p>The name of the field in the standard object table that contains
        ///             the document contents.</p>
        public let documentDataFieldName: Swift.String?
        /// <p>The name of the field in the standard object table that contains
        ///             the document title.</p>
        public let documentTitleFieldName: Swift.String?
        /// <p>One or more objects that map fields in the standard object to
        ///             Amazon Kendra index fields. The index field must exist before you can map
        ///             a Salesforce field to it.</p>
        public let fieldMappings: [KendraClientTypes.DataSourceToIndexFieldMapping]?
        /// <p>The name of the standard object.</p>
        public let name: KendraClientTypes.SalesforceStandardObjectName?

        public init (
            documentDataFieldName: Swift.String? = nil,
            documentTitleFieldName: Swift.String? = nil,
            fieldMappings: [KendraClientTypes.DataSourceToIndexFieldMapping]? = nil,
            name: KendraClientTypes.SalesforceStandardObjectName? = nil
        )
        {
            self.documentDataFieldName = documentDataFieldName
            self.documentTitleFieldName = documentTitleFieldName
            self.fieldMappings = fieldMappings
            self.name = name
        }
    }

}

extension KendraClientTypes {
    public enum SalesforceStandardObjectName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case account
        case campaign
        case `case`
        case contact
        case contract
        case document
        case group
        case idea
        case lead
        case opportunity
        case partner
        case pricebook
        case product
        case profile
        case solution
        case task
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [SalesforceStandardObjectName] {
            return [
                .account,
                .campaign,
                .case,
                .contact,
                .contract,
                .document,
                .group,
                .idea,
                .lead,
                .opportunity,
                .partner,
                .pricebook,
                .product,
                .profile,
                .solution,
                .task,
                .user,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .account: return "ACCOUNT"
            case .campaign: return "CAMPAIGN"
            case .case: return "CASE"
            case .contact: return "CONTACT"
            case .contract: return "CONTRACT"
            case .document: return "DOCUMENT"
            case .group: return "GROUP"
            case .idea: return "IDEA"
            case .lead: return "LEAD"
            case .opportunity: return "OPPORTUNITY"
            case .partner: return "PARTNER"
            case .pricebook: return "PRICEBOOK"
            case .product: return "PRODUCT"
            case .profile: return "PROFILE"
            case .solution: return "SOLUTION"
            case .task: return "TASK"
            case .user: return "USER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SalesforceStandardObjectName(rawValue: rawValue) ?? SalesforceStandardObjectName.sdkUnknown(rawValue)
        }
    }
}

extension KendraClientTypes.ScoreAttributes: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scoreConfidence = "ScoreConfidence"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let scoreConfidence = scoreConfidence {
            try encodeContainer.encode(scoreConfidence.rawValue, forKey: .scoreConfidence)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scoreConfidenceDecoded = try containerValues.decodeIfPresent(KendraClientTypes.ScoreConfidence.self, forKey: .scoreConfidence)
        scoreConfidence = scoreConfidenceDecoded
    }
}

extension KendraClientTypes.ScoreAttributes: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ScoreAttributes(scoreConfidence: \(Swift.String(describing: scoreConfidence)))"}
}

extension KendraClientTypes {
    /// <p>Provides a relative ranking that indicates how confident Amazon Kendra is
    ///          that the response matches the query.</p>
    public struct ScoreAttributes: Swift.Equatable {
        /// <p>A relative ranking for how well the response matches the
        ///          query.</p>
        public let scoreConfidence: KendraClientTypes.ScoreConfidence?

        public init (
            scoreConfidence: KendraClientTypes.ScoreConfidence? = nil
        )
        {
            self.scoreConfidence = scoreConfidence
        }
    }

}

extension KendraClientTypes {
    /// Enumeration for query score confidence.
    public enum ScoreConfidence: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case high
        case low
        case medium
        case veryHigh
        case sdkUnknown(Swift.String)

        public static var allCases: [ScoreConfidence] {
            return [
                .high,
                .low,
                .medium,
                .veryHigh,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .high: return "HIGH"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case .veryHigh: return "VERY_HIGH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScoreConfidence(rawValue: rawValue) ?? ScoreConfidence.sdkUnknown(rawValue)
        }
    }
}

extension KendraClientTypes.Search: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayable = "Displayable"
        case facetable = "Facetable"
        case searchable = "Searchable"
        case sortable = "Sortable"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if displayable != false {
            try encodeContainer.encode(displayable, forKey: .displayable)
        }
        if facetable != false {
            try encodeContainer.encode(facetable, forKey: .facetable)
        }
        if searchable != false {
            try encodeContainer.encode(searchable, forKey: .searchable)
        }
        if sortable != false {
            try encodeContainer.encode(sortable, forKey: .sortable)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let facetableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .facetable)
        facetable = facetableDecoded
        let searchableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .searchable)
        searchable = searchableDecoded
        let displayableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .displayable)
        displayable = displayableDecoded
        let sortableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .sortable)
        sortable = sortableDecoded
    }
}

extension KendraClientTypes.Search: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Search(displayable: \(Swift.String(describing: displayable)), facetable: \(Swift.String(describing: facetable)), searchable: \(Swift.String(describing: searchable)), sortable: \(Swift.String(describing: sortable)))"}
}

extension KendraClientTypes {
    /// <p>Provides information about how a custom index field is used during
    ///             a search.</p>
    public struct Search: Swift.Equatable {
        /// <p>Determines whether the field is returned in the query response.
        ///             The default is <code>true</code>.</p>
        public let displayable: Swift.Bool
        /// <p>Indicates that the field can be used to create search facets, a
        ///             count of results for each value in the field. The default is
        ///                 <code>false</code> .</p>
        public let facetable: Swift.Bool
        /// <p>Determines whether the field is used in the search. If the
        ///                 <code>Searchable</code> field is <code>true</code>, you can use
        ///             relevance tuning to manually tune how Amazon Kendra weights the field in
        ///             the search. The default is <code>true</code> for string fields and
        ///                 <code>false</code> for number and date fields.</p>
        public let searchable: Swift.Bool
        /// <p>Determines whether the field can be used to sort the results of a
        ///             query. If you specify sorting on a field that does not have
        ///                 <code>Sortable</code> set to <code>true</code>, Amazon Kendra returns an
        ///             exception. The default is <code>false</code>.</p>
        public let sortable: Swift.Bool

        public init (
            displayable: Swift.Bool = false,
            facetable: Swift.Bool = false,
            searchable: Swift.Bool = false,
            sortable: Swift.Bool = false
        )
        {
            self.displayable = displayable
            self.facetable = facetable
            self.searchable = searchable
            self.sortable = sortable
        }
    }

}

extension KendraClientTypes.ServerSideEncryptionConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyId = "KmsKeyId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension KendraClientTypes.ServerSideEncryptionConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServerSideEncryptionConfiguration(kmsKeyId: \(Swift.String(describing: kmsKeyId)))"}
}

extension KendraClientTypes {
    /// <p>Provides the identifier of the AWS KMS customer master key (CMK)
    ///             used to encrypt data indexed by Amazon Kendra. Amazon Kendra doesn't support
    ///             asymmetric CMKs.</p>
    public struct ServerSideEncryptionConfiguration: Swift.Equatable {
        /// <p>The identifier of the AWS KMS customer master key (CMK). Amazon Kendra
        ///             doesn't support asymmetric CMKs.</p>
        public let kmsKeyId: Swift.String?

        public init (
            kmsKeyId: Swift.String? = nil
        )
        {
            self.kmsKeyId = kmsKeyId
        }
    }

}

extension KendraClientTypes {
    public enum ServiceNowAuthenticationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case httpBasic
        case oauth2
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceNowAuthenticationType] {
            return [
                .httpBasic,
                .oauth2,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .httpBasic: return "HTTP_BASIC"
            case .oauth2: return "OAUTH2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceNowAuthenticationType(rawValue: rawValue) ?? ServiceNowAuthenticationType.sdkUnknown(rawValue)
        }
    }
}

extension KendraClientTypes {
    public enum ServiceNowBuildVersionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case london
        case others
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceNowBuildVersionType] {
            return [
                .london,
                .others,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .london: return "LONDON"
            case .others: return "OTHERS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceNowBuildVersionType(rawValue: rawValue) ?? ServiceNowBuildVersionType.sdkUnknown(rawValue)
        }
    }
}

extension KendraClientTypes.ServiceNowConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType = "AuthenticationType"
        case hostUrl = "HostUrl"
        case knowledgeArticleConfiguration = "KnowledgeArticleConfiguration"
        case secretArn = "SecretArn"
        case serviceCatalogConfiguration = "ServiceCatalogConfiguration"
        case serviceNowBuildVersion = "ServiceNowBuildVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationType = authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let hostUrl = hostUrl {
            try encodeContainer.encode(hostUrl, forKey: .hostUrl)
        }
        if let knowledgeArticleConfiguration = knowledgeArticleConfiguration {
            try encodeContainer.encode(knowledgeArticleConfiguration, forKey: .knowledgeArticleConfiguration)
        }
        if let secretArn = secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
        if let serviceCatalogConfiguration = serviceCatalogConfiguration {
            try encodeContainer.encode(serviceCatalogConfiguration, forKey: .serviceCatalogConfiguration)
        }
        if let serviceNowBuildVersion = serviceNowBuildVersion {
            try encodeContainer.encode(serviceNowBuildVersion.rawValue, forKey: .serviceNowBuildVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostUrl)
        hostUrl = hostUrlDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let serviceNowBuildVersionDecoded = try containerValues.decodeIfPresent(KendraClientTypes.ServiceNowBuildVersionType.self, forKey: .serviceNowBuildVersion)
        serviceNowBuildVersion = serviceNowBuildVersionDecoded
        let knowledgeArticleConfigurationDecoded = try containerValues.decodeIfPresent(KendraClientTypes.ServiceNowKnowledgeArticleConfiguration.self, forKey: .knowledgeArticleConfiguration)
        knowledgeArticleConfiguration = knowledgeArticleConfigurationDecoded
        let serviceCatalogConfigurationDecoded = try containerValues.decodeIfPresent(KendraClientTypes.ServiceNowServiceCatalogConfiguration.self, forKey: .serviceCatalogConfiguration)
        serviceCatalogConfiguration = serviceCatalogConfigurationDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(KendraClientTypes.ServiceNowAuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
    }
}

extension KendraClientTypes.ServiceNowConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceNowConfiguration(authenticationType: \(Swift.String(describing: authenticationType)), hostUrl: \(Swift.String(describing: hostUrl)), knowledgeArticleConfiguration: \(Swift.String(describing: knowledgeArticleConfiguration)), secretArn: \(Swift.String(describing: secretArn)), serviceCatalogConfiguration: \(Swift.String(describing: serviceCatalogConfiguration)), serviceNowBuildVersion: \(Swift.String(describing: serviceNowBuildVersion)))"}
}

extension KendraClientTypes {
    /// <p>Provides configuration information required to connect to a
    ///             ServiceNow data source.</p>
    public struct ServiceNowConfiguration: Swift.Equatable {
        /// <p>Determines the type of authentication used to connect to the
        ///             ServiceNow instance. If you choose <code>HTTP_BASIC</code>, Amazon Kendra is
        ///             authenticated using the user name and password provided in the AWS
        ///             Secrets Manager secret in the <code>SecretArn</code> field. When you
        ///             choose <code>OAUTH2</code>, Amazon Kendra is authenticated using the OAuth
        ///             token and secret provided in the Secrets Manager secret, and the
        ///             user name and password are used to determine which information Amazon Kendra
        ///             has access to.</p>
        ///         <p>When you use <code>OAUTH2</code> authentication, you must generate
        ///             a token and a client secret using the ServiceNow console. For more
        ///             information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-servicenow.html">Using a
        ///                 ServiceNow data source</a>.</p>
        public let authenticationType: KendraClientTypes.ServiceNowAuthenticationType?
        /// <p>The ServiceNow instance that the data source connects to. The host
        ///             endpoint should look like the following:
        ///                 <code>{instance}.service-now.com.</code>
        ///          </p>
        public let hostUrl: Swift.String?
        /// <p>Provides configuration information for crawling knowledge articles
        ///             in the ServiceNow site.</p>
        public let knowledgeArticleConfiguration: KendraClientTypes.ServiceNowKnowledgeArticleConfiguration?
        /// <p>The Amazon Resource Name (ARN) of the AWS Secret Manager secret
        ///             that contains the user name and password required to connect to the
        ///             ServiceNow instance.</p>
        public let secretArn: Swift.String?
        /// <p>Provides configuration information for crawling service catalogs
        ///             in the ServiceNow site.</p>
        public let serviceCatalogConfiguration: KendraClientTypes.ServiceNowServiceCatalogConfiguration?
        /// <p>The identifier of the release that the ServiceNow host is running.
        ///             If the host is not running the <code>LONDON</code> release, use
        ///                 <code>OTHERS</code>.</p>
        public let serviceNowBuildVersion: KendraClientTypes.ServiceNowBuildVersionType?

        public init (
            authenticationType: KendraClientTypes.ServiceNowAuthenticationType? = nil,
            hostUrl: Swift.String? = nil,
            knowledgeArticleConfiguration: KendraClientTypes.ServiceNowKnowledgeArticleConfiguration? = nil,
            secretArn: Swift.String? = nil,
            serviceCatalogConfiguration: KendraClientTypes.ServiceNowServiceCatalogConfiguration? = nil,
            serviceNowBuildVersion: KendraClientTypes.ServiceNowBuildVersionType? = nil
        )
        {
            self.authenticationType = authenticationType
            self.hostUrl = hostUrl
            self.knowledgeArticleConfiguration = knowledgeArticleConfiguration
            self.secretArn = secretArn
            self.serviceCatalogConfiguration = serviceCatalogConfiguration
            self.serviceNowBuildVersion = serviceNowBuildVersion
        }
    }

}

extension KendraClientTypes.ServiceNowKnowledgeArticleConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crawlAttachments = "CrawlAttachments"
        case documentDataFieldName = "DocumentDataFieldName"
        case documentTitleFieldName = "DocumentTitleFieldName"
        case excludeAttachmentFilePatterns = "ExcludeAttachmentFilePatterns"
        case fieldMappings = "FieldMappings"
        case filterQuery = "FilterQuery"
        case includeAttachmentFilePatterns = "IncludeAttachmentFilePatterns"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if crawlAttachments != false {
            try encodeContainer.encode(crawlAttachments, forKey: .crawlAttachments)
        }
        if let documentDataFieldName = documentDataFieldName {
            try encodeContainer.encode(documentDataFieldName, forKey: .documentDataFieldName)
        }
        if let documentTitleFieldName = documentTitleFieldName {
            try encodeContainer.encode(documentTitleFieldName, forKey: .documentTitleFieldName)
        }
        if let excludeAttachmentFilePatterns = excludeAttachmentFilePatterns {
            var excludeAttachmentFilePatternsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .excludeAttachmentFilePatterns)
            for datasourceinclusionsexclusionsstrings0 in excludeAttachmentFilePatterns {
                try excludeAttachmentFilePatternsContainer.encode(datasourceinclusionsexclusionsstrings0)
            }
        }
        if let fieldMappings = fieldMappings {
            var fieldMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fieldMappings)
            for datasourcetoindexfieldmappinglist0 in fieldMappings {
                try fieldMappingsContainer.encode(datasourcetoindexfieldmappinglist0)
            }
        }
        if let filterQuery = filterQuery {
            try encodeContainer.encode(filterQuery, forKey: .filterQuery)
        }
        if let includeAttachmentFilePatterns = includeAttachmentFilePatterns {
            var includeAttachmentFilePatternsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .includeAttachmentFilePatterns)
            for datasourceinclusionsexclusionsstrings0 in includeAttachmentFilePatterns {
                try includeAttachmentFilePatternsContainer.encode(datasourceinclusionsexclusionsstrings0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let crawlAttachmentsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .crawlAttachments)
        crawlAttachments = crawlAttachmentsDecoded
        let includeAttachmentFilePatternsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .includeAttachmentFilePatterns)
        var includeAttachmentFilePatternsDecoded0:[Swift.String]? = nil
        if let includeAttachmentFilePatternsContainer = includeAttachmentFilePatternsContainer {
            includeAttachmentFilePatternsDecoded0 = [Swift.String]()
            for string0 in includeAttachmentFilePatternsContainer {
                if let string0 = string0 {
                    includeAttachmentFilePatternsDecoded0?.append(string0)
                }
            }
        }
        includeAttachmentFilePatterns = includeAttachmentFilePatternsDecoded0
        let excludeAttachmentFilePatternsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .excludeAttachmentFilePatterns)
        var excludeAttachmentFilePatternsDecoded0:[Swift.String]? = nil
        if let excludeAttachmentFilePatternsContainer = excludeAttachmentFilePatternsContainer {
            excludeAttachmentFilePatternsDecoded0 = [Swift.String]()
            for string0 in excludeAttachmentFilePatternsContainer {
                if let string0 = string0 {
                    excludeAttachmentFilePatternsDecoded0?.append(string0)
                }
            }
        }
        excludeAttachmentFilePatterns = excludeAttachmentFilePatternsDecoded0
        let documentDataFieldNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentDataFieldName)
        documentDataFieldName = documentDataFieldNameDecoded
        let documentTitleFieldNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentTitleFieldName)
        documentTitleFieldName = documentTitleFieldNameDecoded
        let fieldMappingsContainer = try containerValues.decodeIfPresent([KendraClientTypes.DataSourceToIndexFieldMapping?].self, forKey: .fieldMappings)
        var fieldMappingsDecoded0:[KendraClientTypes.DataSourceToIndexFieldMapping]? = nil
        if let fieldMappingsContainer = fieldMappingsContainer {
            fieldMappingsDecoded0 = [KendraClientTypes.DataSourceToIndexFieldMapping]()
            for structure0 in fieldMappingsContainer {
                if let structure0 = structure0 {
                    fieldMappingsDecoded0?.append(structure0)
                }
            }
        }
        fieldMappings = fieldMappingsDecoded0
        let filterQueryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterQuery)
        filterQuery = filterQueryDecoded
    }
}

extension KendraClientTypes.ServiceNowKnowledgeArticleConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceNowKnowledgeArticleConfiguration(crawlAttachments: \(Swift.String(describing: crawlAttachments)), documentDataFieldName: \(Swift.String(describing: documentDataFieldName)), documentTitleFieldName: \(Swift.String(describing: documentTitleFieldName)), excludeAttachmentFilePatterns: \(Swift.String(describing: excludeAttachmentFilePatterns)), fieldMappings: \(Swift.String(describing: fieldMappings)), filterQuery: \(Swift.String(describing: filterQuery)), includeAttachmentFilePatterns: \(Swift.String(describing: includeAttachmentFilePatterns)))"}
}

extension KendraClientTypes {
    /// <p>Provides configuration information for crawling knowledge articles
    ///             in the ServiceNow site.</p>
    public struct ServiceNowKnowledgeArticleConfiguration: Swift.Equatable {
        /// <p>Indicates whether Amazon Kendra should index attachments to knowledge
        ///             articles.</p>
        public let crawlAttachments: Swift.Bool
        /// <p>The name of the ServiceNow field that is mapped to the index
        ///             document contents field in the Amazon Kendra index.</p>
        public let documentDataFieldName: Swift.String?
        /// <p>The name of the ServiceNow field that is mapped to the index
        ///             document title field.</p>
        public let documentTitleFieldName: Swift.String?
        /// <p>List of regular expressions applied to knowledge articles. Items
        ///             that don't match the inclusion pattern are not indexed. The regex is
        ///             applied to the field specified in the
        ///                 <code>PatternTargetField</code>
        ///          </p>
        public let excludeAttachmentFilePatterns: [Swift.String]?
        /// <p>Mapping between ServiceNow fields and Amazon Kendra index fields. You
        ///             must create the index field before you map the field.</p>
        public let fieldMappings: [KendraClientTypes.DataSourceToIndexFieldMapping]?
        /// <p>A query that selects the knowledge articles to index. The query
        ///             can return articles from multiple knowledge bases, and the knowledge
        ///             bases can be public or private.</p>
        ///         <p>The query string must be one generated by the ServiceNow console.
        ///             For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/servicenow-query.html">Specifying
        ///                 documents to index with a query</a>. </p>
        public let filterQuery: Swift.String?
        /// <p>List of regular expressions applied to knowledge articles. Items
        ///             that don't match the inclusion pattern are not indexed. The regex is
        ///             applied to the field specified in the
        ///                 <code>PatternTargetField</code>.</p>
        public let includeAttachmentFilePatterns: [Swift.String]?

        public init (
            crawlAttachments: Swift.Bool = false,
            documentDataFieldName: Swift.String? = nil,
            documentTitleFieldName: Swift.String? = nil,
            excludeAttachmentFilePatterns: [Swift.String]? = nil,
            fieldMappings: [KendraClientTypes.DataSourceToIndexFieldMapping]? = nil,
            filterQuery: Swift.String? = nil,
            includeAttachmentFilePatterns: [Swift.String]? = nil
        )
        {
            self.crawlAttachments = crawlAttachments
            self.documentDataFieldName = documentDataFieldName
            self.documentTitleFieldName = documentTitleFieldName
            self.excludeAttachmentFilePatterns = excludeAttachmentFilePatterns
            self.fieldMappings = fieldMappings
            self.filterQuery = filterQuery
            self.includeAttachmentFilePatterns = includeAttachmentFilePatterns
        }
    }

}

extension KendraClientTypes.ServiceNowServiceCatalogConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crawlAttachments = "CrawlAttachments"
        case documentDataFieldName = "DocumentDataFieldName"
        case documentTitleFieldName = "DocumentTitleFieldName"
        case excludeAttachmentFilePatterns = "ExcludeAttachmentFilePatterns"
        case fieldMappings = "FieldMappings"
        case includeAttachmentFilePatterns = "IncludeAttachmentFilePatterns"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if crawlAttachments != false {
            try encodeContainer.encode(crawlAttachments, forKey: .crawlAttachments)
        }
        if let documentDataFieldName = documentDataFieldName {
            try encodeContainer.encode(documentDataFieldName, forKey: .documentDataFieldName)
        }
        if let documentTitleFieldName = documentTitleFieldName {
            try encodeContainer.encode(documentTitleFieldName, forKey: .documentTitleFieldName)
        }
        if let excludeAttachmentFilePatterns = excludeAttachmentFilePatterns {
            var excludeAttachmentFilePatternsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .excludeAttachmentFilePatterns)
            for datasourceinclusionsexclusionsstrings0 in excludeAttachmentFilePatterns {
                try excludeAttachmentFilePatternsContainer.encode(datasourceinclusionsexclusionsstrings0)
            }
        }
        if let fieldMappings = fieldMappings {
            var fieldMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fieldMappings)
            for datasourcetoindexfieldmappinglist0 in fieldMappings {
                try fieldMappingsContainer.encode(datasourcetoindexfieldmappinglist0)
            }
        }
        if let includeAttachmentFilePatterns = includeAttachmentFilePatterns {
            var includeAttachmentFilePatternsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .includeAttachmentFilePatterns)
            for datasourceinclusionsexclusionsstrings0 in includeAttachmentFilePatterns {
                try includeAttachmentFilePatternsContainer.encode(datasourceinclusionsexclusionsstrings0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let crawlAttachmentsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .crawlAttachments)
        crawlAttachments = crawlAttachmentsDecoded
        let includeAttachmentFilePatternsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .includeAttachmentFilePatterns)
        var includeAttachmentFilePatternsDecoded0:[Swift.String]? = nil
        if let includeAttachmentFilePatternsContainer = includeAttachmentFilePatternsContainer {
            includeAttachmentFilePatternsDecoded0 = [Swift.String]()
            for string0 in includeAttachmentFilePatternsContainer {
                if let string0 = string0 {
                    includeAttachmentFilePatternsDecoded0?.append(string0)
                }
            }
        }
        includeAttachmentFilePatterns = includeAttachmentFilePatternsDecoded0
        let excludeAttachmentFilePatternsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .excludeAttachmentFilePatterns)
        var excludeAttachmentFilePatternsDecoded0:[Swift.String]? = nil
        if let excludeAttachmentFilePatternsContainer = excludeAttachmentFilePatternsContainer {
            excludeAttachmentFilePatternsDecoded0 = [Swift.String]()
            for string0 in excludeAttachmentFilePatternsContainer {
                if let string0 = string0 {
                    excludeAttachmentFilePatternsDecoded0?.append(string0)
                }
            }
        }
        excludeAttachmentFilePatterns = excludeAttachmentFilePatternsDecoded0
        let documentDataFieldNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentDataFieldName)
        documentDataFieldName = documentDataFieldNameDecoded
        let documentTitleFieldNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentTitleFieldName)
        documentTitleFieldName = documentTitleFieldNameDecoded
        let fieldMappingsContainer = try containerValues.decodeIfPresent([KendraClientTypes.DataSourceToIndexFieldMapping?].self, forKey: .fieldMappings)
        var fieldMappingsDecoded0:[KendraClientTypes.DataSourceToIndexFieldMapping]? = nil
        if let fieldMappingsContainer = fieldMappingsContainer {
            fieldMappingsDecoded0 = [KendraClientTypes.DataSourceToIndexFieldMapping]()
            for structure0 in fieldMappingsContainer {
                if let structure0 = structure0 {
                    fieldMappingsDecoded0?.append(structure0)
                }
            }
        }
        fieldMappings = fieldMappingsDecoded0
    }
}

extension KendraClientTypes.ServiceNowServiceCatalogConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceNowServiceCatalogConfiguration(crawlAttachments: \(Swift.String(describing: crawlAttachments)), documentDataFieldName: \(Swift.String(describing: documentDataFieldName)), documentTitleFieldName: \(Swift.String(describing: documentTitleFieldName)), excludeAttachmentFilePatterns: \(Swift.String(describing: excludeAttachmentFilePatterns)), fieldMappings: \(Swift.String(describing: fieldMappings)), includeAttachmentFilePatterns: \(Swift.String(describing: includeAttachmentFilePatterns)))"}
}

extension KendraClientTypes {
    /// <p>Provides configuration information for crawling service catalog
    ///             items in the ServiceNow site</p>
    public struct ServiceNowServiceCatalogConfiguration: Swift.Equatable {
        /// <p>Indicates whether Amazon Kendra should crawl attachments to the service
        ///             catalog items. </p>
        public let crawlAttachments: Swift.Bool
        /// <p>The name of the ServiceNow field that is mapped to the index
        ///             document contents field in the Amazon Kendra index.</p>
        public let documentDataFieldName: Swift.String?
        /// <p>The name of the ServiceNow field that is mapped to the index
        ///             document title field.</p>
        public let documentTitleFieldName: Swift.String?
        /// <p>A list of regular expression patterns. Documents that match the
        ///             patterns are excluded from the index. Documents that don't match the
        ///             patterns are included in the index. If a document matches both an
        ///             exclusion pattern and an inclusion pattern, the document is not
        ///             included in the index.</p>
        ///         <p>The regex is applied to the file name of the attachment.</p>
        public let excludeAttachmentFilePatterns: [Swift.String]?
        /// <p>Mapping between ServiceNow fields and Amazon Kendra index fields. You
        ///             must create the index field before you map the field.</p>
        public let fieldMappings: [KendraClientTypes.DataSourceToIndexFieldMapping]?
        /// <p>A list of regular expression patterns. Documents that match the
        ///             patterns are included in the index. Documents that don't match the
        ///             patterns are excluded from the index. If a document matches both an
        ///             exclusion pattern and an inclusion pattern, the document is not
        ///             included in the index.</p>
        ///         <p>The regex is applied to the file name of the attachment.</p>
        public let includeAttachmentFilePatterns: [Swift.String]?

        public init (
            crawlAttachments: Swift.Bool = false,
            documentDataFieldName: Swift.String? = nil,
            documentTitleFieldName: Swift.String? = nil,
            excludeAttachmentFilePatterns: [Swift.String]? = nil,
            fieldMappings: [KendraClientTypes.DataSourceToIndexFieldMapping]? = nil,
            includeAttachmentFilePatterns: [Swift.String]? = nil
        )
        {
            self.crawlAttachments = crawlAttachments
            self.documentDataFieldName = documentDataFieldName
            self.documentTitleFieldName = documentTitleFieldName
            self.excludeAttachmentFilePatterns = excludeAttachmentFilePatterns
            self.fieldMappings = fieldMappings
            self.includeAttachmentFilePatterns = includeAttachmentFilePatterns
        }
    }

}

extension ServiceQuotaExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceQuotaExceededException(message: \(Swift.String(describing: message)))"}
}

extension ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct ServiceQuotaExceededException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KendraClientTypes.SharePointConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crawlAttachments = "CrawlAttachments"
        case disableLocalGroups = "DisableLocalGroups"
        case documentTitleFieldName = "DocumentTitleFieldName"
        case exclusionPatterns = "ExclusionPatterns"
        case fieldMappings = "FieldMappings"
        case inclusionPatterns = "InclusionPatterns"
        case secretArn = "SecretArn"
        case sharePointVersion = "SharePointVersion"
        case urls = "Urls"
        case useChangeLog = "UseChangeLog"
        case vpcConfiguration = "VpcConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if crawlAttachments != false {
            try encodeContainer.encode(crawlAttachments, forKey: .crawlAttachments)
        }
        if disableLocalGroups != false {
            try encodeContainer.encode(disableLocalGroups, forKey: .disableLocalGroups)
        }
        if let documentTitleFieldName = documentTitleFieldName {
            try encodeContainer.encode(documentTitleFieldName, forKey: .documentTitleFieldName)
        }
        if let exclusionPatterns = exclusionPatterns {
            var exclusionPatternsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .exclusionPatterns)
            for datasourceinclusionsexclusionsstrings0 in exclusionPatterns {
                try exclusionPatternsContainer.encode(datasourceinclusionsexclusionsstrings0)
            }
        }
        if let fieldMappings = fieldMappings {
            var fieldMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fieldMappings)
            for datasourcetoindexfieldmappinglist0 in fieldMappings {
                try fieldMappingsContainer.encode(datasourcetoindexfieldmappinglist0)
            }
        }
        if let inclusionPatterns = inclusionPatterns {
            var inclusionPatternsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inclusionPatterns)
            for datasourceinclusionsexclusionsstrings0 in inclusionPatterns {
                try inclusionPatternsContainer.encode(datasourceinclusionsexclusionsstrings0)
            }
        }
        if let secretArn = secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
        if let sharePointVersion = sharePointVersion {
            try encodeContainer.encode(sharePointVersion.rawValue, forKey: .sharePointVersion)
        }
        if let urls = urls {
            var urlsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .urls)
            for sharepointurllist0 in urls {
                try urlsContainer.encode(sharepointurllist0)
            }
        }
        if useChangeLog != false {
            try encodeContainer.encode(useChangeLog, forKey: .useChangeLog)
        }
        if let vpcConfiguration = vpcConfiguration {
            try encodeContainer.encode(vpcConfiguration, forKey: .vpcConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sharePointVersionDecoded = try containerValues.decodeIfPresent(KendraClientTypes.SharePointVersion.self, forKey: .sharePointVersion)
        sharePointVersion = sharePointVersionDecoded
        let urlsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .urls)
        var urlsDecoded0:[Swift.String]? = nil
        if let urlsContainer = urlsContainer {
            urlsDecoded0 = [Swift.String]()
            for string0 in urlsContainer {
                if let string0 = string0 {
                    urlsDecoded0?.append(string0)
                }
            }
        }
        urls = urlsDecoded0
        let secretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let crawlAttachmentsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .crawlAttachments)
        crawlAttachments = crawlAttachmentsDecoded
        let useChangeLogDecoded = try containerValues.decode(Swift.Bool.self, forKey: .useChangeLog)
        useChangeLog = useChangeLogDecoded
        let inclusionPatternsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .inclusionPatterns)
        var inclusionPatternsDecoded0:[Swift.String]? = nil
        if let inclusionPatternsContainer = inclusionPatternsContainer {
            inclusionPatternsDecoded0 = [Swift.String]()
            for string0 in inclusionPatternsContainer {
                if let string0 = string0 {
                    inclusionPatternsDecoded0?.append(string0)
                }
            }
        }
        inclusionPatterns = inclusionPatternsDecoded0
        let exclusionPatternsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .exclusionPatterns)
        var exclusionPatternsDecoded0:[Swift.String]? = nil
        if let exclusionPatternsContainer = exclusionPatternsContainer {
            exclusionPatternsDecoded0 = [Swift.String]()
            for string0 in exclusionPatternsContainer {
                if let string0 = string0 {
                    exclusionPatternsDecoded0?.append(string0)
                }
            }
        }
        exclusionPatterns = exclusionPatternsDecoded0
        let vpcConfigurationDecoded = try containerValues.decodeIfPresent(KendraClientTypes.DataSourceVpcConfiguration.self, forKey: .vpcConfiguration)
        vpcConfiguration = vpcConfigurationDecoded
        let fieldMappingsContainer = try containerValues.decodeIfPresent([KendraClientTypes.DataSourceToIndexFieldMapping?].self, forKey: .fieldMappings)
        var fieldMappingsDecoded0:[KendraClientTypes.DataSourceToIndexFieldMapping]? = nil
        if let fieldMappingsContainer = fieldMappingsContainer {
            fieldMappingsDecoded0 = [KendraClientTypes.DataSourceToIndexFieldMapping]()
            for structure0 in fieldMappingsContainer {
                if let structure0 = structure0 {
                    fieldMappingsDecoded0?.append(structure0)
                }
            }
        }
        fieldMappings = fieldMappingsDecoded0
        let documentTitleFieldNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentTitleFieldName)
        documentTitleFieldName = documentTitleFieldNameDecoded
        let disableLocalGroupsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .disableLocalGroups)
        disableLocalGroups = disableLocalGroupsDecoded
    }
}

extension KendraClientTypes.SharePointConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SharePointConfiguration(crawlAttachments: \(Swift.String(describing: crawlAttachments)), disableLocalGroups: \(Swift.String(describing: disableLocalGroups)), documentTitleFieldName: \(Swift.String(describing: documentTitleFieldName)), exclusionPatterns: \(Swift.String(describing: exclusionPatterns)), fieldMappings: \(Swift.String(describing: fieldMappings)), inclusionPatterns: \(Swift.String(describing: inclusionPatterns)), secretArn: \(Swift.String(describing: secretArn)), sharePointVersion: \(Swift.String(describing: sharePointVersion)), urls: \(Swift.String(describing: urls)), useChangeLog: \(Swift.String(describing: useChangeLog)), vpcConfiguration: \(Swift.String(describing: vpcConfiguration)))"}
}

extension KendraClientTypes {
    /// <p>Provides configuration information for connecting to a Microsoft
    ///             SharePoint data source.</p>
    public struct SharePointConfiguration: Swift.Equatable {
        /// <p>
        ///             <code>TRUE</code> to include attachments to documents stored in
        ///             your Microsoft SharePoint site in the index; otherwise,
        ///                 <code>FALSE</code>.</p>
        public let crawlAttachments: Swift.Bool
        /// <p>A Boolean value that specifies whether local
        ///          groups are disabled (<code>True</code>) or enabled (<code>False</code>).
        ///       </p>
        public let disableLocalGroups: Swift.Bool
        /// <p>The Microsoft SharePoint attribute field that contains the title
        ///             of the document.</p>
        public let documentTitleFieldName: Swift.String?
        /// <p>A list of regular expression patterns. Documents that match the
        ///             patterns are excluded from the index. Documents that don't match the
        ///             patterns are included in the index. If a document matches both an
        ///             exclusion pattern and an inclusion pattern, the document is not
        ///             included in the index.</p>
        ///         <p>The regex is applied to the display URL of the SharePoint
        ///             document.</p>
        public let exclusionPatterns: [Swift.String]?
        /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that
        ///             map Microsoft SharePoint attributes to custom fields in the Amazon Kendra
        ///             index. You must first create the index fields using the
        ///                 <code>UpdateIndex</code> operation before you map SharePoint
        ///             attributes. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping Data Source
        ///                 Fields</a>.</p>
        public let fieldMappings: [KendraClientTypes.DataSourceToIndexFieldMapping]?
        /// <p>A list of regular expression patterns. Documents that match the
        ///             patterns are included in the index. Documents that don't match the
        ///             patterns are excluded from the index. If a document matches both an
        ///             inclusion pattern and an exclusion pattern, the document is not
        ///             included in the index.</p>
        ///         <p>The regex is applied to the display URL of the SharePoint
        ///             document.</p>
        public let inclusionPatterns: [Swift.String]?
        /// <p>The Amazon Resource Name (ARN) of credentials stored in AWS
        ///             Secrets Manager. The credentials should be a user/password pair. For
        ///             more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-sharepoint.html">Using a
        ///                 Microsoft SharePoint Data Source</a>. For more information
        ///             about AWS Secrets Manager, see <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html"> What Is AWS
        ///                 Secrets Manager </a> in the <i>AWS Secrets
        ///                 Manager</i> user guide.</p>
        public let secretArn: Swift.String?
        /// <p>The version of Microsoft SharePoint that you are using as a data
        ///             source.</p>
        public let sharePointVersion: KendraClientTypes.SharePointVersion?
        /// <p>The URLs of the Microsoft SharePoint site that contains the
        ///             documents that should be indexed.</p>
        public let urls: [Swift.String]?
        /// <p>Set to <code>TRUE</code> to use the Microsoft SharePoint change
        ///             log to determine the documents that need to be updated in the index.
        ///             Depending on the size of the SharePoint change log, it may take
        ///             longer for Amazon Kendra to use the change log than it takes it to
        ///             determine the changed documents using the Amazon Kendra document
        ///             crawler.</p>
        public let useChangeLog: Swift.Bool
        /// <p>Provides information for connecting to an Amazon VPC.</p>
        public let vpcConfiguration: KendraClientTypes.DataSourceVpcConfiguration?

        public init (
            crawlAttachments: Swift.Bool = false,
            disableLocalGroups: Swift.Bool = false,
            documentTitleFieldName: Swift.String? = nil,
            exclusionPatterns: [Swift.String]? = nil,
            fieldMappings: [KendraClientTypes.DataSourceToIndexFieldMapping]? = nil,
            inclusionPatterns: [Swift.String]? = nil,
            secretArn: Swift.String? = nil,
            sharePointVersion: KendraClientTypes.SharePointVersion? = nil,
            urls: [Swift.String]? = nil,
            useChangeLog: Swift.Bool = false,
            vpcConfiguration: KendraClientTypes.DataSourceVpcConfiguration? = nil
        )
        {
            self.crawlAttachments = crawlAttachments
            self.disableLocalGroups = disableLocalGroups
            self.documentTitleFieldName = documentTitleFieldName
            self.exclusionPatterns = exclusionPatterns
            self.fieldMappings = fieldMappings
            self.inclusionPatterns = inclusionPatterns
            self.secretArn = secretArn
            self.sharePointVersion = sharePointVersion
            self.urls = urls
            self.useChangeLog = useChangeLog
            self.vpcConfiguration = vpcConfiguration
        }
    }

}

extension KendraClientTypes {
    public enum SharePointVersion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sharepointOnline
        case sdkUnknown(Swift.String)

        public static var allCases: [SharePointVersion] {
            return [
                .sharepointOnline,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sharepointOnline: return "SHAREPOINT_ONLINE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SharePointVersion(rawValue: rawValue) ?? SharePointVersion.sdkUnknown(rawValue)
        }
    }
}

extension KendraClientTypes {
    public enum SortOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case asc
        case desc
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .asc,
                .desc,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .asc: return "ASC"
            case .desc: return "DESC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortOrder(rawValue: rawValue) ?? SortOrder.sdkUnknown(rawValue)
        }
    }
}

extension KendraClientTypes.SortingConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentAttributeKey = "DocumentAttributeKey"
        case sortOrder = "SortOrder"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentAttributeKey = documentAttributeKey {
            try encodeContainer.encode(documentAttributeKey, forKey: .documentAttributeKey)
        }
        if let sortOrder = sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentAttributeKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentAttributeKey)
        documentAttributeKey = documentAttributeKeyDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(KendraClientTypes.SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
    }
}

extension KendraClientTypes.SortingConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SortingConfiguration(documentAttributeKey: \(Swift.String(describing: documentAttributeKey)), sortOrder: \(Swift.String(describing: sortOrder)))"}
}

extension KendraClientTypes {
    /// <p>Specifies the document attribute to use to sort the response to a
    ///             Amazon Kendra query. You can specify a single attribute for sorting. The
    ///             attribute must have the <code>Sortable</code> flag set to
    ///                 <code>true</code>, otherwise Amazon Kendra returns an exception.</p>
    ///         <p>You can sort attributes of the following types.</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Date value</p>
    ///             </li>
    ///             <li>
    ///                 <p>Long value</p>
    ///             </li>
    ///             <li>
    ///                 <p>String value</p>
    ///             </li>
    ///          </ul>
    ///         <p>You can't sort attributes of the following type.</p>
    ///         <ul>
    ///             <li>
    ///                 <p>String list value</p>
    ///             </li>
    ///          </ul>
    public struct SortingConfiguration: Swift.Equatable {
        /// <p>The name of the document attribute used to sort the response. You
        ///             can use any field that has the <code>Sortable</code> flag set to
        ///             true.</p>
        ///         <p>You can also sort by any of the following built-in
        ///             attributes:</p>
        ///         <ul>
        ///             <li>
        ///                 <p>_category</p>
        ///             </li>
        ///             <li>
        ///                 <p>_created_at</p>
        ///             </li>
        ///             <li>
        ///                 <p>_last_updated_at</p>
        ///             </li>
        ///             <li>
        ///                 <p>_version</p>
        ///             </li>
        ///             <li>
        ///                 <p>_view_count</p>
        ///             </li>
        ///          </ul>
        public let documentAttributeKey: Swift.String?
        /// <p>The order that the results should be returned in. In case of ties,
        ///             the relevance assigned to the result by Amazon Kendra is used as the
        ///             tie-breaker.</p>
        public let sortOrder: KendraClientTypes.SortOrder?

        public init (
            documentAttributeKey: Swift.String? = nil,
            sortOrder: KendraClientTypes.SortOrder? = nil
        )
        {
            self.documentAttributeKey = documentAttributeKey
            self.sortOrder = sortOrder
        }
    }

}

extension KendraClientTypes.SqlConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryIdentifiersEnclosingOption = "QueryIdentifiersEnclosingOption"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queryIdentifiersEnclosingOption = queryIdentifiersEnclosingOption {
            try encodeContainer.encode(queryIdentifiersEnclosingOption.rawValue, forKey: .queryIdentifiersEnclosingOption)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryIdentifiersEnclosingOptionDecoded = try containerValues.decodeIfPresent(KendraClientTypes.QueryIdentifiersEnclosingOption.self, forKey: .queryIdentifiersEnclosingOption)
        queryIdentifiersEnclosingOption = queryIdentifiersEnclosingOptionDecoded
    }
}

extension KendraClientTypes.SqlConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SqlConfiguration(queryIdentifiersEnclosingOption: \(Swift.String(describing: queryIdentifiersEnclosingOption)))"}
}

extension KendraClientTypes {
    /// <p>Provides information that configures Amazon Kendra to use a SQL
    ///             database.</p>
    public struct SqlConfiguration: Swift.Equatable {
        /// <p>Determines whether Amazon Kendra encloses SQL identifiers for tables and
        ///             column names in double quotes (") when making a database
        ///             query.</p>
        ///         <p>By default, Amazon Kendra passes SQL identifiers the way that they are
        ///             entered into the data source configuration. It does not change the
        ///             case of identifiers or enclose them in quotes.</p>
        ///         <p>PostgreSQL internally converts uppercase characters to lower case
        ///             characters in identifiers unless they are quoted. Choosing this
        ///             option encloses identifiers in quotes so that PostgreSQL does not
        ///             convert the character's case.</p>
        ///         <p>For MySQL databases, you must enable the <code>ansi_quotes</code>
        ///             option when you set this field to <code>DOUBLE_QUOTES</code>.</p>
        public let queryIdentifiersEnclosingOption: KendraClientTypes.QueryIdentifiersEnclosingOption?

        public init (
            queryIdentifiersEnclosingOption: KendraClientTypes.QueryIdentifiersEnclosingOption? = nil
        )
        {
            self.queryIdentifiersEnclosingOption = queryIdentifiersEnclosingOption
        }
    }

}

public struct StartDataSourceSyncJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartDataSourceSyncJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartDataSourceSyncJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartDataSourceSyncJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartDataSourceSyncJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartDataSourceSyncJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartDataSourceSyncJobOutputError>
}

extension StartDataSourceSyncJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartDataSourceSyncJobInput(id: \(Swift.String(describing: id)), indexId: \(Swift.String(describing: indexId)))"}
}

extension StartDataSourceSyncJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case indexId = "IndexId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
    }
}

public struct StartDataSourceSyncJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartDataSourceSyncJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartDataSourceSyncJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartDataSourceSyncJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartDataSourceSyncJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartDataSourceSyncJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartDataSourceSyncJobOutputError>
}

public struct StartDataSourceSyncJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartDataSourceSyncJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartDataSourceSyncJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartDataSourceSyncJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartDataSourceSyncJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartDataSourceSyncJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartDataSourceSyncJobOutputError>
}

public struct StartDataSourceSyncJobInput: Swift.Equatable {
    /// <p>The identifier of the data source to synchronize.</p>
    public let id: Swift.String?
    /// <p>The identifier of the index that contains the data source.</p>
    public let indexId: Swift.String?

    public init (
        id: Swift.String? = nil,
        indexId: Swift.String? = nil
    )
    {
        self.id = id
        self.indexId = indexId
    }
}

struct StartDataSourceSyncJobInputBody: Swift.Equatable {
    public let id: Swift.String?
    public let indexId: Swift.String?
}

extension StartDataSourceSyncJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case indexId = "IndexId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let indexIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexId)
        indexId = indexIdDecoded
    }
}

extension StartDataSourceSyncJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartDataSourceSyncJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartDataSourceSyncJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartDataSourceSyncJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartDataSourceSyncJobOutputResponse(executionId: \(Swift.String(describing: executionId)))"}
}

extension StartDataSourceSyncJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartDataSourceSyncJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.executionId = output.executionId
        } else {
            self.executionId = nil
        }
    }
}

public struct StartDataSourceSyncJobOutputResponse: Swift.Equatable {
    /// <p>Identifies a particular synchronization job.</p>
    public let executionId: Swift.String?

    public init (
        executionId: Swift.String? = nil
    )
    {
        self.executionId = executionId
    }
}

struct StartDataSourceSyncJobOutputResponseBody: Swift.Equatable {
    public let executionId: Swift.String?
}

extension StartDataSourceSyncJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionId = "ExecutionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionId)
        executionId = executionIdDecoded
    }
}

public struct StopDataSourceSyncJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopDataSourceSyncJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopDataSourceSyncJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopDataSourceSyncJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopDataSourceSyncJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopDataSourceSyncJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopDataSourceSyncJobOutputError>
}

extension StopDataSourceSyncJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopDataSourceSyncJobInput(id: \(Swift.String(describing: id)), indexId: \(Swift.String(describing: indexId)))"}
}

extension StopDataSourceSyncJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case indexId = "IndexId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
    }
}

public struct StopDataSourceSyncJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopDataSourceSyncJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopDataSourceSyncJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopDataSourceSyncJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopDataSourceSyncJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopDataSourceSyncJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopDataSourceSyncJobOutputError>
}

public struct StopDataSourceSyncJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopDataSourceSyncJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopDataSourceSyncJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopDataSourceSyncJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopDataSourceSyncJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopDataSourceSyncJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopDataSourceSyncJobOutputError>
}

public struct StopDataSourceSyncJobInput: Swift.Equatable {
    /// <p>The identifier of the data source for which to stop the
    ///       synchronization jobs.</p>
    public let id: Swift.String?
    /// <p>The identifier of the index that contains the data source.</p>
    public let indexId: Swift.String?

    public init (
        id: Swift.String? = nil,
        indexId: Swift.String? = nil
    )
    {
        self.id = id
        self.indexId = indexId
    }
}

struct StopDataSourceSyncJobInputBody: Swift.Equatable {
    public let id: Swift.String?
    public let indexId: Swift.String?
}

extension StopDataSourceSyncJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case indexId = "IndexId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let indexIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexId)
        indexId = indexIdDecoded
    }
}

extension StopDataSourceSyncJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopDataSourceSyncJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopDataSourceSyncJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopDataSourceSyncJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopDataSourceSyncJobOutputResponse()"}
}

extension StopDataSourceSyncJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StopDataSourceSyncJobOutputResponse: Swift.Equatable {

    public init() {}
}

struct StopDataSourceSyncJobOutputResponseBody: Swift.Equatable {
}

extension StopDataSourceSyncJobOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct SubmitFeedbackInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SubmitFeedbackInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SubmitFeedbackInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SubmitFeedbackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SubmitFeedbackInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SubmitFeedbackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SubmitFeedbackOutputError>
}

extension SubmitFeedbackInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubmitFeedbackInput(clickFeedbackItems: \(Swift.String(describing: clickFeedbackItems)), indexId: \(Swift.String(describing: indexId)), queryId: \(Swift.String(describing: queryId)), relevanceFeedbackItems: \(Swift.String(describing: relevanceFeedbackItems)))"}
}

extension SubmitFeedbackInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clickFeedbackItems = "ClickFeedbackItems"
        case indexId = "IndexId"
        case queryId = "QueryId"
        case relevanceFeedbackItems = "RelevanceFeedbackItems"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clickFeedbackItems = clickFeedbackItems {
            var clickFeedbackItemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .clickFeedbackItems)
            for clickfeedbacklist0 in clickFeedbackItems {
                try clickFeedbackItemsContainer.encode(clickfeedbacklist0)
            }
        }
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
        if let queryId = queryId {
            try encodeContainer.encode(queryId, forKey: .queryId)
        }
        if let relevanceFeedbackItems = relevanceFeedbackItems {
            var relevanceFeedbackItemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relevanceFeedbackItems)
            for relevancefeedbacklist0 in relevanceFeedbackItems {
                try relevanceFeedbackItemsContainer.encode(relevancefeedbacklist0)
            }
        }
    }
}

public struct SubmitFeedbackInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SubmitFeedbackInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SubmitFeedbackInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SubmitFeedbackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SubmitFeedbackInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SubmitFeedbackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SubmitFeedbackOutputError>
}

public struct SubmitFeedbackInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SubmitFeedbackInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SubmitFeedbackInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SubmitFeedbackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SubmitFeedbackInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SubmitFeedbackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SubmitFeedbackOutputError>
}

public struct SubmitFeedbackInput: Swift.Equatable {
    /// <p>Tells Amazon Kendra that a particular search result link was chosen
    ///             by the user. </p>
    public let clickFeedbackItems: [KendraClientTypes.ClickFeedback]?
    /// <p>The identifier of the index that was queried.</p>
    public let indexId: Swift.String?
    /// <p>The identifier of the specific query for which you are submitting
    ///             feedback. The query ID is returned in the response to the
    ///                 <code>Query</code> operation.</p>
    public let queryId: Swift.String?
    /// <p>Provides Amazon Kendra with relevant or not relevant feedback for
    ///             whether a particular item was relevant to the search.</p>
    public let relevanceFeedbackItems: [KendraClientTypes.RelevanceFeedback]?

    public init (
        clickFeedbackItems: [KendraClientTypes.ClickFeedback]? = nil,
        indexId: Swift.String? = nil,
        queryId: Swift.String? = nil,
        relevanceFeedbackItems: [KendraClientTypes.RelevanceFeedback]? = nil
    )
    {
        self.clickFeedbackItems = clickFeedbackItems
        self.indexId = indexId
        self.queryId = queryId
        self.relevanceFeedbackItems = relevanceFeedbackItems
    }
}

struct SubmitFeedbackInputBody: Swift.Equatable {
    public let indexId: Swift.String?
    public let queryId: Swift.String?
    public let clickFeedbackItems: [KendraClientTypes.ClickFeedback]?
    public let relevanceFeedbackItems: [KendraClientTypes.RelevanceFeedback]?
}

extension SubmitFeedbackInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clickFeedbackItems = "ClickFeedbackItems"
        case indexId = "IndexId"
        case queryId = "QueryId"
        case relevanceFeedbackItems = "RelevanceFeedbackItems"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexId)
        indexId = indexIdDecoded
        let queryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryId)
        queryId = queryIdDecoded
        let clickFeedbackItemsContainer = try containerValues.decodeIfPresent([KendraClientTypes.ClickFeedback?].self, forKey: .clickFeedbackItems)
        var clickFeedbackItemsDecoded0:[KendraClientTypes.ClickFeedback]? = nil
        if let clickFeedbackItemsContainer = clickFeedbackItemsContainer {
            clickFeedbackItemsDecoded0 = [KendraClientTypes.ClickFeedback]()
            for structure0 in clickFeedbackItemsContainer {
                if let structure0 = structure0 {
                    clickFeedbackItemsDecoded0?.append(structure0)
                }
            }
        }
        clickFeedbackItems = clickFeedbackItemsDecoded0
        let relevanceFeedbackItemsContainer = try containerValues.decodeIfPresent([KendraClientTypes.RelevanceFeedback?].self, forKey: .relevanceFeedbackItems)
        var relevanceFeedbackItemsDecoded0:[KendraClientTypes.RelevanceFeedback]? = nil
        if let relevanceFeedbackItemsContainer = relevanceFeedbackItemsContainer {
            relevanceFeedbackItemsDecoded0 = [KendraClientTypes.RelevanceFeedback]()
            for structure0 in relevanceFeedbackItemsContainer {
                if let structure0 = structure0 {
                    relevanceFeedbackItemsDecoded0?.append(structure0)
                }
            }
        }
        relevanceFeedbackItems = relevanceFeedbackItemsDecoded0
    }
}

extension SubmitFeedbackOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SubmitFeedbackOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SubmitFeedbackOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SubmitFeedbackOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubmitFeedbackOutputResponse()"}
}

extension SubmitFeedbackOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct SubmitFeedbackOutputResponse: Swift.Equatable {

    public init() {}
}

struct SubmitFeedbackOutputResponseBody: Swift.Equatable {
}

extension SubmitFeedbackOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension KendraClientTypes.Suggestion: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let valueDecoded = try containerValues.decodeIfPresent(KendraClientTypes.SuggestionValue.self, forKey: .value)
        value = valueDecoded
    }
}

extension KendraClientTypes.Suggestion: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Suggestion(id: \(Swift.String(describing: id)), value: \(Swift.String(describing: value)))"}
}

extension KendraClientTypes {
    /// <p>A single query suggestion.</p>
    public struct Suggestion: Swift.Equatable {
        /// <p>The unique UUID (universally unique identifier) of a single
        ///             query suggestion.</p>
        public let id: Swift.String?
        /// <p>The value for the unique UUID (universally unique identifier)
        ///             of a single query suggestion.</p>
        ///         <p>The value is the text string of a suggestion.</p>
        public let value: KendraClientTypes.SuggestionValue?

        public init (
            id: Swift.String? = nil,
            value: KendraClientTypes.SuggestionValue? = nil
        )
        {
            self.id = id
            self.value = value
        }
    }

}

extension KendraClientTypes.SuggestionHighlight: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case beginOffset = "BeginOffset"
        case endOffset = "EndOffset"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let beginOffset = beginOffset {
            try encodeContainer.encode(beginOffset, forKey: .beginOffset)
        }
        if let endOffset = endOffset {
            try encodeContainer.encode(endOffset, forKey: .endOffset)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let beginOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .beginOffset)
        beginOffset = beginOffsetDecoded
        let endOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .endOffset)
        endOffset = endOffsetDecoded
    }
}

extension KendraClientTypes.SuggestionHighlight: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SuggestionHighlight(beginOffset: \(Swift.String(describing: beginOffset)), endOffset: \(Swift.String(describing: endOffset)))"}
}

extension KendraClientTypes {
    /// <p>The text highlights for a single query suggestion.</p>
    public struct SuggestionHighlight: Swift.Equatable {
        /// <p>The zero-based location in the response string where the highlight starts.</p>
        public let beginOffset: Swift.Int?
        /// <p>The zero-based location in the response string where the highlight ends.</p>
        public let endOffset: Swift.Int?

        public init (
            beginOffset: Swift.Int? = nil,
            endOffset: Swift.Int? = nil
        )
        {
            self.beginOffset = beginOffset
            self.endOffset = endOffset
        }
    }

}

extension KendraClientTypes.SuggestionTextWithHighlights: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case highlights = "Highlights"
        case text = "Text"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let highlights = highlights {
            var highlightsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .highlights)
            for suggestionhighlightlist0 in highlights {
                try highlightsContainer.encode(suggestionhighlightlist0)
            }
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let highlightsContainer = try containerValues.decodeIfPresent([KendraClientTypes.SuggestionHighlight?].self, forKey: .highlights)
        var highlightsDecoded0:[KendraClientTypes.SuggestionHighlight]? = nil
        if let highlightsContainer = highlightsContainer {
            highlightsDecoded0 = [KendraClientTypes.SuggestionHighlight]()
            for structure0 in highlightsContainer {
                if let structure0 = structure0 {
                    highlightsDecoded0?.append(structure0)
                }
            }
        }
        highlights = highlightsDecoded0
    }
}

extension KendraClientTypes.SuggestionTextWithHighlights: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SuggestionTextWithHighlights(highlights: \(Swift.String(describing: highlights)), text: \(Swift.String(describing: text)))"}
}

extension KendraClientTypes {
    /// <p>Provides text and information about where to highlight the query suggestion text.</p>
    public struct SuggestionTextWithHighlights: Swift.Equatable {
        /// <p>The beginning and end of the query suggestion text that should be highlighted.</p>
        public let highlights: [KendraClientTypes.SuggestionHighlight]?
        /// <p>The query suggestion text to display to the user.</p>
        public let text: Swift.String?

        public init (
            highlights: [KendraClientTypes.SuggestionHighlight]? = nil,
            text: Swift.String? = nil
        )
        {
            self.highlights = highlights
            self.text = text
        }
    }

}

extension KendraClientTypes.SuggestionValue: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text = "Text"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(KendraClientTypes.SuggestionTextWithHighlights.self, forKey: .text)
        text = textDecoded
    }
}

extension KendraClientTypes.SuggestionValue: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SuggestionValue(text: \(Swift.String(describing: text)))"}
}

extension KendraClientTypes {
    /// <p>The <code>SuggestionTextWithHighlights</code> structure information.</p>
    public struct SuggestionValue: Swift.Equatable {
        /// <p>The <code>SuggestionTextWithHighlights</code> structure that contains
        ///             the query suggestion text and highlights.</p>
        public let text: KendraClientTypes.SuggestionTextWithHighlights?

        public init (
            text: KendraClientTypes.SuggestionTextWithHighlights? = nil
        )
        {
            self.text = text
        }
    }

}

extension KendraClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension KendraClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension KendraClientTypes {
    /// <p>A list of key/value pairs that identify an index, FAQ, or data source.
    ///       Tag keys and values can consist of Unicode letters, digits, white space,
    ///       and any of the following symbols: _ . : / = + - @.</p>
    public struct Tag: Swift.Equatable {
        /// <p>The key for the tag. Keys are not case sensitive and must be unique
        ///       for the index, FAQ, or data source.</p>
        public let key: Swift.String?
        /// <p>The value associated with the tag. The value may be an empty string
        ///       but it can't be null.</p>
        public let value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceARN: \(Swift.String(describing: resourceARN)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the index, FAQ, or data source to
    ///       tag.</p>
    public let resourceARN: Swift.String?
    /// <p>A list of tag keys to add to the index, FAQ, or data source. If a tag
    ///       already exists, the existing value is replaced with the new value.</p>
    public let tags: [KendraClientTypes.Tag]?

    public init (
        resourceARN: Swift.String? = nil,
        tags: [KendraClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let resourceARN: Swift.String?
    public let tags: [KendraClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([KendraClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[KendraClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [KendraClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension KendraClientTypes.TextDocumentStatistics: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexedTextBytes = "IndexedTextBytes"
        case indexedTextDocumentsCount = "IndexedTextDocumentsCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if indexedTextBytes != 0 {
            try encodeContainer.encode(indexedTextBytes, forKey: .indexedTextBytes)
        }
        if indexedTextDocumentsCount != 0 {
            try encodeContainer.encode(indexedTextDocumentsCount, forKey: .indexedTextDocumentsCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexedTextDocumentsCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .indexedTextDocumentsCount)
        indexedTextDocumentsCount = indexedTextDocumentsCountDecoded
        let indexedTextBytesDecoded = try containerValues.decode(Swift.Int.self, forKey: .indexedTextBytes)
        indexedTextBytes = indexedTextBytesDecoded
    }
}

extension KendraClientTypes.TextDocumentStatistics: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TextDocumentStatistics(indexedTextBytes: \(Swift.String(describing: indexedTextBytes)), indexedTextDocumentsCount: \(Swift.String(describing: indexedTextDocumentsCount)))"}
}

extension KendraClientTypes {
    /// <p>Provides information about text documents indexed in an
    ///             index.</p>
    public struct TextDocumentStatistics: Swift.Equatable {
        /// <p>The total size, in bytes, of the indexed documents.</p>
        public let indexedTextBytes: Swift.Int
        /// <p>The number of text documents indexed.</p>
        public let indexedTextDocumentsCount: Swift.Int

        public init (
            indexedTextBytes: Swift.Int = 0,
            indexedTextDocumentsCount: Swift.Int = 0
        )
        {
            self.indexedTextBytes = indexedTextBytes
            self.indexedTextDocumentsCount = indexedTextDocumentsCount
        }
    }

}

extension KendraClientTypes.TextWithHighlights: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case highlights = "Highlights"
        case text = "Text"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let highlights = highlights {
            var highlightsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .highlights)
            for highlightlist0 in highlights {
                try highlightsContainer.encode(highlightlist0)
            }
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let highlightsContainer = try containerValues.decodeIfPresent([KendraClientTypes.Highlight?].self, forKey: .highlights)
        var highlightsDecoded0:[KendraClientTypes.Highlight]? = nil
        if let highlightsContainer = highlightsContainer {
            highlightsDecoded0 = [KendraClientTypes.Highlight]()
            for structure0 in highlightsContainer {
                if let structure0 = structure0 {
                    highlightsDecoded0?.append(structure0)
                }
            }
        }
        highlights = highlightsDecoded0
    }
}

extension KendraClientTypes.TextWithHighlights: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TextWithHighlights(highlights: \(Swift.String(describing: highlights)), text: \(Swift.String(describing: text)))"}
}

extension KendraClientTypes {
    /// <p>Provides text and information about where to highlight the
    ///             text.</p>
    public struct TextWithHighlights: Swift.Equatable {
        /// <p>The beginning and end of the text that should be
        ///             highlighted.</p>
        public let highlights: [KendraClientTypes.Highlight]?
        /// <p>The text to display to the user.</p>
        public let text: Swift.String?

        public init (
            highlights: [KendraClientTypes.Highlight]? = nil,
            text: Swift.String? = nil
        )
        {
            self.highlights = highlights
            self.text = text
        }
    }

}

extension KendraClientTypes {
    public enum ThesaurusStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case activeButUpdateFailed
        case creating
        case deleting
        case failed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [ThesaurusStatus] {
            return [
                .active,
                .activeButUpdateFailed,
                .creating,
                .deleting,
                .failed,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .activeButUpdateFailed: return "ACTIVE_BUT_UPDATE_FAILED"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ThesaurusStatus(rawValue: rawValue) ?? ThesaurusStatus.sdkUnknown(rawValue)
        }
    }
}

extension KendraClientTypes.ThesaurusSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case id = "Id"
        case name = "Name"
        case status = "Status"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(KendraClientTypes.ThesaurusStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension KendraClientTypes.ThesaurusSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ThesaurusSummary(createdAt: \(Swift.String(describing: createdAt)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)))"}
}

extension KendraClientTypes {
    /// <p>An array of summary information for one or more thesauruses.</p>
    public struct ThesaurusSummary: Swift.Equatable {
        /// <p>The Unix datetime that the thesaurus was created.</p>
        public let createdAt: ClientRuntime.Date?
        /// <p>The identifier of the thesaurus.</p>
        public let id: Swift.String?
        /// <p>The name of the thesaurus.</p>
        public let name: Swift.String?
        /// <p>The status of the thesaurus.</p>
        public let status: KendraClientTypes.ThesaurusStatus?
        /// <p>The Unix datetime that the thesaurus was last updated.</p>
        public let updatedAt: ClientRuntime.Date?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            status: KendraClientTypes.ThesaurusStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.id = id
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
        }
    }

}

extension ThrottlingException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ThrottlingException(message: \(Swift.String(describing: message)))"}
}

extension ThrottlingException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct ThrottlingException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KendraClientTypes.TimeRange: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension KendraClientTypes.TimeRange: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TimeRange(endTime: \(Swift.String(describing: endTime)), startTime: \(Swift.String(describing: startTime)))"}
}

extension KendraClientTypes {
    /// <p>Provides a range of time.</p>
    public struct TimeRange: Swift.Equatable {
        /// <p>The UNIX datetime of the end of the time range.</p>
        public let endTime: ClientRuntime.Date?
        /// <p>The UNIX datetime of the beginning of the time range.</p>
        public let startTime: ClientRuntime.Date?

        public init (
            endTime: ClientRuntime.Date? = nil,
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.endTime = endTime
            self.startTime = startTime
        }
    }

}

public struct UntagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceARN: \(Swift.String(describing: resourceARN)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the index, FAQ, or data source to
    ///       remove the tag from.</p>
    public let resourceARN: Swift.String?
    /// <p>A list of tag keys to remove from the index, FAQ, or data source. If a
    ///       tag key does not exist on the resource, it is ignored.</p>
    public let tagKeys: [Swift.String]?

    public init (
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    public let resourceARN: Swift.String?
    public let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateDataSourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDataSourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDataSourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDataSourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDataSourceOutputError>
}

extension UpdateDataSourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDataSourceInput(configuration: \(Swift.String(describing: configuration)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), indexId: \(Swift.String(describing: indexId)), name: \(Swift.String(describing: name)), roleArn: \(Swift.String(describing: roleArn)), schedule: \(Swift.String(describing: schedule)))"}
}

extension UpdateDataSourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
        case description = "Description"
        case id = "Id"
        case indexId = "IndexId"
        case name = "Name"
        case roleArn = "RoleArn"
        case schedule = "Schedule"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let schedule = schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
    }
}

public struct UpdateDataSourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDataSourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDataSourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDataSourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDataSourceOutputError>
}

public struct UpdateDataSourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDataSourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDataSourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDataSourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDataSourceOutputError>
}

public struct UpdateDataSourceInput: Swift.Equatable {
    /// <p>Configuration information for a Amazon Kendra data source.</p>
    public let configuration: KendraClientTypes.DataSourceConfiguration?
    /// <p>The new description for the data source.</p>
    public let description: Swift.String?
    /// <p>The unique identifier of the data source to update.</p>
    public let id: Swift.String?
    /// <p>The identifier of the index that contains the data source to
    ///       update.</p>
    public let indexId: Swift.String?
    /// <p>The name of the data source to update. The name of the data source
    ///       can't be updated. To rename a data source you must delete the data source
    ///       and re-create it.</p>
    public let name: Swift.String?
    /// <p>The Amazon Resource Name (ARN) of the new role to use when the data
    ///       source is accessing resources on your behalf.</p>
    public let roleArn: Swift.String?
    /// <p>The new update schedule for the data source.</p>
    public let schedule: Swift.String?

    public init (
        configuration: KendraClientTypes.DataSourceConfiguration? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        indexId: Swift.String? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        schedule: Swift.String? = nil
    )
    {
        self.configuration = configuration
        self.description = description
        self.id = id
        self.indexId = indexId
        self.name = name
        self.roleArn = roleArn
        self.schedule = schedule
    }
}

struct UpdateDataSourceInputBody: Swift.Equatable {
    public let id: Swift.String?
    public let name: Swift.String?
    public let indexId: Swift.String?
    public let configuration: KendraClientTypes.DataSourceConfiguration?
    public let description: Swift.String?
    public let schedule: Swift.String?
    public let roleArn: Swift.String?
}

extension UpdateDataSourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
        case description = "Description"
        case id = "Id"
        case indexId = "IndexId"
        case name = "Name"
        case roleArn = "RoleArn"
        case schedule = "Schedule"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let indexIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexId)
        indexId = indexIdDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(KendraClientTypes.DataSourceConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schedule)
        schedule = scheduleDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension UpdateDataSourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDataSourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDataSourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDataSourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDataSourceOutputResponse()"}
}

extension UpdateDataSourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDataSourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateDataSourceOutputResponseBody: Swift.Equatable {
}

extension UpdateDataSourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateIndexInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateIndexInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateIndexInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateIndexInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateIndexOutputError>
}

extension UpdateIndexInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateIndexInput(capacityUnits: \(Swift.String(describing: capacityUnits)), description: \(Swift.String(describing: description)), documentMetadataConfigurationUpdates: \(Swift.String(describing: documentMetadataConfigurationUpdates)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), roleArn: \(Swift.String(describing: roleArn)), userContextPolicy: \(Swift.String(describing: userContextPolicy)), userTokenConfigurations: \(Swift.String(describing: userTokenConfigurations)))"}
}

extension UpdateIndexInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capacityUnits = "CapacityUnits"
        case description = "Description"
        case documentMetadataConfigurationUpdates = "DocumentMetadataConfigurationUpdates"
        case id = "Id"
        case name = "Name"
        case roleArn = "RoleArn"
        case userContextPolicy = "UserContextPolicy"
        case userTokenConfigurations = "UserTokenConfigurations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capacityUnits = capacityUnits {
            try encodeContainer.encode(capacityUnits, forKey: .capacityUnits)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let documentMetadataConfigurationUpdates = documentMetadataConfigurationUpdates {
            var documentMetadataConfigurationUpdatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .documentMetadataConfigurationUpdates)
            for documentmetadataconfigurationlist0 in documentMetadataConfigurationUpdates {
                try documentMetadataConfigurationUpdatesContainer.encode(documentmetadataconfigurationlist0)
            }
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let userContextPolicy = userContextPolicy {
            try encodeContainer.encode(userContextPolicy.rawValue, forKey: .userContextPolicy)
        }
        if let userTokenConfigurations = userTokenConfigurations {
            var userTokenConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userTokenConfigurations)
            for usertokenconfigurationlist0 in userTokenConfigurations {
                try userTokenConfigurationsContainer.encode(usertokenconfigurationlist0)
            }
        }
    }
}

public struct UpdateIndexInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateIndexInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateIndexInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateIndexInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateIndexOutputError>
}

public struct UpdateIndexInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateIndexInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateIndexInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateIndexInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateIndexOutputError>
}

public struct UpdateIndexInput: Swift.Equatable {
    /// <p>Sets the number of additional storage and query capacity units that
    ///       should be used by the index. You can change the capacity of the index up
    ///       to 5 times per day.</p>
    ///          <p>If you are using extra storage units, you can't reduce the storage
    ///       capacity below that required to meet the storage needs for your
    ///       index.</p>
    public let capacityUnits: KendraClientTypes.CapacityUnitsConfiguration?
    /// <p>A new description for the index.</p>
    public let description: Swift.String?
    /// <p>The document metadata to update. </p>
    public let documentMetadataConfigurationUpdates: [KendraClientTypes.DocumentMetadataConfiguration]?
    /// <p>The identifier of the index to update.</p>
    public let id: Swift.String?
    /// <p>The name of the index to update.</p>
    public let name: Swift.String?
    /// <p>A new IAM role that gives Amazon Kendra permission to access your
    ///       Amazon CloudWatch logs.</p>
    public let roleArn: Swift.String?
    /// <p>The user user token context policy.</p>
    public let userContextPolicy: KendraClientTypes.UserContextPolicy?
    /// <p>The user token configuration.</p>
    public let userTokenConfigurations: [KendraClientTypes.UserTokenConfiguration]?

    public init (
        capacityUnits: KendraClientTypes.CapacityUnitsConfiguration? = nil,
        description: Swift.String? = nil,
        documentMetadataConfigurationUpdates: [KendraClientTypes.DocumentMetadataConfiguration]? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        userContextPolicy: KendraClientTypes.UserContextPolicy? = nil,
        userTokenConfigurations: [KendraClientTypes.UserTokenConfiguration]? = nil
    )
    {
        self.capacityUnits = capacityUnits
        self.description = description
        self.documentMetadataConfigurationUpdates = documentMetadataConfigurationUpdates
        self.id = id
        self.name = name
        self.roleArn = roleArn
        self.userContextPolicy = userContextPolicy
        self.userTokenConfigurations = userTokenConfigurations
    }
}

struct UpdateIndexInputBody: Swift.Equatable {
    public let id: Swift.String?
    public let name: Swift.String?
    public let roleArn: Swift.String?
    public let description: Swift.String?
    public let documentMetadataConfigurationUpdates: [KendraClientTypes.DocumentMetadataConfiguration]?
    public let capacityUnits: KendraClientTypes.CapacityUnitsConfiguration?
    public let userTokenConfigurations: [KendraClientTypes.UserTokenConfiguration]?
    public let userContextPolicy: KendraClientTypes.UserContextPolicy?
}

extension UpdateIndexInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capacityUnits = "CapacityUnits"
        case description = "Description"
        case documentMetadataConfigurationUpdates = "DocumentMetadataConfigurationUpdates"
        case id = "Id"
        case name = "Name"
        case roleArn = "RoleArn"
        case userContextPolicy = "UserContextPolicy"
        case userTokenConfigurations = "UserTokenConfigurations"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let documentMetadataConfigurationUpdatesContainer = try containerValues.decodeIfPresent([KendraClientTypes.DocumentMetadataConfiguration?].self, forKey: .documentMetadataConfigurationUpdates)
        var documentMetadataConfigurationUpdatesDecoded0:[KendraClientTypes.DocumentMetadataConfiguration]? = nil
        if let documentMetadataConfigurationUpdatesContainer = documentMetadataConfigurationUpdatesContainer {
            documentMetadataConfigurationUpdatesDecoded0 = [KendraClientTypes.DocumentMetadataConfiguration]()
            for structure0 in documentMetadataConfigurationUpdatesContainer {
                if let structure0 = structure0 {
                    documentMetadataConfigurationUpdatesDecoded0?.append(structure0)
                }
            }
        }
        documentMetadataConfigurationUpdates = documentMetadataConfigurationUpdatesDecoded0
        let capacityUnitsDecoded = try containerValues.decodeIfPresent(KendraClientTypes.CapacityUnitsConfiguration.self, forKey: .capacityUnits)
        capacityUnits = capacityUnitsDecoded
        let userTokenConfigurationsContainer = try containerValues.decodeIfPresent([KendraClientTypes.UserTokenConfiguration?].self, forKey: .userTokenConfigurations)
        var userTokenConfigurationsDecoded0:[KendraClientTypes.UserTokenConfiguration]? = nil
        if let userTokenConfigurationsContainer = userTokenConfigurationsContainer {
            userTokenConfigurationsDecoded0 = [KendraClientTypes.UserTokenConfiguration]()
            for structure0 in userTokenConfigurationsContainer {
                if let structure0 = structure0 {
                    userTokenConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        userTokenConfigurations = userTokenConfigurationsDecoded0
        let userContextPolicyDecoded = try containerValues.decodeIfPresent(KendraClientTypes.UserContextPolicy.self, forKey: .userContextPolicy)
        userContextPolicy = userContextPolicyDecoded
    }
}

extension UpdateIndexOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateIndexOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateIndexOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateIndexOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateIndexOutputResponse()"}
}

extension UpdateIndexOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateIndexOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateIndexOutputResponseBody: Swift.Equatable {
}

extension UpdateIndexOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateQuerySuggestionsBlockListInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateQuerySuggestionsBlockListInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateQuerySuggestionsBlockListInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateQuerySuggestionsBlockListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateQuerySuggestionsBlockListInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateQuerySuggestionsBlockListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateQuerySuggestionsBlockListOutputError>
}

extension UpdateQuerySuggestionsBlockListInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateQuerySuggestionsBlockListInput(description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), indexId: \(Swift.String(describing: indexId)), name: \(Swift.String(describing: name)), roleArn: \(Swift.String(describing: roleArn)), sourceS3Path: \(Swift.String(describing: sourceS3Path)))"}
}

extension UpdateQuerySuggestionsBlockListInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case id = "Id"
        case indexId = "IndexId"
        case name = "Name"
        case roleArn = "RoleArn"
        case sourceS3Path = "SourceS3Path"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let sourceS3Path = sourceS3Path {
            try encodeContainer.encode(sourceS3Path, forKey: .sourceS3Path)
        }
    }
}

public struct UpdateQuerySuggestionsBlockListInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateQuerySuggestionsBlockListInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateQuerySuggestionsBlockListInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateQuerySuggestionsBlockListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateQuerySuggestionsBlockListInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateQuerySuggestionsBlockListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateQuerySuggestionsBlockListOutputError>
}

public struct UpdateQuerySuggestionsBlockListInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateQuerySuggestionsBlockListInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateQuerySuggestionsBlockListInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateQuerySuggestionsBlockListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateQuerySuggestionsBlockListInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateQuerySuggestionsBlockListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateQuerySuggestionsBlockListOutputError>
}

public struct UpdateQuerySuggestionsBlockListInput: Swift.Equatable {
    /// <p>The description for a block list.</p>
    public let description: Swift.String?
    /// <p>The unique identifier of a block list.</p>
    public let id: Swift.String?
    /// <p>The identifier of the index for a block list.</p>
    public let indexId: Swift.String?
    /// <p>The name of a block list.</p>
    public let name: Swift.String?
    /// <p>The IAM (Identity and Access Management) role used to access the
    ///             block list text file in S3.</p>
    public let roleArn: Swift.String?
    /// <p>The S3 path where your block list text file sits in S3.</p>
    ///         <p>If you update your block list and provide the same path to the
    ///             block list text file in S3, then Amazon Kendra reloads the file to refresh
    ///             the block list. Amazon Kendra does not automatically refresh your block list.
    ///             You need to call the <code>UpdateQuerySuggestionsBlockList</code> API
    ///             to refresh you block list.</p>
    ///         <p>If you update your block list, then Amazon Kendra asynchronously refreshes
    ///             all query suggestions with the latest content in the S3 file. This
    ///             means changes might not take effect immediately.</p>
    public let sourceS3Path: KendraClientTypes.S3Path?

    public init (
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        indexId: Swift.String? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        sourceS3Path: KendraClientTypes.S3Path? = nil
    )
    {
        self.description = description
        self.id = id
        self.indexId = indexId
        self.name = name
        self.roleArn = roleArn
        self.sourceS3Path = sourceS3Path
    }
}

struct UpdateQuerySuggestionsBlockListInputBody: Swift.Equatable {
    public let indexId: Swift.String?
    public let id: Swift.String?
    public let name: Swift.String?
    public let description: Swift.String?
    public let sourceS3Path: KendraClientTypes.S3Path?
    public let roleArn: Swift.String?
}

extension UpdateQuerySuggestionsBlockListInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case id = "Id"
        case indexId = "IndexId"
        case name = "Name"
        case roleArn = "RoleArn"
        case sourceS3Path = "SourceS3Path"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexId)
        indexId = indexIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sourceS3PathDecoded = try containerValues.decodeIfPresent(KendraClientTypes.S3Path.self, forKey: .sourceS3Path)
        sourceS3Path = sourceS3PathDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension UpdateQuerySuggestionsBlockListOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateQuerySuggestionsBlockListOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateQuerySuggestionsBlockListOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateQuerySuggestionsBlockListOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateQuerySuggestionsBlockListOutputResponse()"}
}

extension UpdateQuerySuggestionsBlockListOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateQuerySuggestionsBlockListOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateQuerySuggestionsBlockListOutputResponseBody: Swift.Equatable {
}

extension UpdateQuerySuggestionsBlockListOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateQuerySuggestionsConfigInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateQuerySuggestionsConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateQuerySuggestionsConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateQuerySuggestionsConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateQuerySuggestionsConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateQuerySuggestionsConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateQuerySuggestionsConfigOutputError>
}

extension UpdateQuerySuggestionsConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateQuerySuggestionsConfigInput(includeQueriesWithoutUserInformation: \(Swift.String(describing: includeQueriesWithoutUserInformation)), indexId: \(Swift.String(describing: indexId)), minimumNumberOfQueryingUsers: \(Swift.String(describing: minimumNumberOfQueryingUsers)), minimumQueryCount: \(Swift.String(describing: minimumQueryCount)), mode: \(Swift.String(describing: mode)), queryLogLookBackWindowInDays: \(Swift.String(describing: queryLogLookBackWindowInDays)))"}
}

extension UpdateQuerySuggestionsConfigInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case includeQueriesWithoutUserInformation = "IncludeQueriesWithoutUserInformation"
        case indexId = "IndexId"
        case minimumNumberOfQueryingUsers = "MinimumNumberOfQueryingUsers"
        case minimumQueryCount = "MinimumQueryCount"
        case mode = "Mode"
        case queryLogLookBackWindowInDays = "QueryLogLookBackWindowInDays"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let includeQueriesWithoutUserInformation = includeQueriesWithoutUserInformation {
            try encodeContainer.encode(includeQueriesWithoutUserInformation, forKey: .includeQueriesWithoutUserInformation)
        }
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
        if let minimumNumberOfQueryingUsers = minimumNumberOfQueryingUsers {
            try encodeContainer.encode(minimumNumberOfQueryingUsers, forKey: .minimumNumberOfQueryingUsers)
        }
        if let minimumQueryCount = minimumQueryCount {
            try encodeContainer.encode(minimumQueryCount, forKey: .minimumQueryCount)
        }
        if let mode = mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
        if let queryLogLookBackWindowInDays = queryLogLookBackWindowInDays {
            try encodeContainer.encode(queryLogLookBackWindowInDays, forKey: .queryLogLookBackWindowInDays)
        }
    }
}

public struct UpdateQuerySuggestionsConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateQuerySuggestionsConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateQuerySuggestionsConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateQuerySuggestionsConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateQuerySuggestionsConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateQuerySuggestionsConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateQuerySuggestionsConfigOutputError>
}

public struct UpdateQuerySuggestionsConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateQuerySuggestionsConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateQuerySuggestionsConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateQuerySuggestionsConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateQuerySuggestionsConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateQuerySuggestionsConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateQuerySuggestionsConfigOutputError>
}

public struct UpdateQuerySuggestionsConfigInput: Swift.Equatable {
    /// <p>
    ///             <code>TRUE</code> to include queries without user information (i.e. all queries,
    ///             irrespective of the user), otherwise <code>FALSE</code> to only include queries
    ///             with user information.</p>
    ///         <p>If you pass user information to Amazon Kendra along with the queries, you can set this
    ///             flag to <code>FALSE</code> and instruct Amazon Kendra to only consider queries with user
    ///             information.</p>
    ///         <p>If you set to <code>FALSE</code>, Amazon Kendra only considers queries searched at least
    ///             <code>MinimumQueryCount</code> times across <code>MinimumNumberOfQueryingUsers</code>
    ///             unique users for suggestions.</p>
    ///         <p>If you set to <code>TRUE</code>, Amazon Kendra ignores all user information and learns
    ///             from all queries.</p>
    public let includeQueriesWithoutUserInformation: Swift.Bool?
    /// <p>The identifier of the index you want to update query suggestions settings for.</p>
    public let indexId: Swift.String?
    /// <p>The minimum number of unique users who must search a query in order for the query
    ///             to be eligible to suggest to your users.</p>
    ///         <p>Increasing this number might decrease the number of suggestions. However, this
    ///             ensures a query is searched by many users and is truly popular to suggest to users.</p>
    ///         <p>How you tune this setting depends on your specific needs.</p>
    public let minimumNumberOfQueryingUsers: Swift.Int?
    /// <p>The the minimum number of times a query must be searched in order to be
    ///             eligible to suggest to your users.</p>
    ///         <p>Decreasing this number increases the number of suggestions. However, this
    ///             affects the quality of suggestions as it sets a low bar for a query to be
    ///             considered popular to suggest to users.</p>
    ///         <p>How you tune this setting depends on your specific needs.</p>
    public let minimumQueryCount: Swift.Int?
    /// <p>Set the mode to <code>ENABLED</code> or <code>LEARN_ONLY</code>.</p>
    ///         <p>By default, Amazon Kendra enables query suggestions.
    ///             <code>LEARN_ONLY</code> mode allows you to turn off query suggestions.
    ///             You can to update this at any time.</p>
    ///         <p>In <code>LEARN_ONLY</code> mode, Amazon Kendra continues to learn from new
    ///             queries to keep suggestions up to date for when you are ready to
    ///             switch to ENABLED mode again.</p>
    public let mode: KendraClientTypes.Mode?
    /// <p>How recent your queries are in your query log time window.</p>
    ///         <p>The time window is the number of days from current day to past days.</p>
    ///         <p>By default, Amazon Kendra sets this to 180.</p>
    public let queryLogLookBackWindowInDays: Swift.Int?

    public init (
        includeQueriesWithoutUserInformation: Swift.Bool? = nil,
        indexId: Swift.String? = nil,
        minimumNumberOfQueryingUsers: Swift.Int? = nil,
        minimumQueryCount: Swift.Int? = nil,
        mode: KendraClientTypes.Mode? = nil,
        queryLogLookBackWindowInDays: Swift.Int? = nil
    )
    {
        self.includeQueriesWithoutUserInformation = includeQueriesWithoutUserInformation
        self.indexId = indexId
        self.minimumNumberOfQueryingUsers = minimumNumberOfQueryingUsers
        self.minimumQueryCount = minimumQueryCount
        self.mode = mode
        self.queryLogLookBackWindowInDays = queryLogLookBackWindowInDays
    }
}

struct UpdateQuerySuggestionsConfigInputBody: Swift.Equatable {
    public let indexId: Swift.String?
    public let mode: KendraClientTypes.Mode?
    public let queryLogLookBackWindowInDays: Swift.Int?
    public let includeQueriesWithoutUserInformation: Swift.Bool?
    public let minimumNumberOfQueryingUsers: Swift.Int?
    public let minimumQueryCount: Swift.Int?
}

extension UpdateQuerySuggestionsConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case includeQueriesWithoutUserInformation = "IncludeQueriesWithoutUserInformation"
        case indexId = "IndexId"
        case minimumNumberOfQueryingUsers = "MinimumNumberOfQueryingUsers"
        case minimumQueryCount = "MinimumQueryCount"
        case mode = "Mode"
        case queryLogLookBackWindowInDays = "QueryLogLookBackWindowInDays"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexId)
        indexId = indexIdDecoded
        let modeDecoded = try containerValues.decodeIfPresent(KendraClientTypes.Mode.self, forKey: .mode)
        mode = modeDecoded
        let queryLogLookBackWindowInDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .queryLogLookBackWindowInDays)
        queryLogLookBackWindowInDays = queryLogLookBackWindowInDaysDecoded
        let includeQueriesWithoutUserInformationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeQueriesWithoutUserInformation)
        includeQueriesWithoutUserInformation = includeQueriesWithoutUserInformationDecoded
        let minimumNumberOfQueryingUsersDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minimumNumberOfQueryingUsers)
        minimumNumberOfQueryingUsers = minimumNumberOfQueryingUsersDecoded
        let minimumQueryCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minimumQueryCount)
        minimumQueryCount = minimumQueryCountDecoded
    }
}

extension UpdateQuerySuggestionsConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateQuerySuggestionsConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateQuerySuggestionsConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateQuerySuggestionsConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateQuerySuggestionsConfigOutputResponse()"}
}

extension UpdateQuerySuggestionsConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateQuerySuggestionsConfigOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateQuerySuggestionsConfigOutputResponseBody: Swift.Equatable {
}

extension UpdateQuerySuggestionsConfigOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateThesaurusInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateThesaurusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateThesaurusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateThesaurusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateThesaurusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateThesaurusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateThesaurusOutputError>
}

extension UpdateThesaurusInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateThesaurusInput(description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), indexId: \(Swift.String(describing: indexId)), name: \(Swift.String(describing: name)), roleArn: \(Swift.String(describing: roleArn)), sourceS3Path: \(Swift.String(describing: sourceS3Path)))"}
}

extension UpdateThesaurusInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case id = "Id"
        case indexId = "IndexId"
        case name = "Name"
        case roleArn = "RoleArn"
        case sourceS3Path = "SourceS3Path"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let sourceS3Path = sourceS3Path {
            try encodeContainer.encode(sourceS3Path, forKey: .sourceS3Path)
        }
    }
}

public struct UpdateThesaurusInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateThesaurusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateThesaurusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateThesaurusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateThesaurusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateThesaurusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateThesaurusOutputError>
}

public struct UpdateThesaurusInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateThesaurusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateThesaurusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateThesaurusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateThesaurusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateThesaurusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateThesaurusOutputError>
}

public struct UpdateThesaurusInput: Swift.Equatable {
    /// <p>The updated description of the thesaurus.</p>
    public let description: Swift.String?
    /// <p>The identifier of the thesaurus to update.</p>
    public let id: Swift.String?
    /// <p>The identifier of the index associated with the thesaurus to update.</p>
    public let indexId: Swift.String?
    /// <p>The updated name of the thesaurus.</p>
    public let name: Swift.String?
    /// <p>The updated role ARN of the thesaurus.</p>
    public let roleArn: Swift.String?
    /// <p>Information required to find a specific file in an Amazon S3
    ///             bucket.</p>
    public let sourceS3Path: KendraClientTypes.S3Path?

    public init (
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        indexId: Swift.String? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        sourceS3Path: KendraClientTypes.S3Path? = nil
    )
    {
        self.description = description
        self.id = id
        self.indexId = indexId
        self.name = name
        self.roleArn = roleArn
        self.sourceS3Path = sourceS3Path
    }
}

struct UpdateThesaurusInputBody: Swift.Equatable {
    public let id: Swift.String?
    public let name: Swift.String?
    public let indexId: Swift.String?
    public let description: Swift.String?
    public let roleArn: Swift.String?
    public let sourceS3Path: KendraClientTypes.S3Path?
}

extension UpdateThesaurusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case id = "Id"
        case indexId = "IndexId"
        case name = "Name"
        case roleArn = "RoleArn"
        case sourceS3Path = "SourceS3Path"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let indexIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexId)
        indexId = indexIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let sourceS3PathDecoded = try containerValues.decodeIfPresent(KendraClientTypes.S3Path.self, forKey: .sourceS3Path)
        sourceS3Path = sourceS3PathDecoded
    }
}

extension UpdateThesaurusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateThesaurusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateThesaurusOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateThesaurusOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateThesaurusOutputResponse()"}
}

extension UpdateThesaurusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateThesaurusOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateThesaurusOutputResponseBody: Swift.Equatable {
}

extension UpdateThesaurusOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension KendraClientTypes.UserContext: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case token = "Token"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let token = token {
            try encodeContainer.encode(token, forKey: .token)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .token)
        token = tokenDecoded
    }
}

extension KendraClientTypes.UserContext: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UserContext(token: \(Swift.String(describing: token)))"}
}

extension KendraClientTypes {
    /// <p>Provides information about the user context for a Amazon Kendra index.</p>
    public struct UserContext: Swift.Equatable {
        /// <p>The user context token. It must be a JWT or a JSON token.</p>
        public let token: Swift.String?

        public init (
            token: Swift.String? = nil
        )
        {
            self.token = token
        }
    }

}

extension KendraClientTypes {
    public enum UserContextPolicy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case attributeFilter
        case userToken
        case sdkUnknown(Swift.String)

        public static var allCases: [UserContextPolicy] {
            return [
                .attributeFilter,
                .userToken,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .attributeFilter: return "ATTRIBUTE_FILTER"
            case .userToken: return "USER_TOKEN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UserContextPolicy(rawValue: rawValue) ?? UserContextPolicy.sdkUnknown(rawValue)
        }
    }
}

extension KendraClientTypes.UserTokenConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jsonTokenTypeConfiguration = "JsonTokenTypeConfiguration"
        case jwtTokenTypeConfiguration = "JwtTokenTypeConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jsonTokenTypeConfiguration = jsonTokenTypeConfiguration {
            try encodeContainer.encode(jsonTokenTypeConfiguration, forKey: .jsonTokenTypeConfiguration)
        }
        if let jwtTokenTypeConfiguration = jwtTokenTypeConfiguration {
            try encodeContainer.encode(jwtTokenTypeConfiguration, forKey: .jwtTokenTypeConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jwtTokenTypeConfigurationDecoded = try containerValues.decodeIfPresent(KendraClientTypes.JwtTokenTypeConfiguration.self, forKey: .jwtTokenTypeConfiguration)
        jwtTokenTypeConfiguration = jwtTokenTypeConfigurationDecoded
        let jsonTokenTypeConfigurationDecoded = try containerValues.decodeIfPresent(KendraClientTypes.JsonTokenTypeConfiguration.self, forKey: .jsonTokenTypeConfiguration)
        jsonTokenTypeConfiguration = jsonTokenTypeConfigurationDecoded
    }
}

extension KendraClientTypes.UserTokenConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UserTokenConfiguration(jsonTokenTypeConfiguration: \(Swift.String(describing: jsonTokenTypeConfiguration)), jwtTokenTypeConfiguration: \(Swift.String(describing: jwtTokenTypeConfiguration)))"}
}

extension KendraClientTypes {
    /// <p>Provides configuration information for a token configuration.</p>
    public struct UserTokenConfiguration: Swift.Equatable {
        /// <p>Information about the JSON token type configuration.</p>
        public let jsonTokenTypeConfiguration: KendraClientTypes.JsonTokenTypeConfiguration?
        /// <p>Information about the JWT token type configuration.</p>
        public let jwtTokenTypeConfiguration: KendraClientTypes.JwtTokenTypeConfiguration?

        public init (
            jsonTokenTypeConfiguration: KendraClientTypes.JsonTokenTypeConfiguration? = nil,
            jwtTokenTypeConfiguration: KendraClientTypes.JwtTokenTypeConfiguration? = nil
        )
        {
            self.jsonTokenTypeConfiguration = jsonTokenTypeConfiguration
            self.jwtTokenTypeConfiguration = jwtTokenTypeConfiguration
        }
    }

}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(message: \(Swift.String(describing: message)))"}
}

extension ValidationException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct ValidationException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
