// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

#if swift(>=5.5)
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, macCatalyst 15.0, *)
public extension ConfigClient {
    /// <p>Returns the current configuration items for resources that are present in your AWS Config aggregator. The operation also returns a list of resources that are not processed in the current request.
    /// 			If there are no unprocessed resources, the operation returns an empty <code>unprocessedResourceIdentifiers</code> list. </p>
    /// 		
    /// 		       <note>
    ///             <ul>
    ///                <li>
    ///                   <p>The API does not return results for deleted resources.</p>
    ///                </li>
    ///                <li>
    ///                   <p> The API does not return tags and relationships.</p>
    ///                </li>
    ///             </ul>
    ///          </note>
    func batchGetAggregateResourceConfig(input: BatchGetAggregateResourceConfigInput) async throws -> BatchGetAggregateResourceConfigOutputResponse
    {
        typealias batchGetAggregateResourceConfigContinuation = CheckedContinuation<BatchGetAggregateResourceConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: batchGetAggregateResourceConfigContinuation) in
            batchGetAggregateResourceConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns the current configuration for one or more requested
    /// 			resources. The operation also returns a list of resources that are
    /// 			not processed in the current request. If there are no unprocessed
    /// 			resources, the operation returns an empty unprocessedResourceKeys
    /// 			list. </p>
    /// 		       <note>
    /// 			         <ul>
    ///                <li>
    /// 					             <p>The API does not return results for deleted
    /// 						resources.</p>
    /// 				           </li>
    ///                <li>
    /// 					             <p> The API does not return any tags for the requested
    /// 						resources. This information is filtered out of the
    /// 						supplementaryConfiguration section of the API
    /// 						response.</p>
    /// 				           </li>
    ///             </ul>
    /// 		       </note>
    func batchGetResourceConfig(input: BatchGetResourceConfigInput) async throws -> BatchGetResourceConfigOutputResponse
    {
        typealias batchGetResourceConfigContinuation = CheckedContinuation<BatchGetResourceConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: batchGetResourceConfigContinuation) in
            batchGetResourceConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes the authorization granted to the specified
    /// 			configuration aggregator account in a specified region.</p>
    func deleteAggregationAuthorization(input: DeleteAggregationAuthorizationInput) async throws -> DeleteAggregationAuthorizationOutputResponse
    {
        typealias deleteAggregationAuthorizationContinuation = CheckedContinuation<DeleteAggregationAuthorizationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteAggregationAuthorizationContinuation) in
            deleteAggregationAuthorization(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes the specified AWS Config rule and all of its evaluation
    /// 			results.</p>
    /// 		       <p>AWS Config sets the state of a rule to <code>DELETING</code>
    /// 			until the deletion is complete. You cannot update a rule while it is
    /// 			in this state. If you make a <code>PutConfigRule</code> or
    /// 				<code>DeleteConfigRule</code> request for the rule, you will
    /// 			receive a <code>ResourceInUseException</code>.</p>
    /// 		       <p>You can check the state of a rule by using the
    /// 				<code>DescribeConfigRules</code> request.</p>
    func deleteConfigRule(input: DeleteConfigRuleInput) async throws -> DeleteConfigRuleOutputResponse
    {
        typealias deleteConfigRuleContinuation = CheckedContinuation<DeleteConfigRuleOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteConfigRuleContinuation) in
            deleteConfigRule(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes the specified configuration aggregator and the
    /// 			aggregated data associated with the aggregator.</p>
    func deleteConfigurationAggregator(input: DeleteConfigurationAggregatorInput) async throws -> DeleteConfigurationAggregatorOutputResponse
    {
        typealias deleteConfigurationAggregatorContinuation = CheckedContinuation<DeleteConfigurationAggregatorOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteConfigurationAggregatorContinuation) in
            deleteConfigurationAggregator(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes the configuration recorder.</p>
    /// 		       <p>After the configuration recorder is deleted, AWS Config will
    /// 			not record resource configuration changes until you create a new
    /// 			configuration recorder.</p>
    /// 		       <p>This action does not delete the configuration information that
    /// 			was previously recorded. You will be able to access the previously
    /// 			recorded information by using the
    /// 				<code>GetResourceConfigHistory</code> action, but you will not
    /// 			be able to access this information in the AWS Config console until
    /// 			you create a new configuration recorder.</p>
    func deleteConfigurationRecorder(input: DeleteConfigurationRecorderInput) async throws -> DeleteConfigurationRecorderOutputResponse
    {
        typealias deleteConfigurationRecorderContinuation = CheckedContinuation<DeleteConfigurationRecorderOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteConfigurationRecorderContinuation) in
            deleteConfigurationRecorder(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes the specified conformance pack and all the AWS Config rules, remediation actions, and all evaluation results within that
    /// 			conformance pack.</p>
    /// 		       <p>AWS Config sets the conformance pack to <code>DELETE_IN_PROGRESS</code> until the deletion is complete.
    /// 			You cannot update a conformance pack while it is in this state.</p>
    func deleteConformancePack(input: DeleteConformancePackInput) async throws -> DeleteConformancePackOutputResponse
    {
        typealias deleteConformancePackContinuation = CheckedContinuation<DeleteConformancePackOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteConformancePackContinuation) in
            deleteConformancePack(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes the delivery channel.</p>
    /// 		       <p>Before you can delete the delivery channel, you must stop the
    /// 			configuration recorder by using the <a>StopConfigurationRecorder</a> action.</p>
    func deleteDeliveryChannel(input: DeleteDeliveryChannelInput) async throws -> DeleteDeliveryChannelOutputResponse
    {
        typealias deleteDeliveryChannelContinuation = CheckedContinuation<DeleteDeliveryChannelOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteDeliveryChannelContinuation) in
            deleteDeliveryChannel(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes the evaluation results for the specified AWS Config
    /// 			rule. You can specify one AWS Config rule per request. After you
    /// 			delete the evaluation results, you can call the <a>StartConfigRulesEvaluation</a> API to start evaluating
    /// 			your AWS resources against the rule.</p>
    func deleteEvaluationResults(input: DeleteEvaluationResultsInput) async throws -> DeleteEvaluationResultsOutputResponse
    {
        typealias deleteEvaluationResultsContinuation = CheckedContinuation<DeleteEvaluationResultsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteEvaluationResultsContinuation) in
            deleteEvaluationResults(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes the specified organization config rule and all of its evaluation results from all member accounts in that organization. </p>
    /// 	        <p>Only a master account and a delegated administrator account can delete an organization config rule.
    /// 		When calling this API with a delegated administrator, you must ensure AWS Organizations
    /// 			<code>ListDelegatedAdministrator</code> permissions are added.</p>
    /// 		       <p>AWS Config sets the state of a rule to DELETE_IN_PROGRESS until the deletion is complete.
    /// 			You cannot update a rule while it is in this state.</p>
    func deleteOrganizationConfigRule(input: DeleteOrganizationConfigRuleInput) async throws -> DeleteOrganizationConfigRuleOutputResponse
    {
        typealias deleteOrganizationConfigRuleContinuation = CheckedContinuation<DeleteOrganizationConfigRuleOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteOrganizationConfigRuleContinuation) in
            deleteOrganizationConfigRule(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes the specified organization conformance pack and all of the config rules and remediation actions from
    /// 			all member accounts in that organization. </p>
    ///          <p> Only a master account or a delegated administrator account can delete an organization conformance pack.
    /// 	When calling this API with a delegated administrator, you must ensure AWS Organizations
    /// 		<code>ListDelegatedAdministrator</code> permissions are added.</p>
    /// 			      <p>AWS Config sets the state of a conformance pack to DELETE_IN_PROGRESS until the deletion is complete.
    /// 				You cannot update a conformance pack while it is in this state. </p>
    func deleteOrganizationConformancePack(input: DeleteOrganizationConformancePackInput) async throws -> DeleteOrganizationConformancePackOutputResponse
    {
        typealias deleteOrganizationConformancePackContinuation = CheckedContinuation<DeleteOrganizationConformancePackOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteOrganizationConformancePackContinuation) in
            deleteOrganizationConformancePack(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes pending authorization requests for a specified
    /// 			aggregator account in a specified region.</p>
    func deletePendingAggregationRequest(input: DeletePendingAggregationRequestInput) async throws -> DeletePendingAggregationRequestOutputResponse
    {
        typealias deletePendingAggregationRequestContinuation = CheckedContinuation<DeletePendingAggregationRequestOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deletePendingAggregationRequestContinuation) in
            deletePendingAggregationRequest(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes the remediation configuration.</p>
    func deleteRemediationConfiguration(input: DeleteRemediationConfigurationInput) async throws -> DeleteRemediationConfigurationOutputResponse
    {
        typealias deleteRemediationConfigurationContinuation = CheckedContinuation<DeleteRemediationConfigurationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteRemediationConfigurationContinuation) in
            deleteRemediationConfiguration(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes one or more remediation exceptions mentioned in the resource keys.</p>
    /// 		       <note>
    ///             <p>AWS Config generates a remediation exception when a problem occurs executing a remediation action to a specific resource.
    /// 			Remediation exceptions blocks auto-remediation until the exception is cleared.</p>
    ///          </note>
    func deleteRemediationExceptions(input: DeleteRemediationExceptionsInput) async throws -> DeleteRemediationExceptionsOutputResponse
    {
        typealias deleteRemediationExceptionsContinuation = CheckedContinuation<DeleteRemediationExceptionsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteRemediationExceptionsContinuation) in
            deleteRemediationExceptions(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Records the configuration state for a custom resource that has been deleted.  This API records a new ConfigurationItem with a ResourceDeleted status. You can retrieve the ConfigurationItems recorded for this resource in your AWS Config History.
    /// 			 </p>
    func deleteResourceConfig(input: DeleteResourceConfigInput) async throws -> DeleteResourceConfigOutputResponse
    {
        typealias deleteResourceConfigContinuation = CheckedContinuation<DeleteResourceConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteResourceConfigContinuation) in
            deleteResourceConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes the retention configuration.</p>
    func deleteRetentionConfiguration(input: DeleteRetentionConfigurationInput) async throws -> DeleteRetentionConfigurationOutputResponse
    {
        typealias deleteRetentionConfigurationContinuation = CheckedContinuation<DeleteRetentionConfigurationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteRetentionConfigurationContinuation) in
            deleteRetentionConfiguration(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes the stored query for a single AWS account and a single AWS Region.</p>
    func deleteStoredQuery(input: DeleteStoredQueryInput) async throws -> DeleteStoredQueryOutputResponse
    {
        typealias deleteStoredQueryContinuation = CheckedContinuation<DeleteStoredQueryOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteStoredQueryContinuation) in
            deleteStoredQuery(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Schedules delivery of a configuration snapshot to the Amazon S3
    /// 			bucket in the specified delivery channel. After the delivery has
    /// 			started, AWS Config sends the following notifications using an
    /// 			Amazon SNS topic that you have specified.</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>Notification of the start of the delivery.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Notification of the completion of the delivery, if the
    /// 					delivery was successfully completed.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Notification of delivery failure, if the delivery
    /// 					failed.</p>
    /// 			         </li>
    ///          </ul>
    func deliverConfigSnapshot(input: DeliverConfigSnapshotInput) async throws -> DeliverConfigSnapshotOutputResponse
    {
        typealias deliverConfigSnapshotContinuation = CheckedContinuation<DeliverConfigSnapshotOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deliverConfigSnapshotContinuation) in
            deliverConfigSnapshot(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns a list of compliant and noncompliant rules with the
    /// 			number of resources for compliant and noncompliant rules.
    /// 			</p>
    /// 		       <note>
    /// 			         <p>The results can return an empty result page, but if you
    /// 				have a <code>nextToken</code>, the results are displayed on the next
    /// 				page.</p>
    /// 		       </note>
    func describeAggregateComplianceByConfigRules(input: DescribeAggregateComplianceByConfigRulesInput) async throws -> DescribeAggregateComplianceByConfigRulesOutputResponse
    {
        typealias describeAggregateComplianceByConfigRulesContinuation = CheckedContinuation<DescribeAggregateComplianceByConfigRulesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeAggregateComplianceByConfigRulesContinuation) in
            describeAggregateComplianceByConfigRules(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns a list of the conformance packs and their associated compliance status with the count of compliant and noncompliant AWS Config rules within each conformance pack.
    /// 			Also returns the total rule count which includes compliant rules, noncompliant rules, and rules that cannot be evaluated due to insufficient data.</p>
    /// 		       <note>
    ///             <p>The results can return an empty result page, but if you have a <code>nextToken</code>, the results are displayed on the next page.</p>
    ///          </note>
    func describeAggregateComplianceByConformancePacks(input: DescribeAggregateComplianceByConformancePacksInput) async throws -> DescribeAggregateComplianceByConformancePacksOutputResponse
    {
        typealias describeAggregateComplianceByConformancePacksContinuation = CheckedContinuation<DescribeAggregateComplianceByConformancePacksOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeAggregateComplianceByConformancePacksContinuation) in
            describeAggregateComplianceByConformancePacks(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns a list of authorizations granted to various aggregator
    /// 			accounts and regions.</p>
    func describeAggregationAuthorizations(input: DescribeAggregationAuthorizationsInput) async throws -> DescribeAggregationAuthorizationsOutputResponse
    {
        typealias describeAggregationAuthorizationsContinuation = CheckedContinuation<DescribeAggregationAuthorizationsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeAggregationAuthorizationsContinuation) in
            describeAggregationAuthorizations(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Indicates whether the specified AWS Config rules are compliant.
    /// 			If a rule is noncompliant, this action returns the number of AWS
    /// 			resources that do not comply with the rule.</p>
    /// 		       <p>A rule is compliant if all of the evaluated resources comply
    /// 			with it. It is noncompliant if any of these resources do not
    /// 			comply.</p>
    /// 		       <p>If AWS Config has no current evaluation results for the rule,
    /// 			it returns <code>INSUFFICIENT_DATA</code>. This result might
    /// 			indicate one of the following conditions:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>AWS Config has never invoked an evaluation for the
    /// 					rule. To check whether it has, use the
    /// 						<code>DescribeConfigRuleEvaluationStatus</code> action
    /// 					to get the <code>LastSuccessfulInvocationTime</code> and
    /// 						<code>LastFailedInvocationTime</code>.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>The rule's AWS Lambda function is failing to send
    /// 					evaluation results to AWS Config. Verify that the role you
    /// 					assigned to your configuration recorder includes the
    /// 						<code>config:PutEvaluations</code> permission. If the
    /// 					rule is a custom rule, verify that the AWS Lambda execution
    /// 					role includes the <code>config:PutEvaluations</code>
    /// 					permission.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>The rule's AWS Lambda function has returned
    /// 						<code>NOT_APPLICABLE</code> for all evaluation results.
    /// 					This can occur if the resources were deleted or removed from
    /// 					the rule's scope.</p>
    /// 			         </li>
    ///          </ul>
    func describeComplianceByConfigRule(input: DescribeComplianceByConfigRuleInput) async throws -> DescribeComplianceByConfigRuleOutputResponse
    {
        typealias describeComplianceByConfigRuleContinuation = CheckedContinuation<DescribeComplianceByConfigRuleOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeComplianceByConfigRuleContinuation) in
            describeComplianceByConfigRule(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Indicates whether the specified AWS resources are compliant. If
    /// 			a resource is noncompliant, this action returns the number of AWS
    /// 			Config rules that the resource does not comply with.</p>
    /// 		       <p>A resource is compliant if it complies with all the AWS Config
    /// 			rules that evaluate it. It is noncompliant if it does not comply
    /// 			with one or more of these rules.</p>
    /// 		       <p>If AWS Config has no current evaluation results for the
    /// 			resource, it returns <code>INSUFFICIENT_DATA</code>. This result
    /// 			might indicate one of the following conditions about the rules that
    /// 			evaluate the resource:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>AWS Config has never invoked an evaluation for the
    /// 					rule. To check whether it has, use the
    /// 						<code>DescribeConfigRuleEvaluationStatus</code> action
    /// 					to get the <code>LastSuccessfulInvocationTime</code> and
    /// 						<code>LastFailedInvocationTime</code>.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>The rule's AWS Lambda function is failing to send
    /// 					evaluation results to AWS Config. Verify that the role that
    /// 					you assigned to your configuration recorder includes the
    /// 						<code>config:PutEvaluations</code> permission. If the
    /// 					rule is a custom rule, verify that the AWS Lambda execution
    /// 					role includes the <code>config:PutEvaluations</code>
    /// 					permission.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>The rule's AWS Lambda function has returned
    /// 						<code>NOT_APPLICABLE</code> for all evaluation results.
    /// 					This can occur if the resources were deleted or removed from
    /// 					the rule's scope.</p>
    /// 			         </li>
    ///          </ul>
    func describeComplianceByResource(input: DescribeComplianceByResourceInput) async throws -> DescribeComplianceByResourceOutputResponse
    {
        typealias describeComplianceByResourceContinuation = CheckedContinuation<DescribeComplianceByResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeComplianceByResourceContinuation) in
            describeComplianceByResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns status information for each of your AWS managed Config
    /// 			rules. The status includes information such as the last time AWS
    /// 			Config invoked the rule, the last time AWS Config failed to invoke
    /// 			the rule, and the related error for the last failure.</p>
    func describeConfigRuleEvaluationStatus(input: DescribeConfigRuleEvaluationStatusInput) async throws -> DescribeConfigRuleEvaluationStatusOutputResponse
    {
        typealias describeConfigRuleEvaluationStatusContinuation = CheckedContinuation<DescribeConfigRuleEvaluationStatusOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeConfigRuleEvaluationStatusContinuation) in
            describeConfigRuleEvaluationStatus(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns details about your AWS Config rules.</p>
    func describeConfigRules(input: DescribeConfigRulesInput) async throws -> DescribeConfigRulesOutputResponse
    {
        typealias describeConfigRulesContinuation = CheckedContinuation<DescribeConfigRulesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeConfigRulesContinuation) in
            describeConfigRules(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns status information for sources within an aggregator.
    /// 			The status includes information about the last time AWS Config verified authorization between the source account and an aggregator account. In case of a failure, the status contains the related error code or message. </p>
    func describeConfigurationAggregatorSourcesStatus(input: DescribeConfigurationAggregatorSourcesStatusInput) async throws -> DescribeConfigurationAggregatorSourcesStatusOutputResponse
    {
        typealias describeConfigurationAggregatorSourcesStatusContinuation = CheckedContinuation<DescribeConfigurationAggregatorSourcesStatusOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeConfigurationAggregatorSourcesStatusContinuation) in
            describeConfigurationAggregatorSourcesStatus(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns the details of one or more configuration aggregators.
    /// 			If the configuration aggregator is not specified, this action
    /// 			returns the details for all the configuration aggregators associated
    /// 			with the account. </p>
    func describeConfigurationAggregators(input: DescribeConfigurationAggregatorsInput) async throws -> DescribeConfigurationAggregatorsOutputResponse
    {
        typealias describeConfigurationAggregatorsContinuation = CheckedContinuation<DescribeConfigurationAggregatorsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeConfigurationAggregatorsContinuation) in
            describeConfigurationAggregators(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns the current status of the specified configuration
    /// 			recorder. If a configuration recorder is not specified, this action
    /// 			returns the status of all configuration recorders associated with
    /// 			the account.</p>
    /// 		       <note>
    /// 			         <p>Currently, you can specify only one configuration recorder
    /// 				per region in your account.</p>
    /// 		       </note>
    func describeConfigurationRecorderStatus(input: DescribeConfigurationRecorderStatusInput) async throws -> DescribeConfigurationRecorderStatusOutputResponse
    {
        typealias describeConfigurationRecorderStatusContinuation = CheckedContinuation<DescribeConfigurationRecorderStatusOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeConfigurationRecorderStatusContinuation) in
            describeConfigurationRecorderStatus(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns the details for the specified configuration recorders.
    /// 			If the configuration recorder is not specified, this action returns
    /// 			the details for all configuration recorders associated with the
    /// 			account.</p>
    /// 		       <note>
    /// 			         <p>Currently, you can specify only one configuration recorder
    /// 				per region in your account.</p>
    /// 		       </note>
    func describeConfigurationRecorders(input: DescribeConfigurationRecordersInput) async throws -> DescribeConfigurationRecordersOutputResponse
    {
        typealias describeConfigurationRecordersContinuation = CheckedContinuation<DescribeConfigurationRecordersOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeConfigurationRecordersContinuation) in
            describeConfigurationRecorders(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns compliance details for each rule in that conformance pack.</p>
    /// 		       <note>
    ///             <p>You must provide exact rule names.</p>
    ///          </note>
    func describeConformancePackCompliance(input: DescribeConformancePackComplianceInput) async throws -> DescribeConformancePackComplianceOutputResponse
    {
        typealias describeConformancePackComplianceContinuation = CheckedContinuation<DescribeConformancePackComplianceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeConformancePackComplianceContinuation) in
            describeConformancePackCompliance(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Provides one or more conformance packs deployment status.</p>
    /// 		       <note>
    ///             <p>If there are no conformance packs then you will see an empty result.</p>
    ///          </note>
    func describeConformancePackStatus(input: DescribeConformancePackStatusInput) async throws -> DescribeConformancePackStatusOutputResponse
    {
        typealias describeConformancePackStatusContinuation = CheckedContinuation<DescribeConformancePackStatusOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeConformancePackStatusContinuation) in
            describeConformancePackStatus(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns a list of one or more conformance packs.</p>
    func describeConformancePacks(input: DescribeConformancePacksInput) async throws -> DescribeConformancePacksOutputResponse
    {
        typealias describeConformancePacksContinuation = CheckedContinuation<DescribeConformancePacksOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeConformancePacksContinuation) in
            describeConformancePacks(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns the current status of the specified delivery channel.
    /// 			If a delivery channel is not specified, this action returns the
    /// 			current status of all delivery channels associated with the
    /// 			account.</p>
    /// 		       <note>
    /// 			         <p>Currently, you can specify only one delivery channel per
    /// 				region in your account.</p>
    /// 		       </note>
    func describeDeliveryChannelStatus(input: DescribeDeliveryChannelStatusInput) async throws -> DescribeDeliveryChannelStatusOutputResponse
    {
        typealias describeDeliveryChannelStatusContinuation = CheckedContinuation<DescribeDeliveryChannelStatusOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeDeliveryChannelStatusContinuation) in
            describeDeliveryChannelStatus(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns details about the specified delivery channel. If a
    /// 			delivery channel is not specified, this action returns the details
    /// 			of all delivery channels associated with the account.</p>
    /// 		       <note>
    /// 			         <p>Currently, you can specify only one delivery channel per
    /// 				region in your account.</p>
    /// 		       </note>
    func describeDeliveryChannels(input: DescribeDeliveryChannelsInput) async throws -> DescribeDeliveryChannelsOutputResponse
    {
        typealias describeDeliveryChannelsContinuation = CheckedContinuation<DescribeDeliveryChannelsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeDeliveryChannelsContinuation) in
            describeDeliveryChannels(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Provides organization config rule deployment status for an organization.</p>
    /// 		
    /// 		       <note>
    ///             <p>The status is not considered successful until organization config rule is successfully deployed in all the member
    /// 			accounts with an exception of excluded accounts.</p>
    /// 			         <p>When you specify the limit and the next token, you receive a paginated response.
    /// 			Limit and next token are not applicable if you specify organization config rule names.
    /// 			It is only applicable, when you request all the organization config rules.</p>
    /// 			      </note>
    func describeOrganizationConfigRuleStatuses(input: DescribeOrganizationConfigRuleStatusesInput) async throws -> DescribeOrganizationConfigRuleStatusesOutputResponse
    {
        typealias describeOrganizationConfigRuleStatusesContinuation = CheckedContinuation<DescribeOrganizationConfigRuleStatusesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeOrganizationConfigRuleStatusesContinuation) in
            describeOrganizationConfigRuleStatuses(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns a list of organization config rules. </p>
    /// 			
    /// 		       <note>
    ///             <p>When you specify the limit and the next token, you receive a paginated response.
    /// 			Limit and next token are not applicable if you specify organization config rule names.
    /// 			It is only applicable, when you request all the organization config rules.</p>
    ///          </note>
    func describeOrganizationConfigRules(input: DescribeOrganizationConfigRulesInput) async throws -> DescribeOrganizationConfigRulesOutputResponse
    {
        typealias describeOrganizationConfigRulesContinuation = CheckedContinuation<DescribeOrganizationConfigRulesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeOrganizationConfigRulesContinuation) in
            describeOrganizationConfigRules(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Provides organization conformance pack deployment status for an organization. </p>
    /// 		       <note>
    /// 			         <p>The status is not considered successful until organization conformance pack is successfully
    /// 				deployed in all the member accounts with an exception of excluded accounts.</p>
    /// 			         <p>When you specify the limit and the next token, you receive a paginated response.
    /// 				Limit and next token are not applicable if you specify organization conformance pack names.
    /// 				They are only applicable, when you request all the organization conformance packs.</p>
    ///          </note>
    func describeOrganizationConformancePackStatuses(input: DescribeOrganizationConformancePackStatusesInput) async throws -> DescribeOrganizationConformancePackStatusesOutputResponse
    {
        typealias describeOrganizationConformancePackStatusesContinuation = CheckedContinuation<DescribeOrganizationConformancePackStatusesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeOrganizationConformancePackStatusesContinuation) in
            describeOrganizationConformancePackStatuses(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns a list of organization conformance packs. </p>
    /// 		       <note>
    ///             <p>When you specify the limit and the next token, you receive a paginated response. </p>
    /// 			         <p>Limit and next token are not applicable if you specify organization conformance packs names. They are only applicable,
    /// 			when you request all the organization conformance packs. </p>
    ///          </note>
    func describeOrganizationConformancePacks(input: DescribeOrganizationConformancePacksInput) async throws -> DescribeOrganizationConformancePacksOutputResponse
    {
        typealias describeOrganizationConformancePacksContinuation = CheckedContinuation<DescribeOrganizationConformancePacksOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeOrganizationConformancePacksContinuation) in
            describeOrganizationConformancePacks(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns a list of all pending aggregation requests.</p>
    func describePendingAggregationRequests(input: DescribePendingAggregationRequestsInput) async throws -> DescribePendingAggregationRequestsOutputResponse
    {
        typealias describePendingAggregationRequestsContinuation = CheckedContinuation<DescribePendingAggregationRequestsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describePendingAggregationRequestsContinuation) in
            describePendingAggregationRequests(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns the details of one or more remediation configurations.</p>
    func describeRemediationConfigurations(input: DescribeRemediationConfigurationsInput) async throws -> DescribeRemediationConfigurationsOutputResponse
    {
        typealias describeRemediationConfigurationsContinuation = CheckedContinuation<DescribeRemediationConfigurationsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeRemediationConfigurationsContinuation) in
            describeRemediationConfigurations(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns the details of one or more remediation exceptions. A detailed view of a remediation exception for a set of resources that includes an explanation of an exception and the time when the exception will be deleted.
    /// 			When you specify the limit and the next token, you receive a paginated response. </p>
    /// 		       <note>
    ///             <p>AWS Config generates a remediation exception when a problem occurs executing a remediation action to a specific resource.
    /// 				Remediation exceptions blocks auto-remediation until the exception is cleared.</p>
    /// 			         <p>When you specify the limit and the next token, you receive a paginated response. </p>
    /// 			         <p>Limit and next token are not applicable if you request resources in batch. It is only applicable, when you request all resources.</p>
    ///          </note>
    func describeRemediationExceptions(input: DescribeRemediationExceptionsInput) async throws -> DescribeRemediationExceptionsOutputResponse
    {
        typealias describeRemediationExceptionsContinuation = CheckedContinuation<DescribeRemediationExceptionsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeRemediationExceptionsContinuation) in
            describeRemediationExceptions(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Provides a detailed view of a Remediation Execution for a set of resources including state, timestamps for when steps for the remediation execution occur, and any error messages for steps that have failed.
    /// 			When you specify the limit and the next token, you receive a paginated response.</p>
    func describeRemediationExecutionStatus(input: DescribeRemediationExecutionStatusInput) async throws -> DescribeRemediationExecutionStatusOutputResponse
    {
        typealias describeRemediationExecutionStatusContinuation = CheckedContinuation<DescribeRemediationExecutionStatusOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeRemediationExecutionStatusContinuation) in
            describeRemediationExecutionStatus(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns the details of one or more retention configurations. If
    /// 			the retention configuration name is not specified, this action
    /// 			returns the details for all the retention configurations for that
    /// 			account.</p>
    /// 		       <note>
    /// 			         <p>Currently, AWS Config supports only one retention
    /// 				configuration per region in your account.</p>
    /// 		       </note>
    func describeRetentionConfigurations(input: DescribeRetentionConfigurationsInput) async throws -> DescribeRetentionConfigurationsOutputResponse
    {
        typealias describeRetentionConfigurationsContinuation = CheckedContinuation<DescribeRetentionConfigurationsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeRetentionConfigurationsContinuation) in
            describeRetentionConfigurations(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns the evaluation results for the specified AWS Config
    /// 			rule for a specific resource in a rule. The results indicate which
    /// 			AWS resources were evaluated by the rule, when each resource was
    /// 			last evaluated, and whether each resource complies with the rule. </p>
    /// 		       <note>
    /// 			         <p>The results can return an empty result page. But if you
    /// 				have a <code>nextToken</code>, the results are displayed on the next
    /// 				page.</p>
    /// 		       </note>
    func getAggregateComplianceDetailsByConfigRule(input: GetAggregateComplianceDetailsByConfigRuleInput) async throws -> GetAggregateComplianceDetailsByConfigRuleOutputResponse
    {
        typealias getAggregateComplianceDetailsByConfigRuleContinuation = CheckedContinuation<GetAggregateComplianceDetailsByConfigRuleOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getAggregateComplianceDetailsByConfigRuleContinuation) in
            getAggregateComplianceDetailsByConfigRule(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns the number of compliant and noncompliant rules for one
    /// 			or more accounts and regions in an aggregator.</p>
    /// 		       <note>
    /// 			         <p>The results can return an empty result page, but if you
    /// 				have a nextToken, the results are displayed on the next
    /// 				page.</p>
    /// 		       </note>
    func getAggregateConfigRuleComplianceSummary(input: GetAggregateConfigRuleComplianceSummaryInput) async throws -> GetAggregateConfigRuleComplianceSummaryOutputResponse
    {
        typealias getAggregateConfigRuleComplianceSummaryContinuation = CheckedContinuation<GetAggregateConfigRuleComplianceSummaryOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getAggregateConfigRuleComplianceSummaryContinuation) in
            getAggregateConfigRuleComplianceSummary(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns the count of compliant and noncompliant conformance packs across all AWS Accounts and AWS Regions in an aggregator. You can filter based on AWS Account ID or AWS Region.</p>
    /// 		       <note>
    ///             <p>The results can return an empty result page, but if you have a nextToken, the results are displayed on the next page.</p>
    ///          </note>
    func getAggregateConformancePackComplianceSummary(input: GetAggregateConformancePackComplianceSummaryInput) async throws -> GetAggregateConformancePackComplianceSummaryOutputResponse
    {
        typealias getAggregateConformancePackComplianceSummaryContinuation = CheckedContinuation<GetAggregateConformancePackComplianceSummaryOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getAggregateConformancePackComplianceSummaryContinuation) in
            getAggregateConformancePackComplianceSummary(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns the resource counts across accounts and regions that are present in your AWS Config aggregator. You can request the resource counts by providing filters and GroupByKey.</p>
    /// 		       <p>For example, if the input contains accountID 12345678910 and region us-east-1 in filters, the API returns the count of resources in account ID 12345678910 and region us-east-1.
    /// 			If the input contains ACCOUNT_ID as a GroupByKey, the API returns resource counts for all source accounts that are present in your aggregator.</p>
    func getAggregateDiscoveredResourceCounts(input: GetAggregateDiscoveredResourceCountsInput) async throws -> GetAggregateDiscoveredResourceCountsOutputResponse
    {
        typealias getAggregateDiscoveredResourceCountsContinuation = CheckedContinuation<GetAggregateDiscoveredResourceCountsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getAggregateDiscoveredResourceCountsContinuation) in
            getAggregateDiscoveredResourceCounts(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns configuration item that is aggregated for your specific resource in a specific source account and region.</p>
    func getAggregateResourceConfig(input: GetAggregateResourceConfigInput) async throws -> GetAggregateResourceConfigOutputResponse
    {
        typealias getAggregateResourceConfigContinuation = CheckedContinuation<GetAggregateResourceConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getAggregateResourceConfigContinuation) in
            getAggregateResourceConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns the evaluation results for the specified AWS Config
    /// 			rule. The results indicate which AWS resources were evaluated by the
    /// 			rule, when each resource was last evaluated, and whether each
    /// 			resource complies with the rule.</p>
    func getComplianceDetailsByConfigRule(input: GetComplianceDetailsByConfigRuleInput) async throws -> GetComplianceDetailsByConfigRuleOutputResponse
    {
        typealias getComplianceDetailsByConfigRuleContinuation = CheckedContinuation<GetComplianceDetailsByConfigRuleOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getComplianceDetailsByConfigRuleContinuation) in
            getComplianceDetailsByConfigRule(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns the evaluation results for the specified AWS resource.
    /// 			The results indicate which AWS Config rules were used to evaluate
    /// 			the resource, when each rule was last used, and whether the resource
    /// 			complies with each rule.</p>
    func getComplianceDetailsByResource(input: GetComplianceDetailsByResourceInput) async throws -> GetComplianceDetailsByResourceOutputResponse
    {
        typealias getComplianceDetailsByResourceContinuation = CheckedContinuation<GetComplianceDetailsByResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getComplianceDetailsByResourceContinuation) in
            getComplianceDetailsByResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns the number of AWS Config rules that are compliant and
    /// 			noncompliant, up to a maximum of 25 for each.</p>
    func getComplianceSummaryByConfigRule(input: GetComplianceSummaryByConfigRuleInput) async throws -> GetComplianceSummaryByConfigRuleOutputResponse
    {
        typealias getComplianceSummaryByConfigRuleContinuation = CheckedContinuation<GetComplianceSummaryByConfigRuleOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getComplianceSummaryByConfigRuleContinuation) in
            getComplianceSummaryByConfigRule(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns the number of resources that are compliant and the
    /// 			number that are noncompliant. You can specify one or more resource
    /// 			types to get these numbers for each resource type. The maximum
    /// 			number returned is 100.</p>
    func getComplianceSummaryByResourceType(input: GetComplianceSummaryByResourceTypeInput) async throws -> GetComplianceSummaryByResourceTypeOutputResponse
    {
        typealias getComplianceSummaryByResourceTypeContinuation = CheckedContinuation<GetComplianceSummaryByResourceTypeOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getComplianceSummaryByResourceTypeContinuation) in
            getComplianceSummaryByResourceType(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns compliance details of a conformance pack for all AWS resources that are monitered by conformance pack.</p>
    func getConformancePackComplianceDetails(input: GetConformancePackComplianceDetailsInput) async throws -> GetConformancePackComplianceDetailsOutputResponse
    {
        typealias getConformancePackComplianceDetailsContinuation = CheckedContinuation<GetConformancePackComplianceDetailsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getConformancePackComplianceDetailsContinuation) in
            getConformancePackComplianceDetails(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns compliance details for the conformance pack based on the cumulative compliance results of all the rules in that conformance pack.</p>
    func getConformancePackComplianceSummary(input: GetConformancePackComplianceSummaryInput) async throws -> GetConformancePackComplianceSummaryOutputResponse
    {
        typealias getConformancePackComplianceSummaryContinuation = CheckedContinuation<GetConformancePackComplianceSummaryOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getConformancePackComplianceSummaryContinuation) in
            getConformancePackComplianceSummary(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns the resource types, the number of each resource type,
    /// 			and the total number of resources that AWS Config is recording in
    /// 			this region for your AWS account. </p>
    /// 		       <p class="title">
    ///             <b>Example</b>
    ///          </p>
    ///          <ol>
    ///             <li>
    /// 				           <p>AWS Config is recording three resource types in the US
    /// 					East (Ohio) Region for your account: 25 EC2 instances, 20
    /// 					IAM users, and 15 S3 buckets.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>You make a call to the
    /// 						<code>GetDiscoveredResourceCounts</code> action and
    /// 					specify that you want all resource types. </p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>AWS Config returns the following:</p>
    ///
    /// 				           <ul>
    ///                   <li>
    /// 						               <p>The resource types (EC2 instances, IAM users,
    /// 							and S3 buckets).</p>
    /// 					             </li>
    ///                   <li>
    /// 						               <p>The number of each resource type (25, 20, and
    /// 							15).</p>
    /// 					             </li>
    ///                   <li>
    /// 						               <p>The total number of all resources
    /// 							(60).</p>
    /// 					             </li>
    ///                </ul>
    ///
    /// 			         </li>
    ///          </ol>
    ///
    /// 		       <p>The response is paginated. By default, AWS Config lists 100
    /// 				<a>ResourceCount</a> objects on each page. You can
    /// 			customize this number with the <code>limit</code> parameter. The
    /// 			response includes a <code>nextToken</code> string. To get the next
    /// 			page of results, run the request again and specify the string for
    /// 			the <code>nextToken</code> parameter.</p>
    ///
    /// 		       <note>
    /// 			         <p>If you make a call to the <a>GetDiscoveredResourceCounts</a> action, you might
    /// 				not immediately receive resource counts in the following
    /// 				situations:</p>
    ///
    /// 			         <ul>
    ///                <li>
    /// 					             <p>You are a new AWS Config customer.</p>
    /// 				           </li>
    ///                <li>
    /// 					             <p>You just enabled resource recording.</p>
    /// 				           </li>
    ///             </ul>
    ///
    /// 			         <p>It might take a few minutes for AWS Config to record and
    /// 				count your resources. Wait a few minutes and then retry the
    /// 					<a>GetDiscoveredResourceCounts</a> action.
    /// 			</p>
    /// 		       </note>
    func getDiscoveredResourceCounts(input: GetDiscoveredResourceCountsInput) async throws -> GetDiscoveredResourceCountsOutputResponse
    {
        typealias getDiscoveredResourceCountsContinuation = CheckedContinuation<GetDiscoveredResourceCountsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getDiscoveredResourceCountsContinuation) in
            getDiscoveredResourceCounts(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns detailed status for each member account within an organization for a given organization config rule.</p>
    func getOrganizationConfigRuleDetailedStatus(input: GetOrganizationConfigRuleDetailedStatusInput) async throws -> GetOrganizationConfigRuleDetailedStatusOutputResponse
    {
        typealias getOrganizationConfigRuleDetailedStatusContinuation = CheckedContinuation<GetOrganizationConfigRuleDetailedStatusOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getOrganizationConfigRuleDetailedStatusContinuation) in
            getOrganizationConfigRuleDetailedStatus(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns detailed status for each member account within an organization for a given organization conformance pack.</p>
    func getOrganizationConformancePackDetailedStatus(input: GetOrganizationConformancePackDetailedStatusInput) async throws -> GetOrganizationConformancePackDetailedStatusOutputResponse
    {
        typealias getOrganizationConformancePackDetailedStatusContinuation = CheckedContinuation<GetOrganizationConformancePackDetailedStatusOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getOrganizationConformancePackDetailedStatusContinuation) in
            getOrganizationConformancePackDetailedStatus(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns a list of configuration items for the specified
    /// 			resource. The list contains details about each state of the resource
    /// 			during the specified time interval. If you specified a retention
    /// 			period to retain your <code>ConfigurationItems</code> between a
    /// 			minimum of 30 days and a maximum of 7 years (2557 days), AWS Config
    /// 			returns the <code>ConfigurationItems</code> for the specified
    /// 			retention period. </p>
    /// 		       <p>The response is paginated. By default, AWS Config returns a
    /// 			limit of 10 configuration items per page. You can customize this
    /// 			number with the <code>limit</code> parameter. The response includes
    /// 			a <code>nextToken</code> string. To get the next page of results,
    /// 			run the request again and specify the string for the
    /// 				<code>nextToken</code> parameter.</p>
    /// 		       <note>
    /// 			         <p>Each call to the API is limited to span a duration of seven
    /// 				days. It is likely that the number of records returned is
    /// 				smaller than the specified <code>limit</code>. In such cases,
    /// 				you can make another call, using the
    /// 				<code>nextToken</code>.</p>
    /// 		       </note>
    func getResourceConfigHistory(input: GetResourceConfigHistoryInput) async throws -> GetResourceConfigHistoryOutputResponse
    {
        typealias getResourceConfigHistoryContinuation = CheckedContinuation<GetResourceConfigHistoryOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getResourceConfigHistoryContinuation) in
            getResourceConfigHistory(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns the details of a specific stored query.</p>
    func getStoredQuery(input: GetStoredQueryInput) async throws -> GetStoredQueryOutputResponse
    {
        typealias getStoredQueryContinuation = CheckedContinuation<GetStoredQueryOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getStoredQueryContinuation) in
            getStoredQuery(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Accepts a resource type and returns a list of resource identifiers that are aggregated for a specific resource type across accounts and regions.
    /// 			A resource identifier includes the resource type, ID, (if available) the custom resource name, source account, and source region.
    /// 			You can narrow the results to include only resources that have specific resource IDs, or a resource name, or source account ID, or source region.</p>
    /// 			      <p>For example, if the input consists of accountID 12345678910 and the region is us-east-1 for resource type <code>AWS::EC2::Instance</code> then the API returns all the EC2 instance identifiers of accountID 12345678910 and region us-east-1.</p>
    func listAggregateDiscoveredResources(input: ListAggregateDiscoveredResourcesInput) async throws -> ListAggregateDiscoveredResourcesOutputResponse
    {
        typealias listAggregateDiscoveredResourcesContinuation = CheckedContinuation<ListAggregateDiscoveredResourcesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listAggregateDiscoveredResourcesContinuation) in
            listAggregateDiscoveredResources(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Accepts a resource type and returns a list of resource
    /// 			identifiers for the resources of that type. A resource identifier
    /// 			includes the resource type, ID, and (if available) the custom
    /// 			resource name. The results consist of resources that AWS Config has
    /// 			discovered, including those that AWS Config is not currently
    /// 			recording. You can narrow the results to include only resources that
    /// 			have specific resource IDs or a resource name.</p>
    /// 		       <note>
    /// 			         <p>You can specify either resource IDs or a resource name, but
    /// 				not both, in the same request.</p>
    /// 		       </note>
    /// 		       <p>The response is paginated. By default, AWS Config lists 100
    /// 			resource identifiers on each page. You can customize this number
    /// 			with the <code>limit</code> parameter. The response includes a
    /// 				<code>nextToken</code> string. To get the next page of results,
    /// 			run the request again and specify the string for the
    /// 				<code>nextToken</code> parameter.</p>
    func listDiscoveredResources(input: ListDiscoveredResourcesInput) async throws -> ListDiscoveredResourcesOutputResponse
    {
        typealias listDiscoveredResourcesContinuation = CheckedContinuation<ListDiscoveredResourcesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listDiscoveredResourcesContinuation) in
            listDiscoveredResources(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Lists the stored queries for a single AWS account and a single AWS Region. The default is 100. </p>
    func listStoredQueries(input: ListStoredQueriesInput) async throws -> ListStoredQueriesOutputResponse
    {
        typealias listStoredQueriesContinuation = CheckedContinuation<ListStoredQueriesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listStoredQueriesContinuation) in
            listStoredQueries(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>List the tags for AWS Config resource.</p>
    func listTagsForResource(input: ListTagsForResourceInput) async throws -> ListTagsForResourceOutputResponse
    {
        typealias listTagsForResourceContinuation = CheckedContinuation<ListTagsForResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listTagsForResourceContinuation) in
            listTagsForResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Authorizes the aggregator account and region to collect data
    /// 			from the source account and region. </p>
    func putAggregationAuthorization(input: PutAggregationAuthorizationInput) async throws -> PutAggregationAuthorizationOutputResponse
    {
        typealias putAggregationAuthorizationContinuation = CheckedContinuation<PutAggregationAuthorizationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putAggregationAuthorizationContinuation) in
            putAggregationAuthorization(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Adds or updates an AWS Config rule for evaluating whether your
    /// 			AWS resources comply with your desired configurations.</p>
    /// 		       <p>You can use this action for custom AWS Config rules and AWS
    /// 			managed Config rules. A custom AWS Config rule is a rule that you
    /// 			develop and maintain. An AWS managed Config rule is a customizable,
    /// 			predefined rule that AWS Config provides.</p>
    /// 		       <p>If you are adding a new custom AWS Config rule, you must first
    /// 			create the AWS Lambda function that the rule invokes to evaluate
    /// 			your resources. When you use the <code>PutConfigRule</code> action
    /// 			to add the rule to AWS Config, you must specify the Amazon Resource
    /// 			Name (ARN) that AWS Lambda assigns to the function. Specify the ARN
    /// 			for the <code>SourceIdentifier</code> key. This key is part of the
    /// 				<code>Source</code> object, which is part of the
    /// 				<code>ConfigRule</code> object. </p>
    /// 		       <p>If you are adding an AWS managed Config rule, specify the
    /// 			rule's identifier for the <code>SourceIdentifier</code> key. To
    /// 			reference AWS managed Config rule identifiers, see <a href="https://docs.aws.amazon.com/config/latest/developerguide/evaluate-config_use-managed-rules.html">About AWS Managed Config Rules</a>.</p>
    /// 		       <p>For any new rule that you add, specify the
    /// 				<code>ConfigRuleName</code> in the <code>ConfigRule</code>
    /// 			object. Do not specify the <code>ConfigRuleArn</code> or the
    /// 				<code>ConfigRuleId</code>. These values are generated by AWS
    /// 			Config for new rules.</p>
    /// 		       <p>If you are updating a rule that you added previously, you can
    /// 			specify the rule by <code>ConfigRuleName</code>,
    /// 				<code>ConfigRuleId</code>, or <code>ConfigRuleArn</code> in the
    /// 				<code>ConfigRule</code> data type that you use in this
    /// 			request.</p>
    /// 		       <p>The maximum number of rules that AWS Config supports is 150.</p>
    ///
    /// 		       <p>For information about requesting a rule limit increase, see
    /// 				<a href="http://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html#limits_config">AWS Config Limits</a> in the <i>AWS General
    /// 				Reference Guide</i>.</p>
    ///
    /// 		       <p>For more information about developing and using AWS Config
    /// 			rules, see <a href="https://docs.aws.amazon.com/config/latest/developerguide/evaluate-config.html">Evaluating AWS Resource Configurations with AWS Config</a>
    /// 			in the <i>AWS Config Developer Guide</i>.</p>
    func putConfigRule(input: PutConfigRuleInput) async throws -> PutConfigRuleOutputResponse
    {
        typealias putConfigRuleContinuation = CheckedContinuation<PutConfigRuleOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putConfigRuleContinuation) in
            putConfigRule(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates and updates the configuration aggregator with the
    /// 			selected source accounts and regions. The source account can be
    /// 			individual account(s) or an organization.</p>
    /// 		
    /// 		       <p>
    ///             <code>accountIds</code> that are passed will be replaced with existing accounts.
    /// 			If you want to add additional accounts into the aggregator, call <code>DescribeAggregator</code> to get the previous accounts and then append new ones.</p>
    /// 		       <note>
    /// 			         <p>AWS Config should be enabled in source accounts and regions
    /// 				you want to aggregate.</p>
    /// 			
    /// 			         <p>If your source type is an organization, you must be signed in to the management account or a registered delegated administrator and all the features must be enabled in your organization.
    /// 				If the caller is a management account, AWS Config calls <code>EnableAwsServiceAccess</code> API to enable integration between AWS Config and AWS Organizations.
    /// 				If the caller is a registered delegated administrator, AWS Config calls <code>ListDelegatedAdministrators</code> API to verify whether the caller is a valid delegated administrator.</p>
    /// 			         <p>To register a delegated administrator, see <a href="https://docs.aws.amazon.com/config/latest/developerguide/set-up-aggregator-cli.html#register-a-delegated-administrator-cli">Register a Delegated Administrator</a> in the AWS Config developer guide. </p>
    /// 		       </note>
    func putConfigurationAggregator(input: PutConfigurationAggregatorInput) async throws -> PutConfigurationAggregatorOutputResponse
    {
        typealias putConfigurationAggregatorContinuation = CheckedContinuation<PutConfigurationAggregatorOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putConfigurationAggregatorContinuation) in
            putConfigurationAggregator(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates a new configuration recorder to record the selected
    /// 			resource configurations.</p>
    /// 		       <p>You can use this action to change the role <code>roleARN</code>
    /// 			or the <code>recordingGroup</code> of an existing recorder. To
    /// 			change the role, call the action on the existing configuration
    /// 			recorder and specify a role.</p>
    /// 		       <note>
    /// 			         <p>Currently, you can specify only one configuration recorder
    /// 				per region in your account.</p>
    /// 			         <p>If <code>ConfigurationRecorder</code> does not have the
    /// 					<b>recordingGroup</b> parameter
    /// 				specified, the default is to record all supported resource
    /// 				types.</p>
    /// 		       </note>
    func putConfigurationRecorder(input: PutConfigurationRecorderInput) async throws -> PutConfigurationRecorderOutputResponse
    {
        typealias putConfigurationRecorderContinuation = CheckedContinuation<PutConfigurationRecorderOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putConfigurationRecorderContinuation) in
            putConfigurationRecorder(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates or updates a conformance pack. A conformance pack is a collection of AWS Config rules that can be easily deployed in an account and a region and across AWS Organization.</p>
    /// 		       <p>This API creates a service linked role <code>AWSServiceRoleForConfigConforms</code> in your account.
    /// 		The service linked role is created only when the role does not exist in your account. </p>
    /// 		       <note>
    ///             <p>You must specify either the <code>TemplateS3Uri</code> or the <code>TemplateBody</code> parameter, but not both.
    /// 			If you provide both AWS Config uses the <code>TemplateS3Uri</code> parameter and ignores the <code>TemplateBody</code> parameter.</p>
    ///          </note>
    func putConformancePack(input: PutConformancePackInput) async throws -> PutConformancePackOutputResponse
    {
        typealias putConformancePackContinuation = CheckedContinuation<PutConformancePackOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putConformancePackContinuation) in
            putConformancePack(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates a delivery channel object to deliver configuration
    /// 			information to an Amazon S3 bucket and Amazon SNS topic.</p>
    /// 		       <p>Before you can create a delivery channel, you must create a
    /// 			configuration recorder.</p>
    /// 		       <p>You can use this action to change the Amazon S3 bucket or an
    /// 			Amazon SNS topic of the existing delivery channel. To change the
    /// 			Amazon S3 bucket or an Amazon SNS topic, call this action and
    /// 			specify the changed values for the S3 bucket and the SNS topic. If
    /// 			you specify a different value for either the S3 bucket or the SNS
    /// 			topic, this action will keep the existing value for the parameter
    /// 			that is not changed.</p>
    /// 		       <note>
    /// 			         <p>You can have only one delivery channel per region in your
    /// 				account.</p>
    /// 			
    ///
    /// 		       </note>
    func putDeliveryChannel(input: PutDeliveryChannelInput) async throws -> PutDeliveryChannelOutputResponse
    {
        typealias putDeliveryChannelContinuation = CheckedContinuation<PutDeliveryChannelOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putDeliveryChannelContinuation) in
            putDeliveryChannel(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Used by an AWS Lambda function to deliver evaluation results to
    /// 			AWS Config. This action is required in every AWS Lambda function
    /// 			that is invoked by an AWS Config rule.</p>
    func putEvaluations(input: PutEvaluationsInput) async throws -> PutEvaluationsOutputResponse
    {
        typealias putEvaluationsContinuation = CheckedContinuation<PutEvaluationsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putEvaluationsContinuation) in
            putEvaluations(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Add or updates the evaluations for process checks.		
    /// 			This API checks if the rule is a process check when the name of the AWS Config rule is provided.</p>
    func putExternalEvaluation(input: PutExternalEvaluationInput) async throws -> PutExternalEvaluationOutputResponse
    {
        typealias putExternalEvaluationContinuation = CheckedContinuation<PutExternalEvaluationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putExternalEvaluationContinuation) in
            putExternalEvaluation(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Adds or updates organization config rule for your entire organization evaluating whether your AWS resources comply with your
    /// 			desired configurations.</p>
    /// 	        <p> Only a master account and a delegated administrator can create or update an organization config rule.
    /// 		When calling this API with a delegated administrator, you must ensure AWS Organizations
    /// 		<code>ListDelegatedAdministrator</code> permissions are added. </p>
    /// 		       <p>This API enables organization service access through the <code>EnableAWSServiceAccess</code> action and creates a service linked
    /// 			role <code>AWSServiceRoleForConfigMultiAccountSetup</code> in the master or delegated administrator account of your organization.
    /// 			The service linked role is created only when the role does not exist in the caller account.
    /// 			AWS Config verifies the existence of role with <code>GetRole</code> action.</p>
    /// 		       <p>To use this API with delegated administrator, register a delegated administrator by calling AWS Organization
    /// 			<code>register-delegated-administrator</code> for <code>config-multiaccountsetup.amazonaws.com</code>. </p>
    /// 		       <p>You can use this action to create both custom AWS Config rules and AWS managed Config rules.
    /// 			If you are adding a new custom AWS Config rule, you must first create AWS Lambda function in the master account or a delegated
    /// 			administrator that the rule invokes to evaluate your resources.
    /// 			When you use the <code>PutOrganizationConfigRule</code> action to add the rule to AWS Config, you must
    /// 			specify the Amazon Resource Name (ARN) that AWS Lambda assigns to the function.
    /// 			If you are adding an AWS managed Config rule, specify the rule's identifier for the <code>RuleIdentifier</code> key.</p>
    /// 		       <p>The maximum number of organization config rules that AWS Config supports is 150 and 3 delegated administrator per organization. </p>
    /// 		       <note>
    ///             <p>Prerequisite: Ensure you call <code>EnableAllFeatures</code> API to enable all features in an organization.</p>
    /// 			         <p>Specify either <code>OrganizationCustomRuleMetadata</code> or <code>OrganizationManagedRuleMetadata</code>.</p>
    /// 			      </note>
    func putOrganizationConfigRule(input: PutOrganizationConfigRuleInput) async throws -> PutOrganizationConfigRuleOutputResponse
    {
        typealias putOrganizationConfigRuleContinuation = CheckedContinuation<PutOrganizationConfigRuleOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putOrganizationConfigRuleContinuation) in
            putOrganizationConfigRule(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deploys conformance packs across member accounts in an AWS Organization.</p>
    /// 		       <p>Only a master account and a delegated administrator can call this API.
    /// 			When calling this API with a delegated administrator, you must ensure AWS Organizations
    /// 			<code>ListDelegatedAdministrator</code> permissions are added.</p>
    /// 		       <p>This API enables organization service access for <code>config-multiaccountsetup.amazonaws.com</code>
    /// 			through the <code>EnableAWSServiceAccess</code> action and creates a
    /// 			service linked role <code>AWSServiceRoleForConfigMultiAccountSetup</code> in the master or delegated administrator account of your organization.
    /// 			The service linked role is created only when the role does not exist in the caller account.
    /// 			To use this API with delegated administrator, register a delegated administrator by calling AWS Organization
    /// 			<code>register-delegate-admin</code> for <code>config-multiaccountsetup.amazonaws.com</code>.</p>
    ///
    /// 			
    /// 			
    /// 		       <note>
    /// 			         <p>Prerequisite: Ensure you call <code>EnableAllFeatures</code> API to enable all features in an organization.</p>
    /// 			         <p>You must specify either the <code>TemplateS3Uri</code> or the <code>TemplateBody</code> parameter, but not both.
    /// 			If you provide both AWS Config uses the <code>TemplateS3Uri</code> parameter and ignores the <code>TemplateBody</code> parameter.</p>
    /// 			         <p>AWS Config sets the state of a conformance pack to CREATE_IN_PROGRESS and UPDATE_IN_PROGRESS until the conformance pack is created or updated.
    /// 				You cannot update a conformance pack while it is in this state.</p>
    /// 			         <p>You can create 50 conformance packs with 25 AWS Config rules in each pack and 3 delegated administrator per organization. </p>
    ///          </note>
    func putOrganizationConformancePack(input: PutOrganizationConformancePackInput) async throws -> PutOrganizationConformancePackOutputResponse
    {
        typealias putOrganizationConformancePackContinuation = CheckedContinuation<PutOrganizationConformancePackOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putOrganizationConformancePackContinuation) in
            putOrganizationConformancePack(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Adds or updates the remediation configuration with a specific AWS Config rule with the
    /// 			selected target or action.
    /// 			The API creates the <code>RemediationConfiguration</code> object for the AWS Config rule.
    /// 		The AWS Config rule must already exist for you to add a remediation configuration.
    /// 		The target (SSM document) must exist and have permissions to use the target. </p>
    /// 		       <note>
    ///             <p>If you make backward incompatible changes to the SSM document,
    /// 			you must call this again to ensure the remediations can run.</p>
    /// 			         <p>This API does not support adding remediation configurations for service-linked AWS Config Rules such as Organization Config rules,
    /// 				the rules deployed by conformance packs, and rules deployed by AWS Security Hub.</p>
    ///          </note>
    func putRemediationConfigurations(input: PutRemediationConfigurationsInput) async throws -> PutRemediationConfigurationsOutputResponse
    {
        typealias putRemediationConfigurationsContinuation = CheckedContinuation<PutRemediationConfigurationsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putRemediationConfigurationsContinuation) in
            putRemediationConfigurations(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>A remediation exception is when a specific resource is no longer considered for auto-remediation.
    /// 			This API adds a new exception or updates an existing exception for a specific resource with a specific AWS Config rule. </p>
    /// 		       <note>
    ///             <p>AWS Config generates a remediation exception when a problem occurs executing a remediation action to a specific resource.
    /// 			Remediation exceptions blocks auto-remediation until the exception is cleared.</p>
    ///          </note>
    func putRemediationExceptions(input: PutRemediationExceptionsInput) async throws -> PutRemediationExceptionsOutputResponse
    {
        typealias putRemediationExceptionsContinuation = CheckedContinuation<PutRemediationExceptionsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putRemediationExceptionsContinuation) in
            putRemediationExceptions(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Records the configuration state for the resource provided in the request.
    /// 			
    /// 			The configuration state of a resource is represented in AWS Config as Configuration Items.
    /// 			Once this API records the configuration item, you can retrieve the list of configuration items for the custom resource type using existing AWS Config APIs. </p>
    /// 		       <note>
    ///             <p>The custom resource type must be registered with AWS CloudFormation. This API accepts the configuration item registered with AWS CloudFormation.</p>
    /// 			         <p>When you call this API, AWS Config only stores configuration state of the resource provided in the request. This API does not change or remediate the configuration of the resource.
    /// 				</p>
    /// 		          <p>Write-only schema properites are not recorded as part of the published configuration item.</p>
    ///          </note>
    func putResourceConfig(input: PutResourceConfigInput) async throws -> PutResourceConfigOutputResponse
    {
        typealias putResourceConfigContinuation = CheckedContinuation<PutResourceConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putResourceConfigContinuation) in
            putResourceConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates and updates the retention configuration with details
    /// 			about retention period (number of days) that AWS Config stores your
    /// 			historical information. The API creates the
    /// 				<code>RetentionConfiguration</code> object and names the object
    /// 			as <b>default</b>. When you have a
    /// 				<code>RetentionConfiguration</code> object named <b>default</b>, calling the API modifies the
    /// 			default object. </p>
    /// 		       <note>
    /// 			         <p>Currently, AWS Config supports only one retention
    /// 				configuration per region in your account.</p>
    /// 		       </note>
    func putRetentionConfiguration(input: PutRetentionConfigurationInput) async throws -> PutRetentionConfigurationOutputResponse
    {
        typealias putRetentionConfigurationContinuation = CheckedContinuation<PutRetentionConfigurationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putRetentionConfigurationContinuation) in
            putRetentionConfiguration(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Saves a new query or updates an existing saved query. The <code>QueryName</code> must be unique for a single AWS account and a single AWS Region.
    /// 			You can create upto 300 queries in a single AWS account and a single AWS Region.</p>
    func putStoredQuery(input: PutStoredQueryInput) async throws -> PutStoredQueryOutputResponse
    {
        typealias putStoredQueryContinuation = CheckedContinuation<PutStoredQueryOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putStoredQueryContinuation) in
            putStoredQuery(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Accepts a structured query language (SQL) SELECT command and an aggregator to query configuration state of AWS resources across multiple accounts and regions,
    /// 			performs the corresponding search, and returns resource configurations matching the properties.</p>
    /// 		       <p>For more information about query components, see the
    /// 			<a href="https://docs.aws.amazon.com/config/latest/developerguide/query-components.html">
    ///                <b>Query Components</b>
    ///             </a> section in the AWS Config Developer Guide.</p>
    func selectAggregateResourceConfig(input: SelectAggregateResourceConfigInput) async throws -> SelectAggregateResourceConfigOutputResponse
    {
        typealias selectAggregateResourceConfigContinuation = CheckedContinuation<SelectAggregateResourceConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: selectAggregateResourceConfigContinuation) in
            selectAggregateResourceConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Accepts a structured query language (SQL) <code>SELECT</code> command, performs the corresponding search, and returns resource configurations matching the properties.</p>
    /// 		       <p>For more information about query components, see the
    /// 			<a href="https://docs.aws.amazon.com/config/latest/developerguide/query-components.html">
    ///                <b>Query Components</b>
    ///             </a> section in the AWS Config Developer Guide.</p>
    func selectResourceConfig(input: SelectResourceConfigInput) async throws -> SelectResourceConfigOutputResponse
    {
        typealias selectResourceConfigContinuation = CheckedContinuation<SelectResourceConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: selectResourceConfigContinuation) in
            selectResourceConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Runs an on-demand evaluation for the specified AWS Config rules
    /// 			against the last known configuration state of the resources. Use
    /// 				<code>StartConfigRulesEvaluation</code> when you want to test
    /// 			that a rule you updated is working as expected.
    /// 				<code>StartConfigRulesEvaluation</code> does not re-record the
    /// 			latest configuration state for your resources. It re-runs an
    /// 			evaluation against the last known state of your resources. </p>
    /// 		       <p>You can specify up to 25 AWS Config rules per request. </p>
    ///
    /// 		
    /// 		       <p>An existing <code>StartConfigRulesEvaluation</code> call for
    /// 			the specified rules must complete before you can call the API again.
    /// 			If you chose to have AWS Config stream to an Amazon SNS topic, you
    /// 			will receive a <code>ConfigRuleEvaluationStarted</code> notification
    /// 			when the evaluation starts.</p>
    /// 		       <note>
    /// 			         <p>You don't need to call the
    /// 					<code>StartConfigRulesEvaluation</code> API to run an
    /// 				evaluation for a new rule. When you create a rule, AWS Config
    /// 				evaluates your resources against the rule automatically.
    /// 			</p>
    /// 		       </note>
    /// 		       <p>The <code>StartConfigRulesEvaluation</code> API is useful if
    /// 			you want to run on-demand evaluations, such as the following
    /// 			example:</p>
    /// 		       <ol>
    ///             <li>
    /// 				           <p>You have a custom rule that evaluates your IAM
    /// 					resources every 24 hours.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>You update your Lambda function to add additional
    /// 					conditions to your rule.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Instead of waiting for the next periodic evaluation,
    /// 					you call the <code>StartConfigRulesEvaluation</code>
    /// 					API.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>AWS Config invokes your Lambda function and evaluates
    /// 					your IAM resources.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Your custom rule will still run periodic evaluations
    /// 					every 24 hours.</p>
    /// 			         </li>
    ///          </ol>
    func startConfigRulesEvaluation(input: StartConfigRulesEvaluationInput) async throws -> StartConfigRulesEvaluationOutputResponse
    {
        typealias startConfigRulesEvaluationContinuation = CheckedContinuation<StartConfigRulesEvaluationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: startConfigRulesEvaluationContinuation) in
            startConfigRulesEvaluation(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Starts recording configurations of the AWS resources you have
    /// 			selected to record in your AWS account.</p>
    /// 		       <p>You must have created at least one delivery channel to
    /// 			successfully start the configuration recorder.</p>
    func startConfigurationRecorder(input: StartConfigurationRecorderInput) async throws -> StartConfigurationRecorderOutputResponse
    {
        typealias startConfigurationRecorderContinuation = CheckedContinuation<StartConfigurationRecorderOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: startConfigurationRecorderContinuation) in
            startConfigurationRecorder(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Runs an on-demand remediation for the specified AWS Config rules against the last known remediation configuration. It runs an execution against the current state of your resources. Remediation execution is asynchronous.</p>
    /// 			      <p>You can specify up to 100 resource keys per request. An existing StartRemediationExecution call for the specified resource keys must complete before you can call the API again.</p>
    func startRemediationExecution(input: StartRemediationExecutionInput) async throws -> StartRemediationExecutionOutputResponse
    {
        typealias startRemediationExecutionContinuation = CheckedContinuation<StartRemediationExecutionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: startRemediationExecutionContinuation) in
            startRemediationExecution(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Stops recording configurations of the AWS resources you have selected to record in your AWS account.</p>
    func stopConfigurationRecorder(input: StopConfigurationRecorderInput) async throws -> StopConfigurationRecorderOutputResponse
    {
        typealias stopConfigurationRecorderContinuation = CheckedContinuation<StopConfigurationRecorderOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: stopConfigurationRecorderContinuation) in
            stopConfigurationRecorder(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Associates the specified tags to a resource with the specified resourceArn. If existing tags on a resource are not specified in the request parameters, they are not changed.
    /// 			When a resource is deleted, the tags associated with that resource are deleted as well.</p>
    func tagResource(input: TagResourceInput) async throws -> TagResourceOutputResponse
    {
        typealias tagResourceContinuation = CheckedContinuation<TagResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: tagResourceContinuation) in
            tagResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes specified tags from a resource.</p>
    func untagResource(input: UntagResourceInput) async throws -> UntagResourceOutputResponse
    {
        typealias untagResourceContinuation = CheckedContinuation<UntagResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: untagResourceContinuation) in
            untagResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

}
#endif
