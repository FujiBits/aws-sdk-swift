// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension PricingClientTypes.AttributeValue: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension PricingClientTypes.AttributeValue: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AttributeValue(value: \(Swift.String(describing: value)))"}
}

extension PricingClientTypes {
    /// The values of a given attribute, such as Throughput Optimized HDD or Provisioned
    ///           IOPS for the Amazon EC2
    ///             volumeType attribute.
    public struct AttributeValue: Swift.Equatable {
        /// The specific value of an attributeName.
        public var value: Swift.String?

        public init (
            value: Swift.String? = nil
        )
        {
            self.value = value
        }
    }

}

public struct DescribeServicesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeServicesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeServicesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeServicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeServicesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeServicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeServicesOutputError>
}

extension DescribeServicesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeServicesInput(formatVersion: \(Swift.String(describing: formatVersion)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), serviceCode: \(Swift.String(describing: serviceCode)))"}
}

extension DescribeServicesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case formatVersion = "FormatVersion"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceCode = "ServiceCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let formatVersion = formatVersion {
            try encodeContainer.encode(formatVersion, forKey: .formatVersion)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serviceCode = serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
    }
}

public struct DescribeServicesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeServicesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeServicesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeServicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeServicesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeServicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeServicesOutputError>
}

public struct DescribeServicesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeServicesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeServicesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeServicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeServicesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeServicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeServicesOutputError>
}

public struct DescribeServicesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeServicesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeServicesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeServicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeServicesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeServicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeServicesOutputError>
}

public struct DescribeServicesInput: Swift.Equatable {
    /// The format version that you want the response to be in.
    ///          Valid values are: aws_v1
    ///
    public var formatVersion: Swift.String?
    /// The maximum number of results that you want returned in the response.
    public var maxResults: Swift.Int
    /// The pagination token that indicates the next set of results that you want to retrieve.
    public var nextToken: Swift.String?
    /// The code for the service whose information you want to retrieve, such as AmazonEC2.
    ///           You can use
    ///          the ServiceCode to filter the results in a GetProducts call.
    ///       To retrieve a list of all services, leave this blank.
    public var serviceCode: Swift.String?

    public init (
        formatVersion: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.formatVersion = formatVersion
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceCode = serviceCode
    }
}

struct DescribeServicesInputBody: Swift.Equatable {
    public let serviceCode: Swift.String?
    public let formatVersion: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int
}

extension DescribeServicesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case formatVersion = "FormatVersion"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceCode = "ServiceCode"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let formatVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .formatVersion)
        formatVersion = formatVersionDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeServicesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeServicesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ExpiredNextTokenException" : self = .expiredNextTokenException(try ExpiredNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeServicesOutputError: Swift.Error, Swift.Equatable {
    case expiredNextTokenException(ExpiredNextTokenException)
    case internalErrorException(InternalErrorException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeServicesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeServicesOutputResponse(formatVersion: \(Swift.String(describing: formatVersion)), nextToken: \(Swift.String(describing: nextToken)), services: \(Swift.String(describing: services)))"}
}

extension DescribeServicesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeServicesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.formatVersion = output.formatVersion
            self.nextToken = output.nextToken
            self.services = output.services
        } else {
            self.formatVersion = nil
            self.nextToken = nil
            self.services = nil
        }
    }
}

public struct DescribeServicesOutputResponse: Swift.Equatable {
    /// The format version of the response. For example, aws_v1.
    public var formatVersion: Swift.String?
    /// The pagination token for the next set of retreivable results.
    public var nextToken: Swift.String?
    /// The service metadata for the service or services in the response.
    public var services: [PricingClientTypes.Service]?

    public init (
        formatVersion: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        services: [PricingClientTypes.Service]? = nil
    )
    {
        self.formatVersion = formatVersion
        self.nextToken = nextToken
        self.services = services
    }
}

struct DescribeServicesOutputResponseBody: Swift.Equatable {
    public let services: [PricingClientTypes.Service]?
    public let formatVersion: Swift.String?
    public let nextToken: Swift.String?
}

extension DescribeServicesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case formatVersion = "FormatVersion"
        case nextToken = "NextToken"
        case services = "Services"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let servicesContainer = try containerValues.decodeIfPresent([PricingClientTypes.Service?].self, forKey: .services)
        var servicesDecoded0:[PricingClientTypes.Service]? = nil
        if let servicesContainer = servicesContainer {
            servicesDecoded0 = [PricingClientTypes.Service]()
            for structure0 in servicesContainer {
                if let structure0 = structure0 {
                    servicesDecoded0?.append(structure0)
                }
            }
        }
        services = servicesDecoded0
        let formatVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .formatVersion)
        formatVersion = formatVersionDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ExpiredNextTokenException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExpiredNextTokenException(message: \(Swift.String(describing: message)))"}
}

extension ExpiredNextTokenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ExpiredNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The pagination token expired. Try again without a pagination token.
public struct ExpiredNextTokenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ExpiredNextTokenExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ExpiredNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PricingClientTypes.Filter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case field = "Field"
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let field = field {
            try encodeContainer.encode(field, forKey: .field)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(PricingClientTypes.FilterType.self, forKey: .type)
        type = typeDecoded
        let fieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .field)
        field = fieldDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension PricingClientTypes.Filter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Filter(field: \(Swift.String(describing: field)), type: \(Swift.String(describing: type)), value: \(Swift.String(describing: value)))"}
}

extension PricingClientTypes {
    /// The constraints that you want all returned products to match.
    public struct Filter: Swift.Equatable {
        /// The product metadata field that you want to filter on. You can filter by just the
        ///          service code to see all products for a specific service, filter
        ///          by just the attribute name to see a specific attribute for multiple services, or use both a service code
        ///          and an attribute name to retrieve only products that match both fields.
        ///          Valid values include: ServiceCode, and all attribute names
        ///
        ///          For example, you can filter by the AmazonEC2 service code and the
        ///          volumeType attribute name to get the prices for only Amazon EC2 volumes.
        /// This member is required.
        public var field: Swift.String?
        /// The type of filter that you want to use.
        ///          Valid values are: TERM_MATCH. TERM_MATCH returns only
        ///          products that match both the given filter field and the given value.
        /// This member is required.
        public var type: PricingClientTypes.FilterType?
        /// The service code or attribute value that you want to filter by. If you are filtering by
        ///          service code this is the actual service code, such as AmazonEC2. If you are
        ///          filtering by attribute name, this is the attribute value that you want the returned products
        ///          to match, such as a Provisioned IOPS volume.
        /// This member is required.
        public var value: Swift.String?

        public init (
            field: Swift.String? = nil,
            type: PricingClientTypes.FilterType? = nil,
            value: Swift.String? = nil
        )
        {
            self.field = field
            self.type = type
            self.value = value
        }
    }

}

extension PricingClientTypes {
    public enum FilterType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case termMatch
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterType] {
            return [
                .termMatch,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .termMatch: return "TERM_MATCH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FilterType(rawValue: rawValue) ?? FilterType.sdkUnknown(rawValue)
        }
    }
}

public struct GetAttributeValuesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAttributeValuesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAttributeValuesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAttributeValuesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAttributeValuesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAttributeValuesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAttributeValuesOutputError>
}

extension GetAttributeValuesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAttributeValuesInput(attributeName: \(Swift.String(describing: attributeName)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), serviceCode: \(Swift.String(describing: serviceCode)))"}
}

extension GetAttributeValuesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "AttributeName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceCode = "ServiceCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = attributeName {
            try encodeContainer.encode(attributeName, forKey: .attributeName)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serviceCode = serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
    }
}

public struct GetAttributeValuesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAttributeValuesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAttributeValuesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAttributeValuesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAttributeValuesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAttributeValuesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAttributeValuesOutputError>
}

public struct GetAttributeValuesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAttributeValuesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAttributeValuesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAttributeValuesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAttributeValuesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAttributeValuesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAttributeValuesOutputError>
}

public struct GetAttributeValuesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAttributeValuesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetAttributeValuesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAttributeValuesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetAttributeValuesInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetAttributeValuesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAttributeValuesOutputError>
}

public struct GetAttributeValuesInput: Swift.Equatable {
    /// The name of the attribute that you want to retrieve the values for, such as volumeType.
    /// This member is required.
    public var attributeName: Swift.String?
    /// The maximum number of results to return in response.
    public var maxResults: Swift.Int
    /// The pagination token that indicates the next set of results that you want to retrieve.
    public var nextToken: Swift.String?
    /// The service code for the service whose attributes you want to retrieve. For example, if you want
    ///           the retrieve an EC2 attribute, use AmazonEC2.
    /// This member is required.
    public var serviceCode: Swift.String?

    public init (
        attributeName: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.attributeName = attributeName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceCode = serviceCode
    }
}

struct GetAttributeValuesInputBody: Swift.Equatable {
    public let serviceCode: Swift.String?
    public let attributeName: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int
}

extension GetAttributeValuesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "AttributeName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceCode = "ServiceCode"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let attributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetAttributeValuesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAttributeValuesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ExpiredNextTokenException" : self = .expiredNextTokenException(try ExpiredNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAttributeValuesOutputError: Swift.Error, Swift.Equatable {
    case expiredNextTokenException(ExpiredNextTokenException)
    case internalErrorException(InternalErrorException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAttributeValuesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAttributeValuesOutputResponse(attributeValues: \(Swift.String(describing: attributeValues)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetAttributeValuesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAttributeValuesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attributeValues = output.attributeValues
            self.nextToken = output.nextToken
        } else {
            self.attributeValues = nil
            self.nextToken = nil
        }
    }
}

public struct GetAttributeValuesOutputResponse: Swift.Equatable {
    /// The list of values for an attribute. For example, Throughput Optimized HDD and
    ///       Provisioned IOPS are two available values for the AmazonEC2
    ///             volumeType.
    public var attributeValues: [PricingClientTypes.AttributeValue]?
    /// The pagination token that indicates the next set of results to retrieve.
    public var nextToken: Swift.String?

    public init (
        attributeValues: [PricingClientTypes.AttributeValue]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.attributeValues = attributeValues
        self.nextToken = nextToken
    }
}

struct GetAttributeValuesOutputResponseBody: Swift.Equatable {
    public let attributeValues: [PricingClientTypes.AttributeValue]?
    public let nextToken: Swift.String?
}

extension GetAttributeValuesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeValues = "AttributeValues"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeValuesContainer = try containerValues.decodeIfPresent([PricingClientTypes.AttributeValue?].self, forKey: .attributeValues)
        var attributeValuesDecoded0:[PricingClientTypes.AttributeValue]? = nil
        if let attributeValuesContainer = attributeValuesContainer {
            attributeValuesDecoded0 = [PricingClientTypes.AttributeValue]()
            for structure0 in attributeValuesContainer {
                if let structure0 = structure0 {
                    attributeValuesDecoded0?.append(structure0)
                }
            }
        }
        attributeValues = attributeValuesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetProductsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetProductsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetProductsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetProductsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetProductsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetProductsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetProductsOutputError>
}

extension GetProductsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetProductsInput(filters: \(Swift.String(describing: filters)), formatVersion: \(Swift.String(describing: formatVersion)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), serviceCode: \(Swift.String(describing: serviceCode)))"}
}

extension GetProductsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case formatVersion = "FormatVersion"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceCode = "ServiceCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let formatVersion = formatVersion {
            try encodeContainer.encode(formatVersion, forKey: .formatVersion)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serviceCode = serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
    }
}

public struct GetProductsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetProductsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetProductsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetProductsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetProductsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetProductsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetProductsOutputError>
}

public struct GetProductsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetProductsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetProductsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetProductsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetProductsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetProductsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetProductsOutputError>
}

public struct GetProductsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetProductsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetProductsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetProductsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetProductsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetProductsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetProductsOutputError>
}

public struct GetProductsInput: Swift.Equatable {
    /// The list of filters that limit the returned products. only products that match all filters
    ///          are returned.
    public var filters: [PricingClientTypes.Filter]?
    /// The format version that you want the response to be in.
    ///          Valid values are: aws_v1
    ///
    public var formatVersion: Swift.String?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int
    /// The pagination token that indicates the next set of results that you want to retrieve.
    public var nextToken: Swift.String?
    /// The code for the service whose products you want to retrieve.
    public var serviceCode: Swift.String?

    public init (
        filters: [PricingClientTypes.Filter]? = nil,
        formatVersion: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.filters = filters
        self.formatVersion = formatVersion
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceCode = serviceCode
    }
}

struct GetProductsInputBody: Swift.Equatable {
    public let serviceCode: Swift.String?
    public let filters: [PricingClientTypes.Filter]?
    public let formatVersion: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int
}

extension GetProductsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case formatVersion = "FormatVersion"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceCode = "ServiceCode"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let filtersContainer = try containerValues.decodeIfPresent([PricingClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[PricingClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [PricingClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let formatVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .formatVersion)
        formatVersion = formatVersionDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetProductsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetProductsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ExpiredNextTokenException" : self = .expiredNextTokenException(try ExpiredNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetProductsOutputError: Swift.Error, Swift.Equatable {
    case expiredNextTokenException(ExpiredNextTokenException)
    case internalErrorException(InternalErrorException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetProductsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetProductsOutputResponse(formatVersion: \(Swift.String(describing: formatVersion)), nextToken: \(Swift.String(describing: nextToken)), priceList: \(Swift.String(describing: priceList)))"}
}

extension GetProductsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetProductsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.formatVersion = output.formatVersion
            self.nextToken = output.nextToken
            self.priceList = output.priceList
        } else {
            self.formatVersion = nil
            self.nextToken = nil
            self.priceList = nil
        }
    }
}

public struct GetProductsOutputResponse: Swift.Equatable {
    /// The format version of the response. For example, aws_v1.
    public var formatVersion: Swift.String?
    /// The pagination token that indicates the next set of results to retrieve.
    public var nextToken: Swift.String?
    /// The list of products that match your filters. The list contains both the product metadata and
    ///          the price information.
    public var priceList: [Swift.String]?

    public init (
        formatVersion: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        priceList: [Swift.String]? = nil
    )
    {
        self.formatVersion = formatVersion
        self.nextToken = nextToken
        self.priceList = priceList
    }
}

struct GetProductsOutputResponseBody: Swift.Equatable {
    public let formatVersion: Swift.String?
    public let priceList: [Swift.String]?
    public let nextToken: Swift.String?
}

extension GetProductsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case formatVersion = "FormatVersion"
        case nextToken = "NextToken"
        case priceList = "PriceList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .formatVersion)
        formatVersion = formatVersionDecoded
        let priceListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .priceList)
        var priceListDecoded0:[Swift.String]? = nil
        if let priceListContainer = priceListContainer {
            priceListDecoded0 = [Swift.String]()
            for string0 in priceListContainer {
                if let string0 = string0 {
                    priceListDecoded0?.append(string0)
                }
            }
        }
        priceList = priceListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension InternalErrorException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalErrorException(message: \(Swift.String(describing: message)))"}
}

extension InternalErrorException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An error on the server occurred during the processing of your request. Try again later.
public struct InternalErrorException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalErrorExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidNextTokenException(message: \(Swift.String(describing: message)))"}
}

extension InvalidNextTokenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The pagination token is invalid. Try again without a pagination token.
public struct InvalidNextTokenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidParameterException(message: \(Swift.String(describing: message)))"}
}

extension InvalidParameterException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more parameters had an invalid value.
public struct InvalidParameterException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotFoundException(message: \(Swift.String(describing: message)))"}
}

extension NotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested resource can't be found.
public struct NotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PricingClientTypes.Service: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeNames = "AttributeNames"
        case serviceCode = "ServiceCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeNames = attributeNames {
            var attributeNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributeNames)
            for attributenamelist0 in attributeNames {
                try attributeNamesContainer.encode(attributenamelist0)
            }
        }
        if let serviceCode = serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let attributeNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .attributeNames)
        var attributeNamesDecoded0:[Swift.String]? = nil
        if let attributeNamesContainer = attributeNamesContainer {
            attributeNamesDecoded0 = [Swift.String]()
            for string0 in attributeNamesContainer {
                if let string0 = string0 {
                    attributeNamesDecoded0?.append(string0)
                }
            }
        }
        attributeNames = attributeNamesDecoded0
    }
}

extension PricingClientTypes.Service: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Service(attributeNames: \(Swift.String(describing: attributeNames)), serviceCode: \(Swift.String(describing: serviceCode)))"}
}

extension PricingClientTypes {
    /// The metadata for a service, such as the service code and available attribute names.
    public struct Service: Swift.Equatable {
        /// The attributes that are available for this service.
        public var attributeNames: [Swift.String]?
        /// The code for the Amazon Web Services service.
        public var serviceCode: Swift.String?

        public init (
            attributeNames: [Swift.String]? = nil,
            serviceCode: Swift.String? = nil
        )
        {
            self.attributeNames = attributeNames
            self.serviceCode = serviceCode
        }
    }

}
