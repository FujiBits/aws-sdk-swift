// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

#if swift(>=5.5) && canImport(_Concurrency)
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, macCatalyst 15.0, *)
public extension GreengrassClient {
    /// Associates a role with a group. Your Greengrass core will use the role to access AWS cloud services. The role's permissions should allow Greengrass core Lambda functions to perform actions against the cloud.
    func associateRoleToGroup(input: AssociateRoleToGroupInput) async throws -> AssociateRoleToGroupOutputResponse
    {
        typealias associateRoleToGroupContinuation = CheckedContinuation<AssociateRoleToGroupOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: associateRoleToGroupContinuation) in
            associateRoleToGroup(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Associates a role with your account. AWS IoT Greengrass will use the role to access your Lambda functions and AWS IoT resources. This is necessary for deployments to succeed. The role must have at least minimum permissions in the policy ''AWSGreengrassResourceAccessRolePolicy''.
    func associateServiceRoleToAccount(input: AssociateServiceRoleToAccountInput) async throws -> AssociateServiceRoleToAccountOutputResponse
    {
        typealias associateServiceRoleToAccountContinuation = CheckedContinuation<AssociateServiceRoleToAccountOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: associateServiceRoleToAccountContinuation) in
            associateServiceRoleToAccount(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a connector definition. You may provide the initial version of the connector definition now or use ''CreateConnectorDefinitionVersion'' at a later time.
    func createConnectorDefinition(input: CreateConnectorDefinitionInput) async throws -> CreateConnectorDefinitionOutputResponse
    {
        typealias createConnectorDefinitionContinuation = CheckedContinuation<CreateConnectorDefinitionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createConnectorDefinitionContinuation) in
            createConnectorDefinition(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a version of a connector definition which has already been defined.
    func createConnectorDefinitionVersion(input: CreateConnectorDefinitionVersionInput) async throws -> CreateConnectorDefinitionVersionOutputResponse
    {
        typealias createConnectorDefinitionVersionContinuation = CheckedContinuation<CreateConnectorDefinitionVersionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createConnectorDefinitionVersionContinuation) in
            createConnectorDefinitionVersion(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a core definition. You may provide the initial version of the core definition now or use ''CreateCoreDefinitionVersion'' at a later time. Greengrass groups must each contain exactly one Greengrass core.
    func createCoreDefinition(input: CreateCoreDefinitionInput) async throws -> CreateCoreDefinitionOutputResponse
    {
        typealias createCoreDefinitionContinuation = CheckedContinuation<CreateCoreDefinitionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createCoreDefinitionContinuation) in
            createCoreDefinition(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a version of a core definition that has already been defined. Greengrass groups must each contain exactly one Greengrass core.
    func createCoreDefinitionVersion(input: CreateCoreDefinitionVersionInput) async throws -> CreateCoreDefinitionVersionOutputResponse
    {
        typealias createCoreDefinitionVersionContinuation = CheckedContinuation<CreateCoreDefinitionVersionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createCoreDefinitionVersionContinuation) in
            createCoreDefinitionVersion(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a deployment. ''CreateDeployment'' requests are idempotent with respect to the ''X-Amzn-Client-Token'' token and the request parameters.
    func createDeployment(input: CreateDeploymentInput) async throws -> CreateDeploymentOutputResponse
    {
        typealias createDeploymentContinuation = CheckedContinuation<CreateDeploymentOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createDeploymentContinuation) in
            createDeployment(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a device definition. You may provide the initial version of the device definition now or use ''CreateDeviceDefinitionVersion'' at a later time.
    func createDeviceDefinition(input: CreateDeviceDefinitionInput) async throws -> CreateDeviceDefinitionOutputResponse
    {
        typealias createDeviceDefinitionContinuation = CheckedContinuation<CreateDeviceDefinitionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createDeviceDefinitionContinuation) in
            createDeviceDefinition(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a version of a device definition that has already been defined.
    func createDeviceDefinitionVersion(input: CreateDeviceDefinitionVersionInput) async throws -> CreateDeviceDefinitionVersionOutputResponse
    {
        typealias createDeviceDefinitionVersionContinuation = CheckedContinuation<CreateDeviceDefinitionVersionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createDeviceDefinitionVersionContinuation) in
            createDeviceDefinitionVersion(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a Lambda function definition which contains a list of Lambda functions and their configurations to be used in a group. You can create an initial version of the definition by providing a list of Lambda functions and their configurations now, or use ''CreateFunctionDefinitionVersion'' later.
    func createFunctionDefinition(input: CreateFunctionDefinitionInput) async throws -> CreateFunctionDefinitionOutputResponse
    {
        typealias createFunctionDefinitionContinuation = CheckedContinuation<CreateFunctionDefinitionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createFunctionDefinitionContinuation) in
            createFunctionDefinition(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a version of a Lambda function definition that has already been defined.
    func createFunctionDefinitionVersion(input: CreateFunctionDefinitionVersionInput) async throws -> CreateFunctionDefinitionVersionOutputResponse
    {
        typealias createFunctionDefinitionVersionContinuation = CheckedContinuation<CreateFunctionDefinitionVersionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createFunctionDefinitionVersionContinuation) in
            createFunctionDefinitionVersion(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a group. You may provide the initial version of the group or use ''CreateGroupVersion'' at a later time. Tip: You can use the ''gg_group_setup'' package (https://github.com/awslabs/aws-greengrass-group-setup) as a library or command-line application to create and deploy Greengrass groups.
    func createGroup(input: CreateGroupInput) async throws -> CreateGroupOutputResponse
    {
        typealias createGroupContinuation = CheckedContinuation<CreateGroupOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createGroupContinuation) in
            createGroup(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a CA for the group. If a CA already exists, it will rotate the existing CA.
    func createGroupCertificateAuthority(input: CreateGroupCertificateAuthorityInput) async throws -> CreateGroupCertificateAuthorityOutputResponse
    {
        typealias createGroupCertificateAuthorityContinuation = CheckedContinuation<CreateGroupCertificateAuthorityOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createGroupCertificateAuthorityContinuation) in
            createGroupCertificateAuthority(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a version of a group which has already been defined.
    func createGroupVersion(input: CreateGroupVersionInput) async throws -> CreateGroupVersionOutputResponse
    {
        typealias createGroupVersionContinuation = CheckedContinuation<CreateGroupVersionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createGroupVersionContinuation) in
            createGroupVersion(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a logger definition. You may provide the initial version of the logger definition now or use ''CreateLoggerDefinitionVersion'' at a later time.
    func createLoggerDefinition(input: CreateLoggerDefinitionInput) async throws -> CreateLoggerDefinitionOutputResponse
    {
        typealias createLoggerDefinitionContinuation = CheckedContinuation<CreateLoggerDefinitionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createLoggerDefinitionContinuation) in
            createLoggerDefinition(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a version of a logger definition that has already been defined.
    func createLoggerDefinitionVersion(input: CreateLoggerDefinitionVersionInput) async throws -> CreateLoggerDefinitionVersionOutputResponse
    {
        typealias createLoggerDefinitionVersionContinuation = CheckedContinuation<CreateLoggerDefinitionVersionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createLoggerDefinitionVersionContinuation) in
            createLoggerDefinitionVersion(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a resource definition which contains a list of resources to be used in a group. You can create an initial version of the definition by providing a list of resources now, or use ''CreateResourceDefinitionVersion'' later.
    func createResourceDefinition(input: CreateResourceDefinitionInput) async throws -> CreateResourceDefinitionOutputResponse
    {
        typealias createResourceDefinitionContinuation = CheckedContinuation<CreateResourceDefinitionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createResourceDefinitionContinuation) in
            createResourceDefinition(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a version of a resource definition that has already been defined.
    func createResourceDefinitionVersion(input: CreateResourceDefinitionVersionInput) async throws -> CreateResourceDefinitionVersionOutputResponse
    {
        typealias createResourceDefinitionVersionContinuation = CheckedContinuation<CreateResourceDefinitionVersionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createResourceDefinitionVersionContinuation) in
            createResourceDefinitionVersion(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a software update for a core or group of cores (specified as an IoT thing group.) Use this to update the OTA Agent as well as the Greengrass core software. It makes use of the IoT Jobs feature which provides additional commands to manage a Greengrass core software update job.
    func createSoftwareUpdateJob(input: CreateSoftwareUpdateJobInput) async throws -> CreateSoftwareUpdateJobOutputResponse
    {
        typealias createSoftwareUpdateJobContinuation = CheckedContinuation<CreateSoftwareUpdateJobOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createSoftwareUpdateJobContinuation) in
            createSoftwareUpdateJob(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a subscription definition. You may provide the initial version of the subscription definition now or use ''CreateSubscriptionDefinitionVersion'' at a later time.
    func createSubscriptionDefinition(input: CreateSubscriptionDefinitionInput) async throws -> CreateSubscriptionDefinitionOutputResponse
    {
        typealias createSubscriptionDefinitionContinuation = CheckedContinuation<CreateSubscriptionDefinitionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createSubscriptionDefinitionContinuation) in
            createSubscriptionDefinition(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a version of a subscription definition which has already been defined.
    func createSubscriptionDefinitionVersion(input: CreateSubscriptionDefinitionVersionInput) async throws -> CreateSubscriptionDefinitionVersionOutputResponse
    {
        typealias createSubscriptionDefinitionVersionContinuation = CheckedContinuation<CreateSubscriptionDefinitionVersionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createSubscriptionDefinitionVersionContinuation) in
            createSubscriptionDefinitionVersion(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes a connector definition.
    func deleteConnectorDefinition(input: DeleteConnectorDefinitionInput) async throws -> DeleteConnectorDefinitionOutputResponse
    {
        typealias deleteConnectorDefinitionContinuation = CheckedContinuation<DeleteConnectorDefinitionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteConnectorDefinitionContinuation) in
            deleteConnectorDefinition(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes a core definition.
    func deleteCoreDefinition(input: DeleteCoreDefinitionInput) async throws -> DeleteCoreDefinitionOutputResponse
    {
        typealias deleteCoreDefinitionContinuation = CheckedContinuation<DeleteCoreDefinitionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteCoreDefinitionContinuation) in
            deleteCoreDefinition(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes a device definition.
    func deleteDeviceDefinition(input: DeleteDeviceDefinitionInput) async throws -> DeleteDeviceDefinitionOutputResponse
    {
        typealias deleteDeviceDefinitionContinuation = CheckedContinuation<DeleteDeviceDefinitionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteDeviceDefinitionContinuation) in
            deleteDeviceDefinition(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes a Lambda function definition.
    func deleteFunctionDefinition(input: DeleteFunctionDefinitionInput) async throws -> DeleteFunctionDefinitionOutputResponse
    {
        typealias deleteFunctionDefinitionContinuation = CheckedContinuation<DeleteFunctionDefinitionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteFunctionDefinitionContinuation) in
            deleteFunctionDefinition(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes a group.
    func deleteGroup(input: DeleteGroupInput) async throws -> DeleteGroupOutputResponse
    {
        typealias deleteGroupContinuation = CheckedContinuation<DeleteGroupOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteGroupContinuation) in
            deleteGroup(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes a logger definition.
    func deleteLoggerDefinition(input: DeleteLoggerDefinitionInput) async throws -> DeleteLoggerDefinitionOutputResponse
    {
        typealias deleteLoggerDefinitionContinuation = CheckedContinuation<DeleteLoggerDefinitionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteLoggerDefinitionContinuation) in
            deleteLoggerDefinition(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes a resource definition.
    func deleteResourceDefinition(input: DeleteResourceDefinitionInput) async throws -> DeleteResourceDefinitionOutputResponse
    {
        typealias deleteResourceDefinitionContinuation = CheckedContinuation<DeleteResourceDefinitionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteResourceDefinitionContinuation) in
            deleteResourceDefinition(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes a subscription definition.
    func deleteSubscriptionDefinition(input: DeleteSubscriptionDefinitionInput) async throws -> DeleteSubscriptionDefinitionOutputResponse
    {
        typealias deleteSubscriptionDefinitionContinuation = CheckedContinuation<DeleteSubscriptionDefinitionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteSubscriptionDefinitionContinuation) in
            deleteSubscriptionDefinition(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Disassociates the role from a group.
    func disassociateRoleFromGroup(input: DisassociateRoleFromGroupInput) async throws -> DisassociateRoleFromGroupOutputResponse
    {
        typealias disassociateRoleFromGroupContinuation = CheckedContinuation<DisassociateRoleFromGroupOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: disassociateRoleFromGroupContinuation) in
            disassociateRoleFromGroup(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Disassociates the service role from your account. Without a service role, deployments will not work.
    func disassociateServiceRoleFromAccount(input: DisassociateServiceRoleFromAccountInput) async throws -> DisassociateServiceRoleFromAccountOutputResponse
    {
        typealias disassociateServiceRoleFromAccountContinuation = CheckedContinuation<DisassociateServiceRoleFromAccountOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: disassociateServiceRoleFromAccountContinuation) in
            disassociateServiceRoleFromAccount(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves the role associated with a particular group.
    func getAssociatedRole(input: GetAssociatedRoleInput) async throws -> GetAssociatedRoleOutputResponse
    {
        typealias getAssociatedRoleContinuation = CheckedContinuation<GetAssociatedRoleOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getAssociatedRoleContinuation) in
            getAssociatedRole(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns the status of a bulk deployment.
    func getBulkDeploymentStatus(input: GetBulkDeploymentStatusInput) async throws -> GetBulkDeploymentStatusOutputResponse
    {
        typealias getBulkDeploymentStatusContinuation = CheckedContinuation<GetBulkDeploymentStatusOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getBulkDeploymentStatusContinuation) in
            getBulkDeploymentStatus(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves the connectivity information for a core.
    func getConnectivityInfo(input: GetConnectivityInfoInput) async throws -> GetConnectivityInfoOutputResponse
    {
        typealias getConnectivityInfoContinuation = CheckedContinuation<GetConnectivityInfoOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getConnectivityInfoContinuation) in
            getConnectivityInfo(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves information about a connector definition.
    func getConnectorDefinition(input: GetConnectorDefinitionInput) async throws -> GetConnectorDefinitionOutputResponse
    {
        typealias getConnectorDefinitionContinuation = CheckedContinuation<GetConnectorDefinitionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getConnectorDefinitionContinuation) in
            getConnectorDefinition(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves information about a connector definition version, including the connectors that the version contains. Connectors are prebuilt modules that interact with local infrastructure, device protocols, AWS, and other cloud services.
    func getConnectorDefinitionVersion(input: GetConnectorDefinitionVersionInput) async throws -> GetConnectorDefinitionVersionOutputResponse
    {
        typealias getConnectorDefinitionVersionContinuation = CheckedContinuation<GetConnectorDefinitionVersionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getConnectorDefinitionVersionContinuation) in
            getConnectorDefinitionVersion(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves information about a core definition version.
    func getCoreDefinition(input: GetCoreDefinitionInput) async throws -> GetCoreDefinitionOutputResponse
    {
        typealias getCoreDefinitionContinuation = CheckedContinuation<GetCoreDefinitionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getCoreDefinitionContinuation) in
            getCoreDefinition(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves information about a core definition version.
    func getCoreDefinitionVersion(input: GetCoreDefinitionVersionInput) async throws -> GetCoreDefinitionVersionOutputResponse
    {
        typealias getCoreDefinitionVersionContinuation = CheckedContinuation<GetCoreDefinitionVersionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getCoreDefinitionVersionContinuation) in
            getCoreDefinitionVersion(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns the status of a deployment.
    func getDeploymentStatus(input: GetDeploymentStatusInput) async throws -> GetDeploymentStatusOutputResponse
    {
        typealias getDeploymentStatusContinuation = CheckedContinuation<GetDeploymentStatusOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getDeploymentStatusContinuation) in
            getDeploymentStatus(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves information about a device definition.
    func getDeviceDefinition(input: GetDeviceDefinitionInput) async throws -> GetDeviceDefinitionOutputResponse
    {
        typealias getDeviceDefinitionContinuation = CheckedContinuation<GetDeviceDefinitionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getDeviceDefinitionContinuation) in
            getDeviceDefinition(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves information about a device definition version.
    func getDeviceDefinitionVersion(input: GetDeviceDefinitionVersionInput) async throws -> GetDeviceDefinitionVersionOutputResponse
    {
        typealias getDeviceDefinitionVersionContinuation = CheckedContinuation<GetDeviceDefinitionVersionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getDeviceDefinitionVersionContinuation) in
            getDeviceDefinitionVersion(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves information about a Lambda function definition, including its creation time and latest version.
    func getFunctionDefinition(input: GetFunctionDefinitionInput) async throws -> GetFunctionDefinitionOutputResponse
    {
        typealias getFunctionDefinitionContinuation = CheckedContinuation<GetFunctionDefinitionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getFunctionDefinitionContinuation) in
            getFunctionDefinition(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves information about a Lambda function definition version, including which Lambda functions are included in the version and their configurations.
    func getFunctionDefinitionVersion(input: GetFunctionDefinitionVersionInput) async throws -> GetFunctionDefinitionVersionOutputResponse
    {
        typealias getFunctionDefinitionVersionContinuation = CheckedContinuation<GetFunctionDefinitionVersionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getFunctionDefinitionVersionContinuation) in
            getFunctionDefinitionVersion(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves information about a group.
    func getGroup(input: GetGroupInput) async throws -> GetGroupOutputResponse
    {
        typealias getGroupContinuation = CheckedContinuation<GetGroupOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getGroupContinuation) in
            getGroup(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retreives the CA associated with a group. Returns the public key of the CA.
    func getGroupCertificateAuthority(input: GetGroupCertificateAuthorityInput) async throws -> GetGroupCertificateAuthorityOutputResponse
    {
        typealias getGroupCertificateAuthorityContinuation = CheckedContinuation<GetGroupCertificateAuthorityOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getGroupCertificateAuthorityContinuation) in
            getGroupCertificateAuthority(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves the current configuration for the CA used by the group.
    func getGroupCertificateConfiguration(input: GetGroupCertificateConfigurationInput) async throws -> GetGroupCertificateConfigurationOutputResponse
    {
        typealias getGroupCertificateConfigurationContinuation = CheckedContinuation<GetGroupCertificateConfigurationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getGroupCertificateConfigurationContinuation) in
            getGroupCertificateConfiguration(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves information about a group version.
    func getGroupVersion(input: GetGroupVersionInput) async throws -> GetGroupVersionOutputResponse
    {
        typealias getGroupVersionContinuation = CheckedContinuation<GetGroupVersionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getGroupVersionContinuation) in
            getGroupVersion(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves information about a logger definition.
    func getLoggerDefinition(input: GetLoggerDefinitionInput) async throws -> GetLoggerDefinitionOutputResponse
    {
        typealias getLoggerDefinitionContinuation = CheckedContinuation<GetLoggerDefinitionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getLoggerDefinitionContinuation) in
            getLoggerDefinition(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves information about a logger definition version.
    func getLoggerDefinitionVersion(input: GetLoggerDefinitionVersionInput) async throws -> GetLoggerDefinitionVersionOutputResponse
    {
        typealias getLoggerDefinitionVersionContinuation = CheckedContinuation<GetLoggerDefinitionVersionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getLoggerDefinitionVersionContinuation) in
            getLoggerDefinitionVersion(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves information about a resource definition, including its creation time and latest version.
    func getResourceDefinition(input: GetResourceDefinitionInput) async throws -> GetResourceDefinitionOutputResponse
    {
        typealias getResourceDefinitionContinuation = CheckedContinuation<GetResourceDefinitionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getResourceDefinitionContinuation) in
            getResourceDefinition(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves information about a resource definition version, including which resources are included in the version.
    func getResourceDefinitionVersion(input: GetResourceDefinitionVersionInput) async throws -> GetResourceDefinitionVersionOutputResponse
    {
        typealias getResourceDefinitionVersionContinuation = CheckedContinuation<GetResourceDefinitionVersionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getResourceDefinitionVersionContinuation) in
            getResourceDefinitionVersion(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves the service role that is attached to your account.
    func getServiceRoleForAccount(input: GetServiceRoleForAccountInput) async throws -> GetServiceRoleForAccountOutputResponse
    {
        typealias getServiceRoleForAccountContinuation = CheckedContinuation<GetServiceRoleForAccountOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getServiceRoleForAccountContinuation) in
            getServiceRoleForAccount(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves information about a subscription definition.
    func getSubscriptionDefinition(input: GetSubscriptionDefinitionInput) async throws -> GetSubscriptionDefinitionOutputResponse
    {
        typealias getSubscriptionDefinitionContinuation = CheckedContinuation<GetSubscriptionDefinitionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getSubscriptionDefinitionContinuation) in
            getSubscriptionDefinition(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves information about a subscription definition version.
    func getSubscriptionDefinitionVersion(input: GetSubscriptionDefinitionVersionInput) async throws -> GetSubscriptionDefinitionVersionOutputResponse
    {
        typealias getSubscriptionDefinitionVersionContinuation = CheckedContinuation<GetSubscriptionDefinitionVersionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getSubscriptionDefinitionVersionContinuation) in
            getSubscriptionDefinitionVersion(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Get the runtime configuration of a thing.
    func getThingRuntimeConfiguration(input: GetThingRuntimeConfigurationInput) async throws -> GetThingRuntimeConfigurationOutputResponse
    {
        typealias getThingRuntimeConfigurationContinuation = CheckedContinuation<GetThingRuntimeConfigurationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getThingRuntimeConfigurationContinuation) in
            getThingRuntimeConfiguration(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Gets a paginated list of the deployments that have been started in a bulk deployment operation, and their current deployment status.
    func listBulkDeploymentDetailedReports(input: ListBulkDeploymentDetailedReportsInput) async throws -> ListBulkDeploymentDetailedReportsOutputResponse
    {
        typealias listBulkDeploymentDetailedReportsContinuation = CheckedContinuation<ListBulkDeploymentDetailedReportsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listBulkDeploymentDetailedReportsContinuation) in
            listBulkDeploymentDetailedReports(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns a list of bulk deployments.
    func listBulkDeployments(input: ListBulkDeploymentsInput) async throws -> ListBulkDeploymentsOutputResponse
    {
        typealias listBulkDeploymentsContinuation = CheckedContinuation<ListBulkDeploymentsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listBulkDeploymentsContinuation) in
            listBulkDeployments(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Lists the versions of a connector definition, which are containers for connectors. Connectors run on the Greengrass core and contain built-in integration with local infrastructure, device protocols, AWS, and other cloud services.
    func listConnectorDefinitionVersions(input: ListConnectorDefinitionVersionsInput) async throws -> ListConnectorDefinitionVersionsOutputResponse
    {
        typealias listConnectorDefinitionVersionsContinuation = CheckedContinuation<ListConnectorDefinitionVersionsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listConnectorDefinitionVersionsContinuation) in
            listConnectorDefinitionVersions(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves a list of connector definitions.
    func listConnectorDefinitions(input: ListConnectorDefinitionsInput) async throws -> ListConnectorDefinitionsOutputResponse
    {
        typealias listConnectorDefinitionsContinuation = CheckedContinuation<ListConnectorDefinitionsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listConnectorDefinitionsContinuation) in
            listConnectorDefinitions(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Lists the versions of a core definition.
    func listCoreDefinitionVersions(input: ListCoreDefinitionVersionsInput) async throws -> ListCoreDefinitionVersionsOutputResponse
    {
        typealias listCoreDefinitionVersionsContinuation = CheckedContinuation<ListCoreDefinitionVersionsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listCoreDefinitionVersionsContinuation) in
            listCoreDefinitionVersions(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves a list of core definitions.
    func listCoreDefinitions(input: ListCoreDefinitionsInput) async throws -> ListCoreDefinitionsOutputResponse
    {
        typealias listCoreDefinitionsContinuation = CheckedContinuation<ListCoreDefinitionsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listCoreDefinitionsContinuation) in
            listCoreDefinitions(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns a history of deployments for the group.
    func listDeployments(input: ListDeploymentsInput) async throws -> ListDeploymentsOutputResponse
    {
        typealias listDeploymentsContinuation = CheckedContinuation<ListDeploymentsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listDeploymentsContinuation) in
            listDeployments(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Lists the versions of a device definition.
    func listDeviceDefinitionVersions(input: ListDeviceDefinitionVersionsInput) async throws -> ListDeviceDefinitionVersionsOutputResponse
    {
        typealias listDeviceDefinitionVersionsContinuation = CheckedContinuation<ListDeviceDefinitionVersionsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listDeviceDefinitionVersionsContinuation) in
            listDeviceDefinitionVersions(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves a list of device definitions.
    func listDeviceDefinitions(input: ListDeviceDefinitionsInput) async throws -> ListDeviceDefinitionsOutputResponse
    {
        typealias listDeviceDefinitionsContinuation = CheckedContinuation<ListDeviceDefinitionsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listDeviceDefinitionsContinuation) in
            listDeviceDefinitions(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Lists the versions of a Lambda function definition.
    func listFunctionDefinitionVersions(input: ListFunctionDefinitionVersionsInput) async throws -> ListFunctionDefinitionVersionsOutputResponse
    {
        typealias listFunctionDefinitionVersionsContinuation = CheckedContinuation<ListFunctionDefinitionVersionsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listFunctionDefinitionVersionsContinuation) in
            listFunctionDefinitionVersions(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves a list of Lambda function definitions.
    func listFunctionDefinitions(input: ListFunctionDefinitionsInput) async throws -> ListFunctionDefinitionsOutputResponse
    {
        typealias listFunctionDefinitionsContinuation = CheckedContinuation<ListFunctionDefinitionsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listFunctionDefinitionsContinuation) in
            listFunctionDefinitions(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves the current CAs for a group.
    func listGroupCertificateAuthorities(input: ListGroupCertificateAuthoritiesInput) async throws -> ListGroupCertificateAuthoritiesOutputResponse
    {
        typealias listGroupCertificateAuthoritiesContinuation = CheckedContinuation<ListGroupCertificateAuthoritiesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listGroupCertificateAuthoritiesContinuation) in
            listGroupCertificateAuthorities(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Lists the versions of a group.
    func listGroupVersions(input: ListGroupVersionsInput) async throws -> ListGroupVersionsOutputResponse
    {
        typealias listGroupVersionsContinuation = CheckedContinuation<ListGroupVersionsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listGroupVersionsContinuation) in
            listGroupVersions(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves a list of groups.
    func listGroups(input: ListGroupsInput) async throws -> ListGroupsOutputResponse
    {
        typealias listGroupsContinuation = CheckedContinuation<ListGroupsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listGroupsContinuation) in
            listGroups(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Lists the versions of a logger definition.
    func listLoggerDefinitionVersions(input: ListLoggerDefinitionVersionsInput) async throws -> ListLoggerDefinitionVersionsOutputResponse
    {
        typealias listLoggerDefinitionVersionsContinuation = CheckedContinuation<ListLoggerDefinitionVersionsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listLoggerDefinitionVersionsContinuation) in
            listLoggerDefinitionVersions(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves a list of logger definitions.
    func listLoggerDefinitions(input: ListLoggerDefinitionsInput) async throws -> ListLoggerDefinitionsOutputResponse
    {
        typealias listLoggerDefinitionsContinuation = CheckedContinuation<ListLoggerDefinitionsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listLoggerDefinitionsContinuation) in
            listLoggerDefinitions(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Lists the versions of a resource definition.
    func listResourceDefinitionVersions(input: ListResourceDefinitionVersionsInput) async throws -> ListResourceDefinitionVersionsOutputResponse
    {
        typealias listResourceDefinitionVersionsContinuation = CheckedContinuation<ListResourceDefinitionVersionsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listResourceDefinitionVersionsContinuation) in
            listResourceDefinitionVersions(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves a list of resource definitions.
    func listResourceDefinitions(input: ListResourceDefinitionsInput) async throws -> ListResourceDefinitionsOutputResponse
    {
        typealias listResourceDefinitionsContinuation = CheckedContinuation<ListResourceDefinitionsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listResourceDefinitionsContinuation) in
            listResourceDefinitions(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Lists the versions of a subscription definition.
    func listSubscriptionDefinitionVersions(input: ListSubscriptionDefinitionVersionsInput) async throws -> ListSubscriptionDefinitionVersionsOutputResponse
    {
        typealias listSubscriptionDefinitionVersionsContinuation = CheckedContinuation<ListSubscriptionDefinitionVersionsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listSubscriptionDefinitionVersionsContinuation) in
            listSubscriptionDefinitionVersions(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves a list of subscription definitions.
    func listSubscriptionDefinitions(input: ListSubscriptionDefinitionsInput) async throws -> ListSubscriptionDefinitionsOutputResponse
    {
        typealias listSubscriptionDefinitionsContinuation = CheckedContinuation<ListSubscriptionDefinitionsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listSubscriptionDefinitionsContinuation) in
            listSubscriptionDefinitions(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves a list of resource tags for a resource arn.
    func listTagsForResource(input: ListTagsForResourceInput) async throws -> ListTagsForResourceOutputResponse
    {
        typealias listTagsForResourceContinuation = CheckedContinuation<ListTagsForResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listTagsForResourceContinuation) in
            listTagsForResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Resets a group's deployments.
    func resetDeployments(input: ResetDeploymentsInput) async throws -> ResetDeploymentsOutputResponse
    {
        typealias resetDeploymentsContinuation = CheckedContinuation<ResetDeploymentsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: resetDeploymentsContinuation) in
            resetDeployments(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deploys multiple groups in one operation. This action starts the bulk deployment of a specified set of group versions. Each group version deployment will be triggered with an adaptive rate that has a fixed upper limit. We recommend that you include an ''X-Amzn-Client-Token'' token in every ''StartBulkDeployment'' request. These requests are idempotent with respect to the token and the request parameters.
    func startBulkDeployment(input: StartBulkDeploymentInput) async throws -> StartBulkDeploymentOutputResponse
    {
        typealias startBulkDeploymentContinuation = CheckedContinuation<StartBulkDeploymentOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: startBulkDeploymentContinuation) in
            startBulkDeployment(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Stops the execution of a bulk deployment. This action returns a status of ''Stopping'' until the deployment is stopped. You cannot start a new bulk deployment while a previous deployment is in the ''Stopping'' state. This action doesn't rollback completed deployments or cancel pending deployments.
    func stopBulkDeployment(input: StopBulkDeploymentInput) async throws -> StopBulkDeploymentOutputResponse
    {
        typealias stopBulkDeploymentContinuation = CheckedContinuation<StopBulkDeploymentOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: stopBulkDeploymentContinuation) in
            stopBulkDeployment(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Adds tags to a Greengrass resource. Valid resources are 'Group', 'ConnectorDefinition', 'CoreDefinition', 'DeviceDefinition', 'FunctionDefinition', 'LoggerDefinition', 'SubscriptionDefinition', 'ResourceDefinition', and 'BulkDeployment'.
    func tagResource(input: TagResourceInput) async throws -> TagResourceOutputResponse
    {
        typealias tagResourceContinuation = CheckedContinuation<TagResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: tagResourceContinuation) in
            tagResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Remove resource tags from a Greengrass Resource.
    func untagResource(input: UntagResourceInput) async throws -> UntagResourceOutputResponse
    {
        typealias untagResourceContinuation = CheckedContinuation<UntagResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: untagResourceContinuation) in
            untagResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates the connectivity information for the core. Any devices that belong to the group which has this core will receive this information in order to find the location of the core and connect to it.
    func updateConnectivityInfo(input: UpdateConnectivityInfoInput) async throws -> UpdateConnectivityInfoOutputResponse
    {
        typealias updateConnectivityInfoContinuation = CheckedContinuation<UpdateConnectivityInfoOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateConnectivityInfoContinuation) in
            updateConnectivityInfo(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates a connector definition.
    func updateConnectorDefinition(input: UpdateConnectorDefinitionInput) async throws -> UpdateConnectorDefinitionOutputResponse
    {
        typealias updateConnectorDefinitionContinuation = CheckedContinuation<UpdateConnectorDefinitionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateConnectorDefinitionContinuation) in
            updateConnectorDefinition(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates a core definition.
    func updateCoreDefinition(input: UpdateCoreDefinitionInput) async throws -> UpdateCoreDefinitionOutputResponse
    {
        typealias updateCoreDefinitionContinuation = CheckedContinuation<UpdateCoreDefinitionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateCoreDefinitionContinuation) in
            updateCoreDefinition(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates a device definition.
    func updateDeviceDefinition(input: UpdateDeviceDefinitionInput) async throws -> UpdateDeviceDefinitionOutputResponse
    {
        typealias updateDeviceDefinitionContinuation = CheckedContinuation<UpdateDeviceDefinitionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateDeviceDefinitionContinuation) in
            updateDeviceDefinition(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates a Lambda function definition.
    func updateFunctionDefinition(input: UpdateFunctionDefinitionInput) async throws -> UpdateFunctionDefinitionOutputResponse
    {
        typealias updateFunctionDefinitionContinuation = CheckedContinuation<UpdateFunctionDefinitionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateFunctionDefinitionContinuation) in
            updateFunctionDefinition(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates a group.
    func updateGroup(input: UpdateGroupInput) async throws -> UpdateGroupOutputResponse
    {
        typealias updateGroupContinuation = CheckedContinuation<UpdateGroupOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateGroupContinuation) in
            updateGroup(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates the Certificate expiry time for a group.
    func updateGroupCertificateConfiguration(input: UpdateGroupCertificateConfigurationInput) async throws -> UpdateGroupCertificateConfigurationOutputResponse
    {
        typealias updateGroupCertificateConfigurationContinuation = CheckedContinuation<UpdateGroupCertificateConfigurationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateGroupCertificateConfigurationContinuation) in
            updateGroupCertificateConfiguration(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates a logger definition.
    func updateLoggerDefinition(input: UpdateLoggerDefinitionInput) async throws -> UpdateLoggerDefinitionOutputResponse
    {
        typealias updateLoggerDefinitionContinuation = CheckedContinuation<UpdateLoggerDefinitionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateLoggerDefinitionContinuation) in
            updateLoggerDefinition(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates a resource definition.
    func updateResourceDefinition(input: UpdateResourceDefinitionInput) async throws -> UpdateResourceDefinitionOutputResponse
    {
        typealias updateResourceDefinitionContinuation = CheckedContinuation<UpdateResourceDefinitionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateResourceDefinitionContinuation) in
            updateResourceDefinition(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates a subscription definition.
    func updateSubscriptionDefinition(input: UpdateSubscriptionDefinitionInput) async throws -> UpdateSubscriptionDefinitionOutputResponse
    {
        typealias updateSubscriptionDefinitionContinuation = CheckedContinuation<UpdateSubscriptionDefinitionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateSubscriptionDefinitionContinuation) in
            updateSubscriptionDefinition(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates the runtime configuration of a thing.
    func updateThingRuntimeConfiguration(input: UpdateThingRuntimeConfigurationInput) async throws -> UpdateThingRuntimeConfigurationOutputResponse
    {
        typealias updateThingRuntimeConfigurationContinuation = CheckedContinuation<UpdateThingRuntimeConfigurationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateThingRuntimeConfigurationContinuation) in
            updateThingRuntimeConfiguration(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

}
#endif
