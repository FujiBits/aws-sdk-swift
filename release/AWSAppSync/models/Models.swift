// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessDeniedException(message: \(Swift.String(describing: message)))"}
}

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You do not have access to perform this operation on this resource.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppSyncClientTypes.AdditionalAuthenticationProvider: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType
        case lambdaAuthorizerConfig
        case openIDConnectConfig
        case userPoolConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationType = authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let lambdaAuthorizerConfig = lambdaAuthorizerConfig {
            try encodeContainer.encode(lambdaAuthorizerConfig, forKey: .lambdaAuthorizerConfig)
        }
        if let openIDConnectConfig = openIDConnectConfig {
            try encodeContainer.encode(openIDConnectConfig, forKey: .openIDConnectConfig)
        }
        if let userPoolConfig = userPoolConfig {
            try encodeContainer.encode(userPoolConfig, forKey: .userPoolConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
        let openIDConnectConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.OpenIDConnectConfig.self, forKey: .openIDConnectConfig)
        openIDConnectConfig = openIDConnectConfigDecoded
        let userPoolConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.CognitoUserPoolConfig.self, forKey: .userPoolConfig)
        userPoolConfig = userPoolConfigDecoded
        let lambdaAuthorizerConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.LambdaAuthorizerConfig.self, forKey: .lambdaAuthorizerConfig)
        lambdaAuthorizerConfig = lambdaAuthorizerConfigDecoded
    }
}

extension AppSyncClientTypes.AdditionalAuthenticationProvider: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AdditionalAuthenticationProvider(authenticationType: \(Swift.String(describing: authenticationType)), lambdaAuthorizerConfig: \(Swift.String(describing: lambdaAuthorizerConfig)), openIDConnectConfig: \(Swift.String(describing: openIDConnectConfig)), userPoolConfig: \(Swift.String(describing: userPoolConfig)))"}
}

extension AppSyncClientTypes {
    /// Describes an additional authentication provider.
    public struct AdditionalAuthenticationProvider: Swift.Equatable {
        /// The authentication type: API key, Identity and Access Management, OIDC, Amazon Cognito user
        ///          pools, or Amazon Web Services Lambda.
        public var authenticationType: AppSyncClientTypes.AuthenticationType?
        /// Configuration for Amazon Web Services Lambda function authorization.
        public var lambdaAuthorizerConfig: AppSyncClientTypes.LambdaAuthorizerConfig?
        /// The OpenID Connect configuration.
        public var openIDConnectConfig: AppSyncClientTypes.OpenIDConnectConfig?
        /// The Amazon Cognito user pool configuration.
        public var userPoolConfig: AppSyncClientTypes.CognitoUserPoolConfig?

        public init (
            authenticationType: AppSyncClientTypes.AuthenticationType? = nil,
            lambdaAuthorizerConfig: AppSyncClientTypes.LambdaAuthorizerConfig? = nil,
            openIDConnectConfig: AppSyncClientTypes.OpenIDConnectConfig? = nil,
            userPoolConfig: AppSyncClientTypes.CognitoUserPoolConfig? = nil
        )
        {
            self.authenticationType = authenticationType
            self.lambdaAuthorizerConfig = lambdaAuthorizerConfig
            self.openIDConnectConfig = openIDConnectConfig
            self.userPoolConfig = userPoolConfig
        }
    }

}

extension AppSyncClientTypes.ApiCache: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiCachingBehavior
        case atRestEncryptionEnabled
        case status
        case transitEncryptionEnabled
        case ttl
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiCachingBehavior = apiCachingBehavior {
            try encodeContainer.encode(apiCachingBehavior.rawValue, forKey: .apiCachingBehavior)
        }
        if atRestEncryptionEnabled != false {
            try encodeContainer.encode(atRestEncryptionEnabled, forKey: .atRestEncryptionEnabled)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if transitEncryptionEnabled != false {
            try encodeContainer.encode(transitEncryptionEnabled, forKey: .transitEncryptionEnabled)
        }
        if ttl != 0 {
            try encodeContainer.encode(ttl, forKey: .ttl)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ttlDecoded = try containerValues.decode(Swift.Int.self, forKey: .ttl)
        ttl = ttlDecoded
        let apiCachingBehaviorDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ApiCachingBehavior.self, forKey: .apiCachingBehavior)
        apiCachingBehavior = apiCachingBehaviorDecoded
        let transitEncryptionEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .transitEncryptionEnabled)
        transitEncryptionEnabled = transitEncryptionEnabledDecoded
        let atRestEncryptionEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .atRestEncryptionEnabled)
        atRestEncryptionEnabled = atRestEncryptionEnabledDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ApiCacheType.self, forKey: .type)
        type = typeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ApiCacheStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension AppSyncClientTypes.ApiCache: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ApiCache(apiCachingBehavior: \(Swift.String(describing: apiCachingBehavior)), atRestEncryptionEnabled: \(Swift.String(describing: atRestEncryptionEnabled)), status: \(Swift.String(describing: status)), transitEncryptionEnabled: \(Swift.String(describing: transitEncryptionEnabled)), ttl: \(Swift.String(describing: ttl)), type: \(Swift.String(describing: type)))"}
}

extension AppSyncClientTypes {
    /// The ApiCache object.
    public struct ApiCache: Swift.Equatable {
        /// Caching behavior.
        ///
        ///
        ///
        ///                   FULL_REQUEST_CACHING: All requests are fully
        ///                cached.
        ///
        ///
        ///
        ///                   PER_RESOLVER_CACHING: Individual resolvers
        ///                that you specify are cached.
        ///
        ///
        public var apiCachingBehavior: AppSyncClientTypes.ApiCachingBehavior?
        /// At rest encryption flag for cache. This setting cannot be updated after creation.
        public var atRestEncryptionEnabled: Swift.Bool
        /// The cache instance status.
        ///
        ///
        ///
        ///                   AVAILABLE: The instance is available for
        ///                use.
        ///
        ///
        ///
        ///                   CREATING: The instance is currently
        ///                creating.
        ///
        ///
        ///
        ///                   DELETING: The instance is currently
        ///                deleting.
        ///
        ///
        ///
        ///                   MODIFYING: The instance is currently
        ///                modifying.
        ///
        ///
        ///
        ///                   FAILED: The instance has failed
        ///                creation.
        ///
        ///
        public var status: AppSyncClientTypes.ApiCacheStatus?
        /// Transit encryption flag when connecting to cache. This setting cannot be updated after
        ///          creation.
        public var transitEncryptionEnabled: Swift.Bool
        /// TTL in seconds for cache entries.
        ///          Valid values are between 1 and 3600 seconds.
        public var ttl: Swift.Int
        /// The cache instance type. Valid values are
        ///
        ///
        ///
        ///                   SMALL
        ///
        ///
        ///
        ///
        ///                   MEDIUM
        ///
        ///
        ///
        ///
        ///                   LARGE
        ///
        ///
        ///
        ///
        ///                   XLARGE
        ///
        ///
        ///
        ///
        ///                   LARGE_2X
        ///
        ///
        ///
        ///
        ///                   LARGE_4X
        ///
        ///
        ///
        ///
        ///                   LARGE_8X (not available in all regions)
        ///
        ///
        ///
        ///                   LARGE_12X
        ///
        ///
        ///
        ///          Historically, instance types were identified by an EC2-style value. As of July 2020, this is deprecated, and the generic identifiers above should be used.
        ///          The following legacy instance types are available, but their use is discouraged:
        ///
        ///
        ///
        ///                   T2_SMALL: A t2.small instance type.
        ///
        ///
        ///
        ///                   T2_MEDIUM: A t2.medium instance type.
        ///
        ///
        ///
        ///                   R4_LARGE: A r4.large instance type.
        ///
        ///
        ///
        ///                   R4_XLARGE: A r4.xlarge instance type.
        ///
        ///
        ///
        ///                   R4_2XLARGE: A r4.2xlarge instance type.
        ///
        ///
        ///
        ///                   R4_4XLARGE: A r4.4xlarge instance type.
        ///
        ///
        ///
        ///                   R4_8XLARGE: A r4.8xlarge instance type.
        ///
        ///
        public var type: AppSyncClientTypes.ApiCacheType?

        public init (
            apiCachingBehavior: AppSyncClientTypes.ApiCachingBehavior? = nil,
            atRestEncryptionEnabled: Swift.Bool = false,
            status: AppSyncClientTypes.ApiCacheStatus? = nil,
            transitEncryptionEnabled: Swift.Bool = false,
            ttl: Swift.Int = 0,
            type: AppSyncClientTypes.ApiCacheType? = nil
        )
        {
            self.apiCachingBehavior = apiCachingBehavior
            self.atRestEncryptionEnabled = atRestEncryptionEnabled
            self.status = status
            self.transitEncryptionEnabled = transitEncryptionEnabled
            self.ttl = ttl
            self.type = type
        }
    }

}

extension AppSyncClientTypes {
    public enum ApiCacheStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case creating
        case deleting
        case failed
        case modifying
        case sdkUnknown(Swift.String)

        public static var allCases: [ApiCacheStatus] {
            return [
                .available,
                .creating,
                .deleting,
                .failed,
                .modifying,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .modifying: return "MODIFYING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApiCacheStatus(rawValue: rawValue) ?? ApiCacheStatus.sdkUnknown(rawValue)
        }
    }
}

extension AppSyncClientTypes {
    public enum ApiCacheType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case large
        case large12x
        case large2x
        case large4x
        case large8x
        case medium
        case r42xlarge
        case r44xlarge
        case r48xlarge
        case r4Large
        case r4Xlarge
        case small
        case t2Medium
        case t2Small
        case xlarge
        case sdkUnknown(Swift.String)

        public static var allCases: [ApiCacheType] {
            return [
                .large,
                .large12x,
                .large2x,
                .large4x,
                .large8x,
                .medium,
                .r42xlarge,
                .r44xlarge,
                .r48xlarge,
                .r4Large,
                .r4Xlarge,
                .small,
                .t2Medium,
                .t2Small,
                .xlarge,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .large: return "LARGE"
            case .large12x: return "LARGE_12X"
            case .large2x: return "LARGE_2X"
            case .large4x: return "LARGE_4X"
            case .large8x: return "LARGE_8X"
            case .medium: return "MEDIUM"
            case .r42xlarge: return "R4_2XLARGE"
            case .r44xlarge: return "R4_4XLARGE"
            case .r48xlarge: return "R4_8XLARGE"
            case .r4Large: return "R4_LARGE"
            case .r4Xlarge: return "R4_XLARGE"
            case .small: return "SMALL"
            case .t2Medium: return "T2_MEDIUM"
            case .t2Small: return "T2_SMALL"
            case .xlarge: return "XLARGE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApiCacheType(rawValue: rawValue) ?? ApiCacheType.sdkUnknown(rawValue)
        }
    }
}

extension AppSyncClientTypes {
    public enum ApiCachingBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fullRequestCaching
        case perResolverCaching
        case sdkUnknown(Swift.String)

        public static var allCases: [ApiCachingBehavior] {
            return [
                .fullRequestCaching,
                .perResolverCaching,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fullRequestCaching: return "FULL_REQUEST_CACHING"
            case .perResolverCaching: return "PER_RESOLVER_CACHING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApiCachingBehavior(rawValue: rawValue) ?? ApiCachingBehavior.sdkUnknown(rawValue)
        }
    }
}

extension AppSyncClientTypes.ApiKey: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletes
        case description
        case expires
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if deletes != 0 {
            try encodeContainer.encode(deletes, forKey: .deletes)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if expires != 0 {
            try encodeContainer.encode(expires, forKey: .expires)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let expiresDecoded = try containerValues.decode(Swift.Int.self, forKey: .expires)
        expires = expiresDecoded
        let deletesDecoded = try containerValues.decode(Swift.Int.self, forKey: .deletes)
        deletes = deletesDecoded
    }
}

extension AppSyncClientTypes.ApiKey: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ApiKey(deletes: \(Swift.String(describing: deletes)), description: \(Swift.String(describing: description)), expires: \(Swift.String(describing: expires)), id: \(Swift.String(describing: id)))"}
}

extension AppSyncClientTypes {
    /// Describes an API key.
    ///          Customers invoke AppSync GraphQL API operations with API keys as an
    ///          identity mechanism. There are two key versions:
    ///
    ///             da1: This version was introduced at launch in November
    ///          2017. These keys always expire after 7 days. Key expiration is managed by Amazon DynamoDB
    ///          TTL. The keys ceased to be valid after February 21, 2018 and should not be used after that
    ///          date.
    ///
    ///
    ///
    ///                   ListApiKeys returns the expiration time in milliseconds.
    ///
    ///
    ///
    ///                   CreateApiKey returns the expiration time in
    ///                milliseconds.
    ///
    ///
    ///
    ///                   UpdateApiKey is not available for this key version.
    ///
    ///
    ///
    ///                   DeleteApiKey deletes the item from the table.
    ///
    ///
    ///                Expiration is stored in Amazon DynamoDB as milliseconds. This results in a bug
    ///                where keys are not automatically deleted because DynamoDB expects the TTL to be
    ///                stored in seconds. As a one-time action, we will delete these keys from the table
    ///                after February 21, 2018.
    ///
    ///
    ///
    ///             da2: This version was introduced in February 2018 when
    ///          AppSync added support to extend key expiration.
    ///
    ///
    ///
    ///                   ListApiKeys returns the expiration time and deletion time in
    ///                seconds.
    ///
    ///
    ///
    ///                   CreateApiKey returns the expiration time and deletion time in
    ///                seconds and accepts a user-provided expiration time in seconds.
    ///
    ///
    ///
    ///                   UpdateApiKey returns the expiration time and and deletion time in
    ///                seconds and accepts a user-provided expiration time in seconds. Expired API keys are
    ///                kept for 60 days after the expiration time. Key expiration time can be updated while
    ///                the key is not deleted.
    ///
    ///
    ///
    ///                   DeleteApiKey deletes the item from the table.
    ///
    ///
    ///                Expiration is stored in Amazon DynamoDB as seconds. After the expiration time,
    ///                using the key to authenticate will fail. But the key can be reinstated before
    ///                deletion.
    ///
    ///
    ///                Deletion is stored in Amazon DynamoDB as seconds. The key will be deleted after
    ///                deletion time.
    ///
    ///
    public struct ApiKey: Swift.Equatable {
        /// The time after which the API key is deleted. The date is represented as seconds since
        ///          the epoch, rounded down to the nearest hour.
        public var deletes: Swift.Int
        /// A description of the purpose of the API key.
        public var description: Swift.String?
        /// The time after which the API key expires. The date is represented as seconds since the
        ///          epoch, rounded down to the nearest hour.
        public var expires: Swift.Int
        /// The API key ID.
        public var id: Swift.String?

        public init (
            deletes: Swift.Int = 0,
            description: Swift.String? = nil,
            expires: Swift.Int = 0,
            id: Swift.String? = nil
        )
        {
            self.deletes = deletes
            self.description = description
            self.expires = expires
            self.id = id
        }
    }

}

extension ApiKeyLimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ApiKeyLimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension ApiKeyLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ApiKeyLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The API key exceeded a limit. Try your request again.
public struct ApiKeyLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ApiKeyLimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ApiKeyLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApiKeyValidityOutOfBoundsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ApiKeyValidityOutOfBoundsException(message: \(Swift.String(describing: message)))"}
}

extension ApiKeyValidityOutOfBoundsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ApiKeyValidityOutOfBoundsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The API key expiration must be set to a value between 1 and 365 days from creation (for
///             CreateApiKey) or from update (for UpdateApiKey).
public struct ApiKeyValidityOutOfBoundsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ApiKeyValidityOutOfBoundsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ApiKeyValidityOutOfBoundsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApiLimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ApiLimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension ApiLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ApiLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The GraphQL API exceeded a limit. Try your request again.
public struct ApiLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ApiLimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ApiLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppSyncClientTypes {
    public enum AuthenticationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case amazonCognitoUserPools
        case apiKey
        case awsIam
        case awsLambda
        case openidConnect
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthenticationType] {
            return [
                .amazonCognitoUserPools,
                .apiKey,
                .awsIam,
                .awsLambda,
                .openidConnect,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amazonCognitoUserPools: return "AMAZON_COGNITO_USER_POOLS"
            case .apiKey: return "API_KEY"
            case .awsIam: return "AWS_IAM"
            case .awsLambda: return "AWS_LAMBDA"
            case .openidConnect: return "OPENID_CONNECT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthenticationType(rawValue: rawValue) ?? AuthenticationType.sdkUnknown(rawValue)
        }
    }
}

extension AppSyncClientTypes.AuthorizationConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizationType
        case awsIamConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizationType = authorizationType {
            try encodeContainer.encode(authorizationType.rawValue, forKey: .authorizationType)
        }
        if let awsIamConfig = awsIamConfig {
            try encodeContainer.encode(awsIamConfig, forKey: .awsIamConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizationTypeDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.AuthorizationType.self, forKey: .authorizationType)
        authorizationType = authorizationTypeDecoded
        let awsIamConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.AwsIamConfig.self, forKey: .awsIamConfig)
        awsIamConfig = awsIamConfigDecoded
    }
}

extension AppSyncClientTypes.AuthorizationConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AuthorizationConfig(authorizationType: \(Swift.String(describing: authorizationType)), awsIamConfig: \(Swift.String(describing: awsIamConfig)))"}
}

extension AppSyncClientTypes {
    /// The authorization config in case the HTTP endpoint requires authorization.
    public struct AuthorizationConfig: Swift.Equatable {
        /// The authorization type required by the HTTP endpoint.
        ///
        ///
        ///
        ///                   AWS_IAM: The authorization type is
        ///                Sigv4.
        ///
        ///
        /// This member is required.
        public var authorizationType: AppSyncClientTypes.AuthorizationType?
        /// The Identity and Access Management settings.
        public var awsIamConfig: AppSyncClientTypes.AwsIamConfig?

        public init (
            authorizationType: AppSyncClientTypes.AuthorizationType? = nil,
            awsIamConfig: AppSyncClientTypes.AwsIamConfig? = nil
        )
        {
            self.authorizationType = authorizationType
            self.awsIamConfig = awsIamConfig
        }
    }

}

extension AppSyncClientTypes {
    public enum AuthorizationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsIam
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthorizationType] {
            return [
                .awsIam,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsIam: return "AWS_IAM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthorizationType(rawValue: rawValue) ?? AuthorizationType.sdkUnknown(rawValue)
        }
    }
}

extension AppSyncClientTypes.AwsIamConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case signingRegion
        case signingServiceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let signingRegion = signingRegion {
            try encodeContainer.encode(signingRegion, forKey: .signingRegion)
        }
        if let signingServiceName = signingServiceName {
            try encodeContainer.encode(signingServiceName, forKey: .signingServiceName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let signingRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingRegion)
        signingRegion = signingRegionDecoded
        let signingServiceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingServiceName)
        signingServiceName = signingServiceNameDecoded
    }
}

extension AppSyncClientTypes.AwsIamConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AwsIamConfig(signingRegion: \(Swift.String(describing: signingRegion)), signingServiceName: \(Swift.String(describing: signingServiceName)))"}
}

extension AppSyncClientTypes {
    /// The Identity and Access Management configuration.
    public struct AwsIamConfig: Swift.Equatable {
        /// The signing region for Identity and Access Management authorization.
        public var signingRegion: Swift.String?
        /// The signing service name for Identity and Access Management authorization.
        public var signingServiceName: Swift.String?

        public init (
            signingRegion: Swift.String? = nil,
            signingServiceName: Swift.String? = nil
        )
        {
            self.signingRegion = signingRegion
            self.signingServiceName = signingServiceName
        }
    }

}

extension BadRequestException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BadRequestException(message: \(Swift.String(describing: message)))"}
}

extension BadRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request is not well formed. For example, a value is invalid or a required field is
///          missing. Check the field values, and then try again.
public struct BadRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppSyncClientTypes.CachingConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachingKeys
        case ttl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cachingKeys = cachingKeys {
            var cachingKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cachingKeys)
            for cachingkeys0 in cachingKeys {
                try cachingKeysContainer.encode(cachingkeys0)
            }
        }
        if ttl != 0 {
            try encodeContainer.encode(ttl, forKey: .ttl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ttlDecoded = try containerValues.decode(Swift.Int.self, forKey: .ttl)
        ttl = ttlDecoded
        let cachingKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cachingKeys)
        var cachingKeysDecoded0:[Swift.String]? = nil
        if let cachingKeysContainer = cachingKeysContainer {
            cachingKeysDecoded0 = [Swift.String]()
            for string0 in cachingKeysContainer {
                if let string0 = string0 {
                    cachingKeysDecoded0?.append(string0)
                }
            }
        }
        cachingKeys = cachingKeysDecoded0
    }
}

extension AppSyncClientTypes.CachingConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CachingConfig(cachingKeys: \(Swift.String(describing: cachingKeys)), ttl: \(Swift.String(describing: ttl)))"}
}

extension AppSyncClientTypes {
    /// The caching configuration for a resolver that has caching enabled.
    public struct CachingConfig: Swift.Equatable {
        /// The caching keys for a resolver that has caching enabled.
        ///          Valid values are entries from the $context.arguments,
        ///             $context.source, and $context.identity maps.
        public var cachingKeys: [Swift.String]?
        /// The TTL in seconds for a resolver that has caching enabled.
        ///          Valid values are between 1 and 3600 seconds.
        public var ttl: Swift.Int

        public init (
            cachingKeys: [Swift.String]? = nil,
            ttl: Swift.Int = 0
        )
        {
            self.cachingKeys = cachingKeys
            self.ttl = ttl
        }
    }

}

extension AppSyncClientTypes.CognitoUserPoolConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appIdClientRegex
        case awsRegion
        case userPoolId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appIdClientRegex = appIdClientRegex {
            try encodeContainer.encode(appIdClientRegex, forKey: .appIdClientRegex)
        }
        if let awsRegion = awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let appIdClientRegexDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appIdClientRegex)
        appIdClientRegex = appIdClientRegexDecoded
    }
}

extension AppSyncClientTypes.CognitoUserPoolConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CognitoUserPoolConfig(appIdClientRegex: \(Swift.String(describing: appIdClientRegex)), awsRegion: \(Swift.String(describing: awsRegion)), userPoolId: \(Swift.String(describing: userPoolId)))"}
}

extension AppSyncClientTypes {
    /// Describes an Amazon Cognito user pool configuration.
    public struct CognitoUserPoolConfig: Swift.Equatable {
        /// A regular expression for validating the incoming Amazon Cognito user pool app client
        ///          ID.
        public var appIdClientRegex: Swift.String?
        /// The Amazon Web Services Region in which the user pool was created.
        /// This member is required.
        public var awsRegion: Swift.String?
        /// The user pool ID.
        /// This member is required.
        public var userPoolId: Swift.String?

        public init (
            appIdClientRegex: Swift.String? = nil,
            awsRegion: Swift.String? = nil,
            userPoolId: Swift.String? = nil
        )
        {
            self.appIdClientRegex = appIdClientRegex
            self.awsRegion = awsRegion
            self.userPoolId = userPoolId
        }
    }

}

extension ConcurrentModificationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConcurrentModificationException(message: \(Swift.String(describing: message)))"}
}

extension ConcurrentModificationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConcurrentModificationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Another modification is in progress at this time and it must complete before you can
///          make your change.
public struct ConcurrentModificationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentModificationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ConcurrentModificationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppSyncClientTypes {
    public enum ConflictDetectionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `none`
        case version
        case sdkUnknown(Swift.String)

        public static var allCases: [ConflictDetectionType] {
            return [
                .none,
                .version,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .none: return "NONE"
            case .version: return "VERSION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConflictDetectionType(rawValue: rawValue) ?? ConflictDetectionType.sdkUnknown(rawValue)
        }
    }
}

extension AppSyncClientTypes {
    public enum ConflictHandlerType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case automerge
        case lambda
        case `none`
        case optimisticConcurrency
        case sdkUnknown(Swift.String)

        public static var allCases: [ConflictHandlerType] {
            return [
                .automerge,
                .lambda,
                .none,
                .optimisticConcurrency,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .automerge: return "AUTOMERGE"
            case .lambda: return "LAMBDA"
            case .none: return "NONE"
            case .optimisticConcurrency: return "OPTIMISTIC_CONCURRENCY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConflictHandlerType(rawValue: rawValue) ?? ConflictHandlerType.sdkUnknown(rawValue)
        }
    }
}

public struct CreateApiCacheInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateApiCacheInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateApiCacheInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateApiCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateApiCacheInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateApiCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateApiCacheOutputError>
}

extension CreateApiCacheInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateApiCacheInput(apiCachingBehavior: \(Swift.String(describing: apiCachingBehavior)), apiId: \(Swift.String(describing: apiId)), atRestEncryptionEnabled: \(Swift.String(describing: atRestEncryptionEnabled)), transitEncryptionEnabled: \(Swift.String(describing: transitEncryptionEnabled)), ttl: \(Swift.String(describing: ttl)), type: \(Swift.String(describing: type)))"}
}

extension CreateApiCacheInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiCachingBehavior
        case atRestEncryptionEnabled
        case transitEncryptionEnabled
        case ttl
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiCachingBehavior = apiCachingBehavior {
            try encodeContainer.encode(apiCachingBehavior.rawValue, forKey: .apiCachingBehavior)
        }
        if atRestEncryptionEnabled != false {
            try encodeContainer.encode(atRestEncryptionEnabled, forKey: .atRestEncryptionEnabled)
        }
        if transitEncryptionEnabled != false {
            try encodeContainer.encode(transitEncryptionEnabled, forKey: .transitEncryptionEnabled)
        }
        if ttl != 0 {
            try encodeContainer.encode(ttl, forKey: .ttl)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct CreateApiCacheInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateApiCacheInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateApiCacheInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateApiCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateApiCacheInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateApiCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateApiCacheOutputError>
}

public struct CreateApiCacheInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateApiCacheInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateApiCacheInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateApiCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateApiCacheInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateApiCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateApiCacheOutputError>
}

public struct CreateApiCacheInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateApiCacheInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateApiCacheInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateApiCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let apiId = input.apiId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("apiId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/v1/apis/\(apiId.urlPercentEncoding())/ApiCaches"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateApiCacheInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateApiCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateApiCacheOutputError>
}

/// Represents the input of a CreateApiCache operation.
public struct CreateApiCacheInput: Swift.Equatable {
    /// Caching behavior.
    ///
    ///
    ///
    ///                   FULL_REQUEST_CACHING: All requests are fully
    ///                cached.
    ///
    ///
    ///
    ///                   PER_RESOLVER_CACHING: Individual resolvers
    ///                that you specify are cached.
    ///
    ///
    /// This member is required.
    public var apiCachingBehavior: AppSyncClientTypes.ApiCachingBehavior?
    /// The GraphQL API Id.
    /// This member is required.
    public var apiId: Swift.String?
    /// At rest encryption flag for cache. This setting cannot be updated after creation.
    public var atRestEncryptionEnabled: Swift.Bool
    /// Transit encryption flag when connecting to cache. This setting cannot be updated after
    ///          creation.
    public var transitEncryptionEnabled: Swift.Bool
    /// TTL in seconds for cache entries.
    ///          Valid values are between 1 and 3600 seconds.
    /// This member is required.
    public var ttl: Swift.Int
    /// The cache instance type. Valid values are
    ///
    ///
    ///
    ///                   SMALL
    ///
    ///
    ///
    ///
    ///                   MEDIUM
    ///
    ///
    ///
    ///
    ///                   LARGE
    ///
    ///
    ///
    ///
    ///                   XLARGE
    ///
    ///
    ///
    ///
    ///                   LARGE_2X
    ///
    ///
    ///
    ///
    ///                   LARGE_4X
    ///
    ///
    ///
    ///
    ///                   LARGE_8X (not available in all regions)
    ///
    ///
    ///
    ///                   LARGE_12X
    ///
    ///
    ///
    ///          Historically, instance types were identified by an EC2-style value. As of July 2020, this is deprecated, and the generic identifiers above should be used.
    ///          The following legacy instance types are available, but their use is discouraged:
    ///
    ///
    ///
    ///                   T2_SMALL: A t2.small instance type.
    ///
    ///
    ///
    ///                   T2_MEDIUM: A t2.medium instance type.
    ///
    ///
    ///
    ///                   R4_LARGE: A r4.large instance type.
    ///
    ///
    ///
    ///                   R4_XLARGE: A r4.xlarge instance type.
    ///
    ///
    ///
    ///                   R4_2XLARGE: A r4.2xlarge instance type.
    ///
    ///
    ///
    ///                   R4_4XLARGE: A r4.4xlarge instance type.
    ///
    ///
    ///
    ///                   R4_8XLARGE: A r4.8xlarge instance type.
    ///
    ///
    /// This member is required.
    public var type: AppSyncClientTypes.ApiCacheType?

    public init (
        apiCachingBehavior: AppSyncClientTypes.ApiCachingBehavior? = nil,
        apiId: Swift.String? = nil,
        atRestEncryptionEnabled: Swift.Bool = false,
        transitEncryptionEnabled: Swift.Bool = false,
        ttl: Swift.Int = 0,
        type: AppSyncClientTypes.ApiCacheType? = nil
    )
    {
        self.apiCachingBehavior = apiCachingBehavior
        self.apiId = apiId
        self.atRestEncryptionEnabled = atRestEncryptionEnabled
        self.transitEncryptionEnabled = transitEncryptionEnabled
        self.ttl = ttl
        self.type = type
    }
}

struct CreateApiCacheInputBody: Swift.Equatable {
    public let ttl: Swift.Int
    public let transitEncryptionEnabled: Swift.Bool
    public let atRestEncryptionEnabled: Swift.Bool
    public let apiCachingBehavior: AppSyncClientTypes.ApiCachingBehavior?
    public let type: AppSyncClientTypes.ApiCacheType?
}

extension CreateApiCacheInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiCachingBehavior
        case atRestEncryptionEnabled
        case transitEncryptionEnabled
        case ttl
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ttlDecoded = try containerValues.decode(Swift.Int.self, forKey: .ttl)
        ttl = ttlDecoded
        let transitEncryptionEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .transitEncryptionEnabled)
        transitEncryptionEnabled = transitEncryptionEnabledDecoded
        let atRestEncryptionEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .atRestEncryptionEnabled)
        atRestEncryptionEnabled = atRestEncryptionEnabledDecoded
        let apiCachingBehaviorDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ApiCachingBehavior.self, forKey: .apiCachingBehavior)
        apiCachingBehavior = apiCachingBehaviorDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ApiCacheType.self, forKey: .type)
        type = typeDecoded
    }
}

extension CreateApiCacheOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateApiCacheOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateApiCacheOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateApiCacheOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateApiCacheOutputResponse(apiCache: \(Swift.String(describing: apiCache)))"}
}

extension CreateApiCacheOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateApiCacheOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiCache = output.apiCache
        } else {
            self.apiCache = nil
        }
    }
}

/// Represents the output of a CreateApiCache operation.
public struct CreateApiCacheOutputResponse: Swift.Equatable {
    /// The ApiCache object.
    public var apiCache: AppSyncClientTypes.ApiCache?

    public init (
        apiCache: AppSyncClientTypes.ApiCache? = nil
    )
    {
        self.apiCache = apiCache
    }
}

struct CreateApiCacheOutputResponseBody: Swift.Equatable {
    public let apiCache: AppSyncClientTypes.ApiCache?
}

extension CreateApiCacheOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiCache
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiCacheDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ApiCache.self, forKey: .apiCache)
        apiCache = apiCacheDecoded
    }
}

public struct CreateApiKeyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateApiKeyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateApiKeyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateApiKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateApiKeyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateApiKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateApiKeyOutputError>
}

extension CreateApiKeyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateApiKeyInput(apiId: \(Swift.String(describing: apiId)), description: \(Swift.String(describing: description)), expires: \(Swift.String(describing: expires)))"}
}

extension CreateApiKeyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case expires
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if expires != 0 {
            try encodeContainer.encode(expires, forKey: .expires)
        }
    }
}

public struct CreateApiKeyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateApiKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateApiKeyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateApiKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateApiKeyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateApiKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateApiKeyOutputError>
}

public struct CreateApiKeyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateApiKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateApiKeyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateApiKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateApiKeyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateApiKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateApiKeyOutputError>
}

public struct CreateApiKeyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateApiKeyInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateApiKeyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateApiKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let apiId = input.apiId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("apiId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/v1/apis/\(apiId.urlPercentEncoding())/apikeys"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateApiKeyInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateApiKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateApiKeyOutputError>
}

public struct CreateApiKeyInput: Swift.Equatable {
    /// The ID for your GraphQL API.
    /// This member is required.
    public var apiId: Swift.String?
    /// A description of the purpose of the API key.
    public var description: Swift.String?
    /// The time from creation time after which the API key expires. The date is represented as
    ///          seconds since the epoch, rounded down to the nearest hour. The default value for this
    ///          parameter is 7 days from creation time. For more information, see .
    public var expires: Swift.Int

    public init (
        apiId: Swift.String? = nil,
        description: Swift.String? = nil,
        expires: Swift.Int = 0
    )
    {
        self.apiId = apiId
        self.description = description
        self.expires = expires
    }
}

struct CreateApiKeyInputBody: Swift.Equatable {
    public let description: Swift.String?
    public let expires: Swift.Int
}

extension CreateApiKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case expires
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let expiresDecoded = try containerValues.decode(Swift.Int.self, forKey: .expires)
        expires = expiresDecoded
    }
}

extension CreateApiKeyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateApiKeyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ApiKeyLimitExceededException" : self = .apiKeyLimitExceededException(try ApiKeyLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ApiKeyValidityOutOfBoundsException" : self = .apiKeyValidityOutOfBoundsException(try ApiKeyValidityOutOfBoundsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateApiKeyOutputError: Swift.Error, Swift.Equatable {
    case apiKeyLimitExceededException(ApiKeyLimitExceededException)
    case apiKeyValidityOutOfBoundsException(ApiKeyValidityOutOfBoundsException)
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateApiKeyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateApiKeyOutputResponse(apiKey: \(Swift.String(describing: apiKey)))"}
}

extension CreateApiKeyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateApiKeyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiKey = output.apiKey
        } else {
            self.apiKey = nil
        }
    }
}

public struct CreateApiKeyOutputResponse: Swift.Equatable {
    /// The API key.
    public var apiKey: AppSyncClientTypes.ApiKey?

    public init (
        apiKey: AppSyncClientTypes.ApiKey? = nil
    )
    {
        self.apiKey = apiKey
    }
}

struct CreateApiKeyOutputResponseBody: Swift.Equatable {
    public let apiKey: AppSyncClientTypes.ApiKey?
}

extension CreateApiKeyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKey
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiKeyDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ApiKey.self, forKey: .apiKey)
        apiKey = apiKeyDecoded
    }
}

public struct CreateDataSourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDataSourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDataSourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDataSourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDataSourceOutputError>
}

extension CreateDataSourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDataSourceInput(apiId: \(Swift.String(describing: apiId)), description: \(Swift.String(describing: description)), dynamodbConfig: \(Swift.String(describing: dynamodbConfig)), elasticsearchConfig: \(Swift.String(describing: elasticsearchConfig)), httpConfig: \(Swift.String(describing: httpConfig)), lambdaConfig: \(Swift.String(describing: lambdaConfig)), name: \(Swift.String(describing: name)), openSearchServiceConfig: \(Swift.String(describing: openSearchServiceConfig)), relationalDatabaseConfig: \(Swift.String(describing: relationalDatabaseConfig)), serviceRoleArn: \(Swift.String(describing: serviceRoleArn)), type: \(Swift.String(describing: type)))"}
}

extension CreateDataSourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case dynamodbConfig
        case elasticsearchConfig
        case httpConfig
        case lambdaConfig
        case name
        case openSearchServiceConfig
        case relationalDatabaseConfig
        case serviceRoleArn
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let dynamodbConfig = dynamodbConfig {
            try encodeContainer.encode(dynamodbConfig, forKey: .dynamodbConfig)
        }
        if let elasticsearchConfig = elasticsearchConfig {
            try encodeContainer.encode(elasticsearchConfig, forKey: .elasticsearchConfig)
        }
        if let httpConfig = httpConfig {
            try encodeContainer.encode(httpConfig, forKey: .httpConfig)
        }
        if let lambdaConfig = lambdaConfig {
            try encodeContainer.encode(lambdaConfig, forKey: .lambdaConfig)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let openSearchServiceConfig = openSearchServiceConfig {
            try encodeContainer.encode(openSearchServiceConfig, forKey: .openSearchServiceConfig)
        }
        if let relationalDatabaseConfig = relationalDatabaseConfig {
            try encodeContainer.encode(relationalDatabaseConfig, forKey: .relationalDatabaseConfig)
        }
        if let serviceRoleArn = serviceRoleArn {
            try encodeContainer.encode(serviceRoleArn, forKey: .serviceRoleArn)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct CreateDataSourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDataSourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDataSourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDataSourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDataSourceOutputError>
}

public struct CreateDataSourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDataSourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDataSourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDataSourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDataSourceOutputError>
}

public struct CreateDataSourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDataSourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateDataSourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let apiId = input.apiId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("apiId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/v1/apis/\(apiId.urlPercentEncoding())/datasources"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateDataSourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDataSourceOutputError>
}

public struct CreateDataSourceInput: Swift.Equatable {
    /// The API ID for the GraphQL API for the DataSource.
    /// This member is required.
    public var apiId: Swift.String?
    /// A description of the DataSource.
    public var description: Swift.String?
    /// Amazon DynamoDB settings.
    public var dynamodbConfig: AppSyncClientTypes.DynamodbDataSourceConfig?
    /// Amazon OpenSearch Service settings.
    ///          As of September 2021, Amazon Elasticsearch service is Amazon OpenSearch Service. This
    ///          configuration is deprecated. For new data sources, use CreateDataSourceRequest$openSearchServiceConfig to create an OpenSearch data source.
    public var elasticsearchConfig: AppSyncClientTypes.ElasticsearchDataSourceConfig?
    /// HTTP endpoint settings.
    public var httpConfig: AppSyncClientTypes.HttpDataSourceConfig?
    /// Amazon Web Services Lambda settings.
    public var lambdaConfig: AppSyncClientTypes.LambdaDataSourceConfig?
    /// A user-supplied name for the DataSource.
    /// This member is required.
    public var name: Swift.String?
    /// Amazon OpenSearch Service settings.
    public var openSearchServiceConfig: AppSyncClientTypes.OpenSearchServiceDataSourceConfig?
    /// Relational database settings.
    public var relationalDatabaseConfig: AppSyncClientTypes.RelationalDatabaseDataSourceConfig?
    /// The Identity and Access Management service role ARN for the data source. The system assumes this
    ///          role when accessing the data source.
    public var serviceRoleArn: Swift.String?
    /// The type of the DataSource.
    /// This member is required.
    public var type: AppSyncClientTypes.DataSourceType?

    public init (
        apiId: Swift.String? = nil,
        description: Swift.String? = nil,
        dynamodbConfig: AppSyncClientTypes.DynamodbDataSourceConfig? = nil,
        elasticsearchConfig: AppSyncClientTypes.ElasticsearchDataSourceConfig? = nil,
        httpConfig: AppSyncClientTypes.HttpDataSourceConfig? = nil,
        lambdaConfig: AppSyncClientTypes.LambdaDataSourceConfig? = nil,
        name: Swift.String? = nil,
        openSearchServiceConfig: AppSyncClientTypes.OpenSearchServiceDataSourceConfig? = nil,
        relationalDatabaseConfig: AppSyncClientTypes.RelationalDatabaseDataSourceConfig? = nil,
        serviceRoleArn: Swift.String? = nil,
        type: AppSyncClientTypes.DataSourceType? = nil
    )
    {
        self.apiId = apiId
        self.description = description
        self.dynamodbConfig = dynamodbConfig
        self.elasticsearchConfig = elasticsearchConfig
        self.httpConfig = httpConfig
        self.lambdaConfig = lambdaConfig
        self.name = name
        self.openSearchServiceConfig = openSearchServiceConfig
        self.relationalDatabaseConfig = relationalDatabaseConfig
        self.serviceRoleArn = serviceRoleArn
        self.type = type
    }
}

struct CreateDataSourceInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let description: Swift.String?
    public let type: AppSyncClientTypes.DataSourceType?
    public let serviceRoleArn: Swift.String?
    public let dynamodbConfig: AppSyncClientTypes.DynamodbDataSourceConfig?
    public let lambdaConfig: AppSyncClientTypes.LambdaDataSourceConfig?
    public let elasticsearchConfig: AppSyncClientTypes.ElasticsearchDataSourceConfig?
    public let openSearchServiceConfig: AppSyncClientTypes.OpenSearchServiceDataSourceConfig?
    public let httpConfig: AppSyncClientTypes.HttpDataSourceConfig?
    public let relationalDatabaseConfig: AppSyncClientTypes.RelationalDatabaseDataSourceConfig?
}

extension CreateDataSourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case dynamodbConfig
        case elasticsearchConfig
        case httpConfig
        case lambdaConfig
        case name
        case openSearchServiceConfig
        case relationalDatabaseConfig
        case serviceRoleArn
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.DataSourceType.self, forKey: .type)
        type = typeDecoded
        let serviceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRoleArn)
        serviceRoleArn = serviceRoleArnDecoded
        let dynamodbConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.DynamodbDataSourceConfig.self, forKey: .dynamodbConfig)
        dynamodbConfig = dynamodbConfigDecoded
        let lambdaConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.LambdaDataSourceConfig.self, forKey: .lambdaConfig)
        lambdaConfig = lambdaConfigDecoded
        let elasticsearchConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ElasticsearchDataSourceConfig.self, forKey: .elasticsearchConfig)
        elasticsearchConfig = elasticsearchConfigDecoded
        let openSearchServiceConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.OpenSearchServiceDataSourceConfig.self, forKey: .openSearchServiceConfig)
        openSearchServiceConfig = openSearchServiceConfigDecoded
        let httpConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.HttpDataSourceConfig.self, forKey: .httpConfig)
        httpConfig = httpConfigDecoded
        let relationalDatabaseConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.RelationalDatabaseDataSourceConfig.self, forKey: .relationalDatabaseConfig)
        relationalDatabaseConfig = relationalDatabaseConfigDecoded
    }
}

extension CreateDataSourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDataSourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDataSourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDataSourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDataSourceOutputResponse(dataSource: \(Swift.String(describing: dataSource)))"}
}

extension CreateDataSourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDataSourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataSource = output.dataSource
        } else {
            self.dataSource = nil
        }
    }
}

public struct CreateDataSourceOutputResponse: Swift.Equatable {
    /// The DataSource object.
    public var dataSource: AppSyncClientTypes.DataSource?

    public init (
        dataSource: AppSyncClientTypes.DataSource? = nil
    )
    {
        self.dataSource = dataSource
    }
}

struct CreateDataSourceOutputResponseBody: Swift.Equatable {
    public let dataSource: AppSyncClientTypes.DataSource?
}

extension CreateDataSourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
    }
}

public struct CreateFunctionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFunctionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFunctionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFunctionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFunctionOutputError>
}

extension CreateFunctionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFunctionInput(apiId: \(Swift.String(describing: apiId)), dataSourceName: \(Swift.String(describing: dataSourceName)), description: \(Swift.String(describing: description)), functionVersion: \(Swift.String(describing: functionVersion)), name: \(Swift.String(describing: name)), requestMappingTemplate: \(Swift.String(describing: requestMappingTemplate)), responseMappingTemplate: \(Swift.String(describing: responseMappingTemplate)), syncConfig: \(Swift.String(describing: syncConfig)))"}
}

extension CreateFunctionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceName
        case description
        case functionVersion
        case name
        case requestMappingTemplate
        case responseMappingTemplate
        case syncConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceName = dataSourceName {
            try encodeContainer.encode(dataSourceName, forKey: .dataSourceName)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let functionVersion = functionVersion {
            try encodeContainer.encode(functionVersion, forKey: .functionVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let requestMappingTemplate = requestMappingTemplate {
            try encodeContainer.encode(requestMappingTemplate, forKey: .requestMappingTemplate)
        }
        if let responseMappingTemplate = responseMappingTemplate {
            try encodeContainer.encode(responseMappingTemplate, forKey: .responseMappingTemplate)
        }
        if let syncConfig = syncConfig {
            try encodeContainer.encode(syncConfig, forKey: .syncConfig)
        }
    }
}

public struct CreateFunctionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFunctionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFunctionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFunctionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFunctionOutputError>
}

public struct CreateFunctionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFunctionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFunctionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFunctionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFunctionOutputError>
}

public struct CreateFunctionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFunctionInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateFunctionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let apiId = input.apiId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("apiId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/v1/apis/\(apiId.urlPercentEncoding())/functions"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateFunctionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFunctionOutputError>
}

public struct CreateFunctionInput: Swift.Equatable {
    /// The GraphQL API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The Function
    ///             DataSource name.
    /// This member is required.
    public var dataSourceName: Swift.String?
    /// The Function description.
    public var description: Swift.String?
    /// The version of the request mapping template. Currently the supported value
    ///          is 2018-05-29.
    /// This member is required.
    public var functionVersion: Swift.String?
    /// The Function name. The function name does not have to be unique.
    /// This member is required.
    public var name: Swift.String?
    /// The Function request mapping template. Functions support only the
    ///          2018-05-29 version of the request mapping template.
    public var requestMappingTemplate: Swift.String?
    /// The Function response mapping template.
    public var responseMappingTemplate: Swift.String?
    /// Describes a Sync configuration for a resolver.
    ///          Contains information on which Conflict Detection as well as Resolution strategy should
    ///          be performed when the resolver is invoked.
    public var syncConfig: AppSyncClientTypes.SyncConfig?

    public init (
        apiId: Swift.String? = nil,
        dataSourceName: Swift.String? = nil,
        description: Swift.String? = nil,
        functionVersion: Swift.String? = nil,
        name: Swift.String? = nil,
        requestMappingTemplate: Swift.String? = nil,
        responseMappingTemplate: Swift.String? = nil,
        syncConfig: AppSyncClientTypes.SyncConfig? = nil
    )
    {
        self.apiId = apiId
        self.dataSourceName = dataSourceName
        self.description = description
        self.functionVersion = functionVersion
        self.name = name
        self.requestMappingTemplate = requestMappingTemplate
        self.responseMappingTemplate = responseMappingTemplate
        self.syncConfig = syncConfig
    }
}

struct CreateFunctionInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let description: Swift.String?
    public let dataSourceName: Swift.String?
    public let requestMappingTemplate: Swift.String?
    public let responseMappingTemplate: Swift.String?
    public let functionVersion: Swift.String?
    public let syncConfig: AppSyncClientTypes.SyncConfig?
}

extension CreateFunctionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceName
        case description
        case functionVersion
        case name
        case requestMappingTemplate
        case responseMappingTemplate
        case syncConfig
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dataSourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceName)
        dataSourceName = dataSourceNameDecoded
        let requestMappingTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestMappingTemplate)
        requestMappingTemplate = requestMappingTemplateDecoded
        let responseMappingTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .responseMappingTemplate)
        responseMappingTemplate = responseMappingTemplateDecoded
        let functionVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionVersion)
        functionVersion = functionVersionDecoded
        let syncConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.SyncConfig.self, forKey: .syncConfig)
        syncConfig = syncConfigDecoded
    }
}

extension CreateFunctionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFunctionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFunctionOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFunctionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFunctionOutputResponse(functionConfiguration: \(Swift.String(describing: functionConfiguration)))"}
}

extension CreateFunctionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateFunctionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.functionConfiguration = output.functionConfiguration
        } else {
            self.functionConfiguration = nil
        }
    }
}

public struct CreateFunctionOutputResponse: Swift.Equatable {
    /// The Function object.
    public var functionConfiguration: AppSyncClientTypes.FunctionConfiguration?

    public init (
        functionConfiguration: AppSyncClientTypes.FunctionConfiguration? = nil
    )
    {
        self.functionConfiguration = functionConfiguration
    }
}

struct CreateFunctionOutputResponseBody: Swift.Equatable {
    public let functionConfiguration: AppSyncClientTypes.FunctionConfiguration?
}

extension CreateFunctionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionConfiguration
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionConfigurationDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.FunctionConfiguration.self, forKey: .functionConfiguration)
        functionConfiguration = functionConfigurationDecoded
    }
}

public struct CreateGraphqlApiInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateGraphqlApiInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateGraphqlApiInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateGraphqlApiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateGraphqlApiInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateGraphqlApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateGraphqlApiOutputError>
}

extension CreateGraphqlApiInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateGraphqlApiInput(additionalAuthenticationProviders: \(Swift.String(describing: additionalAuthenticationProviders)), authenticationType: \(Swift.String(describing: authenticationType)), lambdaAuthorizerConfig: \(Swift.String(describing: lambdaAuthorizerConfig)), logConfig: \(Swift.String(describing: logConfig)), name: \(Swift.String(describing: name)), openIDConnectConfig: \(Swift.String(describing: openIDConnectConfig)), tags: \(Swift.String(describing: tags)), userPoolConfig: \(Swift.String(describing: userPoolConfig)), xrayEnabled: \(Swift.String(describing: xrayEnabled)))"}
}

extension CreateGraphqlApiInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalAuthenticationProviders
        case authenticationType
        case lambdaAuthorizerConfig
        case logConfig
        case name
        case openIDConnectConfig
        case tags
        case userPoolConfig
        case xrayEnabled
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalAuthenticationProviders = additionalAuthenticationProviders {
            var additionalAuthenticationProvidersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalAuthenticationProviders)
            for additionalauthenticationproviders0 in additionalAuthenticationProviders {
                try additionalAuthenticationProvidersContainer.encode(additionalauthenticationproviders0)
            }
        }
        if let authenticationType = authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let lambdaAuthorizerConfig = lambdaAuthorizerConfig {
            try encodeContainer.encode(lambdaAuthorizerConfig, forKey: .lambdaAuthorizerConfig)
        }
        if let logConfig = logConfig {
            try encodeContainer.encode(logConfig, forKey: .logConfig)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let openIDConnectConfig = openIDConnectConfig {
            try encodeContainer.encode(openIDConnectConfig, forKey: .openIDConnectConfig)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let userPoolConfig = userPoolConfig {
            try encodeContainer.encode(userPoolConfig, forKey: .userPoolConfig)
        }
        if xrayEnabled != false {
            try encodeContainer.encode(xrayEnabled, forKey: .xrayEnabled)
        }
    }
}

public struct CreateGraphqlApiInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateGraphqlApiInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateGraphqlApiInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateGraphqlApiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateGraphqlApiInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateGraphqlApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateGraphqlApiOutputError>
}

public struct CreateGraphqlApiInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateGraphqlApiInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateGraphqlApiInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateGraphqlApiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateGraphqlApiInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateGraphqlApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateGraphqlApiOutputError>
}

public struct CreateGraphqlApiInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateGraphqlApiInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateGraphqlApiInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateGraphqlApiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/v1/apis"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateGraphqlApiInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateGraphqlApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateGraphqlApiOutputError>
}

public struct CreateGraphqlApiInput: Swift.Equatable {
    /// A list of additional authentication providers for the GraphqlApi
    ///          API.
    public var additionalAuthenticationProviders: [AppSyncClientTypes.AdditionalAuthenticationProvider]?
    /// The authentication type: API key, Identity and Access Management, OIDC, Amazon Cognito user
    ///          pools, or Amazon Web Services Lambda.
    /// This member is required.
    public var authenticationType: AppSyncClientTypes.AuthenticationType?
    /// Configuration for Amazon Web Services Lambda function authorization.
    public var lambdaAuthorizerConfig: AppSyncClientTypes.LambdaAuthorizerConfig?
    /// The Amazon CloudWatch Logs configuration.
    public var logConfig: AppSyncClientTypes.LogConfig?
    /// A user-supplied name for the GraphqlApi.
    /// This member is required.
    public var name: Swift.String?
    /// The OpenID Connect configuration.
    public var openIDConnectConfig: AppSyncClientTypes.OpenIDConnectConfig?
    /// A TagMap object.
    public var tags: [Swift.String:Swift.String]?
    /// The Amazon Cognito user pool configuration.
    public var userPoolConfig: AppSyncClientTypes.UserPoolConfig?
    /// A flag indicating whether to enable X-Ray tracing for the
    ///          GraphqlApi.
    public var xrayEnabled: Swift.Bool

    public init (
        additionalAuthenticationProviders: [AppSyncClientTypes.AdditionalAuthenticationProvider]? = nil,
        authenticationType: AppSyncClientTypes.AuthenticationType? = nil,
        lambdaAuthorizerConfig: AppSyncClientTypes.LambdaAuthorizerConfig? = nil,
        logConfig: AppSyncClientTypes.LogConfig? = nil,
        name: Swift.String? = nil,
        openIDConnectConfig: AppSyncClientTypes.OpenIDConnectConfig? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        userPoolConfig: AppSyncClientTypes.UserPoolConfig? = nil,
        xrayEnabled: Swift.Bool = false
    )
    {
        self.additionalAuthenticationProviders = additionalAuthenticationProviders
        self.authenticationType = authenticationType
        self.lambdaAuthorizerConfig = lambdaAuthorizerConfig
        self.logConfig = logConfig
        self.name = name
        self.openIDConnectConfig = openIDConnectConfig
        self.tags = tags
        self.userPoolConfig = userPoolConfig
        self.xrayEnabled = xrayEnabled
    }
}

struct CreateGraphqlApiInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let logConfig: AppSyncClientTypes.LogConfig?
    public let authenticationType: AppSyncClientTypes.AuthenticationType?
    public let userPoolConfig: AppSyncClientTypes.UserPoolConfig?
    public let openIDConnectConfig: AppSyncClientTypes.OpenIDConnectConfig?
    public let tags: [Swift.String:Swift.String]?
    public let additionalAuthenticationProviders: [AppSyncClientTypes.AdditionalAuthenticationProvider]?
    public let xrayEnabled: Swift.Bool
    public let lambdaAuthorizerConfig: AppSyncClientTypes.LambdaAuthorizerConfig?
}

extension CreateGraphqlApiInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalAuthenticationProviders
        case authenticationType
        case lambdaAuthorizerConfig
        case logConfig
        case name
        case openIDConnectConfig
        case tags
        case userPoolConfig
        case xrayEnabled
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let logConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.LogConfig.self, forKey: .logConfig)
        logConfig = logConfigDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
        let userPoolConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.UserPoolConfig.self, forKey: .userPoolConfig)
        userPoolConfig = userPoolConfigDecoded
        let openIDConnectConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.OpenIDConnectConfig.self, forKey: .openIDConnectConfig)
        openIDConnectConfig = openIDConnectConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let additionalAuthenticationProvidersContainer = try containerValues.decodeIfPresent([AppSyncClientTypes.AdditionalAuthenticationProvider?].self, forKey: .additionalAuthenticationProviders)
        var additionalAuthenticationProvidersDecoded0:[AppSyncClientTypes.AdditionalAuthenticationProvider]? = nil
        if let additionalAuthenticationProvidersContainer = additionalAuthenticationProvidersContainer {
            additionalAuthenticationProvidersDecoded0 = [AppSyncClientTypes.AdditionalAuthenticationProvider]()
            for structure0 in additionalAuthenticationProvidersContainer {
                if let structure0 = structure0 {
                    additionalAuthenticationProvidersDecoded0?.append(structure0)
                }
            }
        }
        additionalAuthenticationProviders = additionalAuthenticationProvidersDecoded0
        let xrayEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .xrayEnabled)
        xrayEnabled = xrayEnabledDecoded
        let lambdaAuthorizerConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.LambdaAuthorizerConfig.self, forKey: .lambdaAuthorizerConfig)
        lambdaAuthorizerConfig = lambdaAuthorizerConfigDecoded
    }
}

extension CreateGraphqlApiOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateGraphqlApiOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ApiLimitExceededException" : self = .apiLimitExceededException(try ApiLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateGraphqlApiOutputError: Swift.Error, Swift.Equatable {
    case apiLimitExceededException(ApiLimitExceededException)
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case limitExceededException(LimitExceededException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateGraphqlApiOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateGraphqlApiOutputResponse(graphqlApi: \(Swift.String(describing: graphqlApi)))"}
}

extension CreateGraphqlApiOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateGraphqlApiOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.graphqlApi = output.graphqlApi
        } else {
            self.graphqlApi = nil
        }
    }
}

public struct CreateGraphqlApiOutputResponse: Swift.Equatable {
    /// The GraphqlApi.
    public var graphqlApi: AppSyncClientTypes.GraphqlApi?

    public init (
        graphqlApi: AppSyncClientTypes.GraphqlApi? = nil
    )
    {
        self.graphqlApi = graphqlApi
    }
}

struct CreateGraphqlApiOutputResponseBody: Swift.Equatable {
    public let graphqlApi: AppSyncClientTypes.GraphqlApi?
}

extension CreateGraphqlApiOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case graphqlApi
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphqlApiDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.GraphqlApi.self, forKey: .graphqlApi)
        graphqlApi = graphqlApiDecoded
    }
}

public struct CreateResolverInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateResolverInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateResolverInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateResolverOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateResolverInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateResolverOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateResolverOutputError>
}

extension CreateResolverInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateResolverInput(apiId: \(Swift.String(describing: apiId)), cachingConfig: \(Swift.String(describing: cachingConfig)), dataSourceName: \(Swift.String(describing: dataSourceName)), fieldName: \(Swift.String(describing: fieldName)), kind: \(Swift.String(describing: kind)), pipelineConfig: \(Swift.String(describing: pipelineConfig)), requestMappingTemplate: \(Swift.String(describing: requestMappingTemplate)), responseMappingTemplate: \(Swift.String(describing: responseMappingTemplate)), syncConfig: \(Swift.String(describing: syncConfig)), typeName: \(Swift.String(describing: typeName)))"}
}

extension CreateResolverInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachingConfig
        case dataSourceName
        case fieldName
        case kind
        case pipelineConfig
        case requestMappingTemplate
        case responseMappingTemplate
        case syncConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cachingConfig = cachingConfig {
            try encodeContainer.encode(cachingConfig, forKey: .cachingConfig)
        }
        if let dataSourceName = dataSourceName {
            try encodeContainer.encode(dataSourceName, forKey: .dataSourceName)
        }
        if let fieldName = fieldName {
            try encodeContainer.encode(fieldName, forKey: .fieldName)
        }
        if let kind = kind {
            try encodeContainer.encode(kind.rawValue, forKey: .kind)
        }
        if let pipelineConfig = pipelineConfig {
            try encodeContainer.encode(pipelineConfig, forKey: .pipelineConfig)
        }
        if let requestMappingTemplate = requestMappingTemplate {
            try encodeContainer.encode(requestMappingTemplate, forKey: .requestMappingTemplate)
        }
        if let responseMappingTemplate = responseMappingTemplate {
            try encodeContainer.encode(responseMappingTemplate, forKey: .responseMappingTemplate)
        }
        if let syncConfig = syncConfig {
            try encodeContainer.encode(syncConfig, forKey: .syncConfig)
        }
    }
}

public struct CreateResolverInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateResolverInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateResolverInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateResolverOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateResolverInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateResolverOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateResolverOutputError>
}

public struct CreateResolverInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateResolverInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateResolverInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateResolverOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateResolverInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateResolverOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateResolverOutputError>
}

public struct CreateResolverInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateResolverInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateResolverInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateResolverOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let apiId = input.apiId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("apiId is nil and needs a value for the path of this operation"))))
        }
        guard let typeName = input.typeName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("typeName is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/v1/apis/\(apiId.urlPercentEncoding())/types/\(typeName.urlPercentEncoding())/resolvers"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateResolverInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateResolverOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateResolverOutputError>
}

public struct CreateResolverInput: Swift.Equatable {
    /// The ID for the GraphQL API for which the resolver is being created.
    /// This member is required.
    public var apiId: Swift.String?
    /// The caching configuration for the resolver.
    public var cachingConfig: AppSyncClientTypes.CachingConfig?
    /// The name of the data source for which the resolver is being created.
    public var dataSourceName: Swift.String?
    /// The name of the field to attach the resolver to.
    /// This member is required.
    public var fieldName: Swift.String?
    /// The resolver type.
    ///
    ///
    ///
    ///                   UNIT: A UNIT resolver type. A UNIT resolver is
    ///                the default resolver type. A UNIT resolver enables you to execute a GraphQL query
    ///                against a single data source.
    ///
    ///
    ///
    ///                   PIPELINE: A PIPELINE resolver type. A PIPELINE
    ///                resolver enables you to execute a series of Function in a serial manner.
    ///                You can use a pipeline resolver to execute a GraphQL query against multiple data
    ///                sources.
    ///
    ///
    public var kind: AppSyncClientTypes.ResolverKind?
    /// The PipelineConfig.
    public var pipelineConfig: AppSyncClientTypes.PipelineConfig?
    /// The mapping template to be used for requests.
    ///          A resolver uses a request mapping template to convert a GraphQL expression into a format
    ///          that a data source can understand. Mapping templates are written in Apache Velocity
    ///          Template Language (VTL).
    ///          VTL request mapping templates are optional when using a Lambda data source. For all
    ///          other data sources, VTL request and response mapping templates are required.
    public var requestMappingTemplate: Swift.String?
    /// The mapping template to be used for responses from the data source.
    public var responseMappingTemplate: Swift.String?
    /// The SyncConfig for a resolver attached to a versioned datasource.
    public var syncConfig: AppSyncClientTypes.SyncConfig?
    /// The name of the Type.
    /// This member is required.
    public var typeName: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        cachingConfig: AppSyncClientTypes.CachingConfig? = nil,
        dataSourceName: Swift.String? = nil,
        fieldName: Swift.String? = nil,
        kind: AppSyncClientTypes.ResolverKind? = nil,
        pipelineConfig: AppSyncClientTypes.PipelineConfig? = nil,
        requestMappingTemplate: Swift.String? = nil,
        responseMappingTemplate: Swift.String? = nil,
        syncConfig: AppSyncClientTypes.SyncConfig? = nil,
        typeName: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.cachingConfig = cachingConfig
        self.dataSourceName = dataSourceName
        self.fieldName = fieldName
        self.kind = kind
        self.pipelineConfig = pipelineConfig
        self.requestMappingTemplate = requestMappingTemplate
        self.responseMappingTemplate = responseMappingTemplate
        self.syncConfig = syncConfig
        self.typeName = typeName
    }
}

struct CreateResolverInputBody: Swift.Equatable {
    public let fieldName: Swift.String?
    public let dataSourceName: Swift.String?
    public let requestMappingTemplate: Swift.String?
    public let responseMappingTemplate: Swift.String?
    public let kind: AppSyncClientTypes.ResolverKind?
    public let pipelineConfig: AppSyncClientTypes.PipelineConfig?
    public let syncConfig: AppSyncClientTypes.SyncConfig?
    public let cachingConfig: AppSyncClientTypes.CachingConfig?
}

extension CreateResolverInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachingConfig
        case dataSourceName
        case fieldName
        case kind
        case pipelineConfig
        case requestMappingTemplate
        case responseMappingTemplate
        case syncConfig
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldName)
        fieldName = fieldNameDecoded
        let dataSourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceName)
        dataSourceName = dataSourceNameDecoded
        let requestMappingTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestMappingTemplate)
        requestMappingTemplate = requestMappingTemplateDecoded
        let responseMappingTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .responseMappingTemplate)
        responseMappingTemplate = responseMappingTemplateDecoded
        let kindDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ResolverKind.self, forKey: .kind)
        kind = kindDecoded
        let pipelineConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.PipelineConfig.self, forKey: .pipelineConfig)
        pipelineConfig = pipelineConfigDecoded
        let syncConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.SyncConfig.self, forKey: .syncConfig)
        syncConfig = syncConfigDecoded
        let cachingConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.CachingConfig.self, forKey: .cachingConfig)
        cachingConfig = cachingConfigDecoded
    }
}

extension CreateResolverOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateResolverOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateResolverOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateResolverOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateResolverOutputResponse(resolver: \(Swift.String(describing: resolver)))"}
}

extension CreateResolverOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateResolverOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resolver = output.resolver
        } else {
            self.resolver = nil
        }
    }
}

public struct CreateResolverOutputResponse: Swift.Equatable {
    /// The Resolver object.
    public var resolver: AppSyncClientTypes.Resolver?

    public init (
        resolver: AppSyncClientTypes.Resolver? = nil
    )
    {
        self.resolver = resolver
    }
}

struct CreateResolverOutputResponseBody: Swift.Equatable {
    public let resolver: AppSyncClientTypes.Resolver?
}

extension CreateResolverOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolver
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.Resolver.self, forKey: .resolver)
        resolver = resolverDecoded
    }
}

public struct CreateTypeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTypeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTypeOutputError>
}

extension CreateTypeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateTypeInput(apiId: \(Swift.String(describing: apiId)), definition: \(Swift.String(describing: definition)), format: \(Swift.String(describing: format)))"}
}

extension CreateTypeInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition
        case format
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let definition = definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
    }
}

public struct CreateTypeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTypeOutputError>
}

public struct CreateTypeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTypeOutputError>
}

public struct CreateTypeInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTypeInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateTypeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let apiId = input.apiId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("apiId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/v1/apis/\(apiId.urlPercentEncoding())/types"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateTypeInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTypeOutputError>
}

public struct CreateTypeInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The type definition, in GraphQL Schema Definition Language (SDL) format.
    ///          For more information, see the <a href="http://graphql.org/learn/schema/">GraphQL SDL
    ///             documentation.
    /// This member is required.
    public var definition: Swift.String?
    /// The type format: SDL or JSON.
    /// This member is required.
    public var format: AppSyncClientTypes.TypeDefinitionFormat?

    public init (
        apiId: Swift.String? = nil,
        definition: Swift.String? = nil,
        format: AppSyncClientTypes.TypeDefinitionFormat? = nil
    )
    {
        self.apiId = apiId
        self.definition = definition
        self.format = format
    }
}

struct CreateTypeInputBody: Swift.Equatable {
    public let definition: Swift.String?
    public let format: AppSyncClientTypes.TypeDefinitionFormat?
}

extension CreateTypeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition
        case format
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let definitionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .definition)
        definition = definitionDecoded
        let formatDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.TypeDefinitionFormat.self, forKey: .format)
        format = formatDecoded
    }
}

extension CreateTypeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTypeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateTypeOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTypeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateTypeOutputResponse(type: \(Swift.String(describing: type)))"}
}

extension CreateTypeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateTypeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.type = output.type
        } else {
            self.type = nil
        }
    }
}

public struct CreateTypeOutputResponse: Swift.Equatable {
    /// The Type object.
    public var type: AppSyncClientTypes.ModelType?

    public init (
        type: AppSyncClientTypes.ModelType? = nil
    )
    {
        self.type = type
    }
}

struct CreateTypeOutputResponseBody: Swift.Equatable {
    public let type: AppSyncClientTypes.ModelType?
}

extension CreateTypeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ModelType.self, forKey: .type)
        type = typeDecoded
    }
}

extension AppSyncClientTypes.DataSource: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceArn
        case description
        case dynamodbConfig
        case elasticsearchConfig
        case httpConfig
        case lambdaConfig
        case name
        case openSearchServiceConfig
        case relationalDatabaseConfig
        case serviceRoleArn
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceArn = dataSourceArn {
            try encodeContainer.encode(dataSourceArn, forKey: .dataSourceArn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let dynamodbConfig = dynamodbConfig {
            try encodeContainer.encode(dynamodbConfig, forKey: .dynamodbConfig)
        }
        if let elasticsearchConfig = elasticsearchConfig {
            try encodeContainer.encode(elasticsearchConfig, forKey: .elasticsearchConfig)
        }
        if let httpConfig = httpConfig {
            try encodeContainer.encode(httpConfig, forKey: .httpConfig)
        }
        if let lambdaConfig = lambdaConfig {
            try encodeContainer.encode(lambdaConfig, forKey: .lambdaConfig)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let openSearchServiceConfig = openSearchServiceConfig {
            try encodeContainer.encode(openSearchServiceConfig, forKey: .openSearchServiceConfig)
        }
        if let relationalDatabaseConfig = relationalDatabaseConfig {
            try encodeContainer.encode(relationalDatabaseConfig, forKey: .relationalDatabaseConfig)
        }
        if let serviceRoleArn = serviceRoleArn {
            try encodeContainer.encode(serviceRoleArn, forKey: .serviceRoleArn)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceArn)
        dataSourceArn = dataSourceArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.DataSourceType.self, forKey: .type)
        type = typeDecoded
        let serviceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRoleArn)
        serviceRoleArn = serviceRoleArnDecoded
        let dynamodbConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.DynamodbDataSourceConfig.self, forKey: .dynamodbConfig)
        dynamodbConfig = dynamodbConfigDecoded
        let lambdaConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.LambdaDataSourceConfig.self, forKey: .lambdaConfig)
        lambdaConfig = lambdaConfigDecoded
        let elasticsearchConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ElasticsearchDataSourceConfig.self, forKey: .elasticsearchConfig)
        elasticsearchConfig = elasticsearchConfigDecoded
        let openSearchServiceConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.OpenSearchServiceDataSourceConfig.self, forKey: .openSearchServiceConfig)
        openSearchServiceConfig = openSearchServiceConfigDecoded
        let httpConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.HttpDataSourceConfig.self, forKey: .httpConfig)
        httpConfig = httpConfigDecoded
        let relationalDatabaseConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.RelationalDatabaseDataSourceConfig.self, forKey: .relationalDatabaseConfig)
        relationalDatabaseConfig = relationalDatabaseConfigDecoded
    }
}

extension AppSyncClientTypes.DataSource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataSource(dataSourceArn: \(Swift.String(describing: dataSourceArn)), description: \(Swift.String(describing: description)), dynamodbConfig: \(Swift.String(describing: dynamodbConfig)), elasticsearchConfig: \(Swift.String(describing: elasticsearchConfig)), httpConfig: \(Swift.String(describing: httpConfig)), lambdaConfig: \(Swift.String(describing: lambdaConfig)), name: \(Swift.String(describing: name)), openSearchServiceConfig: \(Swift.String(describing: openSearchServiceConfig)), relationalDatabaseConfig: \(Swift.String(describing: relationalDatabaseConfig)), serviceRoleArn: \(Swift.String(describing: serviceRoleArn)), type: \(Swift.String(describing: type)))"}
}

extension AppSyncClientTypes {
    /// Describes a data source.
    public struct DataSource: Swift.Equatable {
        /// The data source ARN.
        public var dataSourceArn: Swift.String?
        /// The description of the data source.
        public var description: Swift.String?
        /// Amazon DynamoDB settings.
        public var dynamodbConfig: AppSyncClientTypes.DynamodbDataSourceConfig?
        /// Amazon OpenSearch Service settings.
        public var elasticsearchConfig: AppSyncClientTypes.ElasticsearchDataSourceConfig?
        /// HTTP endpoint settings.
        public var httpConfig: AppSyncClientTypes.HttpDataSourceConfig?
        /// Amazon Web Services Lambda settings.
        public var lambdaConfig: AppSyncClientTypes.LambdaDataSourceConfig?
        /// The name of the data source.
        public var name: Swift.String?
        /// Amazon OpenSearch Service settings.
        public var openSearchServiceConfig: AppSyncClientTypes.OpenSearchServiceDataSourceConfig?
        /// Relational database settings.
        public var relationalDatabaseConfig: AppSyncClientTypes.RelationalDatabaseDataSourceConfig?
        /// The Identity and Access Management service role ARN for the data source. The system assumes this
        ///          role when accessing the data source.
        public var serviceRoleArn: Swift.String?
        /// The type of the data source.
        ///
        ///
        ///
        ///                   AWS_LAMBDA: The data source is an Amazon Web Services Lambda function.
        ///
        ///
        ///
        ///                   AMAZON_DYNAMODB: The data source is an Amazon
        ///                DynamoDB table.
        ///
        ///
        ///
        ///                   AMAZON_ELASTICSEARCH: The data source is an
        ///                   Amazon OpenSearch Service domain.
        ///
        ///
        ///
        ///                   AMAZON_OPENSEARCH_SERVICE: The data source is
        ///                an Amazon OpenSearch Service domain.
        ///
        ///
        ///
        ///                   NONE: There is no data source. This type is
        ///                used when you wish to invoke a GraphQL operation without connecting to a data source,
        ///                such as performing data transformation with resolvers or triggering a subscription to
        ///                be invoked from a mutation.
        ///
        ///
        ///
        ///                   HTTP: The data source is an HTTP
        ///                endpoint.
        ///
        ///
        ///
        ///                   RELATIONAL_DATABASE: The data source is a
        ///                relational database.
        ///
        ///
        public var type: AppSyncClientTypes.DataSourceType?

        public init (
            dataSourceArn: Swift.String? = nil,
            description: Swift.String? = nil,
            dynamodbConfig: AppSyncClientTypes.DynamodbDataSourceConfig? = nil,
            elasticsearchConfig: AppSyncClientTypes.ElasticsearchDataSourceConfig? = nil,
            httpConfig: AppSyncClientTypes.HttpDataSourceConfig? = nil,
            lambdaConfig: AppSyncClientTypes.LambdaDataSourceConfig? = nil,
            name: Swift.String? = nil,
            openSearchServiceConfig: AppSyncClientTypes.OpenSearchServiceDataSourceConfig? = nil,
            relationalDatabaseConfig: AppSyncClientTypes.RelationalDatabaseDataSourceConfig? = nil,
            serviceRoleArn: Swift.String? = nil,
            type: AppSyncClientTypes.DataSourceType? = nil
        )
        {
            self.dataSourceArn = dataSourceArn
            self.description = description
            self.dynamodbConfig = dynamodbConfig
            self.elasticsearchConfig = elasticsearchConfig
            self.httpConfig = httpConfig
            self.lambdaConfig = lambdaConfig
            self.name = name
            self.openSearchServiceConfig = openSearchServiceConfig
            self.relationalDatabaseConfig = relationalDatabaseConfig
            self.serviceRoleArn = serviceRoleArn
            self.type = type
        }
    }

}

extension AppSyncClientTypes {
    public enum DataSourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case amazonDynamodb
        case amazonElasticsearch
        case amazonOpensearchService
        case awsLambda
        case http
        case `none`
        case relationalDatabase
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSourceType] {
            return [
                .amazonDynamodb,
                .amazonElasticsearch,
                .amazonOpensearchService,
                .awsLambda,
                .http,
                .none,
                .relationalDatabase,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amazonDynamodb: return "AMAZON_DYNAMODB"
            case .amazonElasticsearch: return "AMAZON_ELASTICSEARCH"
            case .amazonOpensearchService: return "AMAZON_OPENSEARCH_SERVICE"
            case .awsLambda: return "AWS_LAMBDA"
            case .http: return "HTTP"
            case .none: return "NONE"
            case .relationalDatabase: return "RELATIONAL_DATABASE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataSourceType(rawValue: rawValue) ?? DataSourceType.sdkUnknown(rawValue)
        }
    }
}

extension AppSyncClientTypes {
    public enum DefaultAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allow
        case deny
        case sdkUnknown(Swift.String)

        public static var allCases: [DefaultAction] {
            return [
                .allow,
                .deny,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allow: return "ALLOW"
            case .deny: return "DENY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DefaultAction(rawValue: rawValue) ?? DefaultAction.sdkUnknown(rawValue)
        }
    }
}

extension DeleteApiCacheInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteApiCacheInput(apiId: \(Swift.String(describing: apiId)))"}
}

extension DeleteApiCacheInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteApiCacheInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteApiCacheInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteApiCacheInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteApiCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteApiCacheInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteApiCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteApiCacheOutputError>
}

public struct DeleteApiCacheInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteApiCacheInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteApiCacheInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteApiCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteApiCacheInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteApiCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteApiCacheOutputError>
}

public struct DeleteApiCacheInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteApiCacheInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteApiCacheInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteApiCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let apiId = input.apiId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("apiId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/v1/apis/\(apiId.urlPercentEncoding())/ApiCaches"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteApiCacheInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteApiCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteApiCacheOutputError>
}

/// Represents the input of a DeleteApiCache operation.
public struct DeleteApiCacheInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?

    public init (
        apiId: Swift.String? = nil
    )
    {
        self.apiId = apiId
    }
}

struct DeleteApiCacheInputBody: Swift.Equatable {
}

extension DeleteApiCacheInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteApiCacheOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApiCacheOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteApiCacheOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApiCacheOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteApiCacheOutputResponse()"}
}

extension DeleteApiCacheOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// Represents the output of a DeleteApiCache operation.
public struct DeleteApiCacheOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteApiCacheOutputResponseBody: Swift.Equatable {
}

extension DeleteApiCacheOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteApiKeyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteApiKeyInput(apiId: \(Swift.String(describing: apiId)), id: \(Swift.String(describing: id)))"}
}

extension DeleteApiKeyInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteApiKeyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteApiKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteApiKeyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteApiKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteApiKeyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteApiKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteApiKeyOutputError>
}

public struct DeleteApiKeyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteApiKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteApiKeyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteApiKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteApiKeyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteApiKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteApiKeyOutputError>
}

public struct DeleteApiKeyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteApiKeyInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteApiKeyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteApiKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let apiId = input.apiId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("apiId is nil and needs a value for the path of this operation"))))
        }
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/v1/apis/\(apiId.urlPercentEncoding())/apikeys/\(id.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteApiKeyInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteApiKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteApiKeyOutputError>
}

public struct DeleteApiKeyInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The ID for the API key.
    /// This member is required.
    public var id: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.id = id
    }
}

struct DeleteApiKeyInputBody: Swift.Equatable {
}

extension DeleteApiKeyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteApiKeyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApiKeyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteApiKeyOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApiKeyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteApiKeyOutputResponse()"}
}

extension DeleteApiKeyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteApiKeyOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteApiKeyOutputResponseBody: Swift.Equatable {
}

extension DeleteApiKeyOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDataSourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDataSourceInput(apiId: \(Swift.String(describing: apiId)), name: \(Swift.String(describing: name)))"}
}

extension DeleteDataSourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteDataSourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDataSourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDataSourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDataSourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDataSourceOutputError>
}

public struct DeleteDataSourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDataSourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDataSourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDataSourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDataSourceOutputError>
}

public struct DeleteDataSourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDataSourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteDataSourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let apiId = input.apiId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("apiId is nil and needs a value for the path of this operation"))))
        }
        guard let name = input.name else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("name is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/v1/apis/\(apiId.urlPercentEncoding())/datasources/\(name.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteDataSourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDataSourceOutputError>
}

public struct DeleteDataSourceInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The name of the data source.
    /// This member is required.
    public var name: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.name = name
    }
}

struct DeleteDataSourceInputBody: Swift.Equatable {
}

extension DeleteDataSourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDataSourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDataSourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDataSourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDataSourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDataSourceOutputResponse()"}
}

extension DeleteDataSourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDataSourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteDataSourceOutputResponseBody: Swift.Equatable {
}

extension DeleteDataSourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFunctionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFunctionInput(apiId: \(Swift.String(describing: apiId)), functionId: \(Swift.String(describing: functionId)))"}
}

extension DeleteFunctionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteFunctionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFunctionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFunctionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFunctionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFunctionOutputError>
}

public struct DeleteFunctionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFunctionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFunctionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFunctionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFunctionOutputError>
}

public struct DeleteFunctionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFunctionInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteFunctionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let apiId = input.apiId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("apiId is nil and needs a value for the path of this operation"))))
        }
        guard let functionId = input.functionId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("functionId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/v1/apis/\(apiId.urlPercentEncoding())/functions/\(functionId.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteFunctionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFunctionOutputError>
}

public struct DeleteFunctionInput: Swift.Equatable {
    /// The GraphQL API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The Function ID.
    /// This member is required.
    public var functionId: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        functionId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.functionId = functionId
    }
}

struct DeleteFunctionInputBody: Swift.Equatable {
}

extension DeleteFunctionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFunctionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFunctionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFunctionOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFunctionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFunctionOutputResponse()"}
}

extension DeleteFunctionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFunctionOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteFunctionOutputResponseBody: Swift.Equatable {
}

extension DeleteFunctionOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteGraphqlApiInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteGraphqlApiInput(apiId: \(Swift.String(describing: apiId)))"}
}

extension DeleteGraphqlApiInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteGraphqlApiInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteGraphqlApiInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteGraphqlApiInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteGraphqlApiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteGraphqlApiInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteGraphqlApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteGraphqlApiOutputError>
}

public struct DeleteGraphqlApiInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteGraphqlApiInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteGraphqlApiInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteGraphqlApiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteGraphqlApiInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteGraphqlApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteGraphqlApiOutputError>
}

public struct DeleteGraphqlApiInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteGraphqlApiInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteGraphqlApiInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteGraphqlApiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let apiId = input.apiId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("apiId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/v1/apis/\(apiId.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteGraphqlApiInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteGraphqlApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteGraphqlApiOutputError>
}

public struct DeleteGraphqlApiInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?

    public init (
        apiId: Swift.String? = nil
    )
    {
        self.apiId = apiId
    }
}

struct DeleteGraphqlApiInputBody: Swift.Equatable {
}

extension DeleteGraphqlApiInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteGraphqlApiOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteGraphqlApiOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteGraphqlApiOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteGraphqlApiOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteGraphqlApiOutputResponse()"}
}

extension DeleteGraphqlApiOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteGraphqlApiOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteGraphqlApiOutputResponseBody: Swift.Equatable {
}

extension DeleteGraphqlApiOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteResolverInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteResolverInput(apiId: \(Swift.String(describing: apiId)), fieldName: \(Swift.String(describing: fieldName)), typeName: \(Swift.String(describing: typeName)))"}
}

extension DeleteResolverInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteResolverInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteResolverInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteResolverInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteResolverOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteResolverInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteResolverOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteResolverOutputError>
}

public struct DeleteResolverInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteResolverInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteResolverInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteResolverOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteResolverInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteResolverOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteResolverOutputError>
}

public struct DeleteResolverInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteResolverInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteResolverInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteResolverOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let apiId = input.apiId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("apiId is nil and needs a value for the path of this operation"))))
        }
        guard let typeName = input.typeName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("typeName is nil and needs a value for the path of this operation"))))
        }
        guard let fieldName = input.fieldName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("fieldName is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/v1/apis/\(apiId.urlPercentEncoding())/types/\(typeName.urlPercentEncoding())/resolvers/\(fieldName.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteResolverInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteResolverOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteResolverOutputError>
}

public struct DeleteResolverInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The resolver field name.
    /// This member is required.
    public var fieldName: Swift.String?
    /// The name of the resolver type.
    /// This member is required.
    public var typeName: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        fieldName: Swift.String? = nil,
        typeName: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.fieldName = fieldName
        self.typeName = typeName
    }
}

struct DeleteResolverInputBody: Swift.Equatable {
}

extension DeleteResolverInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteResolverOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteResolverOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteResolverOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteResolverOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteResolverOutputResponse()"}
}

extension DeleteResolverOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteResolverOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteResolverOutputResponseBody: Swift.Equatable {
}

extension DeleteResolverOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteTypeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteTypeInput(apiId: \(Swift.String(describing: apiId)), typeName: \(Swift.String(describing: typeName)))"}
}

extension DeleteTypeInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteTypeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTypeOutputError>
}

public struct DeleteTypeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTypeOutputError>
}

public struct DeleteTypeInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTypeInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteTypeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let apiId = input.apiId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("apiId is nil and needs a value for the path of this operation"))))
        }
        guard let typeName = input.typeName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("typeName is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/v1/apis/\(apiId.urlPercentEncoding())/types/\(typeName.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteTypeInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTypeOutputError>
}

public struct DeleteTypeInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The type name.
    /// This member is required.
    public var typeName: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        typeName: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.typeName = typeName
    }
}

struct DeleteTypeInputBody: Swift.Equatable {
}

extension DeleteTypeInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteTypeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTypeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTypeOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTypeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteTypeOutputResponse()"}
}

extension DeleteTypeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteTypeOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteTypeOutputResponseBody: Swift.Equatable {
}

extension DeleteTypeOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AppSyncClientTypes.DeltaSyncConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseTableTTL
        case deltaSyncTableName
        case deltaSyncTableTTL
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if baseTableTTL != 0 {
            try encodeContainer.encode(baseTableTTL, forKey: .baseTableTTL)
        }
        if let deltaSyncTableName = deltaSyncTableName {
            try encodeContainer.encode(deltaSyncTableName, forKey: .deltaSyncTableName)
        }
        if deltaSyncTableTTL != 0 {
            try encodeContainer.encode(deltaSyncTableTTL, forKey: .deltaSyncTableTTL)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baseTableTTLDecoded = try containerValues.decode(Swift.Int.self, forKey: .baseTableTTL)
        baseTableTTL = baseTableTTLDecoded
        let deltaSyncTableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deltaSyncTableName)
        deltaSyncTableName = deltaSyncTableNameDecoded
        let deltaSyncTableTTLDecoded = try containerValues.decode(Swift.Int.self, forKey: .deltaSyncTableTTL)
        deltaSyncTableTTL = deltaSyncTableTTLDecoded
    }
}

extension AppSyncClientTypes.DeltaSyncConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeltaSyncConfig(baseTableTTL: \(Swift.String(describing: baseTableTTL)), deltaSyncTableName: \(Swift.String(describing: deltaSyncTableName)), deltaSyncTableTTL: \(Swift.String(describing: deltaSyncTableTTL)))"}
}

extension AppSyncClientTypes {
    /// Describes a Delta Sync configuration.
    public struct DeltaSyncConfig: Swift.Equatable {
        /// The number of minutes an Item is stored in the datasource.
        public var baseTableTTL: Swift.Int
        /// The Delta Sync table name.
        public var deltaSyncTableName: Swift.String?
        /// The number of minutes a Delta Sync log entry is stored in the Delta Sync table.
        public var deltaSyncTableTTL: Swift.Int

        public init (
            baseTableTTL: Swift.Int = 0,
            deltaSyncTableName: Swift.String? = nil,
            deltaSyncTableTTL: Swift.Int = 0
        )
        {
            self.baseTableTTL = baseTableTTL
            self.deltaSyncTableName = deltaSyncTableName
            self.deltaSyncTableTTL = deltaSyncTableTTL
        }
    }

}

extension AppSyncClientTypes.DynamodbDataSourceConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion
        case deltaSyncConfig
        case tableName
        case useCallerCredentials
        case versioned
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let deltaSyncConfig = deltaSyncConfig {
            try encodeContainer.encode(deltaSyncConfig, forKey: .deltaSyncConfig)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
        if useCallerCredentials != false {
            try encodeContainer.encode(useCallerCredentials, forKey: .useCallerCredentials)
        }
        if versioned != false {
            try encodeContainer.encode(versioned, forKey: .versioned)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let useCallerCredentialsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .useCallerCredentials)
        useCallerCredentials = useCallerCredentialsDecoded
        let deltaSyncConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.DeltaSyncConfig.self, forKey: .deltaSyncConfig)
        deltaSyncConfig = deltaSyncConfigDecoded
        let versionedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .versioned)
        versioned = versionedDecoded
    }
}

extension AppSyncClientTypes.DynamodbDataSourceConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DynamodbDataSourceConfig(awsRegion: \(Swift.String(describing: awsRegion)), deltaSyncConfig: \(Swift.String(describing: deltaSyncConfig)), tableName: \(Swift.String(describing: tableName)), useCallerCredentials: \(Swift.String(describing: useCallerCredentials)), versioned: \(Swift.String(describing: versioned)))"}
}

extension AppSyncClientTypes {
    /// Describes an Amazon DynamoDB data source configuration.
    public struct DynamodbDataSourceConfig: Swift.Equatable {
        /// The Amazon Web Services Region.
        /// This member is required.
        public var awsRegion: Swift.String?
        /// The DeltaSyncConfig for a versioned datasource.
        public var deltaSyncConfig: AppSyncClientTypes.DeltaSyncConfig?
        /// The table name.
        /// This member is required.
        public var tableName: Swift.String?
        /// Set to TRUE to use Amazon Cognito credentials with this data source.
        public var useCallerCredentials: Swift.Bool
        /// Set to TRUE to use Conflict Detection and Resolution with this data source.
        public var versioned: Swift.Bool

        public init (
            awsRegion: Swift.String? = nil,
            deltaSyncConfig: AppSyncClientTypes.DeltaSyncConfig? = nil,
            tableName: Swift.String? = nil,
            useCallerCredentials: Swift.Bool = false,
            versioned: Swift.Bool = false
        )
        {
            self.awsRegion = awsRegion
            self.deltaSyncConfig = deltaSyncConfig
            self.tableName = tableName
            self.useCallerCredentials = useCallerCredentials
            self.versioned = versioned
        }
    }

}

extension AppSyncClientTypes.ElasticsearchDataSourceConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion
        case endpoint
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let endpoint = endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
    }
}

extension AppSyncClientTypes.ElasticsearchDataSourceConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ElasticsearchDataSourceConfig(awsRegion: \(Swift.String(describing: awsRegion)), endpoint: \(Swift.String(describing: endpoint)))"}
}

extension AppSyncClientTypes {
    /// Describes an OpenSearch data source configuration.
    ///          As of September 2021, Amazon Elasticsearch service is Amazon OpenSearch Service. This
    ///          configuration is deprecated. For new data sources, use OpenSearchServiceDataSourceConfig to specify an OpenSearch data
    ///          source.
    public struct ElasticsearchDataSourceConfig: Swift.Equatable {
        /// The Amazon Web Services Region.
        /// This member is required.
        public var awsRegion: Swift.String?
        /// The endpoint.
        /// This member is required.
        public var endpoint: Swift.String?

        public init (
            awsRegion: Swift.String? = nil,
            endpoint: Swift.String? = nil
        )
        {
            self.awsRegion = awsRegion
            self.endpoint = endpoint
        }
    }

}

extension AppSyncClientTypes {
    public enum FieldLogLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case error
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [FieldLogLevel] {
            return [
                .all,
                .error,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .error: return "ERROR"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FieldLogLevel(rawValue: rawValue) ?? FieldLogLevel.sdkUnknown(rawValue)
        }
    }
}

extension FlushApiCacheInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FlushApiCacheInput(apiId: \(Swift.String(describing: apiId)))"}
}

extension FlushApiCacheInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct FlushApiCacheInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "FlushApiCacheInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<FlushApiCacheInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<FlushApiCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<FlushApiCacheInput>
    public typealias MOutput = ClientRuntime.OperationOutput<FlushApiCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<FlushApiCacheOutputError>
}

public struct FlushApiCacheInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "FlushApiCacheInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<FlushApiCacheInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<FlushApiCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<FlushApiCacheInput>
    public typealias MOutput = ClientRuntime.OperationOutput<FlushApiCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<FlushApiCacheOutputError>
}

public struct FlushApiCacheInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "FlushApiCacheInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: FlushApiCacheInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<FlushApiCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let apiId = input.apiId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("apiId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/v1/apis/\(apiId.urlPercentEncoding())/FlushCache"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = FlushApiCacheInput
    public typealias MOutput = ClientRuntime.OperationOutput<FlushApiCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<FlushApiCacheOutputError>
}

/// Represents the input of a FlushApiCache operation.
public struct FlushApiCacheInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?

    public init (
        apiId: Swift.String? = nil
    )
    {
        self.apiId = apiId
    }
}

struct FlushApiCacheInputBody: Swift.Equatable {
}

extension FlushApiCacheInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension FlushApiCacheOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension FlushApiCacheOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum FlushApiCacheOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension FlushApiCacheOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FlushApiCacheOutputResponse()"}
}

extension FlushApiCacheOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// Represents the output of a FlushApiCache operation.
public struct FlushApiCacheOutputResponse: Swift.Equatable {

    public init() {}
}

struct FlushApiCacheOutputResponseBody: Swift.Equatable {
}

extension FlushApiCacheOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AppSyncClientTypes.FunctionConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceName
        case description
        case functionArn
        case functionId
        case functionVersion
        case name
        case requestMappingTemplate
        case responseMappingTemplate
        case syncConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceName = dataSourceName {
            try encodeContainer.encode(dataSourceName, forKey: .dataSourceName)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let functionArn = functionArn {
            try encodeContainer.encode(functionArn, forKey: .functionArn)
        }
        if let functionId = functionId {
            try encodeContainer.encode(functionId, forKey: .functionId)
        }
        if let functionVersion = functionVersion {
            try encodeContainer.encode(functionVersion, forKey: .functionVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let requestMappingTemplate = requestMappingTemplate {
            try encodeContainer.encode(requestMappingTemplate, forKey: .requestMappingTemplate)
        }
        if let responseMappingTemplate = responseMappingTemplate {
            try encodeContainer.encode(responseMappingTemplate, forKey: .responseMappingTemplate)
        }
        if let syncConfig = syncConfig {
            try encodeContainer.encode(syncConfig, forKey: .syncConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionId)
        functionId = functionIdDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dataSourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceName)
        dataSourceName = dataSourceNameDecoded
        let requestMappingTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestMappingTemplate)
        requestMappingTemplate = requestMappingTemplateDecoded
        let responseMappingTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .responseMappingTemplate)
        responseMappingTemplate = responseMappingTemplateDecoded
        let functionVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionVersion)
        functionVersion = functionVersionDecoded
        let syncConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.SyncConfig.self, forKey: .syncConfig)
        syncConfig = syncConfigDecoded
    }
}

extension AppSyncClientTypes.FunctionConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FunctionConfiguration(dataSourceName: \(Swift.String(describing: dataSourceName)), description: \(Swift.String(describing: description)), functionArn: \(Swift.String(describing: functionArn)), functionId: \(Swift.String(describing: functionId)), functionVersion: \(Swift.String(describing: functionVersion)), name: \(Swift.String(describing: name)), requestMappingTemplate: \(Swift.String(describing: requestMappingTemplate)), responseMappingTemplate: \(Swift.String(describing: responseMappingTemplate)), syncConfig: \(Swift.String(describing: syncConfig)))"}
}

extension AppSyncClientTypes {
    /// A function is a reusable entity. Multiple functions can be used to compose the resolver
    ///          logic.
    public struct FunctionConfiguration: Swift.Equatable {
        /// The name of the DataSource.
        public var dataSourceName: Swift.String?
        /// The Function description.
        public var description: Swift.String?
        /// The ARN of the Function object.
        public var functionArn: Swift.String?
        /// A unique ID representing the Function object.
        public var functionId: Swift.String?
        /// The version of the request mapping template. Currently only the 2018-05-29 version of
        ///          the template is supported.
        public var functionVersion: Swift.String?
        /// The name of the Function object.
        public var name: Swift.String?
        /// The Function request mapping template. Functions support only the
        ///          2018-05-29 version of the request mapping template.
        public var requestMappingTemplate: Swift.String?
        /// The Function response mapping template.
        public var responseMappingTemplate: Swift.String?
        /// Describes a Sync configuration for a resolver.
        ///          Contains information on which Conflict Detection as well as Resolution strategy should
        ///          be performed when the resolver is invoked.
        public var syncConfig: AppSyncClientTypes.SyncConfig?

        public init (
            dataSourceName: Swift.String? = nil,
            description: Swift.String? = nil,
            functionArn: Swift.String? = nil,
            functionId: Swift.String? = nil,
            functionVersion: Swift.String? = nil,
            name: Swift.String? = nil,
            requestMappingTemplate: Swift.String? = nil,
            responseMappingTemplate: Swift.String? = nil,
            syncConfig: AppSyncClientTypes.SyncConfig? = nil
        )
        {
            self.dataSourceName = dataSourceName
            self.description = description
            self.functionArn = functionArn
            self.functionId = functionId
            self.functionVersion = functionVersion
            self.name = name
            self.requestMappingTemplate = requestMappingTemplate
            self.responseMappingTemplate = responseMappingTemplate
            self.syncConfig = syncConfig
        }
    }

}

extension GetApiCacheInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetApiCacheInput(apiId: \(Swift.String(describing: apiId)))"}
}

extension GetApiCacheInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetApiCacheInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetApiCacheInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetApiCacheInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetApiCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetApiCacheInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetApiCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetApiCacheOutputError>
}

public struct GetApiCacheInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetApiCacheInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetApiCacheInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetApiCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetApiCacheInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetApiCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetApiCacheOutputError>
}

public struct GetApiCacheInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetApiCacheInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetApiCacheInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetApiCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let apiId = input.apiId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("apiId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/v1/apis/\(apiId.urlPercentEncoding())/ApiCaches"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetApiCacheInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetApiCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetApiCacheOutputError>
}

/// Represents the input of a GetApiCache operation.
public struct GetApiCacheInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?

    public init (
        apiId: Swift.String? = nil
    )
    {
        self.apiId = apiId
    }
}

struct GetApiCacheInputBody: Swift.Equatable {
}

extension GetApiCacheInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetApiCacheOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetApiCacheOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetApiCacheOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetApiCacheOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetApiCacheOutputResponse(apiCache: \(Swift.String(describing: apiCache)))"}
}

extension GetApiCacheOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetApiCacheOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiCache = output.apiCache
        } else {
            self.apiCache = nil
        }
    }
}

/// Represents the output of a GetApiCache operation.
public struct GetApiCacheOutputResponse: Swift.Equatable {
    /// The ApiCache object.
    public var apiCache: AppSyncClientTypes.ApiCache?

    public init (
        apiCache: AppSyncClientTypes.ApiCache? = nil
    )
    {
        self.apiCache = apiCache
    }
}

struct GetApiCacheOutputResponseBody: Swift.Equatable {
    public let apiCache: AppSyncClientTypes.ApiCache?
}

extension GetApiCacheOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiCache
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiCacheDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ApiCache.self, forKey: .apiCache)
        apiCache = apiCacheDecoded
    }
}

extension GetDataSourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDataSourceInput(apiId: \(Swift.String(describing: apiId)), name: \(Swift.String(describing: name)))"}
}

extension GetDataSourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetDataSourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDataSourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDataSourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDataSourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDataSourceOutputError>
}

public struct GetDataSourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDataSourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDataSourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDataSourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDataSourceOutputError>
}

public struct GetDataSourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDataSourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetDataSourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let apiId = input.apiId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("apiId is nil and needs a value for the path of this operation"))))
        }
        guard let name = input.name else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("name is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/v1/apis/\(apiId.urlPercentEncoding())/datasources/\(name.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetDataSourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDataSourceOutputError>
}

public struct GetDataSourceInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The name of the data source.
    /// This member is required.
    public var name: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.name = name
    }
}

struct GetDataSourceInputBody: Swift.Equatable {
}

extension GetDataSourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDataSourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDataSourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDataSourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDataSourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDataSourceOutputResponse(dataSource: \(Swift.String(describing: dataSource)))"}
}

extension GetDataSourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDataSourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataSource = output.dataSource
        } else {
            self.dataSource = nil
        }
    }
}

public struct GetDataSourceOutputResponse: Swift.Equatable {
    /// The DataSource object.
    public var dataSource: AppSyncClientTypes.DataSource?

    public init (
        dataSource: AppSyncClientTypes.DataSource? = nil
    )
    {
        self.dataSource = dataSource
    }
}

struct GetDataSourceOutputResponseBody: Swift.Equatable {
    public let dataSource: AppSyncClientTypes.DataSource?
}

extension GetDataSourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
    }
}

extension GetFunctionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFunctionInput(apiId: \(Swift.String(describing: apiId)), functionId: \(Swift.String(describing: functionId)))"}
}

extension GetFunctionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetFunctionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFunctionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetFunctionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetFunctionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFunctionOutputError>
}

public struct GetFunctionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFunctionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetFunctionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetFunctionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFunctionOutputError>
}

public struct GetFunctionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFunctionInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetFunctionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let apiId = input.apiId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("apiId is nil and needs a value for the path of this operation"))))
        }
        guard let functionId = input.functionId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("functionId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/v1/apis/\(apiId.urlPercentEncoding())/functions/\(functionId.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetFunctionInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFunctionOutputError>
}

public struct GetFunctionInput: Swift.Equatable {
    /// The GraphQL API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The Function ID.
    /// This member is required.
    public var functionId: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        functionId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.functionId = functionId
    }
}

struct GetFunctionInputBody: Swift.Equatable {
}

extension GetFunctionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetFunctionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFunctionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFunctionOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFunctionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFunctionOutputResponse(functionConfiguration: \(Swift.String(describing: functionConfiguration)))"}
}

extension GetFunctionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetFunctionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.functionConfiguration = output.functionConfiguration
        } else {
            self.functionConfiguration = nil
        }
    }
}

public struct GetFunctionOutputResponse: Swift.Equatable {
    /// The Function object.
    public var functionConfiguration: AppSyncClientTypes.FunctionConfiguration?

    public init (
        functionConfiguration: AppSyncClientTypes.FunctionConfiguration? = nil
    )
    {
        self.functionConfiguration = functionConfiguration
    }
}

struct GetFunctionOutputResponseBody: Swift.Equatable {
    public let functionConfiguration: AppSyncClientTypes.FunctionConfiguration?
}

extension GetFunctionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionConfiguration
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionConfigurationDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.FunctionConfiguration.self, forKey: .functionConfiguration)
        functionConfiguration = functionConfigurationDecoded
    }
}

extension GetGraphqlApiInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetGraphqlApiInput(apiId: \(Swift.String(describing: apiId)))"}
}

extension GetGraphqlApiInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetGraphqlApiInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetGraphqlApiInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetGraphqlApiInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetGraphqlApiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetGraphqlApiInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetGraphqlApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetGraphqlApiOutputError>
}

public struct GetGraphqlApiInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetGraphqlApiInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetGraphqlApiInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetGraphqlApiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetGraphqlApiInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetGraphqlApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetGraphqlApiOutputError>
}

public struct GetGraphqlApiInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetGraphqlApiInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetGraphqlApiInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetGraphqlApiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let apiId = input.apiId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("apiId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/v1/apis/\(apiId.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetGraphqlApiInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetGraphqlApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetGraphqlApiOutputError>
}

public struct GetGraphqlApiInput: Swift.Equatable {
    /// The API ID for the GraphQL API.
    /// This member is required.
    public var apiId: Swift.String?

    public init (
        apiId: Swift.String? = nil
    )
    {
        self.apiId = apiId
    }
}

struct GetGraphqlApiInputBody: Swift.Equatable {
}

extension GetGraphqlApiInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetGraphqlApiOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetGraphqlApiOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetGraphqlApiOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetGraphqlApiOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetGraphqlApiOutputResponse(graphqlApi: \(Swift.String(describing: graphqlApi)))"}
}

extension GetGraphqlApiOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetGraphqlApiOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.graphqlApi = output.graphqlApi
        } else {
            self.graphqlApi = nil
        }
    }
}

public struct GetGraphqlApiOutputResponse: Swift.Equatable {
    /// The GraphqlApi object.
    public var graphqlApi: AppSyncClientTypes.GraphqlApi?

    public init (
        graphqlApi: AppSyncClientTypes.GraphqlApi? = nil
    )
    {
        self.graphqlApi = graphqlApi
    }
}

struct GetGraphqlApiOutputResponseBody: Swift.Equatable {
    public let graphqlApi: AppSyncClientTypes.GraphqlApi?
}

extension GetGraphqlApiOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case graphqlApi
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphqlApiDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.GraphqlApi.self, forKey: .graphqlApi)
        graphqlApi = graphqlApiDecoded
    }
}

extension GetIntrospectionSchemaInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetIntrospectionSchemaInput(apiId: \(Swift.String(describing: apiId)), format: \(Swift.String(describing: format)), includeDirectives: \(Swift.String(describing: includeDirectives)))"}
}

extension GetIntrospectionSchemaInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetIntrospectionSchemaInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetIntrospectionSchemaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetIntrospectionSchemaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetIntrospectionSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetIntrospectionSchemaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetIntrospectionSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetIntrospectionSchemaOutputError>
}

public struct GetIntrospectionSchemaInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetIntrospectionSchemaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetIntrospectionSchemaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetIntrospectionSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let includeDirectives = input.operationInput.includeDirectives {
            let includeDirectivesQueryItem = ClientRuntime.URLQueryItem(name: "includeDirectives".urlPercentEncoding(), value: Swift.String(includeDirectives).urlPercentEncoding())
            input.builder.withQueryItem(includeDirectivesQueryItem)
        }
        if let format = input.operationInput.format {
            let formatQueryItem = ClientRuntime.URLQueryItem(name: "format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(formatQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetIntrospectionSchemaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetIntrospectionSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetIntrospectionSchemaOutputError>
}

public struct GetIntrospectionSchemaInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetIntrospectionSchemaInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetIntrospectionSchemaInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetIntrospectionSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let apiId = input.apiId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("apiId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/v1/apis/\(apiId.urlPercentEncoding())/schema"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetIntrospectionSchemaInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetIntrospectionSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetIntrospectionSchemaOutputError>
}

public struct GetIntrospectionSchemaInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The schema format: SDL or JSON.
    /// This member is required.
    public var format: AppSyncClientTypes.OutputType?
    /// A flag that specifies whether the schema introspection should contain directives.
    public var includeDirectives: Swift.Bool?

    public init (
        apiId: Swift.String? = nil,
        format: AppSyncClientTypes.OutputType? = nil,
        includeDirectives: Swift.Bool? = nil
    )
    {
        self.apiId = apiId
        self.format = format
        self.includeDirectives = includeDirectives
    }
}

struct GetIntrospectionSchemaInputBody: Swift.Equatable {
}

extension GetIntrospectionSchemaInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetIntrospectionSchemaOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetIntrospectionSchemaOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "GraphQLSchemaException" : self = .graphQLSchemaException(try GraphQLSchemaException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetIntrospectionSchemaOutputError: Swift.Error, Swift.Equatable {
    case graphQLSchemaException(GraphQLSchemaException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetIntrospectionSchemaOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetIntrospectionSchemaOutputResponse(schema: \(Swift.String(describing: schema)))"}
}

extension GetIntrospectionSchemaOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            self.schema = data
        } else {
            self.schema = nil
        }
    }
}

public struct GetIntrospectionSchemaOutputResponse: Swift.Equatable {
    /// The schema, in GraphQL Schema Definition Language (SDL) format.
    ///          For more information, see the <a href="http://graphql.org/learn/schema/">GraphQL SDL
    ///             documentation.
    public var schema: ClientRuntime.Data?

    public init (
        schema: ClientRuntime.Data? = nil
    )
    {
        self.schema = schema
    }
}

struct GetIntrospectionSchemaOutputResponseBody: Swift.Equatable {
    public let schema: ClientRuntime.Data?
}

extension GetIntrospectionSchemaOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case schema
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .schema)
        schema = schemaDecoded
    }
}

extension GetResolverInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetResolverInput(apiId: \(Swift.String(describing: apiId)), fieldName: \(Swift.String(describing: fieldName)), typeName: \(Swift.String(describing: typeName)))"}
}

extension GetResolverInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetResolverInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetResolverInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetResolverInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetResolverOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetResolverInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetResolverOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetResolverOutputError>
}

public struct GetResolverInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetResolverInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetResolverInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetResolverOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetResolverInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetResolverOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetResolverOutputError>
}

public struct GetResolverInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetResolverInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetResolverInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetResolverOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let apiId = input.apiId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("apiId is nil and needs a value for the path of this operation"))))
        }
        guard let typeName = input.typeName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("typeName is nil and needs a value for the path of this operation"))))
        }
        guard let fieldName = input.fieldName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("fieldName is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/v1/apis/\(apiId.urlPercentEncoding())/types/\(typeName.urlPercentEncoding())/resolvers/\(fieldName.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetResolverInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetResolverOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetResolverOutputError>
}

public struct GetResolverInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The resolver field name.
    /// This member is required.
    public var fieldName: Swift.String?
    /// The resolver type name.
    /// This member is required.
    public var typeName: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        fieldName: Swift.String? = nil,
        typeName: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.fieldName = fieldName
        self.typeName = typeName
    }
}

struct GetResolverInputBody: Swift.Equatable {
}

extension GetResolverInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetResolverOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResolverOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResolverOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResolverOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetResolverOutputResponse(resolver: \(Swift.String(describing: resolver)))"}
}

extension GetResolverOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetResolverOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resolver = output.resolver
        } else {
            self.resolver = nil
        }
    }
}

public struct GetResolverOutputResponse: Swift.Equatable {
    /// The Resolver object.
    public var resolver: AppSyncClientTypes.Resolver?

    public init (
        resolver: AppSyncClientTypes.Resolver? = nil
    )
    {
        self.resolver = resolver
    }
}

struct GetResolverOutputResponseBody: Swift.Equatable {
    public let resolver: AppSyncClientTypes.Resolver?
}

extension GetResolverOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolver
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.Resolver.self, forKey: .resolver)
        resolver = resolverDecoded
    }
}

extension GetSchemaCreationStatusInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSchemaCreationStatusInput(apiId: \(Swift.String(describing: apiId)))"}
}

extension GetSchemaCreationStatusInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetSchemaCreationStatusInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSchemaCreationStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSchemaCreationStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSchemaCreationStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSchemaCreationStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSchemaCreationStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSchemaCreationStatusOutputError>
}

public struct GetSchemaCreationStatusInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSchemaCreationStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSchemaCreationStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSchemaCreationStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSchemaCreationStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSchemaCreationStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSchemaCreationStatusOutputError>
}

public struct GetSchemaCreationStatusInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSchemaCreationStatusInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetSchemaCreationStatusInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSchemaCreationStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let apiId = input.apiId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("apiId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/v1/apis/\(apiId.urlPercentEncoding())/schemacreation"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetSchemaCreationStatusInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetSchemaCreationStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSchemaCreationStatusOutputError>
}

public struct GetSchemaCreationStatusInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?

    public init (
        apiId: Swift.String? = nil
    )
    {
        self.apiId = apiId
    }
}

struct GetSchemaCreationStatusInputBody: Swift.Equatable {
}

extension GetSchemaCreationStatusInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSchemaCreationStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSchemaCreationStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSchemaCreationStatusOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSchemaCreationStatusOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSchemaCreationStatusOutputResponse(details: \(Swift.String(describing: details)), status: \(Swift.String(describing: status)))"}
}

extension GetSchemaCreationStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetSchemaCreationStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.details = output.details
            self.status = output.status
        } else {
            self.details = nil
            self.status = nil
        }
    }
}

public struct GetSchemaCreationStatusOutputResponse: Swift.Equatable {
    /// Detailed information about the status of the schema creation operation.
    public var details: Swift.String?
    /// The current state of the schema (PROCESSING, FAILED, SUCCESS, or NOT_APPLICABLE). When
    ///          the schema is in the ACTIVE state, you can add data.
    public var status: AppSyncClientTypes.SchemaStatus?

    public init (
        details: Swift.String? = nil,
        status: AppSyncClientTypes.SchemaStatus? = nil
    )
    {
        self.details = details
        self.status = status
    }
}

struct GetSchemaCreationStatusOutputResponseBody: Swift.Equatable {
    public let status: AppSyncClientTypes.SchemaStatus?
    public let details: Swift.String?
}

extension GetSchemaCreationStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case details
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.SchemaStatus.self, forKey: .status)
        status = statusDecoded
        let detailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .details)
        details = detailsDecoded
    }
}

extension GetTypeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetTypeInput(apiId: \(Swift.String(describing: apiId)), format: \(Swift.String(describing: format)), typeName: \(Swift.String(describing: typeName)))"}
}

extension GetTypeInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetTypeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTypeOutputError>
}

public struct GetTypeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let format = input.operationInput.format {
            let formatQueryItem = ClientRuntime.URLQueryItem(name: "format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(formatQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTypeOutputError>
}

public struct GetTypeInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTypeInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetTypeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let apiId = input.apiId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("apiId is nil and needs a value for the path of this operation"))))
        }
        guard let typeName = input.typeName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("typeName is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/v1/apis/\(apiId.urlPercentEncoding())/types/\(typeName.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetTypeInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTypeOutputError>
}

public struct GetTypeInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The type format: SDL or JSON.
    /// This member is required.
    public var format: AppSyncClientTypes.TypeDefinitionFormat?
    /// The type name.
    /// This member is required.
    public var typeName: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        format: AppSyncClientTypes.TypeDefinitionFormat? = nil,
        typeName: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.format = format
        self.typeName = typeName
    }
}

struct GetTypeInputBody: Swift.Equatable {
}

extension GetTypeInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetTypeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTypeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTypeOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTypeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetTypeOutputResponse(type: \(Swift.String(describing: type)))"}
}

extension GetTypeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetTypeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.type = output.type
        } else {
            self.type = nil
        }
    }
}

public struct GetTypeOutputResponse: Swift.Equatable {
    /// The Type object.
    public var type: AppSyncClientTypes.ModelType?

    public init (
        type: AppSyncClientTypes.ModelType? = nil
    )
    {
        self.type = type
    }
}

struct GetTypeOutputResponseBody: Swift.Equatable {
    public let type: AppSyncClientTypes.ModelType?
}

extension GetTypeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ModelType.self, forKey: .type)
        type = typeDecoded
    }
}

extension GraphQLSchemaException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GraphQLSchemaException(message: \(Swift.String(describing: message)))"}
}

extension GraphQLSchemaException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GraphQLSchemaExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The GraphQL schema is not valid.
public struct GraphQLSchemaException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct GraphQLSchemaExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension GraphQLSchemaExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppSyncClientTypes.GraphqlApi: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalAuthenticationProviders
        case apiId
        case arn
        case authenticationType
        case lambdaAuthorizerConfig
        case logConfig
        case name
        case openIDConnectConfig
        case tags
        case uris
        case userPoolConfig
        case wafWebAclArn
        case xrayEnabled
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalAuthenticationProviders = additionalAuthenticationProviders {
            var additionalAuthenticationProvidersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalAuthenticationProviders)
            for additionalauthenticationproviders0 in additionalAuthenticationProviders {
                try additionalAuthenticationProvidersContainer.encode(additionalauthenticationproviders0)
            }
        }
        if let apiId = apiId {
            try encodeContainer.encode(apiId, forKey: .apiId)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let authenticationType = authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let lambdaAuthorizerConfig = lambdaAuthorizerConfig {
            try encodeContainer.encode(lambdaAuthorizerConfig, forKey: .lambdaAuthorizerConfig)
        }
        if let logConfig = logConfig {
            try encodeContainer.encode(logConfig, forKey: .logConfig)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let openIDConnectConfig = openIDConnectConfig {
            try encodeContainer.encode(openIDConnectConfig, forKey: .openIDConnectConfig)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let uris = uris {
            var urisContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .uris)
            for (dictKey0, mapofstringtostring0) in uris {
                try urisContainer.encode(mapofstringtostring0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let userPoolConfig = userPoolConfig {
            try encodeContainer.encode(userPoolConfig, forKey: .userPoolConfig)
        }
        if let wafWebAclArn = wafWebAclArn {
            try encodeContainer.encode(wafWebAclArn, forKey: .wafWebAclArn)
        }
        if xrayEnabled != false {
            try encodeContainer.encode(xrayEnabled, forKey: .xrayEnabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let apiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiId)
        apiId = apiIdDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
        let logConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.LogConfig.self, forKey: .logConfig)
        logConfig = logConfigDecoded
        let userPoolConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.UserPoolConfig.self, forKey: .userPoolConfig)
        userPoolConfig = userPoolConfigDecoded
        let openIDConnectConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.OpenIDConnectConfig.self, forKey: .openIDConnectConfig)
        openIDConnectConfig = openIDConnectConfigDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let urisContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .uris)
        var urisDecoded0: [Swift.String:Swift.String]? = nil
        if let urisContainer = urisContainer {
            urisDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in urisContainer {
                if let string0 = string0 {
                    urisDecoded0?[key0] = string0
                }
            }
        }
        uris = urisDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let additionalAuthenticationProvidersContainer = try containerValues.decodeIfPresent([AppSyncClientTypes.AdditionalAuthenticationProvider?].self, forKey: .additionalAuthenticationProviders)
        var additionalAuthenticationProvidersDecoded0:[AppSyncClientTypes.AdditionalAuthenticationProvider]? = nil
        if let additionalAuthenticationProvidersContainer = additionalAuthenticationProvidersContainer {
            additionalAuthenticationProvidersDecoded0 = [AppSyncClientTypes.AdditionalAuthenticationProvider]()
            for structure0 in additionalAuthenticationProvidersContainer {
                if let structure0 = structure0 {
                    additionalAuthenticationProvidersDecoded0?.append(structure0)
                }
            }
        }
        additionalAuthenticationProviders = additionalAuthenticationProvidersDecoded0
        let xrayEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .xrayEnabled)
        xrayEnabled = xrayEnabledDecoded
        let wafWebAclArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .wafWebAclArn)
        wafWebAclArn = wafWebAclArnDecoded
        let lambdaAuthorizerConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.LambdaAuthorizerConfig.self, forKey: .lambdaAuthorizerConfig)
        lambdaAuthorizerConfig = lambdaAuthorizerConfigDecoded
    }
}

extension AppSyncClientTypes.GraphqlApi: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GraphqlApi(additionalAuthenticationProviders: \(Swift.String(describing: additionalAuthenticationProviders)), apiId: \(Swift.String(describing: apiId)), arn: \(Swift.String(describing: arn)), authenticationType: \(Swift.String(describing: authenticationType)), lambdaAuthorizerConfig: \(Swift.String(describing: lambdaAuthorizerConfig)), logConfig: \(Swift.String(describing: logConfig)), name: \(Swift.String(describing: name)), openIDConnectConfig: \(Swift.String(describing: openIDConnectConfig)), tags: \(Swift.String(describing: tags)), uris: \(Swift.String(describing: uris)), userPoolConfig: \(Swift.String(describing: userPoolConfig)), wafWebAclArn: \(Swift.String(describing: wafWebAclArn)), xrayEnabled: \(Swift.String(describing: xrayEnabled)))"}
}

extension AppSyncClientTypes {
    /// Describes a GraphQL API.
    public struct GraphqlApi: Swift.Equatable {
        /// A list of additional authentication providers for the GraphqlApi
        ///          API.
        public var additionalAuthenticationProviders: [AppSyncClientTypes.AdditionalAuthenticationProvider]?
        /// The API ID.
        public var apiId: Swift.String?
        /// The ARN.
        public var arn: Swift.String?
        /// The authentication type.
        public var authenticationType: AppSyncClientTypes.AuthenticationType?
        /// Configuration for Amazon Web Services Lambda function authorization.
        public var lambdaAuthorizerConfig: AppSyncClientTypes.LambdaAuthorizerConfig?
        /// The Amazon CloudWatch Logs configuration.
        public var logConfig: AppSyncClientTypes.LogConfig?
        /// The API name.
        public var name: Swift.String?
        /// The OpenID Connect configuration.
        public var openIDConnectConfig: AppSyncClientTypes.OpenIDConnectConfig?
        /// The tags.
        public var tags: [Swift.String:Swift.String]?
        /// The URIs.
        public var uris: [Swift.String:Swift.String]?
        /// The Amazon Cognito user pool configuration.
        public var userPoolConfig: AppSyncClientTypes.UserPoolConfig?
        /// The ARN of the WAF ACL associated with this GraphqlApi,
        ///          if one exists.
        public var wafWebAclArn: Swift.String?
        /// A flag representing whether X-Ray tracing is enabled for this
        ///          GraphqlApi.
        public var xrayEnabled: Swift.Bool

        public init (
            additionalAuthenticationProviders: [AppSyncClientTypes.AdditionalAuthenticationProvider]? = nil,
            apiId: Swift.String? = nil,
            arn: Swift.String? = nil,
            authenticationType: AppSyncClientTypes.AuthenticationType? = nil,
            lambdaAuthorizerConfig: AppSyncClientTypes.LambdaAuthorizerConfig? = nil,
            logConfig: AppSyncClientTypes.LogConfig? = nil,
            name: Swift.String? = nil,
            openIDConnectConfig: AppSyncClientTypes.OpenIDConnectConfig? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            uris: [Swift.String:Swift.String]? = nil,
            userPoolConfig: AppSyncClientTypes.UserPoolConfig? = nil,
            wafWebAclArn: Swift.String? = nil,
            xrayEnabled: Swift.Bool = false
        )
        {
            self.additionalAuthenticationProviders = additionalAuthenticationProviders
            self.apiId = apiId
            self.arn = arn
            self.authenticationType = authenticationType
            self.lambdaAuthorizerConfig = lambdaAuthorizerConfig
            self.logConfig = logConfig
            self.name = name
            self.openIDConnectConfig = openIDConnectConfig
            self.tags = tags
            self.uris = uris
            self.userPoolConfig = userPoolConfig
            self.wafWebAclArn = wafWebAclArn
            self.xrayEnabled = xrayEnabled
        }
    }

}

extension AppSyncClientTypes.HttpDataSourceConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizationConfig
        case endpoint
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizationConfig = authorizationConfig {
            try encodeContainer.encode(authorizationConfig, forKey: .authorizationConfig)
        }
        if let endpoint = endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let authorizationConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.AuthorizationConfig.self, forKey: .authorizationConfig)
        authorizationConfig = authorizationConfigDecoded
    }
}

extension AppSyncClientTypes.HttpDataSourceConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HttpDataSourceConfig(authorizationConfig: \(Swift.String(describing: authorizationConfig)), endpoint: \(Swift.String(describing: endpoint)))"}
}

extension AppSyncClientTypes {
    /// Describes an HTTP data source configuration.
    public struct HttpDataSourceConfig: Swift.Equatable {
        /// The authorization config in case the HTTP endpoint requires authorization.
        public var authorizationConfig: AppSyncClientTypes.AuthorizationConfig?
        /// The HTTP URL endpoint. You can either specify the domain name or IP, and port
        ///          combination, and the URL scheme must be HTTP or HTTPS. If the port is not specified,
        ///             AppSync uses the default port 80 for the HTTP endpoint and port 443 for
        ///          HTTPS endpoints.
        public var endpoint: Swift.String?

        public init (
            authorizationConfig: AppSyncClientTypes.AuthorizationConfig? = nil,
            endpoint: Swift.String? = nil
        )
        {
            self.authorizationConfig = authorizationConfig
            self.endpoint = endpoint
        }
    }

}

extension InternalFailureException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalFailureException(message: \(Swift.String(describing: message)))"}
}

extension InternalFailureException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An internal AppSync error occurred. Try your request again.
public struct InternalFailureException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalFailureExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppSyncClientTypes.LambdaAuthorizerConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizerResultTtlInSeconds
        case authorizerUri
        case identityValidationExpression
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if authorizerResultTtlInSeconds != 0 {
            try encodeContainer.encode(authorizerResultTtlInSeconds, forKey: .authorizerResultTtlInSeconds)
        }
        if let authorizerUri = authorizerUri {
            try encodeContainer.encode(authorizerUri, forKey: .authorizerUri)
        }
        if let identityValidationExpression = identityValidationExpression {
            try encodeContainer.encode(identityValidationExpression, forKey: .identityValidationExpression)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizerResultTtlInSecondsDecoded = try containerValues.decode(Swift.Int.self, forKey: .authorizerResultTtlInSeconds)
        authorizerResultTtlInSeconds = authorizerResultTtlInSecondsDecoded
        let authorizerUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerUri)
        authorizerUri = authorizerUriDecoded
        let identityValidationExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityValidationExpression)
        identityValidationExpression = identityValidationExpressionDecoded
    }
}

extension AppSyncClientTypes.LambdaAuthorizerConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LambdaAuthorizerConfig(authorizerResultTtlInSeconds: \(Swift.String(describing: authorizerResultTtlInSeconds)), authorizerUri: \(Swift.String(describing: authorizerUri)), identityValidationExpression: \(Swift.String(describing: identityValidationExpression)))"}
}

extension AppSyncClientTypes {
    /// A LambdaAuthorizerConfig holds configuration on how to authorize AppSync
    ///          API access when using the AWS_LAMBDA authorizer mode. Be aware that an AppSync
    ///          API may have only one Lambda authorizer configured at a time.
    public struct LambdaAuthorizerConfig: Swift.Equatable {
        /// The number of seconds a response should be cached for. The default is 5 minutes (300
        ///          seconds). The Lambda function can override this by returning a ttlOverride key
        ///          in its response. A value of 0 disables caching of responses.
        public var authorizerResultTtlInSeconds: Swift.Int
        /// The ARN of the Lambda function to be called for authorization. This may be a standard
        ///          Lambda ARN, a version ARN (.../v3) or alias ARN.
        ///
        ///             Note: This Lambda function must have the following resource-based
        ///          policy assigned to it. When configuring Lambda authorizers in the Console, this is done for
        ///          you. To do so with the Amazon Web Services CLI, run the following:
        ///
        ///             aws lambda add-permission --function-name
        ///             "arn:aws:lambda:us-east-2:111122223333:function:my-function" --statement-id "appsync"
        ///             --principal appsync.amazonaws.com --action lambda:InvokeFunction
        ///
        /// This member is required.
        public var authorizerUri: Swift.String?
        /// A regular expression for validation of tokens before the Lambda function is
        ///          called.
        public var identityValidationExpression: Swift.String?

        public init (
            authorizerResultTtlInSeconds: Swift.Int = 0,
            authorizerUri: Swift.String? = nil,
            identityValidationExpression: Swift.String? = nil
        )
        {
            self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
            self.authorizerUri = authorizerUri
            self.identityValidationExpression = identityValidationExpression
        }
    }

}

extension AppSyncClientTypes.LambdaConflictHandlerConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lambdaConflictHandlerArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lambdaConflictHandlerArn = lambdaConflictHandlerArn {
            try encodeContainer.encode(lambdaConflictHandlerArn, forKey: .lambdaConflictHandlerArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lambdaConflictHandlerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lambdaConflictHandlerArn)
        lambdaConflictHandlerArn = lambdaConflictHandlerArnDecoded
    }
}

extension AppSyncClientTypes.LambdaConflictHandlerConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LambdaConflictHandlerConfig(lambdaConflictHandlerArn: \(Swift.String(describing: lambdaConflictHandlerArn)))"}
}

extension AppSyncClientTypes {
    /// The LambdaConflictHandlerConfig object when configuring LAMBDA as the
    ///          Conflict Handler.
    public struct LambdaConflictHandlerConfig: Swift.Equatable {
        /// The Arn for the Lambda function to use as the Conflict Handler.
        public var lambdaConflictHandlerArn: Swift.String?

        public init (
            lambdaConflictHandlerArn: Swift.String? = nil
        )
        {
            self.lambdaConflictHandlerArn = lambdaConflictHandlerArn
        }
    }

}

extension AppSyncClientTypes.LambdaDataSourceConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lambdaFunctionArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lambdaFunctionArn = lambdaFunctionArn {
            try encodeContainer.encode(lambdaFunctionArn, forKey: .lambdaFunctionArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lambdaFunctionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lambdaFunctionArn)
        lambdaFunctionArn = lambdaFunctionArnDecoded
    }
}

extension AppSyncClientTypes.LambdaDataSourceConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LambdaDataSourceConfig(lambdaFunctionArn: \(Swift.String(describing: lambdaFunctionArn)))"}
}

extension AppSyncClientTypes {
    /// Describes an Amazon Web Services Lambda data source configuration.
    public struct LambdaDataSourceConfig: Swift.Equatable {
        /// The ARN for the Lambda function.
        /// This member is required.
        public var lambdaFunctionArn: Swift.String?

        public init (
            lambdaFunctionArn: Swift.String? = nil
        )
        {
            self.lambdaFunctionArn = lambdaFunctionArn
        }
    }

}

extension LimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request exceeded a limit. Try your request again.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListApiKeysInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListApiKeysInput(apiId: \(Swift.String(describing: apiId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListApiKeysInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListApiKeysInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListApiKeysInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListApiKeysInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListApiKeysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListApiKeysInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListApiKeysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListApiKeysOutputError>
}

public struct ListApiKeysInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListApiKeysInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListApiKeysInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListApiKeysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListApiKeysInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListApiKeysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListApiKeysOutputError>
}

public struct ListApiKeysInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListApiKeysInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListApiKeysInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListApiKeysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let apiId = input.apiId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("apiId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/v1/apis/\(apiId.urlPercentEncoding())/apikeys"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListApiKeysInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListApiKeysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListApiKeysOutputError>
}

public struct ListApiKeysInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The maximum number of results you want the request to return.
    public var maxResults: Swift.Int
    /// An identifier that was returned from the previous call to this operation, which can be
    ///          used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListApiKeysInputBody: Swift.Equatable {
}

extension ListApiKeysInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListApiKeysOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListApiKeysOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListApiKeysOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListApiKeysOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListApiKeysOutputResponse(apiKeys: \(Swift.String(describing: apiKeys)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListApiKeysOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListApiKeysOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiKeys = output.apiKeys
            self.nextToken = output.nextToken
        } else {
            self.apiKeys = nil
            self.nextToken = nil
        }
    }
}

public struct ListApiKeysOutputResponse: Swift.Equatable {
    /// The ApiKey objects.
    public var apiKeys: [AppSyncClientTypes.ApiKey]?
    /// An identifier to be passed in the next request to this operation to return the next set
    ///          of items in the list.
    public var nextToken: Swift.String?

    public init (
        apiKeys: [AppSyncClientTypes.ApiKey]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.apiKeys = apiKeys
        self.nextToken = nextToken
    }
}

struct ListApiKeysOutputResponseBody: Swift.Equatable {
    public let apiKeys: [AppSyncClientTypes.ApiKey]?
    public let nextToken: Swift.String?
}

extension ListApiKeysOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeys
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiKeysContainer = try containerValues.decodeIfPresent([AppSyncClientTypes.ApiKey?].self, forKey: .apiKeys)
        var apiKeysDecoded0:[AppSyncClientTypes.ApiKey]? = nil
        if let apiKeysContainer = apiKeysContainer {
            apiKeysDecoded0 = [AppSyncClientTypes.ApiKey]()
            for structure0 in apiKeysContainer {
                if let structure0 = structure0 {
                    apiKeysDecoded0?.append(structure0)
                }
            }
        }
        apiKeys = apiKeysDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDataSourcesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDataSourcesInput(apiId: \(Swift.String(describing: apiId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDataSourcesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListDataSourcesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDataSourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDataSourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDataSourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDataSourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDataSourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDataSourcesOutputError>
}

public struct ListDataSourcesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDataSourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDataSourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDataSourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDataSourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDataSourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDataSourcesOutputError>
}

public struct ListDataSourcesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDataSourcesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListDataSourcesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDataSourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let apiId = input.apiId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("apiId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/v1/apis/\(apiId.urlPercentEncoding())/datasources"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDataSourcesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDataSourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDataSourcesOutputError>
}

public struct ListDataSourcesInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The maximum number of results you want the request to return.
    public var maxResults: Swift.Int
    /// An identifier that was returned from the previous call to this operation, which can be
    ///          used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDataSourcesInputBody: Swift.Equatable {
}

extension ListDataSourcesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDataSourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDataSourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDataSourcesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDataSourcesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDataSourcesOutputResponse(dataSources: \(Swift.String(describing: dataSources)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDataSourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDataSourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataSources = output.dataSources
            self.nextToken = output.nextToken
        } else {
            self.dataSources = nil
            self.nextToken = nil
        }
    }
}

public struct ListDataSourcesOutputResponse: Swift.Equatable {
    /// The DataSource objects.
    public var dataSources: [AppSyncClientTypes.DataSource]?
    /// An identifier to be passed in the next request to this operation to return the next set
    ///          of items in the list.
    public var nextToken: Swift.String?

    public init (
        dataSources: [AppSyncClientTypes.DataSource]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dataSources = dataSources
        self.nextToken = nextToken
    }
}

struct ListDataSourcesOutputResponseBody: Swift.Equatable {
    public let dataSources: [AppSyncClientTypes.DataSource]?
    public let nextToken: Swift.String?
}

extension ListDataSourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSources
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourcesContainer = try containerValues.decodeIfPresent([AppSyncClientTypes.DataSource?].self, forKey: .dataSources)
        var dataSourcesDecoded0:[AppSyncClientTypes.DataSource]? = nil
        if let dataSourcesContainer = dataSourcesContainer {
            dataSourcesDecoded0 = [AppSyncClientTypes.DataSource]()
            for structure0 in dataSourcesContainer {
                if let structure0 = structure0 {
                    dataSourcesDecoded0?.append(structure0)
                }
            }
        }
        dataSources = dataSourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFunctionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListFunctionsInput(apiId: \(Swift.String(describing: apiId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListFunctionsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListFunctionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFunctionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFunctionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFunctionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFunctionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFunctionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFunctionsOutputError>
}

public struct ListFunctionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFunctionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFunctionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFunctionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFunctionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFunctionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFunctionsOutputError>
}

public struct ListFunctionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFunctionsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListFunctionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFunctionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let apiId = input.apiId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("apiId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/v1/apis/\(apiId.urlPercentEncoding())/functions"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListFunctionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListFunctionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFunctionsOutputError>
}

public struct ListFunctionsInput: Swift.Equatable {
    /// The GraphQL API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The maximum number of results you want the request to return.
    public var maxResults: Swift.Int
    /// An identifier that was returned from the previous call to this operation, which can be
    ///          used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFunctionsInputBody: Swift.Equatable {
}

extension ListFunctionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListFunctionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFunctionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFunctionsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFunctionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListFunctionsOutputResponse(functions: \(Swift.String(describing: functions)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListFunctionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListFunctionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.functions = output.functions
            self.nextToken = output.nextToken
        } else {
            self.functions = nil
            self.nextToken = nil
        }
    }
}

public struct ListFunctionsOutputResponse: Swift.Equatable {
    /// A list of Function objects.
    public var functions: [AppSyncClientTypes.FunctionConfiguration]?
    /// An identifier that was returned from the previous call to this operation, which can be
    ///          used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        functions: [AppSyncClientTypes.FunctionConfiguration]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.functions = functions
        self.nextToken = nextToken
    }
}

struct ListFunctionsOutputResponseBody: Swift.Equatable {
    public let functions: [AppSyncClientTypes.FunctionConfiguration]?
    public let nextToken: Swift.String?
}

extension ListFunctionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functions
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionsContainer = try containerValues.decodeIfPresent([AppSyncClientTypes.FunctionConfiguration?].self, forKey: .functions)
        var functionsDecoded0:[AppSyncClientTypes.FunctionConfiguration]? = nil
        if let functionsContainer = functionsContainer {
            functionsDecoded0 = [AppSyncClientTypes.FunctionConfiguration]()
            for structure0 in functionsContainer {
                if let structure0 = structure0 {
                    functionsDecoded0?.append(structure0)
                }
            }
        }
        functions = functionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListGraphqlApisInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListGraphqlApisInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListGraphqlApisInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListGraphqlApisInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListGraphqlApisInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListGraphqlApisInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListGraphqlApisOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListGraphqlApisInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListGraphqlApisOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListGraphqlApisOutputError>
}

public struct ListGraphqlApisInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListGraphqlApisInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListGraphqlApisInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListGraphqlApisOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListGraphqlApisInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListGraphqlApisOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListGraphqlApisOutputError>
}

public struct ListGraphqlApisInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListGraphqlApisInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListGraphqlApisInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListGraphqlApisOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/v1/apis"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListGraphqlApisInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListGraphqlApisOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListGraphqlApisOutputError>
}

public struct ListGraphqlApisInput: Swift.Equatable {
    /// The maximum number of results you want the request to return.
    public var maxResults: Swift.Int
    /// An identifier that was returned from the previous call to this operation, which can be
    ///          used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListGraphqlApisInputBody: Swift.Equatable {
}

extension ListGraphqlApisInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListGraphqlApisOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListGraphqlApisOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListGraphqlApisOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGraphqlApisOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListGraphqlApisOutputResponse(graphqlApis: \(Swift.String(describing: graphqlApis)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListGraphqlApisOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListGraphqlApisOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.graphqlApis = output.graphqlApis
            self.nextToken = output.nextToken
        } else {
            self.graphqlApis = nil
            self.nextToken = nil
        }
    }
}

public struct ListGraphqlApisOutputResponse: Swift.Equatable {
    /// The GraphqlApi objects.
    public var graphqlApis: [AppSyncClientTypes.GraphqlApi]?
    /// An identifier to be passed in the next request to this operation to return the next set
    ///          of items in the list.
    public var nextToken: Swift.String?

    public init (
        graphqlApis: [AppSyncClientTypes.GraphqlApi]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.graphqlApis = graphqlApis
        self.nextToken = nextToken
    }
}

struct ListGraphqlApisOutputResponseBody: Swift.Equatable {
    public let graphqlApis: [AppSyncClientTypes.GraphqlApi]?
    public let nextToken: Swift.String?
}

extension ListGraphqlApisOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case graphqlApis
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphqlApisContainer = try containerValues.decodeIfPresent([AppSyncClientTypes.GraphqlApi?].self, forKey: .graphqlApis)
        var graphqlApisDecoded0:[AppSyncClientTypes.GraphqlApi]? = nil
        if let graphqlApisContainer = graphqlApisContainer {
            graphqlApisDecoded0 = [AppSyncClientTypes.GraphqlApi]()
            for structure0 in graphqlApisContainer {
                if let structure0 = structure0 {
                    graphqlApisDecoded0?.append(structure0)
                }
            }
        }
        graphqlApis = graphqlApisDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListResolversByFunctionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListResolversByFunctionInput(apiId: \(Swift.String(describing: apiId)), functionId: \(Swift.String(describing: functionId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListResolversByFunctionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListResolversByFunctionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResolversByFunctionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListResolversByFunctionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResolversByFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListResolversByFunctionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListResolversByFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResolversByFunctionOutputError>
}

public struct ListResolversByFunctionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResolversByFunctionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListResolversByFunctionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResolversByFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListResolversByFunctionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListResolversByFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResolversByFunctionOutputError>
}

public struct ListResolversByFunctionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResolversByFunctionInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListResolversByFunctionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResolversByFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let apiId = input.apiId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("apiId is nil and needs a value for the path of this operation"))))
        }
        guard let functionId = input.functionId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("functionId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/v1/apis/\(apiId.urlPercentEncoding())/functions/\(functionId.urlPercentEncoding())/resolvers"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListResolversByFunctionInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListResolversByFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResolversByFunctionOutputError>
}

public struct ListResolversByFunctionInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The Function ID.
    /// This member is required.
    public var functionId: Swift.String?
    /// The maximum number of results you want the request to return.
    public var maxResults: Swift.Int
    /// An identifier that was returned from the previous call to this operation, which you can
    ///          use to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        functionId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.functionId = functionId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListResolversByFunctionInputBody: Swift.Equatable {
}

extension ListResolversByFunctionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListResolversByFunctionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResolversByFunctionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResolversByFunctionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResolversByFunctionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListResolversByFunctionOutputResponse(nextToken: \(Swift.String(describing: nextToken)), resolvers: \(Swift.String(describing: resolvers)))"}
}

extension ListResolversByFunctionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListResolversByFunctionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resolvers = output.resolvers
        } else {
            self.nextToken = nil
            self.resolvers = nil
        }
    }
}

public struct ListResolversByFunctionOutputResponse: Swift.Equatable {
    /// An identifier that can be used to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// The list of resolvers.
    public var resolvers: [AppSyncClientTypes.Resolver]?

    public init (
        nextToken: Swift.String? = nil,
        resolvers: [AppSyncClientTypes.Resolver]? = nil
    )
    {
        self.nextToken = nextToken
        self.resolvers = resolvers
    }
}

struct ListResolversByFunctionOutputResponseBody: Swift.Equatable {
    public let resolvers: [AppSyncClientTypes.Resolver]?
    public let nextToken: Swift.String?
}

extension ListResolversByFunctionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case resolvers
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolversContainer = try containerValues.decodeIfPresent([AppSyncClientTypes.Resolver?].self, forKey: .resolvers)
        var resolversDecoded0:[AppSyncClientTypes.Resolver]? = nil
        if let resolversContainer = resolversContainer {
            resolversDecoded0 = [AppSyncClientTypes.Resolver]()
            for structure0 in resolversContainer {
                if let structure0 = structure0 {
                    resolversDecoded0?.append(structure0)
                }
            }
        }
        resolvers = resolversDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListResolversInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListResolversInput(apiId: \(Swift.String(describing: apiId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), typeName: \(Swift.String(describing: typeName)))"}
}

extension ListResolversInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListResolversInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResolversInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListResolversInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResolversOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListResolversInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListResolversOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResolversOutputError>
}

public struct ListResolversInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResolversInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListResolversInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResolversOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListResolversInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListResolversOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResolversOutputError>
}

public struct ListResolversInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResolversInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListResolversInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResolversOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let apiId = input.apiId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("apiId is nil and needs a value for the path of this operation"))))
        }
        guard let typeName = input.typeName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("typeName is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/v1/apis/\(apiId.urlPercentEncoding())/types/\(typeName.urlPercentEncoding())/resolvers"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListResolversInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListResolversOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResolversOutputError>
}

public struct ListResolversInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The maximum number of results you want the request to return.
    public var maxResults: Swift.Int
    /// An identifier that was returned from the previous call to this operation, which can be
    ///          used to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// The type name.
    /// This member is required.
    public var typeName: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        typeName: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.typeName = typeName
    }
}

struct ListResolversInputBody: Swift.Equatable {
}

extension ListResolversInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListResolversOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResolversOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResolversOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResolversOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListResolversOutputResponse(nextToken: \(Swift.String(describing: nextToken)), resolvers: \(Swift.String(describing: resolvers)))"}
}

extension ListResolversOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListResolversOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resolvers = output.resolvers
        } else {
            self.nextToken = nil
            self.resolvers = nil
        }
    }
}

public struct ListResolversOutputResponse: Swift.Equatable {
    /// An identifier to be passed in the next request to this operation to return the next set
    ///          of items in the list.
    public var nextToken: Swift.String?
    /// The Resolver objects.
    public var resolvers: [AppSyncClientTypes.Resolver]?

    public init (
        nextToken: Swift.String? = nil,
        resolvers: [AppSyncClientTypes.Resolver]? = nil
    )
    {
        self.nextToken = nextToken
        self.resolvers = resolvers
    }
}

struct ListResolversOutputResponseBody: Swift.Equatable {
    public let resolvers: [AppSyncClientTypes.Resolver]?
    public let nextToken: Swift.String?
}

extension ListResolversOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case resolvers
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolversContainer = try containerValues.decodeIfPresent([AppSyncClientTypes.Resolver?].self, forKey: .resolvers)
        var resolversDecoded0:[AppSyncClientTypes.Resolver]? = nil
        if let resolversContainer = resolversContainer {
            resolversDecoded0 = [AppSyncClientTypes.Resolver]()
            for structure0 in resolversContainer {
                if let structure0 = structure0 {
                    resolversDecoded0?.append(structure0)
                }
            }
        }
        resolvers = resolversDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/v1/tags/\(resourceArn.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The GraphqlApi ARN.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// A TagMap object.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListTypesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTypesInput(apiId: \(Swift.String(describing: apiId)), format: \(Swift.String(describing: format)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListTypesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTypesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTypesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTypesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTypesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTypesOutputError>
}

public struct ListTypesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTypesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTypesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let format = input.operationInput.format {
            let formatQueryItem = ClientRuntime.URLQueryItem(name: "format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(formatQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTypesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTypesOutputError>
}

public struct ListTypesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTypesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListTypesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let apiId = input.apiId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("apiId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/v1/apis/\(apiId.urlPercentEncoding())/types"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTypesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTypesOutputError>
}

public struct ListTypesInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The type format: SDL or JSON.
    /// This member is required.
    public var format: AppSyncClientTypes.TypeDefinitionFormat?
    /// The maximum number of results you want the request to return.
    public var maxResults: Swift.Int
    /// An identifier that was returned from the previous call to this operation, which can be
    ///          used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        format: AppSyncClientTypes.TypeDefinitionFormat? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.format = format
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListTypesInputBody: Swift.Equatable {
}

extension ListTypesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTypesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTypesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTypesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTypesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTypesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), types: \(Swift.String(describing: types)))"}
}

extension ListTypesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTypesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.types = output.types
        } else {
            self.nextToken = nil
            self.types = nil
        }
    }
}

public struct ListTypesOutputResponse: Swift.Equatable {
    /// An identifier to be passed in the next request to this operation to return the next set
    ///          of items in the list.
    public var nextToken: Swift.String?
    /// The Type objects.
    public var types: [AppSyncClientTypes.ModelType]?

    public init (
        nextToken: Swift.String? = nil,
        types: [AppSyncClientTypes.ModelType]? = nil
    )
    {
        self.nextToken = nextToken
        self.types = types
    }
}

struct ListTypesOutputResponseBody: Swift.Equatable {
    public let types: [AppSyncClientTypes.ModelType]?
    public let nextToken: Swift.String?
}

extension ListTypesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case types
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typesContainer = try containerValues.decodeIfPresent([AppSyncClientTypes.ModelType?].self, forKey: .types)
        var typesDecoded0:[AppSyncClientTypes.ModelType]? = nil
        if let typesContainer = typesContainer {
            typesDecoded0 = [AppSyncClientTypes.ModelType]()
            for structure0 in typesContainer {
                if let structure0 = structure0 {
                    typesDecoded0?.append(structure0)
                }
            }
        }
        types = typesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension AppSyncClientTypes.LogConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogsRoleArn
        case excludeVerboseContent
        case fieldLogLevel
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogsRoleArn = cloudWatchLogsRoleArn {
            try encodeContainer.encode(cloudWatchLogsRoleArn, forKey: .cloudWatchLogsRoleArn)
        }
        if excludeVerboseContent != false {
            try encodeContainer.encode(excludeVerboseContent, forKey: .excludeVerboseContent)
        }
        if let fieldLogLevel = fieldLogLevel {
            try encodeContainer.encode(fieldLogLevel.rawValue, forKey: .fieldLogLevel)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLogLevelDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.FieldLogLevel.self, forKey: .fieldLogLevel)
        fieldLogLevel = fieldLogLevelDecoded
        let cloudWatchLogsRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchLogsRoleArn)
        cloudWatchLogsRoleArn = cloudWatchLogsRoleArnDecoded
        let excludeVerboseContentDecoded = try containerValues.decode(Swift.Bool.self, forKey: .excludeVerboseContent)
        excludeVerboseContent = excludeVerboseContentDecoded
    }
}

extension AppSyncClientTypes.LogConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LogConfig(cloudWatchLogsRoleArn: \(Swift.String(describing: cloudWatchLogsRoleArn)), excludeVerboseContent: \(Swift.String(describing: excludeVerboseContent)), fieldLogLevel: \(Swift.String(describing: fieldLogLevel)))"}
}

extension AppSyncClientTypes {
    /// The CloudWatch Logs configuration.
    public struct LogConfig: Swift.Equatable {
        /// The service role that AppSync will assume to publish to Amazon
        ///          CloudWatch logs in your account.
        /// This member is required.
        public var cloudWatchLogsRoleArn: Swift.String?
        /// Set to TRUE to exclude sections that contain information such as headers, context, and
        ///          evaluated mapping templates, regardless of logging level.
        public var excludeVerboseContent: Swift.Bool
        /// The field logging level. Values can be NONE, ERROR, or ALL.
        ///
        ///
        ///
        ///                   NONE: No field-level logs are
        ///                captured.
        ///
        ///
        ///
        ///                   ERROR: Logs the following information only for
        ///                the fields that are in error:
        ///
        ///
        ///                      The error section in the server response.
        ///
        ///
        ///                      Field-level errors.
        ///
        ///
        ///                      The generated request/response functions that got resolved for error
        ///                      fields.
        ///
        ///
        ///
        ///
        ///
        ///                   ALL: The following information is logged for
        ///                all fields in the query:
        ///
        ///
        ///                      Field-level tracing information.
        ///
        ///
        ///                      The generated request/response functions that got resolved for each
        ///                      field.
        ///
        ///
        ///
        ///
        /// This member is required.
        public var fieldLogLevel: AppSyncClientTypes.FieldLogLevel?

        public init (
            cloudWatchLogsRoleArn: Swift.String? = nil,
            excludeVerboseContent: Swift.Bool = false,
            fieldLogLevel: AppSyncClientTypes.FieldLogLevel? = nil
        )
        {
            self.cloudWatchLogsRoleArn = cloudWatchLogsRoleArn
            self.excludeVerboseContent = excludeVerboseContent
            self.fieldLogLevel = fieldLogLevel
        }
    }

}

extension AppSyncClientTypes.ModelType: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case definition
        case description
        case format
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let definition = definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .definition)
        definition = definitionDecoded
        let formatDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.TypeDefinitionFormat.self, forKey: .format)
        format = formatDecoded
    }
}

extension NotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotFoundException(message: \(Swift.String(describing: message)))"}
}

extension NotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource specified in the request was not found. Check the resource, and then try
///          again.
public struct NotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppSyncClientTypes.OpenIDConnectConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authTTL
        case clientId
        case iatTTL
        case issuer
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if authTTL != 0 {
            try encodeContainer.encode(authTTL, forKey: .authTTL)
        }
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if iatTTL != 0 {
            try encodeContainer.encode(iatTTL, forKey: .iatTTL)
        }
        if let issuer = issuer {
            try encodeContainer.encode(issuer, forKey: .issuer)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let issuerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .issuer)
        issuer = issuerDecoded
        let clientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let iatTTLDecoded = try containerValues.decode(Swift.Int.self, forKey: .iatTTL)
        iatTTL = iatTTLDecoded
        let authTTLDecoded = try containerValues.decode(Swift.Int.self, forKey: .authTTL)
        authTTL = authTTLDecoded
    }
}

extension AppSyncClientTypes.OpenIDConnectConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OpenIDConnectConfig(authTTL: \(Swift.String(describing: authTTL)), clientId: \(Swift.String(describing: clientId)), iatTTL: \(Swift.String(describing: iatTTL)), issuer: \(Swift.String(describing: issuer)))"}
}

extension AppSyncClientTypes {
    /// Describes an OpenID Connect configuration.
    public struct OpenIDConnectConfig: Swift.Equatable {
        /// The number of milliseconds a token is valid after being authenticated.
        public var authTTL: Swift.Int
        /// The client identifier of the Relying party at the OpenID identity provider. This
        ///          identifier is typically obtained when the Relying party is registered with the OpenID
        ///          identity provider. You can specify a regular expression so the AppSync can
        ///          validate against multiple client identifiers at a time.
        public var clientId: Swift.String?
        /// The number of milliseconds a token is valid after being issued to a user.
        public var iatTTL: Swift.Int
        /// The issuer for the OpenID Connect configuration. The issuer returned by discovery must
        ///          exactly match the value of iss in the ID token.
        /// This member is required.
        public var issuer: Swift.String?

        public init (
            authTTL: Swift.Int = 0,
            clientId: Swift.String? = nil,
            iatTTL: Swift.Int = 0,
            issuer: Swift.String? = nil
        )
        {
            self.authTTL = authTTL
            self.clientId = clientId
            self.iatTTL = iatTTL
            self.issuer = issuer
        }
    }

}

extension AppSyncClientTypes.OpenSearchServiceDataSourceConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion
        case endpoint
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let endpoint = endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
    }
}

extension AppSyncClientTypes.OpenSearchServiceDataSourceConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OpenSearchServiceDataSourceConfig(awsRegion: \(Swift.String(describing: awsRegion)), endpoint: \(Swift.String(describing: endpoint)))"}
}

extension AppSyncClientTypes {
    /// Describes an OpenSearch data source configuration.
    public struct OpenSearchServiceDataSourceConfig: Swift.Equatable {
        /// The Amazon Web Services Region.
        /// This member is required.
        public var awsRegion: Swift.String?
        /// The endpoint.
        /// This member is required.
        public var endpoint: Swift.String?

        public init (
            awsRegion: Swift.String? = nil,
            endpoint: Swift.String? = nil
        )
        {
            self.awsRegion = awsRegion
            self.endpoint = endpoint
        }
    }

}

extension AppSyncClientTypes {
    public enum OutputType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case json
        case sdl
        case sdkUnknown(Swift.String)

        public static var allCases: [OutputType] {
            return [
                .json,
                .sdl,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .json: return "JSON"
            case .sdl: return "SDL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OutputType(rawValue: rawValue) ?? OutputType.sdkUnknown(rawValue)
        }
    }
}

extension AppSyncClientTypes.PipelineConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let functions = functions {
            var functionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .functions)
            for functionsids0 in functions {
                try functionsContainer.encode(functionsids0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .functions)
        var functionsDecoded0:[Swift.String]? = nil
        if let functionsContainer = functionsContainer {
            functionsDecoded0 = [Swift.String]()
            for string0 in functionsContainer {
                if let string0 = string0 {
                    functionsDecoded0?.append(string0)
                }
            }
        }
        functions = functionsDecoded0
    }
}

extension AppSyncClientTypes.PipelineConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PipelineConfig(functions: \(Swift.String(describing: functions)))"}
}

extension AppSyncClientTypes {
    /// The pipeline configuration for a resolver of kind PIPELINE.
    public struct PipelineConfig: Swift.Equatable {
        /// A list of Function objects.
        public var functions: [Swift.String]?

        public init (
            functions: [Swift.String]? = nil
        )
        {
            self.functions = functions
        }
    }

}

extension AppSyncClientTypes.RdsHttpEndpointConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion
        case awsSecretStoreArn
        case databaseName
        case dbClusterIdentifier
        case schema
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let awsSecretStoreArn = awsSecretStoreArn {
            try encodeContainer.encode(awsSecretStoreArn, forKey: .awsSecretStoreArn)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let dbClusterIdentifier = dbClusterIdentifier {
            try encodeContainer.encode(dbClusterIdentifier, forKey: .dbClusterIdentifier)
        }
        if let schema = schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let dbClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbClusterIdentifier)
        dbClusterIdentifier = dbClusterIdentifierDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schema)
        schema = schemaDecoded
        let awsSecretStoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsSecretStoreArn)
        awsSecretStoreArn = awsSecretStoreArnDecoded
    }
}

extension AppSyncClientTypes.RdsHttpEndpointConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RdsHttpEndpointConfig(awsRegion: \(Swift.String(describing: awsRegion)), awsSecretStoreArn: \(Swift.String(describing: awsSecretStoreArn)), databaseName: \(Swift.String(describing: databaseName)), dbClusterIdentifier: \(Swift.String(describing: dbClusterIdentifier)), schema: \(Swift.String(describing: schema)))"}
}

extension AppSyncClientTypes {
    /// The Amazon RDS HTTP endpoint configuration.
    public struct RdsHttpEndpointConfig: Swift.Equatable {
        /// Amazon Web Services Region for RDS HTTP endpoint.
        public var awsRegion: Swift.String?
        /// Amazon Web Services secret store ARN for database credentials.
        public var awsSecretStoreArn: Swift.String?
        /// Logical database name.
        public var databaseName: Swift.String?
        /// Amazon RDS cluster ARN.
        public var dbClusterIdentifier: Swift.String?
        /// Logical schema name.
        public var schema: Swift.String?

        public init (
            awsRegion: Swift.String? = nil,
            awsSecretStoreArn: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            dbClusterIdentifier: Swift.String? = nil,
            schema: Swift.String? = nil
        )
        {
            self.awsRegion = awsRegion
            self.awsSecretStoreArn = awsSecretStoreArn
            self.databaseName = databaseName
            self.dbClusterIdentifier = dbClusterIdentifier
            self.schema = schema
        }
    }

}

extension AppSyncClientTypes.RelationalDatabaseDataSourceConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rdsHttpEndpointConfig
        case relationalDatabaseSourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rdsHttpEndpointConfig = rdsHttpEndpointConfig {
            try encodeContainer.encode(rdsHttpEndpointConfig, forKey: .rdsHttpEndpointConfig)
        }
        if let relationalDatabaseSourceType = relationalDatabaseSourceType {
            try encodeContainer.encode(relationalDatabaseSourceType.rawValue, forKey: .relationalDatabaseSourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let relationalDatabaseSourceTypeDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.RelationalDatabaseSourceType.self, forKey: .relationalDatabaseSourceType)
        relationalDatabaseSourceType = relationalDatabaseSourceTypeDecoded
        let rdsHttpEndpointConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.RdsHttpEndpointConfig.self, forKey: .rdsHttpEndpointConfig)
        rdsHttpEndpointConfig = rdsHttpEndpointConfigDecoded
    }
}

extension AppSyncClientTypes.RelationalDatabaseDataSourceConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RelationalDatabaseDataSourceConfig(rdsHttpEndpointConfig: \(Swift.String(describing: rdsHttpEndpointConfig)), relationalDatabaseSourceType: \(Swift.String(describing: relationalDatabaseSourceType)))"}
}

extension AppSyncClientTypes {
    /// Describes a relational database data source configuration.
    public struct RelationalDatabaseDataSourceConfig: Swift.Equatable {
        /// Amazon RDS HTTP endpoint settings.
        public var rdsHttpEndpointConfig: AppSyncClientTypes.RdsHttpEndpointConfig?
        /// Source type for the relational database.
        ///
        ///
        ///
        ///                   RDS_HTTP_ENDPOINT: The relational database
        ///                source type is an Amazon RDS HTTP endpoint.
        ///
        ///
        public var relationalDatabaseSourceType: AppSyncClientTypes.RelationalDatabaseSourceType?

        public init (
            rdsHttpEndpointConfig: AppSyncClientTypes.RdsHttpEndpointConfig? = nil,
            relationalDatabaseSourceType: AppSyncClientTypes.RelationalDatabaseSourceType? = nil
        )
        {
            self.rdsHttpEndpointConfig = rdsHttpEndpointConfig
            self.relationalDatabaseSourceType = relationalDatabaseSourceType
        }
    }

}

extension AppSyncClientTypes {
    public enum RelationalDatabaseSourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case rdsHttpEndpoint
        case sdkUnknown(Swift.String)

        public static var allCases: [RelationalDatabaseSourceType] {
            return [
                .rdsHttpEndpoint,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .rdsHttpEndpoint: return "RDS_HTTP_ENDPOINT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RelationalDatabaseSourceType(rawValue: rawValue) ?? RelationalDatabaseSourceType.sdkUnknown(rawValue)
        }
    }
}

extension AppSyncClientTypes.Resolver: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachingConfig
        case dataSourceName
        case fieldName
        case kind
        case pipelineConfig
        case requestMappingTemplate
        case resolverArn
        case responseMappingTemplate
        case syncConfig
        case typeName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cachingConfig = cachingConfig {
            try encodeContainer.encode(cachingConfig, forKey: .cachingConfig)
        }
        if let dataSourceName = dataSourceName {
            try encodeContainer.encode(dataSourceName, forKey: .dataSourceName)
        }
        if let fieldName = fieldName {
            try encodeContainer.encode(fieldName, forKey: .fieldName)
        }
        if let kind = kind {
            try encodeContainer.encode(kind.rawValue, forKey: .kind)
        }
        if let pipelineConfig = pipelineConfig {
            try encodeContainer.encode(pipelineConfig, forKey: .pipelineConfig)
        }
        if let requestMappingTemplate = requestMappingTemplate {
            try encodeContainer.encode(requestMappingTemplate, forKey: .requestMappingTemplate)
        }
        if let resolverArn = resolverArn {
            try encodeContainer.encode(resolverArn, forKey: .resolverArn)
        }
        if let responseMappingTemplate = responseMappingTemplate {
            try encodeContainer.encode(responseMappingTemplate, forKey: .responseMappingTemplate)
        }
        if let syncConfig = syncConfig {
            try encodeContainer.encode(syncConfig, forKey: .syncConfig)
        }
        if let typeName = typeName {
            try encodeContainer.encode(typeName, forKey: .typeName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let fieldNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldName)
        fieldName = fieldNameDecoded
        let dataSourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceName)
        dataSourceName = dataSourceNameDecoded
        let resolverArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolverArn)
        resolverArn = resolverArnDecoded
        let requestMappingTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestMappingTemplate)
        requestMappingTemplate = requestMappingTemplateDecoded
        let responseMappingTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .responseMappingTemplate)
        responseMappingTemplate = responseMappingTemplateDecoded
        let kindDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ResolverKind.self, forKey: .kind)
        kind = kindDecoded
        let pipelineConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.PipelineConfig.self, forKey: .pipelineConfig)
        pipelineConfig = pipelineConfigDecoded
        let syncConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.SyncConfig.self, forKey: .syncConfig)
        syncConfig = syncConfigDecoded
        let cachingConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.CachingConfig.self, forKey: .cachingConfig)
        cachingConfig = cachingConfigDecoded
    }
}

extension AppSyncClientTypes.Resolver: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Resolver(cachingConfig: \(Swift.String(describing: cachingConfig)), dataSourceName: \(Swift.String(describing: dataSourceName)), fieldName: \(Swift.String(describing: fieldName)), kind: \(Swift.String(describing: kind)), pipelineConfig: \(Swift.String(describing: pipelineConfig)), requestMappingTemplate: \(Swift.String(describing: requestMappingTemplate)), resolverArn: \(Swift.String(describing: resolverArn)), responseMappingTemplate: \(Swift.String(describing: responseMappingTemplate)), syncConfig: \(Swift.String(describing: syncConfig)), typeName: \(Swift.String(describing: typeName)))"}
}

extension AppSyncClientTypes {
    /// Describes a resolver.
    public struct Resolver: Swift.Equatable {
        /// The caching configuration for the resolver.
        public var cachingConfig: AppSyncClientTypes.CachingConfig?
        /// The resolver data source name.
        public var dataSourceName: Swift.String?
        /// The resolver field name.
        public var fieldName: Swift.String?
        /// The resolver type.
        ///
        ///
        ///
        ///                   UNIT: A UNIT resolver type. A UNIT resolver is
        ///                the default resolver type. A UNIT resolver enables you to execute a GraphQL query
        ///                against a single data source.
        ///
        ///
        ///
        ///                   PIPELINE: A PIPELINE resolver type. A PIPELINE
        ///                resolver enables you to execute a series of Function in a serial manner.
        ///                You can use a pipeline resolver to execute a GraphQL query against multiple data
        ///                sources.
        ///
        ///
        public var kind: AppSyncClientTypes.ResolverKind?
        /// The PipelineConfig.
        public var pipelineConfig: AppSyncClientTypes.PipelineConfig?
        /// The request mapping template.
        public var requestMappingTemplate: Swift.String?
        /// The resolver ARN.
        public var resolverArn: Swift.String?
        /// The response mapping template.
        public var responseMappingTemplate: Swift.String?
        /// The SyncConfig for a resolver attached to a versioned datasource.
        public var syncConfig: AppSyncClientTypes.SyncConfig?
        /// The resolver type name.
        public var typeName: Swift.String?

        public init (
            cachingConfig: AppSyncClientTypes.CachingConfig? = nil,
            dataSourceName: Swift.String? = nil,
            fieldName: Swift.String? = nil,
            kind: AppSyncClientTypes.ResolverKind? = nil,
            pipelineConfig: AppSyncClientTypes.PipelineConfig? = nil,
            requestMappingTemplate: Swift.String? = nil,
            resolverArn: Swift.String? = nil,
            responseMappingTemplate: Swift.String? = nil,
            syncConfig: AppSyncClientTypes.SyncConfig? = nil,
            typeName: Swift.String? = nil
        )
        {
            self.cachingConfig = cachingConfig
            self.dataSourceName = dataSourceName
            self.fieldName = fieldName
            self.kind = kind
            self.pipelineConfig = pipelineConfig
            self.requestMappingTemplate = requestMappingTemplate
            self.resolverArn = resolverArn
            self.responseMappingTemplate = responseMappingTemplate
            self.syncConfig = syncConfig
            self.typeName = typeName
        }
    }

}

extension AppSyncClientTypes {
    public enum ResolverKind: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case pipeline
        case unit
        case sdkUnknown(Swift.String)

        public static var allCases: [ResolverKind] {
            return [
                .pipeline,
                .unit,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .pipeline: return "PIPELINE"
            case .unit: return "UNIT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResolverKind(rawValue: rawValue) ?? ResolverKind.sdkUnknown(rawValue)
        }
    }
}

extension AppSyncClientTypes {
    public enum SchemaStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deleting
        case failed
        case notapplicable
        case processing
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [SchemaStatus] {
            return [
                .active,
                .deleting,
                .failed,
                .notapplicable,
                .processing,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .notapplicable: return "NOT_APPLICABLE"
            case .processing: return "PROCESSING"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SchemaStatus(rawValue: rawValue) ?? SchemaStatus.sdkUnknown(rawValue)
        }
    }
}

public struct StartSchemaCreationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartSchemaCreationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartSchemaCreationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartSchemaCreationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartSchemaCreationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartSchemaCreationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartSchemaCreationOutputError>
}

extension StartSchemaCreationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartSchemaCreationInput(apiId: \(Swift.String(describing: apiId)), definition: \(Swift.String(describing: definition)))"}
}

extension StartSchemaCreationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let definition = definition {
            try encodeContainer.encode(definition.base64EncodedString(), forKey: .definition)
        }
    }
}

public struct StartSchemaCreationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartSchemaCreationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartSchemaCreationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartSchemaCreationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartSchemaCreationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartSchemaCreationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartSchemaCreationOutputError>
}

public struct StartSchemaCreationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartSchemaCreationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartSchemaCreationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartSchemaCreationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartSchemaCreationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartSchemaCreationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartSchemaCreationOutputError>
}

public struct StartSchemaCreationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartSchemaCreationInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: StartSchemaCreationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartSchemaCreationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let apiId = input.apiId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("apiId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/v1/apis/\(apiId.urlPercentEncoding())/schemacreation"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartSchemaCreationInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartSchemaCreationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartSchemaCreationOutputError>
}

public struct StartSchemaCreationInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The schema definition, in GraphQL schema language format.
    /// This member is required.
    public var definition: ClientRuntime.Data?

    public init (
        apiId: Swift.String? = nil,
        definition: ClientRuntime.Data? = nil
    )
    {
        self.apiId = apiId
        self.definition = definition
    }
}

struct StartSchemaCreationInputBody: Swift.Equatable {
    public let definition: ClientRuntime.Data?
}

extension StartSchemaCreationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let definitionDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .definition)
        definition = definitionDecoded
    }
}

extension StartSchemaCreationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartSchemaCreationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartSchemaCreationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartSchemaCreationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartSchemaCreationOutputResponse(status: \(Swift.String(describing: status)))"}
}

extension StartSchemaCreationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartSchemaCreationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct StartSchemaCreationOutputResponse: Swift.Equatable {
    /// The current state of the schema (PROCESSING, FAILED, SUCCESS, or NOT_APPLICABLE). When
    ///          the schema is in the ACTIVE state, you can add data.
    public var status: AppSyncClientTypes.SchemaStatus?

    public init (
        status: AppSyncClientTypes.SchemaStatus? = nil
    )
    {
        self.status = status
    }
}

struct StartSchemaCreationOutputResponseBody: Swift.Equatable {
    public let status: AppSyncClientTypes.SchemaStatus?
}

extension StartSchemaCreationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.SchemaStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension AppSyncClientTypes.SyncConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conflictDetection
        case conflictHandler
        case lambdaConflictHandlerConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conflictDetection = conflictDetection {
            try encodeContainer.encode(conflictDetection.rawValue, forKey: .conflictDetection)
        }
        if let conflictHandler = conflictHandler {
            try encodeContainer.encode(conflictHandler.rawValue, forKey: .conflictHandler)
        }
        if let lambdaConflictHandlerConfig = lambdaConflictHandlerConfig {
            try encodeContainer.encode(lambdaConflictHandlerConfig, forKey: .lambdaConflictHandlerConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conflictHandlerDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ConflictHandlerType.self, forKey: .conflictHandler)
        conflictHandler = conflictHandlerDecoded
        let conflictDetectionDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ConflictDetectionType.self, forKey: .conflictDetection)
        conflictDetection = conflictDetectionDecoded
        let lambdaConflictHandlerConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.LambdaConflictHandlerConfig.self, forKey: .lambdaConflictHandlerConfig)
        lambdaConflictHandlerConfig = lambdaConflictHandlerConfigDecoded
    }
}

extension AppSyncClientTypes.SyncConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SyncConfig(conflictDetection: \(Swift.String(describing: conflictDetection)), conflictHandler: \(Swift.String(describing: conflictHandler)), lambdaConflictHandlerConfig: \(Swift.String(describing: lambdaConflictHandlerConfig)))"}
}

extension AppSyncClientTypes {
    /// Describes a Sync configuration for a resolver.
    ///          Contains information on which Conflict Detection as well as Resolution strategy should
    ///          be performed when the resolver is invoked.
    public struct SyncConfig: Swift.Equatable {
        /// The Conflict Detection strategy to use.
        ///
        ///
        ///
        ///                   VERSION: Detect conflicts based on object
        ///                versions for this resolver.
        ///
        ///
        ///
        ///                   NONE: Do not detect conflicts when executing
        ///                this resolver.
        ///
        ///
        public var conflictDetection: AppSyncClientTypes.ConflictDetectionType?
        /// The Conflict Resolution strategy to perform in the event of a conflict.
        ///
        ///
        ///
        ///                   OPTIMISTIC_CONCURRENCY: Resolve conflicts by
        ///                rejecting mutations when versions do not match the latest version at the
        ///                server.
        ///
        ///
        ///
        ///                   AUTOMERGE: Resolve conflicts with the
        ///                Automerge conflict resolution strategy.
        ///
        ///
        ///
        ///                   LAMBDA: Resolve conflicts with a Lambda
        ///                function supplied in the LambdaConflictHandlerConfig.
        ///
        ///
        public var conflictHandler: AppSyncClientTypes.ConflictHandlerType?
        /// The LambdaConflictHandlerConfig when configuring LAMBDA as the Conflict
        ///          Handler.
        public var lambdaConflictHandlerConfig: AppSyncClientTypes.LambdaConflictHandlerConfig?

        public init (
            conflictDetection: AppSyncClientTypes.ConflictDetectionType? = nil,
            conflictHandler: AppSyncClientTypes.ConflictHandlerType? = nil,
            lambdaConflictHandlerConfig: AppSyncClientTypes.LambdaConflictHandlerConfig? = nil
        )
        {
            self.conflictDetection = conflictDetection
            self.conflictHandler = conflictHandler
            self.lambdaConflictHandlerConfig = lambdaConflictHandlerConfig
        }
    }

}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/v1/tags/\(resourceArn.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// The GraphqlApi ARN.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A TagMap object.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AppSyncClientTypes.ModelType: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModelType(arn: \(Swift.String(describing: arn)), definition: \(Swift.String(describing: definition)), description: \(Swift.String(describing: description)), format: \(Swift.String(describing: format)), name: \(Swift.String(describing: name)))"}
}

extension AppSyncClientTypes {
    /// Describes a type.
    public struct ModelType: Swift.Equatable {
        /// The type ARN.
        public var arn: Swift.String?
        /// The type definition.
        public var definition: Swift.String?
        /// The type description.
        public var description: Swift.String?
        /// The type format: SDL or JSON.
        public var format: AppSyncClientTypes.TypeDefinitionFormat?
        /// The type name.
        public var name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            definition: Swift.String? = nil,
            description: Swift.String? = nil,
            format: AppSyncClientTypes.TypeDefinitionFormat? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.definition = definition
            self.description = description
            self.format = format
            self.name = name
        }
    }

}

extension AppSyncClientTypes {
    public enum TypeDefinitionFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case json
        case sdl
        case sdkUnknown(Swift.String)

        public static var allCases: [TypeDefinitionFormat] {
            return [
                .json,
                .sdl,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .json: return "JSON"
            case .sdl: return "SDL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TypeDefinitionFormat(rawValue: rawValue) ?? TypeDefinitionFormat.sdkUnknown(rawValue)
        }
    }
}

extension UnauthorizedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnauthorizedException(message: \(Swift.String(describing: message)))"}
}

extension UnauthorizedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnauthorizedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You are not authorized to perform this operation.
public struct UnauthorizedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnauthorizedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension UnauthorizedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/v1/tags/\(resourceArn.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// The GraphqlApi ARN.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of TagKey objects.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateApiCacheInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateApiCacheInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateApiCacheInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateApiCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateApiCacheInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateApiCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateApiCacheOutputError>
}

extension UpdateApiCacheInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateApiCacheInput(apiCachingBehavior: \(Swift.String(describing: apiCachingBehavior)), apiId: \(Swift.String(describing: apiId)), ttl: \(Swift.String(describing: ttl)), type: \(Swift.String(describing: type)))"}
}

extension UpdateApiCacheInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiCachingBehavior
        case ttl
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiCachingBehavior = apiCachingBehavior {
            try encodeContainer.encode(apiCachingBehavior.rawValue, forKey: .apiCachingBehavior)
        }
        if ttl != 0 {
            try encodeContainer.encode(ttl, forKey: .ttl)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct UpdateApiCacheInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateApiCacheInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateApiCacheInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateApiCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateApiCacheInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateApiCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateApiCacheOutputError>
}

public struct UpdateApiCacheInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateApiCacheInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateApiCacheInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateApiCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateApiCacheInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateApiCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateApiCacheOutputError>
}

public struct UpdateApiCacheInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateApiCacheInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateApiCacheInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateApiCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let apiId = input.apiId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("apiId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/v1/apis/\(apiId.urlPercentEncoding())/ApiCaches/update"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateApiCacheInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateApiCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateApiCacheOutputError>
}

/// Represents the input of a UpdateApiCache operation.
public struct UpdateApiCacheInput: Swift.Equatable {
    /// Caching behavior.
    ///
    ///
    ///
    ///                   FULL_REQUEST_CACHING: All requests are fully
    ///                cached.
    ///
    ///
    ///
    ///                   PER_RESOLVER_CACHING: Individual resolvers
    ///                that you specify are cached.
    ///
    ///
    /// This member is required.
    public var apiCachingBehavior: AppSyncClientTypes.ApiCachingBehavior?
    /// The GraphQL API Id.
    /// This member is required.
    public var apiId: Swift.String?
    /// TTL in seconds for cache entries.
    ///          Valid values are between 1 and 3600 seconds.
    /// This member is required.
    public var ttl: Swift.Int
    /// The cache instance type. Valid values are
    ///
    ///
    ///
    ///                   SMALL
    ///
    ///
    ///
    ///
    ///                   MEDIUM
    ///
    ///
    ///
    ///
    ///                   LARGE
    ///
    ///
    ///
    ///
    ///                   XLARGE
    ///
    ///
    ///
    ///
    ///                   LARGE_2X
    ///
    ///
    ///
    ///
    ///                   LARGE_4X
    ///
    ///
    ///
    ///
    ///                   LARGE_8X (not available in all regions)
    ///
    ///
    ///
    ///                   LARGE_12X
    ///
    ///
    ///
    ///          Historically, instance types were identified by an EC2-style value. As of July 2020, this is deprecated, and the generic identifiers above should be used.
    ///          The following legacy instance types are available, but their use is discouraged:
    ///
    ///
    ///
    ///                   T2_SMALL: A t2.small instance type.
    ///
    ///
    ///
    ///                   T2_MEDIUM: A t2.medium instance type.
    ///
    ///
    ///
    ///                   R4_LARGE: A r4.large instance type.
    ///
    ///
    ///
    ///                   R4_XLARGE: A r4.xlarge instance type.
    ///
    ///
    ///
    ///                   R4_2XLARGE: A r4.2xlarge instance type.
    ///
    ///
    ///
    ///                   R4_4XLARGE: A r4.4xlarge instance type.
    ///
    ///
    ///
    ///                   R4_8XLARGE: A r4.8xlarge instance type.
    ///
    ///
    /// This member is required.
    public var type: AppSyncClientTypes.ApiCacheType?

    public init (
        apiCachingBehavior: AppSyncClientTypes.ApiCachingBehavior? = nil,
        apiId: Swift.String? = nil,
        ttl: Swift.Int = 0,
        type: AppSyncClientTypes.ApiCacheType? = nil
    )
    {
        self.apiCachingBehavior = apiCachingBehavior
        self.apiId = apiId
        self.ttl = ttl
        self.type = type
    }
}

struct UpdateApiCacheInputBody: Swift.Equatable {
    public let ttl: Swift.Int
    public let apiCachingBehavior: AppSyncClientTypes.ApiCachingBehavior?
    public let type: AppSyncClientTypes.ApiCacheType?
}

extension UpdateApiCacheInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiCachingBehavior
        case ttl
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ttlDecoded = try containerValues.decode(Swift.Int.self, forKey: .ttl)
        ttl = ttlDecoded
        let apiCachingBehaviorDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ApiCachingBehavior.self, forKey: .apiCachingBehavior)
        apiCachingBehavior = apiCachingBehaviorDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ApiCacheType.self, forKey: .type)
        type = typeDecoded
    }
}

extension UpdateApiCacheOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateApiCacheOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateApiCacheOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateApiCacheOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateApiCacheOutputResponse(apiCache: \(Swift.String(describing: apiCache)))"}
}

extension UpdateApiCacheOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateApiCacheOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiCache = output.apiCache
        } else {
            self.apiCache = nil
        }
    }
}

/// Represents the output of a UpdateApiCache operation.
public struct UpdateApiCacheOutputResponse: Swift.Equatable {
    /// The ApiCache object.
    public var apiCache: AppSyncClientTypes.ApiCache?

    public init (
        apiCache: AppSyncClientTypes.ApiCache? = nil
    )
    {
        self.apiCache = apiCache
    }
}

struct UpdateApiCacheOutputResponseBody: Swift.Equatable {
    public let apiCache: AppSyncClientTypes.ApiCache?
}

extension UpdateApiCacheOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiCache
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiCacheDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ApiCache.self, forKey: .apiCache)
        apiCache = apiCacheDecoded
    }
}

public struct UpdateApiKeyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateApiKeyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateApiKeyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateApiKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateApiKeyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateApiKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateApiKeyOutputError>
}

extension UpdateApiKeyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateApiKeyInput(apiId: \(Swift.String(describing: apiId)), description: \(Swift.String(describing: description)), expires: \(Swift.String(describing: expires)), id: \(Swift.String(describing: id)))"}
}

extension UpdateApiKeyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case expires
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if expires != 0 {
            try encodeContainer.encode(expires, forKey: .expires)
        }
    }
}

public struct UpdateApiKeyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateApiKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateApiKeyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateApiKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateApiKeyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateApiKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateApiKeyOutputError>
}

public struct UpdateApiKeyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateApiKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateApiKeyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateApiKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateApiKeyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateApiKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateApiKeyOutputError>
}

public struct UpdateApiKeyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateApiKeyInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateApiKeyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateApiKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let apiId = input.apiId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("apiId is nil and needs a value for the path of this operation"))))
        }
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/v1/apis/\(apiId.urlPercentEncoding())/apikeys/\(id.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateApiKeyInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateApiKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateApiKeyOutputError>
}

public struct UpdateApiKeyInput: Swift.Equatable {
    /// The ID for the GraphQL API.
    /// This member is required.
    public var apiId: Swift.String?
    /// A description of the purpose of the API key.
    public var description: Swift.String?
    /// The time from update time after which the API key expires. The date is represented as
    ///          seconds since the epoch. For more information, see .
    public var expires: Swift.Int
    /// The API key ID.
    /// This member is required.
    public var id: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        description: Swift.String? = nil,
        expires: Swift.Int = 0,
        id: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.description = description
        self.expires = expires
        self.id = id
    }
}

struct UpdateApiKeyInputBody: Swift.Equatable {
    public let description: Swift.String?
    public let expires: Swift.Int
}

extension UpdateApiKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case expires
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let expiresDecoded = try containerValues.decode(Swift.Int.self, forKey: .expires)
        expires = expiresDecoded
    }
}

extension UpdateApiKeyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateApiKeyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ApiKeyValidityOutOfBoundsException" : self = .apiKeyValidityOutOfBoundsException(try ApiKeyValidityOutOfBoundsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateApiKeyOutputError: Swift.Error, Swift.Equatable {
    case apiKeyValidityOutOfBoundsException(ApiKeyValidityOutOfBoundsException)
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateApiKeyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateApiKeyOutputResponse(apiKey: \(Swift.String(describing: apiKey)))"}
}

extension UpdateApiKeyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateApiKeyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiKey = output.apiKey
        } else {
            self.apiKey = nil
        }
    }
}

public struct UpdateApiKeyOutputResponse: Swift.Equatable {
    /// The API key.
    public var apiKey: AppSyncClientTypes.ApiKey?

    public init (
        apiKey: AppSyncClientTypes.ApiKey? = nil
    )
    {
        self.apiKey = apiKey
    }
}

struct UpdateApiKeyOutputResponseBody: Swift.Equatable {
    public let apiKey: AppSyncClientTypes.ApiKey?
}

extension UpdateApiKeyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKey
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiKeyDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ApiKey.self, forKey: .apiKey)
        apiKey = apiKeyDecoded
    }
}

public struct UpdateDataSourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDataSourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDataSourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDataSourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDataSourceOutputError>
}

extension UpdateDataSourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDataSourceInput(apiId: \(Swift.String(describing: apiId)), description: \(Swift.String(describing: description)), dynamodbConfig: \(Swift.String(describing: dynamodbConfig)), elasticsearchConfig: \(Swift.String(describing: elasticsearchConfig)), httpConfig: \(Swift.String(describing: httpConfig)), lambdaConfig: \(Swift.String(describing: lambdaConfig)), name: \(Swift.String(describing: name)), openSearchServiceConfig: \(Swift.String(describing: openSearchServiceConfig)), relationalDatabaseConfig: \(Swift.String(describing: relationalDatabaseConfig)), serviceRoleArn: \(Swift.String(describing: serviceRoleArn)), type: \(Swift.String(describing: type)))"}
}

extension UpdateDataSourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case dynamodbConfig
        case elasticsearchConfig
        case httpConfig
        case lambdaConfig
        case openSearchServiceConfig
        case relationalDatabaseConfig
        case serviceRoleArn
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let dynamodbConfig = dynamodbConfig {
            try encodeContainer.encode(dynamodbConfig, forKey: .dynamodbConfig)
        }
        if let elasticsearchConfig = elasticsearchConfig {
            try encodeContainer.encode(elasticsearchConfig, forKey: .elasticsearchConfig)
        }
        if let httpConfig = httpConfig {
            try encodeContainer.encode(httpConfig, forKey: .httpConfig)
        }
        if let lambdaConfig = lambdaConfig {
            try encodeContainer.encode(lambdaConfig, forKey: .lambdaConfig)
        }
        if let openSearchServiceConfig = openSearchServiceConfig {
            try encodeContainer.encode(openSearchServiceConfig, forKey: .openSearchServiceConfig)
        }
        if let relationalDatabaseConfig = relationalDatabaseConfig {
            try encodeContainer.encode(relationalDatabaseConfig, forKey: .relationalDatabaseConfig)
        }
        if let serviceRoleArn = serviceRoleArn {
            try encodeContainer.encode(serviceRoleArn, forKey: .serviceRoleArn)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct UpdateDataSourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDataSourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDataSourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDataSourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDataSourceOutputError>
}

public struct UpdateDataSourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDataSourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDataSourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDataSourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDataSourceOutputError>
}

public struct UpdateDataSourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDataSourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateDataSourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let apiId = input.apiId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("apiId is nil and needs a value for the path of this operation"))))
        }
        guard let name = input.name else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("name is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/v1/apis/\(apiId.urlPercentEncoding())/datasources/\(name.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateDataSourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDataSourceOutputError>
}

public struct UpdateDataSourceInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The new description for the data source.
    public var description: Swift.String?
    /// The new Amazon DynamoDB configuration.
    public var dynamodbConfig: AppSyncClientTypes.DynamodbDataSourceConfig?
    /// The new OpenSearch configuration.
    ///          As of September 2021, Amazon Elasticsearch service is Amazon OpenSearch Service. This
    ///          configuration is deprecated. Instead, use UpdateDataSourceRequest$openSearchServiceConfig to update an OpenSearch data source.
    public var elasticsearchConfig: AppSyncClientTypes.ElasticsearchDataSourceConfig?
    /// The new HTTP endpoint configuration.
    public var httpConfig: AppSyncClientTypes.HttpDataSourceConfig?
    /// The new Amazon Web Services Lambda configuration.
    public var lambdaConfig: AppSyncClientTypes.LambdaDataSourceConfig?
    /// The new name for the data source.
    /// This member is required.
    public var name: Swift.String?
    /// The new OpenSearch configuration.
    public var openSearchServiceConfig: AppSyncClientTypes.OpenSearchServiceDataSourceConfig?
    /// The new relational database configuration.
    public var relationalDatabaseConfig: AppSyncClientTypes.RelationalDatabaseDataSourceConfig?
    /// The new service role ARN for the data source.
    public var serviceRoleArn: Swift.String?
    /// The new data source type.
    /// This member is required.
    public var type: AppSyncClientTypes.DataSourceType?

    public init (
        apiId: Swift.String? = nil,
        description: Swift.String? = nil,
        dynamodbConfig: AppSyncClientTypes.DynamodbDataSourceConfig? = nil,
        elasticsearchConfig: AppSyncClientTypes.ElasticsearchDataSourceConfig? = nil,
        httpConfig: AppSyncClientTypes.HttpDataSourceConfig? = nil,
        lambdaConfig: AppSyncClientTypes.LambdaDataSourceConfig? = nil,
        name: Swift.String? = nil,
        openSearchServiceConfig: AppSyncClientTypes.OpenSearchServiceDataSourceConfig? = nil,
        relationalDatabaseConfig: AppSyncClientTypes.RelationalDatabaseDataSourceConfig? = nil,
        serviceRoleArn: Swift.String? = nil,
        type: AppSyncClientTypes.DataSourceType? = nil
    )
    {
        self.apiId = apiId
        self.description = description
        self.dynamodbConfig = dynamodbConfig
        self.elasticsearchConfig = elasticsearchConfig
        self.httpConfig = httpConfig
        self.lambdaConfig = lambdaConfig
        self.name = name
        self.openSearchServiceConfig = openSearchServiceConfig
        self.relationalDatabaseConfig = relationalDatabaseConfig
        self.serviceRoleArn = serviceRoleArn
        self.type = type
    }
}

struct UpdateDataSourceInputBody: Swift.Equatable {
    public let description: Swift.String?
    public let type: AppSyncClientTypes.DataSourceType?
    public let serviceRoleArn: Swift.String?
    public let dynamodbConfig: AppSyncClientTypes.DynamodbDataSourceConfig?
    public let lambdaConfig: AppSyncClientTypes.LambdaDataSourceConfig?
    public let elasticsearchConfig: AppSyncClientTypes.ElasticsearchDataSourceConfig?
    public let openSearchServiceConfig: AppSyncClientTypes.OpenSearchServiceDataSourceConfig?
    public let httpConfig: AppSyncClientTypes.HttpDataSourceConfig?
    public let relationalDatabaseConfig: AppSyncClientTypes.RelationalDatabaseDataSourceConfig?
}

extension UpdateDataSourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case dynamodbConfig
        case elasticsearchConfig
        case httpConfig
        case lambdaConfig
        case openSearchServiceConfig
        case relationalDatabaseConfig
        case serviceRoleArn
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.DataSourceType.self, forKey: .type)
        type = typeDecoded
        let serviceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRoleArn)
        serviceRoleArn = serviceRoleArnDecoded
        let dynamodbConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.DynamodbDataSourceConfig.self, forKey: .dynamodbConfig)
        dynamodbConfig = dynamodbConfigDecoded
        let lambdaConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.LambdaDataSourceConfig.self, forKey: .lambdaConfig)
        lambdaConfig = lambdaConfigDecoded
        let elasticsearchConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ElasticsearchDataSourceConfig.self, forKey: .elasticsearchConfig)
        elasticsearchConfig = elasticsearchConfigDecoded
        let openSearchServiceConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.OpenSearchServiceDataSourceConfig.self, forKey: .openSearchServiceConfig)
        openSearchServiceConfig = openSearchServiceConfigDecoded
        let httpConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.HttpDataSourceConfig.self, forKey: .httpConfig)
        httpConfig = httpConfigDecoded
        let relationalDatabaseConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.RelationalDatabaseDataSourceConfig.self, forKey: .relationalDatabaseConfig)
        relationalDatabaseConfig = relationalDatabaseConfigDecoded
    }
}

extension UpdateDataSourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDataSourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDataSourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDataSourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDataSourceOutputResponse(dataSource: \(Swift.String(describing: dataSource)))"}
}

extension UpdateDataSourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateDataSourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataSource = output.dataSource
        } else {
            self.dataSource = nil
        }
    }
}

public struct UpdateDataSourceOutputResponse: Swift.Equatable {
    /// The updated DataSource object.
    public var dataSource: AppSyncClientTypes.DataSource?

    public init (
        dataSource: AppSyncClientTypes.DataSource? = nil
    )
    {
        self.dataSource = dataSource
    }
}

struct UpdateDataSourceOutputResponseBody: Swift.Equatable {
    public let dataSource: AppSyncClientTypes.DataSource?
}

extension UpdateDataSourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
    }
}

public struct UpdateFunctionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFunctionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFunctionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFunctionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFunctionOutputError>
}

extension UpdateFunctionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateFunctionInput(apiId: \(Swift.String(describing: apiId)), dataSourceName: \(Swift.String(describing: dataSourceName)), description: \(Swift.String(describing: description)), functionId: \(Swift.String(describing: functionId)), functionVersion: \(Swift.String(describing: functionVersion)), name: \(Swift.String(describing: name)), requestMappingTemplate: \(Swift.String(describing: requestMappingTemplate)), responseMappingTemplate: \(Swift.String(describing: responseMappingTemplate)), syncConfig: \(Swift.String(describing: syncConfig)))"}
}

extension UpdateFunctionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceName
        case description
        case functionVersion
        case name
        case requestMappingTemplate
        case responseMappingTemplate
        case syncConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceName = dataSourceName {
            try encodeContainer.encode(dataSourceName, forKey: .dataSourceName)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let functionVersion = functionVersion {
            try encodeContainer.encode(functionVersion, forKey: .functionVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let requestMappingTemplate = requestMappingTemplate {
            try encodeContainer.encode(requestMappingTemplate, forKey: .requestMappingTemplate)
        }
        if let responseMappingTemplate = responseMappingTemplate {
            try encodeContainer.encode(responseMappingTemplate, forKey: .responseMappingTemplate)
        }
        if let syncConfig = syncConfig {
            try encodeContainer.encode(syncConfig, forKey: .syncConfig)
        }
    }
}

public struct UpdateFunctionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFunctionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFunctionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFunctionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFunctionOutputError>
}

public struct UpdateFunctionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFunctionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFunctionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFunctionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFunctionOutputError>
}

public struct UpdateFunctionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFunctionInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateFunctionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let apiId = input.apiId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("apiId is nil and needs a value for the path of this operation"))))
        }
        guard let functionId = input.functionId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("functionId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/v1/apis/\(apiId.urlPercentEncoding())/functions/\(functionId.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateFunctionInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFunctionOutputError>
}

public struct UpdateFunctionInput: Swift.Equatable {
    /// The GraphQL API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The Function
    ///             DataSource name.
    /// This member is required.
    public var dataSourceName: Swift.String?
    /// The Function description.
    public var description: Swift.String?
    /// The function ID.
    /// This member is required.
    public var functionId: Swift.String?
    /// The version of the request mapping template. Currently the supported value
    ///          is 2018-05-29.
    /// This member is required.
    public var functionVersion: Swift.String?
    /// The Function name.
    /// This member is required.
    public var name: Swift.String?
    /// The Function request mapping template. Functions support only the
    ///          2018-05-29 version of the request mapping template.
    public var requestMappingTemplate: Swift.String?
    /// The Function request mapping template.
    public var responseMappingTemplate: Swift.String?
    /// Describes a Sync configuration for a resolver.
    ///          Contains information on which Conflict Detection as well as Resolution strategy should
    ///          be performed when the resolver is invoked.
    public var syncConfig: AppSyncClientTypes.SyncConfig?

    public init (
        apiId: Swift.String? = nil,
        dataSourceName: Swift.String? = nil,
        description: Swift.String? = nil,
        functionId: Swift.String? = nil,
        functionVersion: Swift.String? = nil,
        name: Swift.String? = nil,
        requestMappingTemplate: Swift.String? = nil,
        responseMappingTemplate: Swift.String? = nil,
        syncConfig: AppSyncClientTypes.SyncConfig? = nil
    )
    {
        self.apiId = apiId
        self.dataSourceName = dataSourceName
        self.description = description
        self.functionId = functionId
        self.functionVersion = functionVersion
        self.name = name
        self.requestMappingTemplate = requestMappingTemplate
        self.responseMappingTemplate = responseMappingTemplate
        self.syncConfig = syncConfig
    }
}

struct UpdateFunctionInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let description: Swift.String?
    public let dataSourceName: Swift.String?
    public let requestMappingTemplate: Swift.String?
    public let responseMappingTemplate: Swift.String?
    public let functionVersion: Swift.String?
    public let syncConfig: AppSyncClientTypes.SyncConfig?
}

extension UpdateFunctionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceName
        case description
        case functionVersion
        case name
        case requestMappingTemplate
        case responseMappingTemplate
        case syncConfig
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dataSourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceName)
        dataSourceName = dataSourceNameDecoded
        let requestMappingTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestMappingTemplate)
        requestMappingTemplate = requestMappingTemplateDecoded
        let responseMappingTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .responseMappingTemplate)
        responseMappingTemplate = responseMappingTemplateDecoded
        let functionVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionVersion)
        functionVersion = functionVersionDecoded
        let syncConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.SyncConfig.self, forKey: .syncConfig)
        syncConfig = syncConfigDecoded
    }
}

extension UpdateFunctionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFunctionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFunctionOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFunctionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateFunctionOutputResponse(functionConfiguration: \(Swift.String(describing: functionConfiguration)))"}
}

extension UpdateFunctionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateFunctionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.functionConfiguration = output.functionConfiguration
        } else {
            self.functionConfiguration = nil
        }
    }
}

public struct UpdateFunctionOutputResponse: Swift.Equatable {
    /// The Function object.
    public var functionConfiguration: AppSyncClientTypes.FunctionConfiguration?

    public init (
        functionConfiguration: AppSyncClientTypes.FunctionConfiguration? = nil
    )
    {
        self.functionConfiguration = functionConfiguration
    }
}

struct UpdateFunctionOutputResponseBody: Swift.Equatable {
    public let functionConfiguration: AppSyncClientTypes.FunctionConfiguration?
}

extension UpdateFunctionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionConfiguration
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionConfigurationDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.FunctionConfiguration.self, forKey: .functionConfiguration)
        functionConfiguration = functionConfigurationDecoded
    }
}

public struct UpdateGraphqlApiInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateGraphqlApiInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateGraphqlApiInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateGraphqlApiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateGraphqlApiInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateGraphqlApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateGraphqlApiOutputError>
}

extension UpdateGraphqlApiInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateGraphqlApiInput(additionalAuthenticationProviders: \(Swift.String(describing: additionalAuthenticationProviders)), apiId: \(Swift.String(describing: apiId)), authenticationType: \(Swift.String(describing: authenticationType)), lambdaAuthorizerConfig: \(Swift.String(describing: lambdaAuthorizerConfig)), logConfig: \(Swift.String(describing: logConfig)), name: \(Swift.String(describing: name)), openIDConnectConfig: \(Swift.String(describing: openIDConnectConfig)), userPoolConfig: \(Swift.String(describing: userPoolConfig)), xrayEnabled: \(Swift.String(describing: xrayEnabled)))"}
}

extension UpdateGraphqlApiInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalAuthenticationProviders
        case authenticationType
        case lambdaAuthorizerConfig
        case logConfig
        case name
        case openIDConnectConfig
        case userPoolConfig
        case xrayEnabled
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalAuthenticationProviders = additionalAuthenticationProviders {
            var additionalAuthenticationProvidersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalAuthenticationProviders)
            for additionalauthenticationproviders0 in additionalAuthenticationProviders {
                try additionalAuthenticationProvidersContainer.encode(additionalauthenticationproviders0)
            }
        }
        if let authenticationType = authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let lambdaAuthorizerConfig = lambdaAuthorizerConfig {
            try encodeContainer.encode(lambdaAuthorizerConfig, forKey: .lambdaAuthorizerConfig)
        }
        if let logConfig = logConfig {
            try encodeContainer.encode(logConfig, forKey: .logConfig)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let openIDConnectConfig = openIDConnectConfig {
            try encodeContainer.encode(openIDConnectConfig, forKey: .openIDConnectConfig)
        }
        if let userPoolConfig = userPoolConfig {
            try encodeContainer.encode(userPoolConfig, forKey: .userPoolConfig)
        }
        if xrayEnabled != false {
            try encodeContainer.encode(xrayEnabled, forKey: .xrayEnabled)
        }
    }
}

public struct UpdateGraphqlApiInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateGraphqlApiInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateGraphqlApiInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateGraphqlApiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateGraphqlApiInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateGraphqlApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateGraphqlApiOutputError>
}

public struct UpdateGraphqlApiInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateGraphqlApiInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateGraphqlApiInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateGraphqlApiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateGraphqlApiInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateGraphqlApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateGraphqlApiOutputError>
}

public struct UpdateGraphqlApiInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateGraphqlApiInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateGraphqlApiInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateGraphqlApiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let apiId = input.apiId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("apiId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/v1/apis/\(apiId.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateGraphqlApiInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateGraphqlApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateGraphqlApiOutputError>
}

public struct UpdateGraphqlApiInput: Swift.Equatable {
    /// A list of additional authentication providers for the GraphqlApi
    ///          API.
    public var additionalAuthenticationProviders: [AppSyncClientTypes.AdditionalAuthenticationProvider]?
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The new authentication type for the GraphqlApi object.
    public var authenticationType: AppSyncClientTypes.AuthenticationType?
    /// Configuration for Amazon Web Services Lambda function authorization.
    public var lambdaAuthorizerConfig: AppSyncClientTypes.LambdaAuthorizerConfig?
    /// The Amazon CloudWatch Logs configuration for the GraphqlApi object.
    public var logConfig: AppSyncClientTypes.LogConfig?
    /// The new name for the GraphqlApi object.
    /// This member is required.
    public var name: Swift.String?
    /// The OpenID Connect configuration for the GraphqlApi object.
    public var openIDConnectConfig: AppSyncClientTypes.OpenIDConnectConfig?
    /// The new Amazon Cognito user pool configuration for the GraphqlApi
    ///          object.
    public var userPoolConfig: AppSyncClientTypes.UserPoolConfig?
    /// A flag indicating whether to enable X-Ray tracing for the
    ///          GraphqlApi.
    public var xrayEnabled: Swift.Bool

    public init (
        additionalAuthenticationProviders: [AppSyncClientTypes.AdditionalAuthenticationProvider]? = nil,
        apiId: Swift.String? = nil,
        authenticationType: AppSyncClientTypes.AuthenticationType? = nil,
        lambdaAuthorizerConfig: AppSyncClientTypes.LambdaAuthorizerConfig? = nil,
        logConfig: AppSyncClientTypes.LogConfig? = nil,
        name: Swift.String? = nil,
        openIDConnectConfig: AppSyncClientTypes.OpenIDConnectConfig? = nil,
        userPoolConfig: AppSyncClientTypes.UserPoolConfig? = nil,
        xrayEnabled: Swift.Bool = false
    )
    {
        self.additionalAuthenticationProviders = additionalAuthenticationProviders
        self.apiId = apiId
        self.authenticationType = authenticationType
        self.lambdaAuthorizerConfig = lambdaAuthorizerConfig
        self.logConfig = logConfig
        self.name = name
        self.openIDConnectConfig = openIDConnectConfig
        self.userPoolConfig = userPoolConfig
        self.xrayEnabled = xrayEnabled
    }
}

struct UpdateGraphqlApiInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let logConfig: AppSyncClientTypes.LogConfig?
    public let authenticationType: AppSyncClientTypes.AuthenticationType?
    public let userPoolConfig: AppSyncClientTypes.UserPoolConfig?
    public let openIDConnectConfig: AppSyncClientTypes.OpenIDConnectConfig?
    public let additionalAuthenticationProviders: [AppSyncClientTypes.AdditionalAuthenticationProvider]?
    public let xrayEnabled: Swift.Bool
    public let lambdaAuthorizerConfig: AppSyncClientTypes.LambdaAuthorizerConfig?
}

extension UpdateGraphqlApiInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalAuthenticationProviders
        case authenticationType
        case lambdaAuthorizerConfig
        case logConfig
        case name
        case openIDConnectConfig
        case userPoolConfig
        case xrayEnabled
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let logConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.LogConfig.self, forKey: .logConfig)
        logConfig = logConfigDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
        let userPoolConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.UserPoolConfig.self, forKey: .userPoolConfig)
        userPoolConfig = userPoolConfigDecoded
        let openIDConnectConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.OpenIDConnectConfig.self, forKey: .openIDConnectConfig)
        openIDConnectConfig = openIDConnectConfigDecoded
        let additionalAuthenticationProvidersContainer = try containerValues.decodeIfPresent([AppSyncClientTypes.AdditionalAuthenticationProvider?].self, forKey: .additionalAuthenticationProviders)
        var additionalAuthenticationProvidersDecoded0:[AppSyncClientTypes.AdditionalAuthenticationProvider]? = nil
        if let additionalAuthenticationProvidersContainer = additionalAuthenticationProvidersContainer {
            additionalAuthenticationProvidersDecoded0 = [AppSyncClientTypes.AdditionalAuthenticationProvider]()
            for structure0 in additionalAuthenticationProvidersContainer {
                if let structure0 = structure0 {
                    additionalAuthenticationProvidersDecoded0?.append(structure0)
                }
            }
        }
        additionalAuthenticationProviders = additionalAuthenticationProvidersDecoded0
        let xrayEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .xrayEnabled)
        xrayEnabled = xrayEnabledDecoded
        let lambdaAuthorizerConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.LambdaAuthorizerConfig.self, forKey: .lambdaAuthorizerConfig)
        lambdaAuthorizerConfig = lambdaAuthorizerConfigDecoded
    }
}

extension UpdateGraphqlApiOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateGraphqlApiOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateGraphqlApiOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateGraphqlApiOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateGraphqlApiOutputResponse(graphqlApi: \(Swift.String(describing: graphqlApi)))"}
}

extension UpdateGraphqlApiOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateGraphqlApiOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.graphqlApi = output.graphqlApi
        } else {
            self.graphqlApi = nil
        }
    }
}

public struct UpdateGraphqlApiOutputResponse: Swift.Equatable {
    /// The updated GraphqlApi object.
    public var graphqlApi: AppSyncClientTypes.GraphqlApi?

    public init (
        graphqlApi: AppSyncClientTypes.GraphqlApi? = nil
    )
    {
        self.graphqlApi = graphqlApi
    }
}

struct UpdateGraphqlApiOutputResponseBody: Swift.Equatable {
    public let graphqlApi: AppSyncClientTypes.GraphqlApi?
}

extension UpdateGraphqlApiOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case graphqlApi
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphqlApiDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.GraphqlApi.self, forKey: .graphqlApi)
        graphqlApi = graphqlApiDecoded
    }
}

public struct UpdateResolverInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateResolverInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateResolverInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateResolverOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateResolverInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateResolverOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateResolverOutputError>
}

extension UpdateResolverInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateResolverInput(apiId: \(Swift.String(describing: apiId)), cachingConfig: \(Swift.String(describing: cachingConfig)), dataSourceName: \(Swift.String(describing: dataSourceName)), fieldName: \(Swift.String(describing: fieldName)), kind: \(Swift.String(describing: kind)), pipelineConfig: \(Swift.String(describing: pipelineConfig)), requestMappingTemplate: \(Swift.String(describing: requestMappingTemplate)), responseMappingTemplate: \(Swift.String(describing: responseMappingTemplate)), syncConfig: \(Swift.String(describing: syncConfig)), typeName: \(Swift.String(describing: typeName)))"}
}

extension UpdateResolverInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachingConfig
        case dataSourceName
        case kind
        case pipelineConfig
        case requestMappingTemplate
        case responseMappingTemplate
        case syncConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cachingConfig = cachingConfig {
            try encodeContainer.encode(cachingConfig, forKey: .cachingConfig)
        }
        if let dataSourceName = dataSourceName {
            try encodeContainer.encode(dataSourceName, forKey: .dataSourceName)
        }
        if let kind = kind {
            try encodeContainer.encode(kind.rawValue, forKey: .kind)
        }
        if let pipelineConfig = pipelineConfig {
            try encodeContainer.encode(pipelineConfig, forKey: .pipelineConfig)
        }
        if let requestMappingTemplate = requestMappingTemplate {
            try encodeContainer.encode(requestMappingTemplate, forKey: .requestMappingTemplate)
        }
        if let responseMappingTemplate = responseMappingTemplate {
            try encodeContainer.encode(responseMappingTemplate, forKey: .responseMappingTemplate)
        }
        if let syncConfig = syncConfig {
            try encodeContainer.encode(syncConfig, forKey: .syncConfig)
        }
    }
}

public struct UpdateResolverInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateResolverInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateResolverInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateResolverOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateResolverInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateResolverOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateResolverOutputError>
}

public struct UpdateResolverInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateResolverInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateResolverInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateResolverOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateResolverInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateResolverOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateResolverOutputError>
}

public struct UpdateResolverInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateResolverInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateResolverInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateResolverOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let apiId = input.apiId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("apiId is nil and needs a value for the path of this operation"))))
        }
        guard let typeName = input.typeName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("typeName is nil and needs a value for the path of this operation"))))
        }
        guard let fieldName = input.fieldName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("fieldName is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/v1/apis/\(apiId.urlPercentEncoding())/types/\(typeName.urlPercentEncoding())/resolvers/\(fieldName.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateResolverInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateResolverOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateResolverOutputError>
}

public struct UpdateResolverInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The caching configuration for the resolver.
    public var cachingConfig: AppSyncClientTypes.CachingConfig?
    /// The new data source name.
    public var dataSourceName: Swift.String?
    /// The new field name.
    /// This member is required.
    public var fieldName: Swift.String?
    /// The resolver type.
    ///
    ///
    ///
    ///                   UNIT: A UNIT resolver type. A UNIT resolver is
    ///                the default resolver type. A UNIT resolver enables you to execute a GraphQL query
    ///                against a single data source.
    ///
    ///
    ///
    ///                   PIPELINE: A PIPELINE resolver type. A PIPELINE
    ///                resolver enables you to execute a series of Function in a serial manner.
    ///                You can use a pipeline resolver to execute a GraphQL query against multiple data
    ///                sources.
    ///
    ///
    public var kind: AppSyncClientTypes.ResolverKind?
    /// The PipelineConfig.
    public var pipelineConfig: AppSyncClientTypes.PipelineConfig?
    /// The new request mapping template.
    ///          A resolver uses a request mapping template to convert a GraphQL expression into a format
    ///          that a data source can understand. Mapping templates are written in Apache Velocity
    ///          Template Language (VTL).
    ///          VTL request mapping templates are optional when using a Lambda data source. For all
    ///          other data sources, VTL request and response mapping templates are required.
    public var requestMappingTemplate: Swift.String?
    /// The new response mapping template.
    public var responseMappingTemplate: Swift.String?
    /// The SyncConfig for a resolver attached to a versioned datasource.
    public var syncConfig: AppSyncClientTypes.SyncConfig?
    /// The new type name.
    /// This member is required.
    public var typeName: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        cachingConfig: AppSyncClientTypes.CachingConfig? = nil,
        dataSourceName: Swift.String? = nil,
        fieldName: Swift.String? = nil,
        kind: AppSyncClientTypes.ResolverKind? = nil,
        pipelineConfig: AppSyncClientTypes.PipelineConfig? = nil,
        requestMappingTemplate: Swift.String? = nil,
        responseMappingTemplate: Swift.String? = nil,
        syncConfig: AppSyncClientTypes.SyncConfig? = nil,
        typeName: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.cachingConfig = cachingConfig
        self.dataSourceName = dataSourceName
        self.fieldName = fieldName
        self.kind = kind
        self.pipelineConfig = pipelineConfig
        self.requestMappingTemplate = requestMappingTemplate
        self.responseMappingTemplate = responseMappingTemplate
        self.syncConfig = syncConfig
        self.typeName = typeName
    }
}

struct UpdateResolverInputBody: Swift.Equatable {
    public let dataSourceName: Swift.String?
    public let requestMappingTemplate: Swift.String?
    public let responseMappingTemplate: Swift.String?
    public let kind: AppSyncClientTypes.ResolverKind?
    public let pipelineConfig: AppSyncClientTypes.PipelineConfig?
    public let syncConfig: AppSyncClientTypes.SyncConfig?
    public let cachingConfig: AppSyncClientTypes.CachingConfig?
}

extension UpdateResolverInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachingConfig
        case dataSourceName
        case kind
        case pipelineConfig
        case requestMappingTemplate
        case responseMappingTemplate
        case syncConfig
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceName)
        dataSourceName = dataSourceNameDecoded
        let requestMappingTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestMappingTemplate)
        requestMappingTemplate = requestMappingTemplateDecoded
        let responseMappingTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .responseMappingTemplate)
        responseMappingTemplate = responseMappingTemplateDecoded
        let kindDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ResolverKind.self, forKey: .kind)
        kind = kindDecoded
        let pipelineConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.PipelineConfig.self, forKey: .pipelineConfig)
        pipelineConfig = pipelineConfigDecoded
        let syncConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.SyncConfig.self, forKey: .syncConfig)
        syncConfig = syncConfigDecoded
        let cachingConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.CachingConfig.self, forKey: .cachingConfig)
        cachingConfig = cachingConfigDecoded
    }
}

extension UpdateResolverOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateResolverOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateResolverOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateResolverOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateResolverOutputResponse(resolver: \(Swift.String(describing: resolver)))"}
}

extension UpdateResolverOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateResolverOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resolver = output.resolver
        } else {
            self.resolver = nil
        }
    }
}

public struct UpdateResolverOutputResponse: Swift.Equatable {
    /// The updated Resolver object.
    public var resolver: AppSyncClientTypes.Resolver?

    public init (
        resolver: AppSyncClientTypes.Resolver? = nil
    )
    {
        self.resolver = resolver
    }
}

struct UpdateResolverOutputResponseBody: Swift.Equatable {
    public let resolver: AppSyncClientTypes.Resolver?
}

extension UpdateResolverOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolver
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.Resolver.self, forKey: .resolver)
        resolver = resolverDecoded
    }
}

public struct UpdateTypeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateTypeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateTypeOutputError>
}

extension UpdateTypeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateTypeInput(apiId: \(Swift.String(describing: apiId)), definition: \(Swift.String(describing: definition)), format: \(Swift.String(describing: format)), typeName: \(Swift.String(describing: typeName)))"}
}

extension UpdateTypeInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition
        case format
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let definition = definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
    }
}

public struct UpdateTypeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateTypeOutputError>
}

public struct UpdateTypeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateTypeOutputError>
}

public struct UpdateTypeInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateTypeInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateTypeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let apiId = input.apiId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("apiId is nil and needs a value for the path of this operation"))))
        }
        guard let typeName = input.typeName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("typeName is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/v1/apis/\(apiId.urlPercentEncoding())/types/\(typeName.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateTypeInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateTypeOutputError>
}

public struct UpdateTypeInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The new definition.
    public var definition: Swift.String?
    /// The new type format: SDL or JSON.
    /// This member is required.
    public var format: AppSyncClientTypes.TypeDefinitionFormat?
    /// The new type name.
    /// This member is required.
    public var typeName: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        definition: Swift.String? = nil,
        format: AppSyncClientTypes.TypeDefinitionFormat? = nil,
        typeName: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.definition = definition
        self.format = format
        self.typeName = typeName
    }
}

struct UpdateTypeInputBody: Swift.Equatable {
    public let definition: Swift.String?
    public let format: AppSyncClientTypes.TypeDefinitionFormat?
}

extension UpdateTypeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition
        case format
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let definitionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .definition)
        definition = definitionDecoded
        let formatDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.TypeDefinitionFormat.self, forKey: .format)
        format = formatDecoded
    }
}

extension UpdateTypeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateTypeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateTypeOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateTypeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateTypeOutputResponse(type: \(Swift.String(describing: type)))"}
}

extension UpdateTypeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateTypeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.type = output.type
        } else {
            self.type = nil
        }
    }
}

public struct UpdateTypeOutputResponse: Swift.Equatable {
    /// The updated Type object.
    public var type: AppSyncClientTypes.ModelType?

    public init (
        type: AppSyncClientTypes.ModelType? = nil
    )
    {
        self.type = type
    }
}

struct UpdateTypeOutputResponseBody: Swift.Equatable {
    public let type: AppSyncClientTypes.ModelType?
}

extension UpdateTypeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ModelType.self, forKey: .type)
        type = typeDecoded
    }
}

extension AppSyncClientTypes.UserPoolConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appIdClientRegex
        case awsRegion
        case defaultAction
        case userPoolId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appIdClientRegex = appIdClientRegex {
            try encodeContainer.encode(appIdClientRegex, forKey: .appIdClientRegex)
        }
        if let awsRegion = awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let defaultAction = defaultAction {
            try encodeContainer.encode(defaultAction.rawValue, forKey: .defaultAction)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let defaultActionDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.DefaultAction.self, forKey: .defaultAction)
        defaultAction = defaultActionDecoded
        let appIdClientRegexDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appIdClientRegex)
        appIdClientRegex = appIdClientRegexDecoded
    }
}

extension AppSyncClientTypes.UserPoolConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UserPoolConfig(appIdClientRegex: \(Swift.String(describing: appIdClientRegex)), awsRegion: \(Swift.String(describing: awsRegion)), defaultAction: \(Swift.String(describing: defaultAction)), userPoolId: \(Swift.String(describing: userPoolId)))"}
}

extension AppSyncClientTypes {
    /// Describes an Amazon Cognito user pool configuration.
    public struct UserPoolConfig: Swift.Equatable {
        /// A regular expression for validating the incoming Amazon Cognito user pool app client
        ///          ID.
        public var appIdClientRegex: Swift.String?
        /// The Amazon Web Services Region in which the user pool was created.
        /// This member is required.
        public var awsRegion: Swift.String?
        /// The action that you want your GraphQL API to take when a request that uses Amazon
        ///          Cognito user pool authentication doesn't match the Amazon Cognito user pool
        ///          configuration.
        /// This member is required.
        public var defaultAction: AppSyncClientTypes.DefaultAction?
        /// The user pool ID.
        /// This member is required.
        public var userPoolId: Swift.String?

        public init (
            appIdClientRegex: Swift.String? = nil,
            awsRegion: Swift.String? = nil,
            defaultAction: AppSyncClientTypes.DefaultAction? = nil,
            userPoolId: Swift.String? = nil
        )
        {
            self.appIdClientRegex = appIdClientRegex
            self.awsRegion = awsRegion
            self.defaultAction = defaultAction
            self.userPoolId = userPoolId
        }
    }

}
