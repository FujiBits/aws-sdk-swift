// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension CloseTunnelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CloseTunnelInput(delete: \(Swift.String(describing: delete)), tunnelId: \(Swift.String(describing: tunnelId)))"}
}

extension CloseTunnelInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct CloseTunnelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CloseTunnelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CloseTunnelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CloseTunnelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CloseTunnelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CloseTunnelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CloseTunnelOutputError>
}

public struct CloseTunnelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CloseTunnelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CloseTunnelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CloseTunnelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CloseTunnelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CloseTunnelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CloseTunnelOutputError>
}

public struct CloseTunnelInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CloseTunnelInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CloseTunnelInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CloseTunnelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CloseTunnelInput
    public typealias MOutput = ClientRuntime.OperationOutput<CloseTunnelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CloseTunnelOutputError>
}

public struct CloseTunnelInput: Swift.Equatable {
    /// When set to true, AWS IoT Secure Tunneling deletes the tunnel data
    /// 			immediately.
    public var delete: Swift.Bool
    /// The ID of the tunnel to close.
    /// This member is required.
    public var tunnelId: Swift.String?

    public init (
        delete: Swift.Bool = false,
        tunnelId: Swift.String? = nil
    )
    {
        self.delete = delete
        self.tunnelId = tunnelId
    }
}

struct CloseTunnelInputBody: Swift.Equatable {
}

extension CloseTunnelInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CloseTunnelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CloseTunnelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CloseTunnelOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CloseTunnelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CloseTunnelOutputResponse()"}
}

extension CloseTunnelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CloseTunnelOutputResponse: Swift.Equatable {

    public init() {}
}

struct CloseTunnelOutputResponseBody: Swift.Equatable {
}

extension CloseTunnelOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension IoTSecureTunnelingClientTypes.ConnectionState: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastUpdatedAt
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastUpdatedAt = lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(IoTSecureTunnelingClientTypes.ConnectionStatus.self, forKey: .status)
        status = statusDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension IoTSecureTunnelingClientTypes.ConnectionState: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConnectionState(lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), status: \(Swift.String(describing: status)))"}
}

extension IoTSecureTunnelingClientTypes {
    /// The state of a connection.
    public struct ConnectionState: Swift.Equatable {
        /// The last time the connection status was updated.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The connection status of the tunnel. Valid values are CONNECTED and
        /// 				DISCONNECTED.
        public var status: IoTSecureTunnelingClientTypes.ConnectionStatus?

        public init (
            lastUpdatedAt: ClientRuntime.Date? = nil,
            status: IoTSecureTunnelingClientTypes.ConnectionStatus? = nil
        )
        {
            self.lastUpdatedAt = lastUpdatedAt
            self.status = status
        }
    }

}

extension IoTSecureTunnelingClientTypes {
    public enum ConnectionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case connected
        case disconnected
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionStatus] {
            return [
                .connected,
                .disconnected,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .connected: return "CONNECTED"
            case .disconnected: return "DISCONNECTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConnectionStatus(rawValue: rawValue) ?? ConnectionStatus.sdkUnknown(rawValue)
        }
    }
}

extension DescribeTunnelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeTunnelInput(tunnelId: \(Swift.String(describing: tunnelId)))"}
}

extension DescribeTunnelInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeTunnelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTunnelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTunnelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTunnelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTunnelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTunnelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTunnelOutputError>
}

public struct DescribeTunnelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTunnelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTunnelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTunnelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTunnelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTunnelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTunnelOutputError>
}

public struct DescribeTunnelInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTunnelInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeTunnelInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTunnelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeTunnelInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTunnelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTunnelOutputError>
}

public struct DescribeTunnelInput: Swift.Equatable {
    /// The tunnel to describe.
    /// This member is required.
    public var tunnelId: Swift.String?

    public init (
        tunnelId: Swift.String? = nil
    )
    {
        self.tunnelId = tunnelId
    }
}

struct DescribeTunnelInputBody: Swift.Equatable {
}

extension DescribeTunnelInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeTunnelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTunnelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTunnelOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTunnelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeTunnelOutputResponse(tunnel: \(Swift.String(describing: tunnel)))"}
}

extension DescribeTunnelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeTunnelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tunnel = output.tunnel
        } else {
            self.tunnel = nil
        }
    }
}

public struct DescribeTunnelOutputResponse: Swift.Equatable {
    /// The tunnel being described.
    public var tunnel: IoTSecureTunnelingClientTypes.Tunnel?

    public init (
        tunnel: IoTSecureTunnelingClientTypes.Tunnel? = nil
    )
    {
        self.tunnel = tunnel
    }
}

struct DescribeTunnelOutputResponseBody: Swift.Equatable {
    public let tunnel: IoTSecureTunnelingClientTypes.Tunnel?
}

extension DescribeTunnelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tunnel
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tunnelDecoded = try containerValues.decodeIfPresent(IoTSecureTunnelingClientTypes.Tunnel.self, forKey: .tunnel)
        tunnel = tunnelDecoded
    }
}

extension IoTSecureTunnelingClientTypes.DestinationConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case services
        case thingName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let services = services {
            var servicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .services)
            for servicelist0 in services {
                try servicesContainer.encode(servicelist0)
            }
        }
        if let thingName = thingName {
            try encodeContainer.encode(thingName, forKey: .thingName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingName)
        thingName = thingNameDecoded
        let servicesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .services)
        var servicesDecoded0:[Swift.String]? = nil
        if let servicesContainer = servicesContainer {
            servicesDecoded0 = [Swift.String]()
            for string0 in servicesContainer {
                if let string0 = string0 {
                    servicesDecoded0?.append(string0)
                }
            }
        }
        services = servicesDecoded0
    }
}

extension IoTSecureTunnelingClientTypes.DestinationConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DestinationConfig(services: \(Swift.String(describing: services)), thingName: \(Swift.String(describing: thingName)))"}
}

extension IoTSecureTunnelingClientTypes {
    /// The destination configuration.
    public struct DestinationConfig: Swift.Equatable {
        /// A list of service names that identity the target application. The AWS IoT client running on the destination device reads
        /// 			this value and uses it to look up a port or an IP address and a port. The AWS IoT client
        /// 			instantiates the local proxy which uses this information to connect to the destination
        /// 			application.
        /// This member is required.
        public var services: [Swift.String]?
        /// The name of the IoT thing to which you want to connect.
        public var thingName: Swift.String?

        public init (
            services: [Swift.String]? = nil,
            thingName: Swift.String? = nil
        )
        {
            self.services = services
            self.thingName = thingName
        }
    }

}

extension LimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Thrown when a tunnel limit is exceeded.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The resource ARN.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags for the specified resource.
    public var tags: [IoTSecureTunnelingClientTypes.Tag]?

    public init (
        tags: [IoTSecureTunnelingClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [IoTSecureTunnelingClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([IoTSecureTunnelingClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTSecureTunnelingClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTSecureTunnelingClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListTunnelsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTunnelsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), thingName: \(Swift.String(describing: thingName)))"}
}

extension ListTunnelsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTunnelsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTunnelsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTunnelsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTunnelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTunnelsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTunnelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTunnelsOutputError>
}

public struct ListTunnelsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTunnelsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTunnelsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTunnelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTunnelsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTunnelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTunnelsOutputError>
}

public struct ListTunnelsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTunnelsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListTunnelsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTunnelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTunnelsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTunnelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTunnelsOutputError>
}

public struct ListTunnelsInput: Swift.Equatable {
    /// The maximum number of results to return at once.
    public var maxResults: Swift.Int
    /// A token to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The name of the IoT thing associated with the destination device.
    public var thingName: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.thingName = thingName
    }
}

struct ListTunnelsInputBody: Swift.Equatable {
}

extension ListTunnelsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTunnelsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTunnelsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTunnelsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTunnelsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTunnelsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), tunnelSummaries: \(Swift.String(describing: tunnelSummaries)))"}
}

extension ListTunnelsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTunnelsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tunnelSummaries = output.tunnelSummaries
        } else {
            self.nextToken = nil
            self.tunnelSummaries = nil
        }
    }
}

public struct ListTunnelsOutputResponse: Swift.Equatable {
    /// A token to used to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// A short description of the tunnels in an AWS account.
    public var tunnelSummaries: [IoTSecureTunnelingClientTypes.TunnelSummary]?

    public init (
        nextToken: Swift.String? = nil,
        tunnelSummaries: [IoTSecureTunnelingClientTypes.TunnelSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.tunnelSummaries = tunnelSummaries
    }
}

struct ListTunnelsOutputResponseBody: Swift.Equatable {
    public let tunnelSummaries: [IoTSecureTunnelingClientTypes.TunnelSummary]?
    public let nextToken: Swift.String?
}

extension ListTunnelsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case tunnelSummaries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tunnelSummariesContainer = try containerValues.decodeIfPresent([IoTSecureTunnelingClientTypes.TunnelSummary?].self, forKey: .tunnelSummaries)
        var tunnelSummariesDecoded0:[IoTSecureTunnelingClientTypes.TunnelSummary]? = nil
        if let tunnelSummariesContainer = tunnelSummariesContainer {
            tunnelSummariesDecoded0 = [IoTSecureTunnelingClientTypes.TunnelSummary]()
            for structure0 in tunnelSummariesContainer {
                if let structure0 = structure0 {
                    tunnelSummariesDecoded0?.append(structure0)
                }
            }
        }
        tunnelSummaries = tunnelSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct OpenTunnelInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "OpenTunnelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<OpenTunnelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<OpenTunnelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<OpenTunnelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<OpenTunnelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<OpenTunnelOutputError>
}

extension OpenTunnelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OpenTunnelInput(description: \(Swift.String(describing: description)), destinationConfig: \(Swift.String(describing: destinationConfig)), tags: \(Swift.String(describing: tags)), timeoutConfig: \(Swift.String(describing: timeoutConfig)))"}
}

extension OpenTunnelInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case destinationConfig
        case tags
        case timeoutConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destinationConfig = destinationConfig {
            try encodeContainer.encode(destinationConfig, forKey: .destinationConfig)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let timeoutConfig = timeoutConfig {
            try encodeContainer.encode(timeoutConfig, forKey: .timeoutConfig)
        }
    }
}

public struct OpenTunnelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "OpenTunnelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<OpenTunnelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<OpenTunnelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<OpenTunnelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<OpenTunnelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<OpenTunnelOutputError>
}

public struct OpenTunnelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "OpenTunnelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<OpenTunnelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<OpenTunnelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<OpenTunnelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<OpenTunnelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<OpenTunnelOutputError>
}

public struct OpenTunnelInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "OpenTunnelInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: OpenTunnelInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<OpenTunnelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = OpenTunnelInput
    public typealias MOutput = ClientRuntime.OperationOutput<OpenTunnelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<OpenTunnelOutputError>
}

public struct OpenTunnelInput: Swift.Equatable {
    /// A short text description of the tunnel.
    public var description: Swift.String?
    /// The destination configuration for the OpenTunnel request.
    public var destinationConfig: IoTSecureTunnelingClientTypes.DestinationConfig?
    /// A collection of tag metadata.
    public var tags: [IoTSecureTunnelingClientTypes.Tag]?
    /// Timeout configuration for a tunnel.
    public var timeoutConfig: IoTSecureTunnelingClientTypes.TimeoutConfig?

    public init (
        description: Swift.String? = nil,
        destinationConfig: IoTSecureTunnelingClientTypes.DestinationConfig? = nil,
        tags: [IoTSecureTunnelingClientTypes.Tag]? = nil,
        timeoutConfig: IoTSecureTunnelingClientTypes.TimeoutConfig? = nil
    )
    {
        self.description = description
        self.destinationConfig = destinationConfig
        self.tags = tags
        self.timeoutConfig = timeoutConfig
    }
}

struct OpenTunnelInputBody: Swift.Equatable {
    public let description: Swift.String?
    public let tags: [IoTSecureTunnelingClientTypes.Tag]?
    public let destinationConfig: IoTSecureTunnelingClientTypes.DestinationConfig?
    public let timeoutConfig: IoTSecureTunnelingClientTypes.TimeoutConfig?
}

extension OpenTunnelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case destinationConfig
        case tags
        case timeoutConfig
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTSecureTunnelingClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTSecureTunnelingClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTSecureTunnelingClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let destinationConfigDecoded = try containerValues.decodeIfPresent(IoTSecureTunnelingClientTypes.DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
        let timeoutConfigDecoded = try containerValues.decodeIfPresent(IoTSecureTunnelingClientTypes.TimeoutConfig.self, forKey: .timeoutConfig)
        timeoutConfig = timeoutConfigDecoded
    }
}

extension OpenTunnelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension OpenTunnelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum OpenTunnelOutputError: Swift.Error, Swift.Equatable {
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension OpenTunnelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OpenTunnelOutputResponse(destinationAccessToken: \(Swift.String(describing: destinationAccessToken)), sourceAccessToken: \(Swift.String(describing: sourceAccessToken)), tunnelArn: \(Swift.String(describing: tunnelArn)), tunnelId: \(Swift.String(describing: tunnelId)))"}
}

extension OpenTunnelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: OpenTunnelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.destinationAccessToken = output.destinationAccessToken
            self.sourceAccessToken = output.sourceAccessToken
            self.tunnelArn = output.tunnelArn
            self.tunnelId = output.tunnelId
        } else {
            self.destinationAccessToken = nil
            self.sourceAccessToken = nil
            self.tunnelArn = nil
            self.tunnelId = nil
        }
    }
}

public struct OpenTunnelOutputResponse: Swift.Equatable {
    /// The access token the destination local proxy uses to connect to AWS IoT Secure
    /// 			Tunneling.
    public var destinationAccessToken: Swift.String?
    /// The access token the source local proxy uses to connect to AWS IoT Secure
    /// 			Tunneling.
    public var sourceAccessToken: Swift.String?
    /// The Amazon Resource Name for the tunnel. The tunnel ARN format is
    /// 				arn:aws:tunnel:<region>:<account-id>:tunnel/<tunnel-id>
    ///
    public var tunnelArn: Swift.String?
    /// A unique alpha-numeric tunnel ID.
    public var tunnelId: Swift.String?

    public init (
        destinationAccessToken: Swift.String? = nil,
        sourceAccessToken: Swift.String? = nil,
        tunnelArn: Swift.String? = nil,
        tunnelId: Swift.String? = nil
    )
    {
        self.destinationAccessToken = destinationAccessToken
        self.sourceAccessToken = sourceAccessToken
        self.tunnelArn = tunnelArn
        self.tunnelId = tunnelId
    }
}

struct OpenTunnelOutputResponseBody: Swift.Equatable {
    public let tunnelId: Swift.String?
    public let tunnelArn: Swift.String?
    public let sourceAccessToken: Swift.String?
    public let destinationAccessToken: Swift.String?
}

extension OpenTunnelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationAccessToken
        case sourceAccessToken
        case tunnelArn
        case tunnelId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tunnelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tunnelId)
        tunnelId = tunnelIdDecoded
        let tunnelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tunnelArn)
        tunnelArn = tunnelArnDecoded
        let sourceAccessTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceAccessToken)
        sourceAccessToken = sourceAccessTokenDecoded
        let destinationAccessTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationAccessToken)
        destinationAccessToken = destinationAccessTokenDecoded
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Thrown when an operation is attempted on a resource that does not exist.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTSecureTunnelingClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension IoTSecureTunnelingClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension IoTSecureTunnelingClientTypes {
    /// An arbitary key/value pair used to add searchable metadata to secure tunnel
    /// 			resources.
    public struct Tag: Swift.Equatable {
        /// The key of the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the tag.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags for the resource.
    /// This member is required.
    public var tags: [IoTSecureTunnelingClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [IoTSecureTunnelingClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
    public let tags: [IoTSecureTunnelingClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTSecureTunnelingClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTSecureTunnelingClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTSecureTunnelingClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension IoTSecureTunnelingClientTypes.TimeoutConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxLifetimeTimeoutMinutes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxLifetimeTimeoutMinutes != 0 {
            try encodeContainer.encode(maxLifetimeTimeoutMinutes, forKey: .maxLifetimeTimeoutMinutes)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxLifetimeTimeoutMinutesDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxLifetimeTimeoutMinutes)
        maxLifetimeTimeoutMinutes = maxLifetimeTimeoutMinutesDecoded
    }
}

extension IoTSecureTunnelingClientTypes.TimeoutConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TimeoutConfig(maxLifetimeTimeoutMinutes: \(Swift.String(describing: maxLifetimeTimeoutMinutes)))"}
}

extension IoTSecureTunnelingClientTypes {
    /// Tunnel timeout configuration.
    public struct TimeoutConfig: Swift.Equatable {
        /// The maximum amount of time (in minutes) a tunnel can remain open. If not specified,
        /// 			maxLifetimeTimeoutMinutes defaults to 720 minutes. Valid values are from 1 minute to 12
        /// 			hours (720 minutes)
        public var maxLifetimeTimeoutMinutes: Swift.Int

        public init (
            maxLifetimeTimeoutMinutes: Swift.Int = 0
        )
        {
            self.maxLifetimeTimeoutMinutes = maxLifetimeTimeoutMinutes
        }
    }

}

extension IoTSecureTunnelingClientTypes.Tunnel: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case description
        case destinationConfig
        case destinationConnectionState
        case lastUpdatedAt
        case sourceConnectionState
        case status
        case tags
        case timeoutConfig
        case tunnelArn
        case tunnelId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destinationConfig = destinationConfig {
            try encodeContainer.encode(destinationConfig, forKey: .destinationConfig)
        }
        if let destinationConnectionState = destinationConnectionState {
            try encodeContainer.encode(destinationConnectionState, forKey: .destinationConnectionState)
        }
        if let lastUpdatedAt = lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
        if let sourceConnectionState = sourceConnectionState {
            try encodeContainer.encode(sourceConnectionState, forKey: .sourceConnectionState)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let timeoutConfig = timeoutConfig {
            try encodeContainer.encode(timeoutConfig, forKey: .timeoutConfig)
        }
        if let tunnelArn = tunnelArn {
            try encodeContainer.encode(tunnelArn, forKey: .tunnelArn)
        }
        if let tunnelId = tunnelId {
            try encodeContainer.encode(tunnelId, forKey: .tunnelId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tunnelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tunnelId)
        tunnelId = tunnelIdDecoded
        let tunnelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tunnelArn)
        tunnelArn = tunnelArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTSecureTunnelingClientTypes.TunnelStatus.self, forKey: .status)
        status = statusDecoded
        let sourceConnectionStateDecoded = try containerValues.decodeIfPresent(IoTSecureTunnelingClientTypes.ConnectionState.self, forKey: .sourceConnectionState)
        sourceConnectionState = sourceConnectionStateDecoded
        let destinationConnectionStateDecoded = try containerValues.decodeIfPresent(IoTSecureTunnelingClientTypes.ConnectionState.self, forKey: .destinationConnectionState)
        destinationConnectionState = destinationConnectionStateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(IoTSecureTunnelingClientTypes.DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
        let timeoutConfigDecoded = try containerValues.decodeIfPresent(IoTSecureTunnelingClientTypes.TimeoutConfig.self, forKey: .timeoutConfig)
        timeoutConfig = timeoutConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTSecureTunnelingClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTSecureTunnelingClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTSecureTunnelingClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension IoTSecureTunnelingClientTypes.Tunnel: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tunnel(createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), destinationConfig: \(Swift.String(describing: destinationConfig)), destinationConnectionState: \(Swift.String(describing: destinationConnectionState)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), sourceConnectionState: \(Swift.String(describing: sourceConnectionState)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)), timeoutConfig: \(Swift.String(describing: timeoutConfig)), tunnelArn: \(Swift.String(describing: tunnelArn)), tunnelId: \(Swift.String(describing: tunnelId)))"}
}

extension IoTSecureTunnelingClientTypes {
    /// A connection between a source computer and a destination device.
    public struct Tunnel: Swift.Equatable {
        /// The time when the tunnel was created.
        public var createdAt: ClientRuntime.Date?
        /// A description of the tunnel.
        public var description: Swift.String?
        /// The destination configuration that specifies the thing name of the destination
        /// 			device and a service name that the local proxy uses to connect to the destination
        /// 			application.
        public var destinationConfig: IoTSecureTunnelingClientTypes.DestinationConfig?
        /// The connection state of the destination application.
        public var destinationConnectionState: IoTSecureTunnelingClientTypes.ConnectionState?
        /// The last time the tunnel was updated.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The connection state of the source application.
        public var sourceConnectionState: IoTSecureTunnelingClientTypes.ConnectionState?
        /// The status of a tunnel. Valid values are: Open and Closed.
        public var status: IoTSecureTunnelingClientTypes.TunnelStatus?
        /// A list of tag metadata associated with the secure tunnel.
        public var tags: [IoTSecureTunnelingClientTypes.Tag]?
        /// Timeout configuration for the tunnel.
        public var timeoutConfig: IoTSecureTunnelingClientTypes.TimeoutConfig?
        /// The Amazon Resource Name (ARN) of a tunnel. The tunnel ARN format is
        /// 				arn:aws:tunnel:<region>:<account-id>:tunnel/<tunnel-id>
        ///
        public var tunnelArn: Swift.String?
        /// A unique alpha-numeric ID that identifies a tunnel.
        public var tunnelId: Swift.String?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            destinationConfig: IoTSecureTunnelingClientTypes.DestinationConfig? = nil,
            destinationConnectionState: IoTSecureTunnelingClientTypes.ConnectionState? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            sourceConnectionState: IoTSecureTunnelingClientTypes.ConnectionState? = nil,
            status: IoTSecureTunnelingClientTypes.TunnelStatus? = nil,
            tags: [IoTSecureTunnelingClientTypes.Tag]? = nil,
            timeoutConfig: IoTSecureTunnelingClientTypes.TimeoutConfig? = nil,
            tunnelArn: Swift.String? = nil,
            tunnelId: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.description = description
            self.destinationConfig = destinationConfig
            self.destinationConnectionState = destinationConnectionState
            self.lastUpdatedAt = lastUpdatedAt
            self.sourceConnectionState = sourceConnectionState
            self.status = status
            self.tags = tags
            self.timeoutConfig = timeoutConfig
            self.tunnelArn = tunnelArn
            self.tunnelId = tunnelId
        }
    }

}

extension IoTSecureTunnelingClientTypes {
    public enum TunnelStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case closed
        case `open`
        case sdkUnknown(Swift.String)

        public static var allCases: [TunnelStatus] {
            return [
                .closed,
                .open,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .closed: return "CLOSED"
            case .open: return "OPEN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TunnelStatus(rawValue: rawValue) ?? TunnelStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTSecureTunnelingClientTypes.TunnelSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case description
        case lastUpdatedAt
        case status
        case tunnelArn
        case tunnelId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastUpdatedAt = lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tunnelArn = tunnelArn {
            try encodeContainer.encode(tunnelArn, forKey: .tunnelArn)
        }
        if let tunnelId = tunnelId {
            try encodeContainer.encode(tunnelId, forKey: .tunnelId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tunnelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tunnelId)
        tunnelId = tunnelIdDecoded
        let tunnelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tunnelArn)
        tunnelArn = tunnelArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTSecureTunnelingClientTypes.TunnelStatus.self, forKey: .status)
        status = statusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension IoTSecureTunnelingClientTypes.TunnelSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TunnelSummary(createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), status: \(Swift.String(describing: status)), tunnelArn: \(Swift.String(describing: tunnelArn)), tunnelId: \(Swift.String(describing: tunnelId)))"}
}

extension IoTSecureTunnelingClientTypes {
    /// Information about the tunnel.
    public struct TunnelSummary: Swift.Equatable {
        /// The time the tunnel was created.
        public var createdAt: ClientRuntime.Date?
        /// A description of the tunnel.
        public var description: Swift.String?
        /// The time the tunnel was last updated.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The status of a tunnel. Valid values are: Open and Closed.
        public var status: IoTSecureTunnelingClientTypes.TunnelStatus?
        /// The Amazon Resource Name of the tunnel. The tunnel ARN format is
        /// 				arn:aws:tunnel:<region>:<account-id>:tunnel/<tunnel-id>
        ///
        public var tunnelArn: Swift.String?
        /// The unique alpha-numeric identifier for the tunnel.
        public var tunnelId: Swift.String?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            status: IoTSecureTunnelingClientTypes.TunnelStatus? = nil,
            tunnelArn: Swift.String? = nil,
            tunnelId: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.description = description
            self.lastUpdatedAt = lastUpdatedAt
            self.status = status
            self.tunnelArn = tunnelArn
            self.tunnelId = tunnelId
        }
    }

}

public struct UntagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tagKeys
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// The resource ARN.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of the tags to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
    public let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tagKeys
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}
