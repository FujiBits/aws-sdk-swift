// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictException(message: \(Swift.String(describing: message)))"}
}

extension ConflictException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Your request has the same name as another active human loop but has different input data. You cannot start two
///     human loops with the same name and different input data.</p>
public struct ConflictException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SageMakerA2IRuntimeClientTypes {
    public enum ContentClassifier: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case freeOfAdultContent
        case freeOfPersonallyIdentifiableInformation
        case sdkUnknown(Swift.String)

        public static var allCases: [ContentClassifier] {
            return [
                .freeOfAdultContent,
                .freeOfPersonallyIdentifiableInformation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .freeOfAdultContent: return "FreeOfAdultContent"
            case .freeOfPersonallyIdentifiableInformation: return "FreeOfPersonallyIdentifiableInformation"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContentClassifier(rawValue: rawValue) ?? ContentClassifier.sdkUnknown(rawValue)
        }
    }
}

extension DeleteHumanLoopInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteHumanLoopInput(humanLoopName: \(Swift.String(describing: humanLoopName)))"}
}

extension DeleteHumanLoopInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteHumanLoopInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteHumanLoopInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteHumanLoopInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteHumanLoopOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteHumanLoopInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteHumanLoopOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteHumanLoopOutputError>
}

public struct DeleteHumanLoopInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteHumanLoopInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteHumanLoopInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteHumanLoopOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteHumanLoopInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteHumanLoopOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteHumanLoopOutputError>
}

public struct DeleteHumanLoopInput: Swift.Equatable {
    /// <p>The name of the human loop that you want to delete.</p>
    public let humanLoopName: Swift.String?

    public init (
        humanLoopName: Swift.String? = nil
    )
    {
        self.humanLoopName = humanLoopName
    }
}

struct DeleteHumanLoopInputBody: Swift.Equatable {
}

extension DeleteHumanLoopInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteHumanLoopOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteHumanLoopOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteHumanLoopOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteHumanLoopOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteHumanLoopOutputResponse()"}
}

extension DeleteHumanLoopOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteHumanLoopOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteHumanLoopOutputResponseBody: Swift.Equatable {
}

extension DeleteHumanLoopOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeHumanLoopInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeHumanLoopInput(humanLoopName: \(Swift.String(describing: humanLoopName)))"}
}

extension DescribeHumanLoopInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeHumanLoopInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeHumanLoopInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeHumanLoopInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeHumanLoopOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeHumanLoopInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeHumanLoopOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeHumanLoopOutputError>
}

public struct DescribeHumanLoopInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeHumanLoopInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeHumanLoopInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeHumanLoopOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeHumanLoopInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeHumanLoopOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeHumanLoopOutputError>
}

public struct DescribeHumanLoopInput: Swift.Equatable {
    /// <p>The name of the human loop that you want information about.</p>
    public let humanLoopName: Swift.String?

    public init (
        humanLoopName: Swift.String? = nil
    )
    {
        self.humanLoopName = humanLoopName
    }
}

struct DescribeHumanLoopInputBody: Swift.Equatable {
}

extension DescribeHumanLoopInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeHumanLoopOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeHumanLoopOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeHumanLoopOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeHumanLoopOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeHumanLoopOutputResponse(creationTime: \(Swift.String(describing: creationTime)), failureCode: \(Swift.String(describing: failureCode)), failureReason: \(Swift.String(describing: failureReason)), flowDefinitionArn: \(Swift.String(describing: flowDefinitionArn)), humanLoopArn: \(Swift.String(describing: humanLoopArn)), humanLoopName: \(Swift.String(describing: humanLoopName)), humanLoopOutput: \(Swift.String(describing: humanLoopOutput)), humanLoopStatus: \(Swift.String(describing: humanLoopStatus)))"}
}

extension DescribeHumanLoopOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeHumanLoopOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.failureCode = output.failureCode
            self.failureReason = output.failureReason
            self.flowDefinitionArn = output.flowDefinitionArn
            self.humanLoopArn = output.humanLoopArn
            self.humanLoopName = output.humanLoopName
            self.humanLoopOutput = output.humanLoopOutput
            self.humanLoopStatus = output.humanLoopStatus
        } else {
            self.creationTime = nil
            self.failureCode = nil
            self.failureReason = nil
            self.flowDefinitionArn = nil
            self.humanLoopArn = nil
            self.humanLoopName = nil
            self.humanLoopOutput = nil
            self.humanLoopStatus = nil
        }
    }
}

public struct DescribeHumanLoopOutputResponse: Swift.Equatable {
    /// <p>The creation time when Amazon Augmented AI created the human loop.</p>
    public let creationTime: ClientRuntime.Date?
    /// <p>A failure code that identifies the type of failure.</p>
    ///          <p>Possible values: <code>ValidationError</code>, <code>Expired</code>,
    ///         <code>InternalError</code>
    ///          </p>
    public let failureCode: Swift.String?
    /// <p>The reason why a human loop failed. The failure reason is returned when the status of the
    ///       human loop is <code>Failed</code>.</p>
    public let failureReason: Swift.String?
    /// <p>The Amazon Resource Name (ARN) of the flow definition.</p>
    public let flowDefinitionArn: Swift.String?
    /// <p>The Amazon Resource Name (ARN) of the human loop.</p>
    public let humanLoopArn: Swift.String?
    /// <p>The name of the human loop. The name must be lowercase, unique within the Region in your
    ///       account, and can have up to 63 characters. Valid characters: a-z, 0-9, and - (hyphen).</p>
    public let humanLoopName: Swift.String?
    /// <p>An object that contains information about the output of the human loop.</p>
    public let humanLoopOutput: SageMakerA2IRuntimeClientTypes.HumanLoopOutput?
    /// <p>The status of the human loop. </p>
    public let humanLoopStatus: SageMakerA2IRuntimeClientTypes.HumanLoopStatus?

    public init (
        creationTime: ClientRuntime.Date? = nil,
        failureCode: Swift.String? = nil,
        failureReason: Swift.String? = nil,
        flowDefinitionArn: Swift.String? = nil,
        humanLoopArn: Swift.String? = nil,
        humanLoopName: Swift.String? = nil,
        humanLoopOutput: SageMakerA2IRuntimeClientTypes.HumanLoopOutput? = nil,
        humanLoopStatus: SageMakerA2IRuntimeClientTypes.HumanLoopStatus? = nil
    )
    {
        self.creationTime = creationTime
        self.failureCode = failureCode
        self.failureReason = failureReason
        self.flowDefinitionArn = flowDefinitionArn
        self.humanLoopArn = humanLoopArn
        self.humanLoopName = humanLoopName
        self.humanLoopOutput = humanLoopOutput
        self.humanLoopStatus = humanLoopStatus
    }
}

struct DescribeHumanLoopOutputResponseBody: Swift.Equatable {
    public let creationTime: ClientRuntime.Date?
    public let failureReason: Swift.String?
    public let failureCode: Swift.String?
    public let humanLoopStatus: SageMakerA2IRuntimeClientTypes.HumanLoopStatus?
    public let humanLoopName: Swift.String?
    public let humanLoopArn: Swift.String?
    public let flowDefinitionArn: Swift.String?
    public let humanLoopOutput: SageMakerA2IRuntimeClientTypes.HumanLoopOutput?
}

extension DescribeHumanLoopOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case failureCode = "FailureCode"
        case failureReason = "FailureReason"
        case flowDefinitionArn = "FlowDefinitionArn"
        case humanLoopArn = "HumanLoopArn"
        case humanLoopName = "HumanLoopName"
        case humanLoopOutput = "HumanLoopOutput"
        case humanLoopStatus = "HumanLoopStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let humanLoopStatusDecoded = try containerValues.decodeIfPresent(SageMakerA2IRuntimeClientTypes.HumanLoopStatus.self, forKey: .humanLoopStatus)
        humanLoopStatus = humanLoopStatusDecoded
        let humanLoopNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .humanLoopName)
        humanLoopName = humanLoopNameDecoded
        let humanLoopArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .humanLoopArn)
        humanLoopArn = humanLoopArnDecoded
        let flowDefinitionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowDefinitionArn)
        flowDefinitionArn = flowDefinitionArnDecoded
        let humanLoopOutputDecoded = try containerValues.decodeIfPresent(SageMakerA2IRuntimeClientTypes.HumanLoopOutput.self, forKey: .humanLoopOutput)
        humanLoopOutput = humanLoopOutputDecoded
    }
}

extension SageMakerA2IRuntimeClientTypes.HumanLoopDataAttributes: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentClassifiers = "ContentClassifiers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentClassifiers = contentClassifiers {
            var contentClassifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .contentClassifiers)
            for contentclassifiers0 in contentClassifiers {
                try contentClassifiersContainer.encode(contentclassifiers0.rawValue)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentClassifiersContainer = try containerValues.decodeIfPresent([SageMakerA2IRuntimeClientTypes.ContentClassifier?].self, forKey: .contentClassifiers)
        var contentClassifiersDecoded0:[SageMakerA2IRuntimeClientTypes.ContentClassifier]? = nil
        if let contentClassifiersContainer = contentClassifiersContainer {
            contentClassifiersDecoded0 = [SageMakerA2IRuntimeClientTypes.ContentClassifier]()
            for string0 in contentClassifiersContainer {
                if let string0 = string0 {
                    contentClassifiersDecoded0?.append(string0)
                }
            }
        }
        contentClassifiers = contentClassifiersDecoded0
    }
}

extension SageMakerA2IRuntimeClientTypes.HumanLoopDataAttributes: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HumanLoopDataAttributes(contentClassifiers: \(Swift.String(describing: contentClassifiers)))"}
}

extension SageMakerA2IRuntimeClientTypes {
    /// <p>Attributes of the data specified by the customer. Use these to describe the data to be labeled.</p>
    public struct HumanLoopDataAttributes: Swift.Equatable {
        /// <p>Declares that your content is free of personally identifiable information or adult content.</p>
        ///          <p>Amazon SageMaker can restrict the Amazon Mechanical Turk workers who can view your task based on this information.</p>
        public let contentClassifiers: [SageMakerA2IRuntimeClientTypes.ContentClassifier]?

        public init (
            contentClassifiers: [SageMakerA2IRuntimeClientTypes.ContentClassifier]? = nil
        )
        {
            self.contentClassifiers = contentClassifiers
        }
    }

}

extension SageMakerA2IRuntimeClientTypes.HumanLoopInput: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputContent = "InputContent"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputContent = inputContent {
            try encodeContainer.encode(inputContent, forKey: .inputContent)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputContentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputContent)
        inputContent = inputContentDecoded
    }
}

extension SageMakerA2IRuntimeClientTypes.HumanLoopInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HumanLoopInput(inputContent: \(Swift.String(describing: inputContent)))"}
}

extension SageMakerA2IRuntimeClientTypes {
    /// <p>An object containing the human loop input in JSON format.</p>
    public struct HumanLoopInput: Swift.Equatable {
        /// <p>Serialized input from the human loop. The input must be a string representation of a file in JSON format.</p>
        public let inputContent: Swift.String?

        public init (
            inputContent: Swift.String? = nil
        )
        {
            self.inputContent = inputContent
        }
    }

}

extension SageMakerA2IRuntimeClientTypes.HumanLoopOutput: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case outputS3Uri = "OutputS3Uri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let outputS3Uri = outputS3Uri {
            try encodeContainer.encode(outputS3Uri, forKey: .outputS3Uri)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputS3UriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputS3Uri)
        outputS3Uri = outputS3UriDecoded
    }
}

extension SageMakerA2IRuntimeClientTypes.HumanLoopOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HumanLoopOutput(outputS3Uri: \(Swift.String(describing: outputS3Uri)))"}
}

extension SageMakerA2IRuntimeClientTypes {
    /// <p>Information about where the human output will be stored.</p>
    public struct HumanLoopOutput: Swift.Equatable {
        /// <p>The location of the Amazon S3 object where Amazon Augmented AI stores your human loop output.</p>
        public let outputS3Uri: Swift.String?

        public init (
            outputS3Uri: Swift.String? = nil
        )
        {
            self.outputS3Uri = outputS3Uri
        }
    }

}

extension SageMakerA2IRuntimeClientTypes {
    public enum HumanLoopStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [HumanLoopStatus] {
            return [
                .completed,
                .failed,
                .inProgress,
                .stopped,
                .stopping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "Completed"
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case .stopped: return "Stopped"
            case .stopping: return "Stopping"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HumanLoopStatus(rawValue: rawValue) ?? HumanLoopStatus.sdkUnknown(rawValue)
        }
    }
}

extension SageMakerA2IRuntimeClientTypes.HumanLoopSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case failureReason = "FailureReason"
        case flowDefinitionArn = "FlowDefinitionArn"
        case humanLoopName = "HumanLoopName"
        case humanLoopStatus = "HumanLoopStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let flowDefinitionArn = flowDefinitionArn {
            try encodeContainer.encode(flowDefinitionArn, forKey: .flowDefinitionArn)
        }
        if let humanLoopName = humanLoopName {
            try encodeContainer.encode(humanLoopName, forKey: .humanLoopName)
        }
        if let humanLoopStatus = humanLoopStatus {
            try encodeContainer.encode(humanLoopStatus.rawValue, forKey: .humanLoopStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let humanLoopNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .humanLoopName)
        humanLoopName = humanLoopNameDecoded
        let humanLoopStatusDecoded = try containerValues.decodeIfPresent(SageMakerA2IRuntimeClientTypes.HumanLoopStatus.self, forKey: .humanLoopStatus)
        humanLoopStatus = humanLoopStatusDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let flowDefinitionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowDefinitionArn)
        flowDefinitionArn = flowDefinitionArnDecoded
    }
}

extension SageMakerA2IRuntimeClientTypes.HumanLoopSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HumanLoopSummary(creationTime: \(Swift.String(describing: creationTime)), failureReason: \(Swift.String(describing: failureReason)), flowDefinitionArn: \(Swift.String(describing: flowDefinitionArn)), humanLoopName: \(Swift.String(describing: humanLoopName)), humanLoopStatus: \(Swift.String(describing: humanLoopStatus)))"}
}

extension SageMakerA2IRuntimeClientTypes {
    /// <p>Summary information about the human loop.</p>
    public struct HumanLoopSummary: Swift.Equatable {
        /// <p>When Amazon Augmented AI created the human loop.</p>
        public let creationTime: ClientRuntime.Date?
        /// <p>The reason why the human loop failed. A failure reason is returned when the status of the
        ///       human loop is <code>Failed</code>.</p>
        public let failureReason: Swift.String?
        /// <p>The Amazon Resource Name (ARN) of the flow definition used to configure the human
        ///       loop.</p>
        public let flowDefinitionArn: Swift.String?
        /// <p>The name of the human loop.</p>
        public let humanLoopName: Swift.String?
        /// <p>The status of the human loop. </p>
        public let humanLoopStatus: SageMakerA2IRuntimeClientTypes.HumanLoopStatus?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            failureReason: Swift.String? = nil,
            flowDefinitionArn: Swift.String? = nil,
            humanLoopName: Swift.String? = nil,
            humanLoopStatus: SageMakerA2IRuntimeClientTypes.HumanLoopStatus? = nil
        )
        {
            self.creationTime = creationTime
            self.failureReason = failureReason
            self.flowDefinitionArn = flowDefinitionArn
            self.humanLoopName = humanLoopName
            self.humanLoopStatus = humanLoopStatus
        }
    }

}

extension InternalServerException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerException(message: \(Swift.String(describing: message)))"}
}

extension InternalServerException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>We couldn't process your request because of an issue with the server. Try again
///       later.</p>
public struct InternalServerException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListHumanLoopsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListHumanLoopsInput(creationTimeAfter: \(Swift.String(describing: creationTimeAfter)), creationTimeBefore: \(Swift.String(describing: creationTimeBefore)), flowDefinitionArn: \(Swift.String(describing: flowDefinitionArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), sortOrder: \(Swift.String(describing: sortOrder)))"}
}

extension ListHumanLoopsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListHumanLoopsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListHumanLoopsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListHumanLoopsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListHumanLoopsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListHumanLoopsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListHumanLoopsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListHumanLoopsOutputError>
}

public struct ListHumanLoopsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListHumanLoopsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListHumanLoopsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListHumanLoopsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let flowDefinitionArn = input.operationInput.flowDefinitionArn {
            let flowDefinitionArnQueryItem = ClientRuntime.URLQueryItem(name: "FlowDefinitionArn".urlPercentEncoding(), value: Swift.String(flowDefinitionArn).urlPercentEncoding())
            input.builder.withQueryItem(flowDefinitionArnQueryItem)
        }
        if let creationTimeBefore = input.operationInput.creationTimeBefore {
            let creationTimeBeforeQueryItem = ClientRuntime.URLQueryItem(name: "CreationTimeBefore".urlPercentEncoding(), value: Swift.String(creationTimeBefore.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(creationTimeBeforeQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let sortOrder = input.operationInput.sortOrder {
            let sortOrderQueryItem = ClientRuntime.URLQueryItem(name: "SortOrder".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(sortOrderQueryItem)
        }
        if let creationTimeAfter = input.operationInput.creationTimeAfter {
            let creationTimeAfterQueryItem = ClientRuntime.URLQueryItem(name: "CreationTimeAfter".urlPercentEncoding(), value: Swift.String(creationTimeAfter.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(creationTimeAfterQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListHumanLoopsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListHumanLoopsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListHumanLoopsOutputError>
}

public struct ListHumanLoopsInput: Swift.Equatable {
    /// <p>(Optional) The timestamp of the date when you want the human loops to begin in ISO 8601 format. For example, <code>2020-02-24</code>.</p>
    public let creationTimeAfter: ClientRuntime.Date?
    /// <p>(Optional) The timestamp of the date before which you want the human loops to begin in ISO 8601 format. For example, <code>2020-02-24</code>.</p>
    public let creationTimeBefore: ClientRuntime.Date?
    /// <p>The Amazon Resource Name (ARN) of a flow definition.</p>
    public let flowDefinitionArn: Swift.String?
    /// <p>The total number of items to return. If the total number of available items is more than
    ///       the value specified in <code>MaxResults</code>, then a <code>NextToken</code> is returned in
    ///       the output. You can use this token to display the next page of results. </p>
    public let maxResults: Swift.Int
    /// <p>A token to display the next page of results.</p>
    public let nextToken: Swift.String?
    /// <p>Optional. The order for displaying results. Valid values: <code>Ascending</code> and
    ///         <code>Descending</code>.</p>
    public let sortOrder: SageMakerA2IRuntimeClientTypes.SortOrder?

    public init (
        creationTimeAfter: ClientRuntime.Date? = nil,
        creationTimeBefore: ClientRuntime.Date? = nil,
        flowDefinitionArn: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        sortOrder: SageMakerA2IRuntimeClientTypes.SortOrder? = nil
    )
    {
        self.creationTimeAfter = creationTimeAfter
        self.creationTimeBefore = creationTimeBefore
        self.flowDefinitionArn = flowDefinitionArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortOrder = sortOrder
    }
}

struct ListHumanLoopsInputBody: Swift.Equatable {
}

extension ListHumanLoopsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListHumanLoopsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListHumanLoopsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListHumanLoopsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListHumanLoopsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListHumanLoopsOutputResponse(humanLoopSummaries: \(Swift.String(describing: humanLoopSummaries)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListHumanLoopsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListHumanLoopsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.humanLoopSummaries = output.humanLoopSummaries
            self.nextToken = output.nextToken
        } else {
            self.humanLoopSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListHumanLoopsOutputResponse: Swift.Equatable {
    /// <p>An array of objects that contain information about the human loops.</p>
    public let humanLoopSummaries: [SageMakerA2IRuntimeClientTypes.HumanLoopSummary]?
    /// <p>A token to display the next page of results.</p>
    public let nextToken: Swift.String?

    public init (
        humanLoopSummaries: [SageMakerA2IRuntimeClientTypes.HumanLoopSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.humanLoopSummaries = humanLoopSummaries
        self.nextToken = nextToken
    }
}

struct ListHumanLoopsOutputResponseBody: Swift.Equatable {
    public let humanLoopSummaries: [SageMakerA2IRuntimeClientTypes.HumanLoopSummary]?
    public let nextToken: Swift.String?
}

extension ListHumanLoopsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case humanLoopSummaries = "HumanLoopSummaries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let humanLoopSummariesContainer = try containerValues.decodeIfPresent([SageMakerA2IRuntimeClientTypes.HumanLoopSummary?].self, forKey: .humanLoopSummaries)
        var humanLoopSummariesDecoded0:[SageMakerA2IRuntimeClientTypes.HumanLoopSummary]? = nil
        if let humanLoopSummariesContainer = humanLoopSummariesContainer {
            humanLoopSummariesDecoded0 = [SageMakerA2IRuntimeClientTypes.HumanLoopSummary]()
            for structure0 in humanLoopSummariesContainer {
                if let structure0 = structure0 {
                    humanLoopSummariesDecoded0?.append(structure0)
                }
            }
        }
        humanLoopSummaries = humanLoopSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>We couldn't find the requested resource. Check that your resources exists and were created
///       in the same AWS Region as your request, and try your request again. </p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceQuotaExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceQuotaExceededException(message: \(Swift.String(describing: message)))"}
}

extension ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You exceeded your service quota. Service quotas, also referred to as limits, are the
///       maximum number of service resources or operations for your AWS account. For a list of
///       Amazon A2I service quotes, see <a href="https://docs.aws.amazon.com/general/latest/gr/a2i.html">Amazon Augmented AI Service Quotes</a>. Delete some resources or request an increase in your
///       service quota. You can request a quota increase using Service Quotas or the AWS Support
///       Center. To request an increase, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html">AWS Service Quotas</a> in the
///         <i>AWS General Reference</i>.</p>
public struct ServiceQuotaExceededException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SageMakerA2IRuntimeClientTypes {
    public enum SortOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "Ascending"
            case .descending: return "Descending"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortOrder(rawValue: rawValue) ?? SortOrder.sdkUnknown(rawValue)
        }
    }
}

public struct StartHumanLoopInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartHumanLoopInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartHumanLoopInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartHumanLoopOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartHumanLoopInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartHumanLoopOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartHumanLoopOutputError>
}

extension StartHumanLoopInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartHumanLoopInput(dataAttributes: \(Swift.String(describing: dataAttributes)), flowDefinitionArn: \(Swift.String(describing: flowDefinitionArn)), humanLoopInput: \(Swift.String(describing: humanLoopInput)), humanLoopName: \(Swift.String(describing: humanLoopName)))"}
}

extension StartHumanLoopInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataAttributes = "DataAttributes"
        case flowDefinitionArn = "FlowDefinitionArn"
        case humanLoopInput = "HumanLoopInput"
        case humanLoopName = "HumanLoopName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataAttributes = dataAttributes {
            try encodeContainer.encode(dataAttributes, forKey: .dataAttributes)
        }
        if let flowDefinitionArn = flowDefinitionArn {
            try encodeContainer.encode(flowDefinitionArn, forKey: .flowDefinitionArn)
        }
        if let humanLoopInput = humanLoopInput {
            try encodeContainer.encode(humanLoopInput, forKey: .humanLoopInput)
        }
        if let humanLoopName = humanLoopName {
            try encodeContainer.encode(humanLoopName, forKey: .humanLoopName)
        }
    }
}

public struct StartHumanLoopInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartHumanLoopInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartHumanLoopInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartHumanLoopOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartHumanLoopInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartHumanLoopOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartHumanLoopOutputError>
}

public struct StartHumanLoopInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartHumanLoopInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartHumanLoopInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartHumanLoopOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartHumanLoopInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartHumanLoopOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartHumanLoopOutputError>
}

public struct StartHumanLoopInput: Swift.Equatable {
    /// <p>Attributes of the specified data. Use <code>DataAttributes</code> to specify if your data
    ///       is free of personally identifiable information and/or free of adult content.</p>
    public let dataAttributes: SageMakerA2IRuntimeClientTypes.HumanLoopDataAttributes?
    /// <p>The Amazon Resource Name (ARN) of the flow definition associated with this human
    ///       loop.</p>
    public let flowDefinitionArn: Swift.String?
    /// <p>An object that contains information about the human loop.</p>
    public let humanLoopInput: SageMakerA2IRuntimeClientTypes.HumanLoopInput?
    /// <p>The name of the human loop.</p>
    public let humanLoopName: Swift.String?

    public init (
        dataAttributes: SageMakerA2IRuntimeClientTypes.HumanLoopDataAttributes? = nil,
        flowDefinitionArn: Swift.String? = nil,
        humanLoopInput: SageMakerA2IRuntimeClientTypes.HumanLoopInput? = nil,
        humanLoopName: Swift.String? = nil
    )
    {
        self.dataAttributes = dataAttributes
        self.flowDefinitionArn = flowDefinitionArn
        self.humanLoopInput = humanLoopInput
        self.humanLoopName = humanLoopName
    }
}

struct StartHumanLoopInputBody: Swift.Equatable {
    public let humanLoopName: Swift.String?
    public let flowDefinitionArn: Swift.String?
    public let humanLoopInput: SageMakerA2IRuntimeClientTypes.HumanLoopInput?
    public let dataAttributes: SageMakerA2IRuntimeClientTypes.HumanLoopDataAttributes?
}

extension StartHumanLoopInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataAttributes = "DataAttributes"
        case flowDefinitionArn = "FlowDefinitionArn"
        case humanLoopInput = "HumanLoopInput"
        case humanLoopName = "HumanLoopName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let humanLoopNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .humanLoopName)
        humanLoopName = humanLoopNameDecoded
        let flowDefinitionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowDefinitionArn)
        flowDefinitionArn = flowDefinitionArnDecoded
        let humanLoopInputDecoded = try containerValues.decodeIfPresent(SageMakerA2IRuntimeClientTypes.HumanLoopInput.self, forKey: .humanLoopInput)
        humanLoopInput = humanLoopInputDecoded
        let dataAttributesDecoded = try containerValues.decodeIfPresent(SageMakerA2IRuntimeClientTypes.HumanLoopDataAttributes.self, forKey: .dataAttributes)
        dataAttributes = dataAttributesDecoded
    }
}

extension StartHumanLoopOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartHumanLoopOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartHumanLoopOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartHumanLoopOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartHumanLoopOutputResponse(humanLoopArn: \(Swift.String(describing: humanLoopArn)))"}
}

extension StartHumanLoopOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartHumanLoopOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.humanLoopArn = output.humanLoopArn
        } else {
            self.humanLoopArn = nil
        }
    }
}

public struct StartHumanLoopOutputResponse: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the human loop.</p>
    public let humanLoopArn: Swift.String?

    public init (
        humanLoopArn: Swift.String? = nil
    )
    {
        self.humanLoopArn = humanLoopArn
    }
}

struct StartHumanLoopOutputResponseBody: Swift.Equatable {
    public let humanLoopArn: Swift.String?
}

extension StartHumanLoopOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case humanLoopArn = "HumanLoopArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let humanLoopArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .humanLoopArn)
        humanLoopArn = humanLoopArnDecoded
    }
}

public struct StopHumanLoopInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopHumanLoopInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopHumanLoopInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopHumanLoopOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopHumanLoopInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopHumanLoopOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopHumanLoopOutputError>
}

extension StopHumanLoopInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopHumanLoopInput(humanLoopName: \(Swift.String(describing: humanLoopName)))"}
}

extension StopHumanLoopInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case humanLoopName = "HumanLoopName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let humanLoopName = humanLoopName {
            try encodeContainer.encode(humanLoopName, forKey: .humanLoopName)
        }
    }
}

public struct StopHumanLoopInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopHumanLoopInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopHumanLoopInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopHumanLoopOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopHumanLoopInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopHumanLoopOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopHumanLoopOutputError>
}

public struct StopHumanLoopInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopHumanLoopInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopHumanLoopInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopHumanLoopOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopHumanLoopInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopHumanLoopOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopHumanLoopOutputError>
}

public struct StopHumanLoopInput: Swift.Equatable {
    /// <p>The name of the human loop that you want to stop.</p>
    public let humanLoopName: Swift.String?

    public init (
        humanLoopName: Swift.String? = nil
    )
    {
        self.humanLoopName = humanLoopName
    }
}

struct StopHumanLoopInputBody: Swift.Equatable {
    public let humanLoopName: Swift.String?
}

extension StopHumanLoopInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case humanLoopName = "HumanLoopName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let humanLoopNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .humanLoopName)
        humanLoopName = humanLoopNameDecoded
    }
}

extension StopHumanLoopOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopHumanLoopOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopHumanLoopOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopHumanLoopOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopHumanLoopOutputResponse()"}
}

extension StopHumanLoopOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StopHumanLoopOutputResponse: Swift.Equatable {

    public init() {}
}

struct StopHumanLoopOutputResponseBody: Swift.Equatable {
}

extension StopHumanLoopOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ThrottlingException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ThrottlingException(message: \(Swift.String(describing: message)))"}
}

extension ThrottlingException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You exceeded
///       the
///       maximum number of requests.</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(message: \(Swift.String(describing: message)))"}
}

extension ValidationException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The
///       request isn't valid. Check the syntax and try again.</p>
public struct ValidationException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
