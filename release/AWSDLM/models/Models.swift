// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension DlmClientTypes.Action: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crossRegionCopy = "CrossRegionCopy"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let crossRegionCopy = crossRegionCopy {
            var crossRegionCopyContainer = encodeContainer.nestedUnkeyedContainer(forKey: .crossRegionCopy)
            for crossregioncopyactionlist0 in crossRegionCopy {
                try crossRegionCopyContainer.encode(crossregioncopyactionlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let crossRegionCopyContainer = try containerValues.decodeIfPresent([DlmClientTypes.CrossRegionCopyAction?].self, forKey: .crossRegionCopy)
        var crossRegionCopyDecoded0:[DlmClientTypes.CrossRegionCopyAction]? = nil
        if let crossRegionCopyContainer = crossRegionCopyContainer {
            crossRegionCopyDecoded0 = [DlmClientTypes.CrossRegionCopyAction]()
            for structure0 in crossRegionCopyContainer {
                if let structure0 = structure0 {
                    crossRegionCopyDecoded0?.append(structure0)
                }
            }
        }
        crossRegionCopy = crossRegionCopyDecoded0
    }
}

extension DlmClientTypes.Action: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Action(crossRegionCopy: \(Swift.String(describing: crossRegionCopy)), name: \(Swift.String(describing: name)))"}
}

extension DlmClientTypes {
    /// Specifies an action for an event-based policy.
    public struct Action: Swift.Equatable {
        /// The rule for copying shared snapshots across Regions.
        /// This member is required.
        public var crossRegionCopy: [DlmClientTypes.CrossRegionCopyAction]?
        /// A descriptive name for the action.
        /// This member is required.
        public var name: Swift.String?

        public init (
            crossRegionCopy: [DlmClientTypes.CrossRegionCopyAction]? = nil,
            name: Swift.String? = nil
        )
        {
            self.crossRegionCopy = crossRegionCopy
            self.name = name
        }
    }

}

public struct CreateLifecyclePolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLifecyclePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateLifecyclePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLifecyclePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateLifecyclePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLifecyclePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLifecyclePolicyOutputError>
}

extension CreateLifecyclePolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateLifecyclePolicyInput(description: \(Swift.String(describing: description)), executionRoleArn: \(Swift.String(describing: executionRoleArn)), policyDetails: \(Swift.String(describing: policyDetails)), state: \(Swift.String(describing: state)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateLifecyclePolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case executionRoleArn = "ExecutionRoleArn"
        case policyDetails = "PolicyDetails"
        case state = "State"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let executionRoleArn = executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let policyDetails = policyDetails {
            try encodeContainer.encode(policyDetails, forKey: .policyDetails)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateLifecyclePolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLifecyclePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateLifecyclePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLifecyclePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateLifecyclePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLifecyclePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLifecyclePolicyOutputError>
}

public struct CreateLifecyclePolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLifecyclePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateLifecyclePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLifecyclePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateLifecyclePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLifecyclePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLifecyclePolicyOutputError>
}

public struct CreateLifecyclePolicyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLifecyclePolicyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateLifecyclePolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLifecyclePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateLifecyclePolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLifecyclePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLifecyclePolicyOutputError>
}

public struct CreateLifecyclePolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLifecyclePolicyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateLifecyclePolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLifecyclePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/policies"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateLifecyclePolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLifecyclePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLifecyclePolicyOutputError>
}

public struct CreateLifecyclePolicyInput: Swift.Equatable {
    /// A description of the lifecycle policy. The characters ^[0-9A-Za-z _-]+$ are
    /// 			supported.
    /// This member is required.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role used to run the operations specified by
    /// 			the lifecycle policy.
    /// This member is required.
    public var executionRoleArn: Swift.String?
    /// The configuration details of the lifecycle policy.
    /// This member is required.
    public var policyDetails: DlmClientTypes.PolicyDetails?
    /// The desired activation state of the lifecycle policy after creation.
    /// This member is required.
    public var state: DlmClientTypes.SettablePolicyStateValues?
    /// The tags to apply to the lifecycle policy during creation.
    public var tags: [Swift.String:Swift.String]?

    public init (
        description: Swift.String? = nil,
        executionRoleArn: Swift.String? = nil,
        policyDetails: DlmClientTypes.PolicyDetails? = nil,
        state: DlmClientTypes.SettablePolicyStateValues? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.executionRoleArn = executionRoleArn
        self.policyDetails = policyDetails
        self.state = state
        self.tags = tags
    }
}

struct CreateLifecyclePolicyInputBody: Swift.Equatable {
    public let executionRoleArn: Swift.String?
    public let description: Swift.String?
    public let state: DlmClientTypes.SettablePolicyStateValues?
    public let policyDetails: DlmClientTypes.PolicyDetails?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateLifecyclePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case executionRoleArn = "ExecutionRoleArn"
        case policyDetails = "PolicyDetails"
        case state = "State"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(DlmClientTypes.SettablePolicyStateValues.self, forKey: .state)
        state = stateDecoded
        let policyDetailsDecoded = try containerValues.decodeIfPresent(DlmClientTypes.PolicyDetails.self, forKey: .policyDetails)
        policyDetails = policyDetailsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateLifecyclePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateLifecyclePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateLifecyclePolicyOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLifecyclePolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateLifecyclePolicyOutputResponse(policyId: \(Swift.String(describing: policyId)))"}
}

extension CreateLifecyclePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateLifecyclePolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policyId = output.policyId
        } else {
            self.policyId = nil
        }
    }
}

public struct CreateLifecyclePolicyOutputResponse: Swift.Equatable {
    /// The identifier of the lifecycle policy.
    public var policyId: Swift.String?

    public init (
        policyId: Swift.String? = nil
    )
    {
        self.policyId = policyId
    }
}

struct CreateLifecyclePolicyOutputResponseBody: Swift.Equatable {
    public let policyId: Swift.String?
}

extension CreateLifecyclePolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyId = "PolicyId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyId)
        policyId = policyIdDecoded
    }
}

extension DlmClientTypes.CreateRule: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cronExpression = "CronExpression"
        case interval = "Interval"
        case intervalUnit = "IntervalUnit"
        case location = "Location"
        case times = "Times"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cronExpression = cronExpression {
            try encodeContainer.encode(cronExpression, forKey: .cronExpression)
        }
        if interval != 0 {
            try encodeContainer.encode(interval, forKey: .interval)
        }
        if let intervalUnit = intervalUnit {
            try encodeContainer.encode(intervalUnit.rawValue, forKey: .intervalUnit)
        }
        if let location = location {
            try encodeContainer.encode(location.rawValue, forKey: .location)
        }
        if let times = times {
            var timesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .times)
            for timeslist0 in times {
                try timesContainer.encode(timeslist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationDecoded = try containerValues.decodeIfPresent(DlmClientTypes.LocationValues.self, forKey: .location)
        location = locationDecoded
        let intervalDecoded = try containerValues.decode(Swift.Int.self, forKey: .interval)
        interval = intervalDecoded
        let intervalUnitDecoded = try containerValues.decodeIfPresent(DlmClientTypes.IntervalUnitValues.self, forKey: .intervalUnit)
        intervalUnit = intervalUnitDecoded
        let timesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .times)
        var timesDecoded0:[Swift.String]? = nil
        if let timesContainer = timesContainer {
            timesDecoded0 = [Swift.String]()
            for string0 in timesContainer {
                if let string0 = string0 {
                    timesDecoded0?.append(string0)
                }
            }
        }
        times = timesDecoded0
        let cronExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cronExpression)
        cronExpression = cronExpressionDecoded
    }
}

extension DlmClientTypes.CreateRule: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateRule(cronExpression: \(Swift.String(describing: cronExpression)), interval: \(Swift.String(describing: interval)), intervalUnit: \(Swift.String(describing: intervalUnit)), location: \(Swift.String(describing: location)), times: \(Swift.String(describing: times)))"}
}

extension DlmClientTypes {
    /// Specifies when to create snapshots of EBS volumes.
    /// 		       You must specify either a Cron expression or an interval, interval unit, and start
    /// 			time. You cannot specify both.
    public struct CreateRule: Swift.Equatable {
        /// The schedule, as a Cron expression. The schedule interval must be between 1 hour and 1
        /// 			year. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/events/ScheduledEvents.html#CronExpressions">Cron
        /// 				expressions in the Amazon CloudWatch User Guide.
        public var cronExpression: Swift.String?
        /// The interval between snapshots. The supported values are 1, 2, 3, 4, 6, 8, 12, and
        /// 			24.
        public var interval: Swift.Int
        /// The interval unit.
        public var intervalUnit: DlmClientTypes.IntervalUnitValues?
        /// Specifies the destination for snapshots created by the policy. To create snapshots in the same
        /// 			Region as the source resource, specify CLOUD. To create snapshots on the same
        /// 			Outpost as the source resource, specify OUTPOST_LOCAL. If you omit this
        /// 			parameter, CLOUD is used by default.
        /// 		       If the policy targets resources in an Amazon Web Services Region, then you must create snapshots in the same
        /// 			Region as the source resource.
        /// 		       If the policy targets resources on an Outpost, then you can create snapshots on the same Outpost
        /// 			as the source resource, or in the Region of that Outpost.
        public var location: DlmClientTypes.LocationValues?
        /// The time, in UTC, to start the operation. The supported format is hh:mm.
        /// 		       The operation occurs within a one-hour window following the specified time. If you do
        /// 			not specify a time, Amazon DLM selects a time within the next 24 hours.
        public var times: [Swift.String]?

        public init (
            cronExpression: Swift.String? = nil,
            interval: Swift.Int = 0,
            intervalUnit: DlmClientTypes.IntervalUnitValues? = nil,
            location: DlmClientTypes.LocationValues? = nil,
            times: [Swift.String]? = nil
        )
        {
            self.cronExpression = cronExpression
            self.interval = interval
            self.intervalUnit = intervalUnit
            self.location = location
            self.times = times
        }
    }

}

extension DlmClientTypes.CrossRegionCopyAction: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionConfiguration = "EncryptionConfiguration"
        case retainRule = "RetainRule"
        case target = "Target"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionConfiguration = encryptionConfiguration {
            try encodeContainer.encode(encryptionConfiguration, forKey: .encryptionConfiguration)
        }
        if let retainRule = retainRule {
            try encodeContainer.encode(retainRule, forKey: .retainRule)
        }
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
        let encryptionConfigurationDecoded = try containerValues.decodeIfPresent(DlmClientTypes.EncryptionConfiguration.self, forKey: .encryptionConfiguration)
        encryptionConfiguration = encryptionConfigurationDecoded
        let retainRuleDecoded = try containerValues.decodeIfPresent(DlmClientTypes.CrossRegionCopyRetainRule.self, forKey: .retainRule)
        retainRule = retainRuleDecoded
    }
}

extension DlmClientTypes.CrossRegionCopyAction: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CrossRegionCopyAction(encryptionConfiguration: \(Swift.String(describing: encryptionConfiguration)), retainRule: \(Swift.String(describing: retainRule)), target: \(Swift.String(describing: target)))"}
}

extension DlmClientTypes {
    /// Specifies a rule for copying shared snapshots across Regions.
    public struct CrossRegionCopyAction: Swift.Equatable {
        /// The encryption settings for the copied snapshot.
        /// This member is required.
        public var encryptionConfiguration: DlmClientTypes.EncryptionConfiguration?
        /// Specifies the retention rule for cross-Region snapshot copies.
        public var retainRule: DlmClientTypes.CrossRegionCopyRetainRule?
        /// The target Region.
        /// This member is required.
        public var target: Swift.String?

        public init (
            encryptionConfiguration: DlmClientTypes.EncryptionConfiguration? = nil,
            retainRule: DlmClientTypes.CrossRegionCopyRetainRule? = nil,
            target: Swift.String? = nil
        )
        {
            self.encryptionConfiguration = encryptionConfiguration
            self.retainRule = retainRule
            self.target = target
        }
    }

}

extension DlmClientTypes.CrossRegionCopyDeprecateRule: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case interval = "Interval"
        case intervalUnit = "IntervalUnit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if interval != 0 {
            try encodeContainer.encode(interval, forKey: .interval)
        }
        if let intervalUnit = intervalUnit {
            try encodeContainer.encode(intervalUnit.rawValue, forKey: .intervalUnit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let intervalDecoded = try containerValues.decode(Swift.Int.self, forKey: .interval)
        interval = intervalDecoded
        let intervalUnitDecoded = try containerValues.decodeIfPresent(DlmClientTypes.RetentionIntervalUnitValues.self, forKey: .intervalUnit)
        intervalUnit = intervalUnitDecoded
    }
}

extension DlmClientTypes.CrossRegionCopyDeprecateRule: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CrossRegionCopyDeprecateRule(interval: \(Swift.String(describing: interval)), intervalUnit: \(Swift.String(describing: intervalUnit)))"}
}

extension DlmClientTypes {
    /// Specifies an AMI deprecation rule for cross-Region AMI copies created by a cross-Region copy rule.
    public struct CrossRegionCopyDeprecateRule: Swift.Equatable {
        /// The period after which to deprecate the cross-Region AMI copies. The period must be less than or
        /// 			equal to the cross-Region AMI copy retention period, and it can't be greater than 10 years. This is
        /// 			equivalent to 120 months, 520 weeks, or 3650 days.
        public var interval: Swift.Int
        /// The unit of time in which to measure the Interval.
        public var intervalUnit: DlmClientTypes.RetentionIntervalUnitValues?

        public init (
            interval: Swift.Int = 0,
            intervalUnit: DlmClientTypes.RetentionIntervalUnitValues? = nil
        )
        {
            self.interval = interval
            self.intervalUnit = intervalUnit
        }
    }

}

extension DlmClientTypes.CrossRegionCopyRetainRule: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case interval = "Interval"
        case intervalUnit = "IntervalUnit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if interval != 0 {
            try encodeContainer.encode(interval, forKey: .interval)
        }
        if let intervalUnit = intervalUnit {
            try encodeContainer.encode(intervalUnit.rawValue, forKey: .intervalUnit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let intervalDecoded = try containerValues.decode(Swift.Int.self, forKey: .interval)
        interval = intervalDecoded
        let intervalUnitDecoded = try containerValues.decodeIfPresent(DlmClientTypes.RetentionIntervalUnitValues.self, forKey: .intervalUnit)
        intervalUnit = intervalUnitDecoded
    }
}

extension DlmClientTypes.CrossRegionCopyRetainRule: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CrossRegionCopyRetainRule(interval: \(Swift.String(describing: interval)), intervalUnit: \(Swift.String(describing: intervalUnit)))"}
}

extension DlmClientTypes {
    /// Specifies the retention rule for cross-Region snapshot copies.
    public struct CrossRegionCopyRetainRule: Swift.Equatable {
        /// The amount of time to retain each snapshot. The maximum is 100 years. This is
        /// 			equivalent to 1200 months, 5200 weeks, or 36500 days.
        public var interval: Swift.Int
        /// The unit of time for time-based retention.
        public var intervalUnit: DlmClientTypes.RetentionIntervalUnitValues?

        public init (
            interval: Swift.Int = 0,
            intervalUnit: DlmClientTypes.RetentionIntervalUnitValues? = nil
        )
        {
            self.interval = interval
            self.intervalUnit = intervalUnit
        }
    }

}

extension DlmClientTypes.CrossRegionCopyRule: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cmkArn = "CmkArn"
        case copyTags = "CopyTags"
        case deprecateRule = "DeprecateRule"
        case encrypted = "Encrypted"
        case retainRule = "RetainRule"
        case target = "Target"
        case targetRegion = "TargetRegion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cmkArn = cmkArn {
            try encodeContainer.encode(cmkArn, forKey: .cmkArn)
        }
        if let copyTags = copyTags {
            try encodeContainer.encode(copyTags, forKey: .copyTags)
        }
        if let deprecateRule = deprecateRule {
            try encodeContainer.encode(deprecateRule, forKey: .deprecateRule)
        }
        if let encrypted = encrypted {
            try encodeContainer.encode(encrypted, forKey: .encrypted)
        }
        if let retainRule = retainRule {
            try encodeContainer.encode(retainRule, forKey: .retainRule)
        }
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
        if let targetRegion = targetRegion {
            try encodeContainer.encode(targetRegion, forKey: .targetRegion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetRegion)
        targetRegion = targetRegionDecoded
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
        let encryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let cmkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cmkArn)
        cmkArn = cmkArnDecoded
        let copyTagsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTags)
        copyTags = copyTagsDecoded
        let retainRuleDecoded = try containerValues.decodeIfPresent(DlmClientTypes.CrossRegionCopyRetainRule.self, forKey: .retainRule)
        retainRule = retainRuleDecoded
        let deprecateRuleDecoded = try containerValues.decodeIfPresent(DlmClientTypes.CrossRegionCopyDeprecateRule.self, forKey: .deprecateRule)
        deprecateRule = deprecateRuleDecoded
    }
}

extension DlmClientTypes.CrossRegionCopyRule: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CrossRegionCopyRule(cmkArn: \(Swift.String(describing: cmkArn)), copyTags: \(Swift.String(describing: copyTags)), deprecateRule: \(Swift.String(describing: deprecateRule)), encrypted: \(Swift.String(describing: encrypted)), retainRule: \(Swift.String(describing: retainRule)), target: \(Swift.String(describing: target)), targetRegion: \(Swift.String(describing: targetRegion)))"}
}

extension DlmClientTypes {
    /// Specifies a rule for cross-Region snapshot copies.
    public struct CrossRegionCopyRule: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the KMS key to use for EBS encryption. If this
        /// 			parameter is not specified, the default KMS key for the account is used.
        public var cmkArn: Swift.String?
        /// Indicates whether to copy all user-defined tags from the source snapshot to the cross-Region
        /// 			snapshot copy.
        public var copyTags: Swift.Bool?
        /// The AMI deprecation rule for cross-Region AMI copies created by the rule.
        public var deprecateRule: DlmClientTypes.CrossRegionCopyDeprecateRule?
        /// To encrypt a copy of an unencrypted snapshot if encryption by default is not enabled,
        /// 			enable encryption using this parameter. Copies of encrypted snapshots are encrypted,
        /// 			even if this parameter is false or if encryption by default is not enabled.
        /// This member is required.
        public var encrypted: Swift.Bool?
        /// The retention rule that indicates how long snapshot copies are to be retained in the
        /// 			destination Region.
        public var retainRule: DlmClientTypes.CrossRegionCopyRetainRule?
        /// The target Region or the Amazon Resource Name (ARN) of the target Outpost for the
        /// 			snapshot copies.
        /// 		       Use this parameter instead of TargetRegion. Do not
        /// 			specify both.
        public var target: Swift.String?
        /// Avoid using this parameter when creating new policies. Instead, use Target
        /// 			to specify a target Region or a target Outpost for snapshot copies.
        /// 		       For policies created before the Target parameter
        /// 			was introduced, this parameter indicates the target Region for snapshot copies.
        public var targetRegion: Swift.String?

        public init (
            cmkArn: Swift.String? = nil,
            copyTags: Swift.Bool? = nil,
            deprecateRule: DlmClientTypes.CrossRegionCopyDeprecateRule? = nil,
            encrypted: Swift.Bool? = nil,
            retainRule: DlmClientTypes.CrossRegionCopyRetainRule? = nil,
            target: Swift.String? = nil,
            targetRegion: Swift.String? = nil
        )
        {
            self.cmkArn = cmkArn
            self.copyTags = copyTags
            self.deprecateRule = deprecateRule
            self.encrypted = encrypted
            self.retainRule = retainRule
            self.target = target
            self.targetRegion = targetRegion
        }
    }

}

extension DeleteLifecyclePolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteLifecyclePolicyInput(policyId: \(Swift.String(describing: policyId)))"}
}

extension DeleteLifecyclePolicyInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteLifecyclePolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLifecyclePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteLifecyclePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLifecyclePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteLifecyclePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLifecyclePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLifecyclePolicyOutputError>
}

public struct DeleteLifecyclePolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLifecyclePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteLifecyclePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLifecyclePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteLifecyclePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLifecyclePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLifecyclePolicyOutputError>
}

public struct DeleteLifecyclePolicyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLifecyclePolicyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteLifecyclePolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLifecyclePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteLifecyclePolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLifecyclePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLifecyclePolicyOutputError>
}

public struct DeleteLifecyclePolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLifecyclePolicyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteLifecyclePolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLifecyclePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let policyId = input.policyId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("policyId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/policies/\(policyId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteLifecyclePolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLifecyclePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLifecyclePolicyOutputError>
}

public struct DeleteLifecyclePolicyInput: Swift.Equatable {
    /// The identifier of the lifecycle policy.
    /// This member is required.
    public var policyId: Swift.String?

    public init (
        policyId: Swift.String? = nil
    )
    {
        self.policyId = policyId
    }
}

struct DeleteLifecyclePolicyInputBody: Swift.Equatable {
}

extension DeleteLifecyclePolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteLifecyclePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteLifecyclePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteLifecyclePolicyOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLifecyclePolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteLifecyclePolicyOutputResponse()"}
}

extension DeleteLifecyclePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteLifecyclePolicyOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteLifecyclePolicyOutputResponseBody: Swift.Equatable {
}

extension DeleteLifecyclePolicyOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DlmClientTypes.DeprecateRule: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case count = "Count"
        case interval = "Interval"
        case intervalUnit = "IntervalUnit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if count != 0 {
            try encodeContainer.encode(count, forKey: .count)
        }
        if interval != 0 {
            try encodeContainer.encode(interval, forKey: .interval)
        }
        if let intervalUnit = intervalUnit {
            try encodeContainer.encode(intervalUnit.rawValue, forKey: .intervalUnit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countDecoded = try containerValues.decode(Swift.Int.self, forKey: .count)
        count = countDecoded
        let intervalDecoded = try containerValues.decode(Swift.Int.self, forKey: .interval)
        interval = intervalDecoded
        let intervalUnitDecoded = try containerValues.decodeIfPresent(DlmClientTypes.RetentionIntervalUnitValues.self, forKey: .intervalUnit)
        intervalUnit = intervalUnitDecoded
    }
}

extension DlmClientTypes.DeprecateRule: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeprecateRule(count: \(Swift.String(describing: count)), interval: \(Swift.String(describing: interval)), intervalUnit: \(Swift.String(describing: intervalUnit)))"}
}

extension DlmClientTypes {
    /// Specifies an AMI deprecation rule for a schedule.
    public struct DeprecateRule: Swift.Equatable {
        /// If the schedule has a count-based retention rule, this parameter specifies the number of oldest
        /// 			AMIs to deprecate. The count must be less than or equal to the schedule's retention count, and it
        /// 			can't be greater than 1000.
        public var count: Swift.Int
        /// If the schedule has an age-based retention rule, this parameter specifies the period after which
        /// 			to deprecate AMIs created by the schedule. The period must be less than or equal to the schedule's
        /// 			retention period, and it can't be greater than 10 years. This is equivalent to 120 months, 520
        /// 			weeks, or 3650 days.
        public var interval: Swift.Int
        /// The unit of time in which to measure the Interval.
        public var intervalUnit: DlmClientTypes.RetentionIntervalUnitValues?

        public init (
            count: Swift.Int = 0,
            interval: Swift.Int = 0,
            intervalUnit: DlmClientTypes.RetentionIntervalUnitValues? = nil
        )
        {
            self.count = count
            self.interval = interval
            self.intervalUnit = intervalUnit
        }
    }

}

extension DlmClientTypes.EncryptionConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cmkArn = "CmkArn"
        case encrypted = "Encrypted"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cmkArn = cmkArn {
            try encodeContainer.encode(cmkArn, forKey: .cmkArn)
        }
        if let encrypted = encrypted {
            try encodeContainer.encode(encrypted, forKey: .encrypted)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let cmkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cmkArn)
        cmkArn = cmkArnDecoded
    }
}

extension DlmClientTypes.EncryptionConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EncryptionConfiguration(cmkArn: \(Swift.String(describing: cmkArn)), encrypted: \(Swift.String(describing: encrypted)))"}
}

extension DlmClientTypes {
    /// Specifies the encryption settings for shared snapshots that are copied across Regions.
    public struct EncryptionConfiguration: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the KMS key to use for EBS encryption. If
        /// 			this parameter is not specified, the default KMS key for the account is used.
        public var cmkArn: Swift.String?
        /// To encrypt a copy of an unencrypted snapshot when encryption by default is not enabled, enable
        /// 			encryption using this parameter. Copies of encrypted snapshots are encrypted, even if this
        /// 			parameter is false or when encryption by default is not enabled.
        /// This member is required.
        public var encrypted: Swift.Bool?

        public init (
            cmkArn: Swift.String? = nil,
            encrypted: Swift.Bool? = nil
        )
        {
            self.cmkArn = cmkArn
            self.encrypted = encrypted
        }
    }

}

extension DlmClientTypes.EventParameters: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case descriptionRegex = "DescriptionRegex"
        case eventType = "EventType"
        case snapshotOwner = "SnapshotOwner"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let descriptionRegex = descriptionRegex {
            try encodeContainer.encode(descriptionRegex, forKey: .descriptionRegex)
        }
        if let eventType = eventType {
            try encodeContainer.encode(eventType.rawValue, forKey: .eventType)
        }
        if let snapshotOwner = snapshotOwner {
            var snapshotOwnerContainer = encodeContainer.nestedUnkeyedContainer(forKey: .snapshotOwner)
            for snapshotownerlist0 in snapshotOwner {
                try snapshotOwnerContainer.encode(snapshotownerlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTypeDecoded = try containerValues.decodeIfPresent(DlmClientTypes.EventTypeValues.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let snapshotOwnerContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .snapshotOwner)
        var snapshotOwnerDecoded0:[Swift.String]? = nil
        if let snapshotOwnerContainer = snapshotOwnerContainer {
            snapshotOwnerDecoded0 = [Swift.String]()
            for string0 in snapshotOwnerContainer {
                if let string0 = string0 {
                    snapshotOwnerDecoded0?.append(string0)
                }
            }
        }
        snapshotOwner = snapshotOwnerDecoded0
        let descriptionRegexDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .descriptionRegex)
        descriptionRegex = descriptionRegexDecoded
    }
}

extension DlmClientTypes.EventParameters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EventParameters(descriptionRegex: \(Swift.String(describing: descriptionRegex)), eventType: \(Swift.String(describing: eventType)), snapshotOwner: \(Swift.String(describing: snapshotOwner)))"}
}

extension DlmClientTypes {
    /// Specifies an event that triggers an event-based policy.
    public struct EventParameters: Swift.Equatable {
        /// The snapshot description that can trigger the policy. The description pattern is specified using
        /// 			a regular expression. The policy runs only if a snapshot with a description that matches the
        /// 			specified pattern is shared with your account.
        /// 		       For example, specifying ^.*Created for policy: policy-1234567890abcdef0.*$
        /// 			configures the policy to run only if snapshots created by policy policy-1234567890abcdef0
        /// 			are shared with your account.
        /// This member is required.
        public var descriptionRegex: Swift.String?
        /// The type of event. Currently, only snapshot sharing events are supported.
        /// This member is required.
        public var eventType: DlmClientTypes.EventTypeValues?
        /// The IDs of the Amazon Web Services accounts that can trigger policy by sharing snapshots with your account.
        /// 			The policy only runs if one of the specified Amazon Web Services accounts shares a snapshot with your account.
        /// This member is required.
        public var snapshotOwner: [Swift.String]?

        public init (
            descriptionRegex: Swift.String? = nil,
            eventType: DlmClientTypes.EventTypeValues? = nil,
            snapshotOwner: [Swift.String]? = nil
        )
        {
            self.descriptionRegex = descriptionRegex
            self.eventType = eventType
            self.snapshotOwner = snapshotOwner
        }
    }

}

extension DlmClientTypes.EventSource: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameters = "Parameters"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameters = parameters {
            try encodeContainer.encode(parameters, forKey: .parameters)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(DlmClientTypes.EventSourceValues.self, forKey: .type)
        type = typeDecoded
        let parametersDecoded = try containerValues.decodeIfPresent(DlmClientTypes.EventParameters.self, forKey: .parameters)
        parameters = parametersDecoded
    }
}

extension DlmClientTypes.EventSource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EventSource(parameters: \(Swift.String(describing: parameters)), type: \(Swift.String(describing: type)))"}
}

extension DlmClientTypes {
    /// Specifies an event that triggers an event-based policy.
    public struct EventSource: Swift.Equatable {
        /// Information about the event.
        public var parameters: DlmClientTypes.EventParameters?
        /// The source of the event. Currently only managed CloudWatch Events rules are supported.
        /// This member is required.
        public var type: DlmClientTypes.EventSourceValues?

        public init (
            parameters: DlmClientTypes.EventParameters? = nil,
            type: DlmClientTypes.EventSourceValues? = nil
        )
        {
            self.parameters = parameters
            self.type = type
        }
    }

}

extension DlmClientTypes {
    public enum EventSourceValues: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case managedCwe
        case sdkUnknown(Swift.String)

        public static var allCases: [EventSourceValues] {
            return [
                .managedCwe,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .managedCwe: return "MANAGED_CWE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventSourceValues(rawValue: rawValue) ?? EventSourceValues.sdkUnknown(rawValue)
        }
    }
}

extension DlmClientTypes {
    public enum EventTypeValues: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case shareSnapshot
        case sdkUnknown(Swift.String)

        public static var allCases: [EventTypeValues] {
            return [
                .shareSnapshot,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .shareSnapshot: return "shareSnapshot"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventTypeValues(rawValue: rawValue) ?? EventTypeValues.sdkUnknown(rawValue)
        }
    }
}

extension DlmClientTypes.FastRestoreRule: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZones = "AvailabilityZones"
        case count = "Count"
        case interval = "Interval"
        case intervalUnit = "IntervalUnit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availabilityZones)
            for availabilityzonelist0 in availabilityZones {
                try availabilityZonesContainer.encode(availabilityzonelist0)
            }
        }
        if count != 0 {
            try encodeContainer.encode(count, forKey: .count)
        }
        if interval != 0 {
            try encodeContainer.encode(interval, forKey: .interval)
        }
        if let intervalUnit = intervalUnit {
            try encodeContainer.encode(intervalUnit.rawValue, forKey: .intervalUnit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countDecoded = try containerValues.decode(Swift.Int.self, forKey: .count)
        count = countDecoded
        let intervalDecoded = try containerValues.decode(Swift.Int.self, forKey: .interval)
        interval = intervalDecoded
        let intervalUnitDecoded = try containerValues.decodeIfPresent(DlmClientTypes.RetentionIntervalUnitValues.self, forKey: .intervalUnit)
        intervalUnit = intervalUnitDecoded
        let availabilityZonesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .availabilityZones)
        var availabilityZonesDecoded0:[Swift.String]? = nil
        if let availabilityZonesContainer = availabilityZonesContainer {
            availabilityZonesDecoded0 = [Swift.String]()
            for string0 in availabilityZonesContainer {
                if let string0 = string0 {
                    availabilityZonesDecoded0?.append(string0)
                }
            }
        }
        availabilityZones = availabilityZonesDecoded0
    }
}

extension DlmClientTypes.FastRestoreRule: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FastRestoreRule(availabilityZones: \(Swift.String(describing: availabilityZones)), count: \(Swift.String(describing: count)), interval: \(Swift.String(describing: interval)), intervalUnit: \(Swift.String(describing: intervalUnit)))"}
}

extension DlmClientTypes {
    /// Specifies a rule for enabling fast snapshot restore. You can enable fast snapshot
    /// 			restore based on either a count or a time interval.
    public struct FastRestoreRule: Swift.Equatable {
        /// The Availability Zones in which to enable fast snapshot restore.
        /// This member is required.
        public var availabilityZones: [Swift.String]?
        /// The number of snapshots to be enabled with fast snapshot restore.
        public var count: Swift.Int
        /// The amount of time to enable fast snapshot restore. The maximum is 100 years. This is
        /// 			equivalent to 1200 months, 5200 weeks, or 36500 days.
        public var interval: Swift.Int
        /// The unit of time for enabling fast snapshot restore.
        public var intervalUnit: DlmClientTypes.RetentionIntervalUnitValues?

        public init (
            availabilityZones: [Swift.String]? = nil,
            count: Swift.Int = 0,
            interval: Swift.Int = 0,
            intervalUnit: DlmClientTypes.RetentionIntervalUnitValues? = nil
        )
        {
            self.availabilityZones = availabilityZones
            self.count = count
            self.interval = interval
            self.intervalUnit = intervalUnit
        }
    }

}

extension GetLifecyclePoliciesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetLifecyclePoliciesInput(policyIds: \(Swift.String(describing: policyIds)), resourceTypes: \(Swift.String(describing: resourceTypes)), state: \(Swift.String(describing: state)), tagsToAdd: \(Swift.String(describing: tagsToAdd)), targetTags: \(Swift.String(describing: targetTags)))"}
}

extension GetLifecyclePoliciesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetLifecyclePoliciesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLifecyclePoliciesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLifecyclePoliciesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLifecyclePoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLifecyclePoliciesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLifecyclePoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLifecyclePoliciesOutputError>
}

public struct GetLifecyclePoliciesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLifecyclePoliciesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLifecyclePoliciesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLifecyclePoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceTypes = input.operationInput.resourceTypes {
            resourceTypes.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "resourceTypes".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let tagsToAdd = input.operationInput.tagsToAdd {
            tagsToAdd.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagsToAdd".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let state = input.operationInput.state {
            let stateQueryItem = ClientRuntime.URLQueryItem(name: "state".urlPercentEncoding(), value: Swift.String(state.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(stateQueryItem)
        }
        if let policyIds = input.operationInput.policyIds {
            policyIds.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "policyIds".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let targetTags = input.operationInput.targetTags {
            targetTags.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "targetTags".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLifecyclePoliciesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLifecyclePoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLifecyclePoliciesOutputError>
}

public struct GetLifecyclePoliciesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLifecyclePoliciesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetLifecyclePoliciesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLifecyclePoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetLifecyclePoliciesInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetLifecyclePoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLifecyclePoliciesOutputError>
}

public struct GetLifecyclePoliciesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLifecyclePoliciesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetLifecyclePoliciesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLifecyclePoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/policies"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetLifecyclePoliciesInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetLifecyclePoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLifecyclePoliciesOutputError>
}

public struct GetLifecyclePoliciesInput: Swift.Equatable {
    /// The identifiers of the data lifecycle policies.
    public var policyIds: [Swift.String]?
    /// The resource type.
    public var resourceTypes: [DlmClientTypes.ResourceTypeValues]?
    /// The activation state.
    public var state: DlmClientTypes.GettablePolicyStateValues?
    /// The tags to add to objects created by the policy.
    /// 		       Tags are strings in the format key=value.
    /// 		       These user-defined tags are added in addition to the Amazon Web Services-added lifecycle tags.
    public var tagsToAdd: [Swift.String]?
    /// The target tag for a policy.
    /// 		       Tags are strings in the format key=value.
    public var targetTags: [Swift.String]?

    public init (
        policyIds: [Swift.String]? = nil,
        resourceTypes: [DlmClientTypes.ResourceTypeValues]? = nil,
        state: DlmClientTypes.GettablePolicyStateValues? = nil,
        tagsToAdd: [Swift.String]? = nil,
        targetTags: [Swift.String]? = nil
    )
    {
        self.policyIds = policyIds
        self.resourceTypes = resourceTypes
        self.state = state
        self.tagsToAdd = tagsToAdd
        self.targetTags = targetTags
    }
}

struct GetLifecyclePoliciesInputBody: Swift.Equatable {
}

extension GetLifecyclePoliciesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetLifecyclePoliciesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLifecyclePoliciesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLifecyclePoliciesOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLifecyclePoliciesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetLifecyclePoliciesOutputResponse(policies: \(Swift.String(describing: policies)))"}
}

extension GetLifecyclePoliciesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetLifecyclePoliciesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policies = output.policies
        } else {
            self.policies = nil
        }
    }
}

public struct GetLifecyclePoliciesOutputResponse: Swift.Equatable {
    /// Summary information about the lifecycle policies.
    public var policies: [DlmClientTypes.LifecyclePolicySummary]?

    public init (
        policies: [DlmClientTypes.LifecyclePolicySummary]? = nil
    )
    {
        self.policies = policies
    }
}

struct GetLifecyclePoliciesOutputResponseBody: Swift.Equatable {
    public let policies: [DlmClientTypes.LifecyclePolicySummary]?
}

extension GetLifecyclePoliciesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policies = "Policies"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policiesContainer = try containerValues.decodeIfPresent([DlmClientTypes.LifecyclePolicySummary?].self, forKey: .policies)
        var policiesDecoded0:[DlmClientTypes.LifecyclePolicySummary]? = nil
        if let policiesContainer = policiesContainer {
            policiesDecoded0 = [DlmClientTypes.LifecyclePolicySummary]()
            for structure0 in policiesContainer {
                if let structure0 = structure0 {
                    policiesDecoded0?.append(structure0)
                }
            }
        }
        policies = policiesDecoded0
    }
}

extension GetLifecyclePolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetLifecyclePolicyInput(policyId: \(Swift.String(describing: policyId)))"}
}

extension GetLifecyclePolicyInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetLifecyclePolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLifecyclePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLifecyclePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLifecyclePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLifecyclePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLifecyclePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLifecyclePolicyOutputError>
}

public struct GetLifecyclePolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLifecyclePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLifecyclePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLifecyclePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLifecyclePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLifecyclePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLifecyclePolicyOutputError>
}

public struct GetLifecyclePolicyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLifecyclePolicyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetLifecyclePolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLifecyclePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetLifecyclePolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetLifecyclePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLifecyclePolicyOutputError>
}

public struct GetLifecyclePolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLifecyclePolicyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetLifecyclePolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLifecyclePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let policyId = input.policyId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("policyId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/policies/\(policyId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetLifecyclePolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetLifecyclePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLifecyclePolicyOutputError>
}

public struct GetLifecyclePolicyInput: Swift.Equatable {
    /// The identifier of the lifecycle policy.
    /// This member is required.
    public var policyId: Swift.String?

    public init (
        policyId: Swift.String? = nil
    )
    {
        self.policyId = policyId
    }
}

struct GetLifecyclePolicyInputBody: Swift.Equatable {
}

extension GetLifecyclePolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetLifecyclePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLifecyclePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLifecyclePolicyOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLifecyclePolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetLifecyclePolicyOutputResponse(policy: \(Swift.String(describing: policy)))"}
}

extension GetLifecyclePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetLifecyclePolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct GetLifecyclePolicyOutputResponse: Swift.Equatable {
    /// Detailed information about the lifecycle policy.
    public var policy: DlmClientTypes.LifecyclePolicy?

    public init (
        policy: DlmClientTypes.LifecyclePolicy? = nil
    )
    {
        self.policy = policy
    }
}

struct GetLifecyclePolicyOutputResponseBody: Swift.Equatable {
    public let policy: DlmClientTypes.LifecyclePolicy?
}

extension GetLifecyclePolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(DlmClientTypes.LifecyclePolicy.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension DlmClientTypes {
    public enum GettablePolicyStateValues: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case error
        case sdkUnknown(Swift.String)

        public static var allCases: [GettablePolicyStateValues] {
            return [
                .disabled,
                .enabled,
                .error,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case .error: return "ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GettablePolicyStateValues(rawValue: rawValue) ?? GettablePolicyStateValues.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The service failed in an unexpected way.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var code: Swift.String?
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let code: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension DlmClientTypes {
    public enum IntervalUnitValues: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case hours
        case sdkUnknown(Swift.String)

        public static var allCases: [IntervalUnitValues] {
            return [
                .hours,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .hours: return "HOURS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IntervalUnitValues(rawValue: rawValue) ?? IntervalUnitValues.sdkUnknown(rawValue)
        }
    }
}

extension InvalidRequestException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidRequestException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)), mutuallyExclusiveParameters: \(Swift.String(describing: mutuallyExclusiveParameters)), requiredParameters: \(Swift.String(describing: requiredParameters)))"}
}

extension InvalidRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
            self.mutuallyExclusiveParameters = output.mutuallyExclusiveParameters
            self.requiredParameters = output.requiredParameters
        } else {
            self.code = nil
            self.message = nil
            self.mutuallyExclusiveParameters = nil
            self.requiredParameters = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Bad request. The request is missing required parameters or has invalid
/// 			parameters.
public struct InvalidRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    public var message: Swift.String?
    /// The request included parameters that cannot be provided together.
    public var mutuallyExclusiveParameters: [Swift.String]?
    /// The request omitted one or more required parameters.
    public var requiredParameters: [Swift.String]?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        mutuallyExclusiveParameters: [Swift.String]? = nil,
        requiredParameters: [Swift.String]? = nil
    )
    {
        self.code = code
        self.message = message
        self.mutuallyExclusiveParameters = mutuallyExclusiveParameters
        self.requiredParameters = requiredParameters
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let code: Swift.String?
    public let requiredParameters: [Swift.String]?
    public let mutuallyExclusiveParameters: [Swift.String]?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
        case mutuallyExclusiveParameters = "MutuallyExclusiveParameters"
        case requiredParameters = "RequiredParameters"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let requiredParametersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .requiredParameters)
        var requiredParametersDecoded0:[Swift.String]? = nil
        if let requiredParametersContainer = requiredParametersContainer {
            requiredParametersDecoded0 = [Swift.String]()
            for string0 in requiredParametersContainer {
                if let string0 = string0 {
                    requiredParametersDecoded0?.append(string0)
                }
            }
        }
        requiredParameters = requiredParametersDecoded0
        let mutuallyExclusiveParametersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .mutuallyExclusiveParameters)
        var mutuallyExclusiveParametersDecoded0:[Swift.String]? = nil
        if let mutuallyExclusiveParametersContainer = mutuallyExclusiveParametersContainer {
            mutuallyExclusiveParametersDecoded0 = [Swift.String]()
            for string0 in mutuallyExclusiveParametersContainer {
                if let string0 = string0 {
                    mutuallyExclusiveParametersDecoded0?.append(string0)
                }
            }
        }
        mutuallyExclusiveParameters = mutuallyExclusiveParametersDecoded0
    }
}

extension DlmClientTypes.LifecyclePolicy: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dateCreated = "DateCreated"
        case dateModified = "DateModified"
        case description = "Description"
        case executionRoleArn = "ExecutionRoleArn"
        case policyArn = "PolicyArn"
        case policyDetails = "PolicyDetails"
        case policyId = "PolicyId"
        case state = "State"
        case statusMessage = "StatusMessage"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dateCreated = dateCreated {
            try encodeContainer.encode(dateCreated.timeIntervalSince1970, forKey: .dateCreated)
        }
        if let dateModified = dateModified {
            try encodeContainer.encode(dateModified.timeIntervalSince1970, forKey: .dateModified)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let executionRoleArn = executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let policyArn = policyArn {
            try encodeContainer.encode(policyArn, forKey: .policyArn)
        }
        if let policyDetails = policyDetails {
            try encodeContainer.encode(policyDetails, forKey: .policyDetails)
        }
        if let policyId = policyId {
            try encodeContainer.encode(policyId, forKey: .policyId)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyId)
        policyId = policyIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(DlmClientTypes.GettablePolicyStateValues.self, forKey: .state)
        state = stateDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let dateModifiedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .dateModified)
        dateModified = dateModifiedDecoded
        let policyDetailsDecoded = try containerValues.decodeIfPresent(DlmClientTypes.PolicyDetails.self, forKey: .policyDetails)
        policyDetails = policyDetailsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
    }
}

extension DlmClientTypes.LifecyclePolicy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LifecyclePolicy(dateCreated: \(Swift.String(describing: dateCreated)), dateModified: \(Swift.String(describing: dateModified)), description: \(Swift.String(describing: description)), executionRoleArn: \(Swift.String(describing: executionRoleArn)), policyArn: \(Swift.String(describing: policyArn)), policyDetails: \(Swift.String(describing: policyDetails)), policyId: \(Swift.String(describing: policyId)), state: \(Swift.String(describing: state)), statusMessage: \(Swift.String(describing: statusMessage)), tags: \(Swift.String(describing: tags)))"}
}

extension DlmClientTypes {
    /// Detailed information about a lifecycle policy.
    public struct LifecyclePolicy: Swift.Equatable {
        /// The local date and time when the lifecycle policy was created.
        public var dateCreated: ClientRuntime.Date?
        /// The local date and time when the lifecycle policy was last modified.
        public var dateModified: ClientRuntime.Date?
        /// The description of the lifecycle policy.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of the IAM role used to run the operations specified by
        /// 			the lifecycle policy.
        public var executionRoleArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the policy.
        public var policyArn: Swift.String?
        /// The configuration of the lifecycle policy
        public var policyDetails: DlmClientTypes.PolicyDetails?
        /// The identifier of the lifecycle policy.
        public var policyId: Swift.String?
        /// The activation state of the lifecycle policy.
        public var state: DlmClientTypes.GettablePolicyStateValues?
        /// The description of the status.
        public var statusMessage: Swift.String?
        /// The tags.
        public var tags: [Swift.String:Swift.String]?

        public init (
            dateCreated: ClientRuntime.Date? = nil,
            dateModified: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            executionRoleArn: Swift.String? = nil,
            policyArn: Swift.String? = nil,
            policyDetails: DlmClientTypes.PolicyDetails? = nil,
            policyId: Swift.String? = nil,
            state: DlmClientTypes.GettablePolicyStateValues? = nil,
            statusMessage: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.dateCreated = dateCreated
            self.dateModified = dateModified
            self.description = description
            self.executionRoleArn = executionRoleArn
            self.policyArn = policyArn
            self.policyDetails = policyDetails
            self.policyId = policyId
            self.state = state
            self.statusMessage = statusMessage
            self.tags = tags
        }
    }

}

extension DlmClientTypes.LifecyclePolicySummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case policyId = "PolicyId"
        case policyType = "PolicyType"
        case state = "State"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let policyId = policyId {
            try encodeContainer.encode(policyId, forKey: .policyId)
        }
        if let policyType = policyType {
            try encodeContainer.encode(policyType.rawValue, forKey: .policyType)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyId)
        policyId = policyIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(DlmClientTypes.GettablePolicyStateValues.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let policyTypeDecoded = try containerValues.decodeIfPresent(DlmClientTypes.PolicyTypeValues.self, forKey: .policyType)
        policyType = policyTypeDecoded
    }
}

extension DlmClientTypes.LifecyclePolicySummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LifecyclePolicySummary(description: \(Swift.String(describing: description)), policyId: \(Swift.String(describing: policyId)), policyType: \(Swift.String(describing: policyType)), state: \(Swift.String(describing: state)), tags: \(Swift.String(describing: tags)))"}
}

extension DlmClientTypes {
    /// Summary information about a lifecycle policy.
    public struct LifecyclePolicySummary: Swift.Equatable {
        /// The description of the lifecycle policy.
        public var description: Swift.String?
        /// The identifier of the lifecycle policy.
        public var policyId: Swift.String?
        /// The type of policy. EBS_SNAPSHOT_MANAGEMENT indicates that the policy
        /// 			manages the lifecycle of Amazon EBS snapshots. IMAGE_MANAGEMENT
        /// 			indicates that the policy manages the lifecycle of EBS-backed AMIs.
        public var policyType: DlmClientTypes.PolicyTypeValues?
        /// The activation state of the lifecycle policy.
        public var state: DlmClientTypes.GettablePolicyStateValues?
        /// The tags.
        public var tags: [Swift.String:Swift.String]?

        public init (
            description: Swift.String? = nil,
            policyId: Swift.String? = nil,
            policyType: DlmClientTypes.PolicyTypeValues? = nil,
            state: DlmClientTypes.GettablePolicyStateValues? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.description = description
            self.policyId = policyId
            self.policyType = policyType
            self.state = state
            self.tags = tags
        }
    }

}

extension LimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LimitExceededException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
            self.resourceType = output.resourceType
        } else {
            self.code = nil
            self.message = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request failed because a limit was exceeded.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    public var message: Swift.String?
    /// Value is the type of resource for which a limit was exceeded.
    public var resourceType: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
        self.resourceType = resourceType
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let code: Swift.String?
    public let resourceType: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// Information about the tags.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DlmClientTypes {
    public enum LocationValues: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cloud
        case outpostLocal
        case sdkUnknown(Swift.String)

        public static var allCases: [LocationValues] {
            return [
                .cloud,
                .outpostLocal,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cloud: return "CLOUD"
            case .outpostLocal: return "OUTPOST_LOCAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LocationValues(rawValue: rawValue) ?? LocationValues.sdkUnknown(rawValue)
        }
    }
}

extension DlmClientTypes.Parameters: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case excludeBootVolume = "ExcludeBootVolume"
        case noReboot = "NoReboot"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let excludeBootVolume = excludeBootVolume {
            try encodeContainer.encode(excludeBootVolume, forKey: .excludeBootVolume)
        }
        if let noReboot = noReboot {
            try encodeContainer.encode(noReboot, forKey: .noReboot)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let excludeBootVolumeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .excludeBootVolume)
        excludeBootVolume = excludeBootVolumeDecoded
        let noRebootDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .noReboot)
        noReboot = noRebootDecoded
    }
}

extension DlmClientTypes.Parameters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Parameters(excludeBootVolume: \(Swift.String(describing: excludeBootVolume)), noReboot: \(Swift.String(describing: noReboot)))"}
}

extension DlmClientTypes {
    /// Specifies optional parameters to add to a policy. The set of valid parameters depends
    /// 			on the combination of policy type and resource type.
    public struct Parameters: Swift.Equatable {
        /// [EBS Snapshot Management – Instance policies only] Indicates whether to exclude the
        /// 			root volume from snapshots created using <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateSnapshots.html">CreateSnapshots.
        /// 			The default is false.
        public var excludeBootVolume: Swift.Bool?
        /// Applies to AMI lifecycle policies only. Indicates whether targeted instances are rebooted when the lifecycle
        /// 			policy runs. true indicates that targeted instances are not rebooted when the policy
        /// 			runs. false indicates that target instances are rebooted when the policy runs. The
        /// 			default is true (instances are not rebooted).
        public var noReboot: Swift.Bool?

        public init (
            excludeBootVolume: Swift.Bool? = nil,
            noReboot: Swift.Bool? = nil
        )
        {
            self.excludeBootVolume = excludeBootVolume
            self.noReboot = noReboot
        }
    }

}

extension DlmClientTypes.PolicyDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case eventSource = "EventSource"
        case parameters = "Parameters"
        case policyType = "PolicyType"
        case resourceLocations = "ResourceLocations"
        case resourceTypes = "ResourceTypes"
        case schedules = "Schedules"
        case targetTags = "TargetTags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for actionlist0 in actions {
                try actionsContainer.encode(actionlist0)
            }
        }
        if let eventSource = eventSource {
            try encodeContainer.encode(eventSource, forKey: .eventSource)
        }
        if let parameters = parameters {
            try encodeContainer.encode(parameters, forKey: .parameters)
        }
        if let policyType = policyType {
            try encodeContainer.encode(policyType.rawValue, forKey: .policyType)
        }
        if let resourceLocations = resourceLocations {
            var resourceLocationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceLocations)
            for resourcelocationlist0 in resourceLocations {
                try resourceLocationsContainer.encode(resourcelocationlist0.rawValue)
            }
        }
        if let resourceTypes = resourceTypes {
            var resourceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTypes)
            for resourcetypevalueslist0 in resourceTypes {
                try resourceTypesContainer.encode(resourcetypevalueslist0.rawValue)
            }
        }
        if let schedules = schedules {
            var schedulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .schedules)
            for schedulelist0 in schedules {
                try schedulesContainer.encode(schedulelist0)
            }
        }
        if let targetTags = targetTags {
            var targetTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetTags)
            for targettaglist0 in targetTags {
                try targetTagsContainer.encode(targettaglist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyTypeDecoded = try containerValues.decodeIfPresent(DlmClientTypes.PolicyTypeValues.self, forKey: .policyType)
        policyType = policyTypeDecoded
        let resourceTypesContainer = try containerValues.decodeIfPresent([DlmClientTypes.ResourceTypeValues?].self, forKey: .resourceTypes)
        var resourceTypesDecoded0:[DlmClientTypes.ResourceTypeValues]? = nil
        if let resourceTypesContainer = resourceTypesContainer {
            resourceTypesDecoded0 = [DlmClientTypes.ResourceTypeValues]()
            for string0 in resourceTypesContainer {
                if let string0 = string0 {
                    resourceTypesDecoded0?.append(string0)
                }
            }
        }
        resourceTypes = resourceTypesDecoded0
        let resourceLocationsContainer = try containerValues.decodeIfPresent([DlmClientTypes.ResourceLocationValues?].self, forKey: .resourceLocations)
        var resourceLocationsDecoded0:[DlmClientTypes.ResourceLocationValues]? = nil
        if let resourceLocationsContainer = resourceLocationsContainer {
            resourceLocationsDecoded0 = [DlmClientTypes.ResourceLocationValues]()
            for string0 in resourceLocationsContainer {
                if let string0 = string0 {
                    resourceLocationsDecoded0?.append(string0)
                }
            }
        }
        resourceLocations = resourceLocationsDecoded0
        let targetTagsContainer = try containerValues.decodeIfPresent([DlmClientTypes.Tag?].self, forKey: .targetTags)
        var targetTagsDecoded0:[DlmClientTypes.Tag]? = nil
        if let targetTagsContainer = targetTagsContainer {
            targetTagsDecoded0 = [DlmClientTypes.Tag]()
            for structure0 in targetTagsContainer {
                if let structure0 = structure0 {
                    targetTagsDecoded0?.append(structure0)
                }
            }
        }
        targetTags = targetTagsDecoded0
        let schedulesContainer = try containerValues.decodeIfPresent([DlmClientTypes.Schedule?].self, forKey: .schedules)
        var schedulesDecoded0:[DlmClientTypes.Schedule]? = nil
        if let schedulesContainer = schedulesContainer {
            schedulesDecoded0 = [DlmClientTypes.Schedule]()
            for structure0 in schedulesContainer {
                if let structure0 = structure0 {
                    schedulesDecoded0?.append(structure0)
                }
            }
        }
        schedules = schedulesDecoded0
        let parametersDecoded = try containerValues.decodeIfPresent(DlmClientTypes.Parameters.self, forKey: .parameters)
        parameters = parametersDecoded
        let eventSourceDecoded = try containerValues.decodeIfPresent(DlmClientTypes.EventSource.self, forKey: .eventSource)
        eventSource = eventSourceDecoded
        let actionsContainer = try containerValues.decodeIfPresent([DlmClientTypes.Action?].self, forKey: .actions)
        var actionsDecoded0:[DlmClientTypes.Action]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [DlmClientTypes.Action]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
    }
}

extension DlmClientTypes.PolicyDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PolicyDetails(actions: \(Swift.String(describing: actions)), eventSource: \(Swift.String(describing: eventSource)), parameters: \(Swift.String(describing: parameters)), policyType: \(Swift.String(describing: policyType)), resourceLocations: \(Swift.String(describing: resourceLocations)), resourceTypes: \(Swift.String(describing: resourceTypes)), schedules: \(Swift.String(describing: schedules)), targetTags: \(Swift.String(describing: targetTags)))"}
}

extension DlmClientTypes {
    /// Specifies the configuration of a lifecycle policy.
    public struct PolicyDetails: Swift.Equatable {
        /// The actions to be performed when the event-based policy is triggered. You can specify
        /// 		only one action per policy.
        /// 		       This parameter is required for event-based policies only. If you are creating a snapshot or AMI policy, omit this parameter.
        public var actions: [DlmClientTypes.Action]?
        /// The event that triggers the event-based policy.
        /// 		       This parameter is required for event-based policies only. If you are creating a snapshot or AMI policy, omit this parameter.
        public var eventSource: DlmClientTypes.EventSource?
        /// A set of optional parameters for snapshot and AMI lifecycle policies.
        /// 		       This parameter is required for snapshot and AMI policies only. If you are creating an event-based policy, omit this parameter.
        public var parameters: DlmClientTypes.Parameters?
        /// The valid target resource types and actions a policy can manage. Specify EBS_SNAPSHOT_MANAGEMENT
        /// 			to create a lifecycle policy that manages the lifecycle of Amazon EBS snapshots. Specify IMAGE_MANAGEMENT
        /// 			to create a lifecycle policy that manages the lifecycle of EBS-backed AMIs. Specify EVENT_BASED_POLICY
        /// 			to create an event-based policy that performs specific actions when a defined event occurs in your Amazon Web Services account.
        /// 		       The default is EBS_SNAPSHOT_MANAGEMENT.
        public var policyType: DlmClientTypes.PolicyTypeValues?
        /// The location of the resources to backup. If the source resources are located in an Amazon Web Services Region,
        /// 			specify CLOUD. If the source resources are located on an Outpost
        /// 			in your account, specify OUTPOST.
        /// 			      If you specify OUTPOST, Amazon Data Lifecycle Manager backs up all resources
        /// 				of the specified type with matching target tags across all of the Outposts in your account.
        public var resourceLocations: [DlmClientTypes.ResourceLocationValues]?
        /// The target resource type for snapshot and AMI lifecycle policies. Use VOLUME to
        /// 			create snapshots of individual volumes or use INSTANCE to create multi-volume
        /// 			snapshots from the volumes for an instance.
        /// 		       This parameter is required for snapshot and AMI policies only. If you are creating an event-based policy, omit this parameter.
        public var resourceTypes: [DlmClientTypes.ResourceTypeValues]?
        /// The schedules of policy-defined actions for snapshot and AMI lifecycle policies. A policy
        /// 			can have up to four schedules—one mandatory schedule and up to three optional schedules.
        /// 		       This parameter is required for snapshot and AMI policies only. If you are creating an event-based policy, omit this parameter.
        public var schedules: [DlmClientTypes.Schedule]?
        /// The single tag that identifies targeted resources for this policy.
        /// 		       This parameter is required for snapshot and AMI policies only. If you are creating an event-based policy, omit this parameter.
        public var targetTags: [DlmClientTypes.Tag]?

        public init (
            actions: [DlmClientTypes.Action]? = nil,
            eventSource: DlmClientTypes.EventSource? = nil,
            parameters: DlmClientTypes.Parameters? = nil,
            policyType: DlmClientTypes.PolicyTypeValues? = nil,
            resourceLocations: [DlmClientTypes.ResourceLocationValues]? = nil,
            resourceTypes: [DlmClientTypes.ResourceTypeValues]? = nil,
            schedules: [DlmClientTypes.Schedule]? = nil,
            targetTags: [DlmClientTypes.Tag]? = nil
        )
        {
            self.actions = actions
            self.eventSource = eventSource
            self.parameters = parameters
            self.policyType = policyType
            self.resourceLocations = resourceLocations
            self.resourceTypes = resourceTypes
            self.schedules = schedules
            self.targetTags = targetTags
        }
    }

}

extension DlmClientTypes {
    public enum PolicyTypeValues: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ebsSnapshotManagement
        case eventBasedPolicy
        case imageManagement
        case sdkUnknown(Swift.String)

        public static var allCases: [PolicyTypeValues] {
            return [
                .ebsSnapshotManagement,
                .eventBasedPolicy,
                .imageManagement,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ebsSnapshotManagement: return "EBS_SNAPSHOT_MANAGEMENT"
            case .eventBasedPolicy: return "EVENT_BASED_POLICY"
            case .imageManagement: return "IMAGE_MANAGEMENT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PolicyTypeValues(rawValue: rawValue) ?? PolicyTypeValues.sdkUnknown(rawValue)
        }
    }
}

extension DlmClientTypes {
    public enum ResourceLocationValues: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cloud
        case outpost
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceLocationValues] {
            return [
                .cloud,
                .outpost,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cloud: return "CLOUD"
            case .outpost: return "OUTPOST"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceLocationValues(rawValue: rawValue) ?? ResourceLocationValues.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)), resourceIds: \(Swift.String(describing: resourceIds)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
            self.resourceIds = output.resourceIds
            self.resourceType = output.resourceType
        } else {
            self.code = nil
            self.message = nil
            self.resourceIds = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A requested resource was not found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    public var message: Swift.String?
    /// Value is a list of resource IDs that were not found.
    public var resourceIds: [Swift.String]?
    /// Value is the type of resource that was not found.
    public var resourceType: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        resourceIds: [Swift.String]? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
        self.resourceIds = resourceIds
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let code: Swift.String?
    public let resourceType: Swift.String?
    public let resourceIds: [Swift.String]?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
        case resourceIds = "ResourceIds"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceIds)
        var resourceIdsDecoded0:[Swift.String]? = nil
        if let resourceIdsContainer = resourceIdsContainer {
            resourceIdsDecoded0 = [Swift.String]()
            for string0 in resourceIdsContainer {
                if let string0 = string0 {
                    resourceIdsDecoded0?.append(string0)
                }
            }
        }
        resourceIds = resourceIdsDecoded0
    }
}

extension DlmClientTypes {
    public enum ResourceTypeValues: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case instance
        case volume
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceTypeValues] {
            return [
                .instance,
                .volume,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .instance: return "INSTANCE"
            case .volume: return "VOLUME"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceTypeValues(rawValue: rawValue) ?? ResourceTypeValues.sdkUnknown(rawValue)
        }
    }
}

extension DlmClientTypes.RetainRule: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case count = "Count"
        case interval = "Interval"
        case intervalUnit = "IntervalUnit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if count != 0 {
            try encodeContainer.encode(count, forKey: .count)
        }
        if interval != 0 {
            try encodeContainer.encode(interval, forKey: .interval)
        }
        if let intervalUnit = intervalUnit {
            try encodeContainer.encode(intervalUnit.rawValue, forKey: .intervalUnit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countDecoded = try containerValues.decode(Swift.Int.self, forKey: .count)
        count = countDecoded
        let intervalDecoded = try containerValues.decode(Swift.Int.self, forKey: .interval)
        interval = intervalDecoded
        let intervalUnitDecoded = try containerValues.decodeIfPresent(DlmClientTypes.RetentionIntervalUnitValues.self, forKey: .intervalUnit)
        intervalUnit = intervalUnitDecoded
    }
}

extension DlmClientTypes.RetainRule: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RetainRule(count: \(Swift.String(describing: count)), interval: \(Swift.String(describing: interval)), intervalUnit: \(Swift.String(describing: intervalUnit)))"}
}

extension DlmClientTypes {
    /// Specifies the retention rule for a lifecycle policy. You can retain snapshots based on
    /// 			either a count or a time interval.
    public struct RetainRule: Swift.Equatable {
        /// The number of snapshots to retain for each volume, up to a maximum of 1000.
        public var count: Swift.Int
        /// The amount of time to retain each snapshot. The maximum is 100 years. This is
        /// 			equivalent to 1200 months, 5200 weeks, or 36500 days.
        public var interval: Swift.Int
        /// The unit of time for time-based retention.
        public var intervalUnit: DlmClientTypes.RetentionIntervalUnitValues?

        public init (
            count: Swift.Int = 0,
            interval: Swift.Int = 0,
            intervalUnit: DlmClientTypes.RetentionIntervalUnitValues? = nil
        )
        {
            self.count = count
            self.interval = interval
            self.intervalUnit = intervalUnit
        }
    }

}

extension DlmClientTypes {
    public enum RetentionIntervalUnitValues: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case days
        case months
        case weeks
        case years
        case sdkUnknown(Swift.String)

        public static var allCases: [RetentionIntervalUnitValues] {
            return [
                .days,
                .months,
                .weeks,
                .years,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .days: return "DAYS"
            case .months: return "MONTHS"
            case .weeks: return "WEEKS"
            case .years: return "YEARS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RetentionIntervalUnitValues(rawValue: rawValue) ?? RetentionIntervalUnitValues.sdkUnknown(rawValue)
        }
    }
}

extension DlmClientTypes.Schedule: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case copyTags = "CopyTags"
        case createRule = "CreateRule"
        case crossRegionCopyRules = "CrossRegionCopyRules"
        case deprecateRule = "DeprecateRule"
        case fastRestoreRule = "FastRestoreRule"
        case name = "Name"
        case retainRule = "RetainRule"
        case shareRules = "ShareRules"
        case tagsToAdd = "TagsToAdd"
        case variableTags = "VariableTags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if copyTags != false {
            try encodeContainer.encode(copyTags, forKey: .copyTags)
        }
        if let createRule = createRule {
            try encodeContainer.encode(createRule, forKey: .createRule)
        }
        if let crossRegionCopyRules = crossRegionCopyRules {
            var crossRegionCopyRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .crossRegionCopyRules)
            for crossregioncopyrules0 in crossRegionCopyRules {
                try crossRegionCopyRulesContainer.encode(crossregioncopyrules0)
            }
        }
        if let deprecateRule = deprecateRule {
            try encodeContainer.encode(deprecateRule, forKey: .deprecateRule)
        }
        if let fastRestoreRule = fastRestoreRule {
            try encodeContainer.encode(fastRestoreRule, forKey: .fastRestoreRule)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let retainRule = retainRule {
            try encodeContainer.encode(retainRule, forKey: .retainRule)
        }
        if let shareRules = shareRules {
            var shareRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .shareRules)
            for sharerules0 in shareRules {
                try shareRulesContainer.encode(sharerules0)
            }
        }
        if let tagsToAdd = tagsToAdd {
            var tagsToAddContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagsToAdd)
            for tagstoaddlist0 in tagsToAdd {
                try tagsToAddContainer.encode(tagstoaddlist0)
            }
        }
        if let variableTags = variableTags {
            var variableTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .variableTags)
            for variabletagslist0 in variableTags {
                try variableTagsContainer.encode(variabletagslist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let copyTagsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .copyTags)
        copyTags = copyTagsDecoded
        let tagsToAddContainer = try containerValues.decodeIfPresent([DlmClientTypes.Tag?].self, forKey: .tagsToAdd)
        var tagsToAddDecoded0:[DlmClientTypes.Tag]? = nil
        if let tagsToAddContainer = tagsToAddContainer {
            tagsToAddDecoded0 = [DlmClientTypes.Tag]()
            for structure0 in tagsToAddContainer {
                if let structure0 = structure0 {
                    tagsToAddDecoded0?.append(structure0)
                }
            }
        }
        tagsToAdd = tagsToAddDecoded0
        let variableTagsContainer = try containerValues.decodeIfPresent([DlmClientTypes.Tag?].self, forKey: .variableTags)
        var variableTagsDecoded0:[DlmClientTypes.Tag]? = nil
        if let variableTagsContainer = variableTagsContainer {
            variableTagsDecoded0 = [DlmClientTypes.Tag]()
            for structure0 in variableTagsContainer {
                if let structure0 = structure0 {
                    variableTagsDecoded0?.append(structure0)
                }
            }
        }
        variableTags = variableTagsDecoded0
        let createRuleDecoded = try containerValues.decodeIfPresent(DlmClientTypes.CreateRule.self, forKey: .createRule)
        createRule = createRuleDecoded
        let retainRuleDecoded = try containerValues.decodeIfPresent(DlmClientTypes.RetainRule.self, forKey: .retainRule)
        retainRule = retainRuleDecoded
        let fastRestoreRuleDecoded = try containerValues.decodeIfPresent(DlmClientTypes.FastRestoreRule.self, forKey: .fastRestoreRule)
        fastRestoreRule = fastRestoreRuleDecoded
        let crossRegionCopyRulesContainer = try containerValues.decodeIfPresent([DlmClientTypes.CrossRegionCopyRule?].self, forKey: .crossRegionCopyRules)
        var crossRegionCopyRulesDecoded0:[DlmClientTypes.CrossRegionCopyRule]? = nil
        if let crossRegionCopyRulesContainer = crossRegionCopyRulesContainer {
            crossRegionCopyRulesDecoded0 = [DlmClientTypes.CrossRegionCopyRule]()
            for structure0 in crossRegionCopyRulesContainer {
                if let structure0 = structure0 {
                    crossRegionCopyRulesDecoded0?.append(structure0)
                }
            }
        }
        crossRegionCopyRules = crossRegionCopyRulesDecoded0
        let shareRulesContainer = try containerValues.decodeIfPresent([DlmClientTypes.ShareRule?].self, forKey: .shareRules)
        var shareRulesDecoded0:[DlmClientTypes.ShareRule]? = nil
        if let shareRulesContainer = shareRulesContainer {
            shareRulesDecoded0 = [DlmClientTypes.ShareRule]()
            for structure0 in shareRulesContainer {
                if let structure0 = structure0 {
                    shareRulesDecoded0?.append(structure0)
                }
            }
        }
        shareRules = shareRulesDecoded0
        let deprecateRuleDecoded = try containerValues.decodeIfPresent(DlmClientTypes.DeprecateRule.self, forKey: .deprecateRule)
        deprecateRule = deprecateRuleDecoded
    }
}

extension DlmClientTypes.Schedule: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Schedule(copyTags: \(Swift.String(describing: copyTags)), createRule: \(Swift.String(describing: createRule)), crossRegionCopyRules: \(Swift.String(describing: crossRegionCopyRules)), deprecateRule: \(Swift.String(describing: deprecateRule)), fastRestoreRule: \(Swift.String(describing: fastRestoreRule)), name: \(Swift.String(describing: name)), retainRule: \(Swift.String(describing: retainRule)), shareRules: \(Swift.String(describing: shareRules)), tagsToAdd: \(Swift.String(describing: tagsToAdd)), variableTags: \(Swift.String(describing: variableTags)))"}
}

extension DlmClientTypes {
    /// Specifies a backup schedule for a snapshot or AMI lifecycle policy.
    public struct Schedule: Swift.Equatable {
        /// Copy all user-defined tags on a source volume to snapshots of the volume created by
        /// 			this policy.
        public var copyTags: Swift.Bool
        /// The creation rule.
        public var createRule: DlmClientTypes.CreateRule?
        /// The rule for cross-Region snapshot copies.
        /// 		       You can only specify cross-Region copy rules for policies that create snapshots in a Region.
        /// 			If the policy creates snapshots on an Outpost, then you cannot copy the snapshots to a Region or
        /// 			to an Outpost. If the policy creates snapshots in a Region, then snapshots can be copied to up to three
        /// 			Regions or Outposts.
        public var crossRegionCopyRules: [DlmClientTypes.CrossRegionCopyRule]?
        /// The AMI deprecation rule for the schedule.
        public var deprecateRule: DlmClientTypes.DeprecateRule?
        /// The rule for enabling fast snapshot restore.
        public var fastRestoreRule: DlmClientTypes.FastRestoreRule?
        /// The name of the schedule.
        public var name: Swift.String?
        /// The retention rule.
        public var retainRule: DlmClientTypes.RetainRule?
        /// The rule for sharing snapshots with other Amazon Web Services accounts.
        public var shareRules: [DlmClientTypes.ShareRule]?
        /// The tags to apply to policy-created resources. These user-defined tags are in addition
        /// 			to the Amazon Web Services-added lifecycle tags.
        public var tagsToAdd: [DlmClientTypes.Tag]?
        /// A collection of key/value pairs with values determined dynamically when the policy is
        /// 			executed. Keys may be any valid Amazon EC2 tag key. Values must be in one of the two
        /// 			following formats: $(instance-id) or $(timestamp). Variable
        /// 			tags are only valid for EBS Snapshot Management – Instance policies.
        public var variableTags: [DlmClientTypes.Tag]?

        public init (
            copyTags: Swift.Bool = false,
            createRule: DlmClientTypes.CreateRule? = nil,
            crossRegionCopyRules: [DlmClientTypes.CrossRegionCopyRule]? = nil,
            deprecateRule: DlmClientTypes.DeprecateRule? = nil,
            fastRestoreRule: DlmClientTypes.FastRestoreRule? = nil,
            name: Swift.String? = nil,
            retainRule: DlmClientTypes.RetainRule? = nil,
            shareRules: [DlmClientTypes.ShareRule]? = nil,
            tagsToAdd: [DlmClientTypes.Tag]? = nil,
            variableTags: [DlmClientTypes.Tag]? = nil
        )
        {
            self.copyTags = copyTags
            self.createRule = createRule
            self.crossRegionCopyRules = crossRegionCopyRules
            self.deprecateRule = deprecateRule
            self.fastRestoreRule = fastRestoreRule
            self.name = name
            self.retainRule = retainRule
            self.shareRules = shareRules
            self.tagsToAdd = tagsToAdd
            self.variableTags = variableTags
        }
    }

}

extension DlmClientTypes {
    public enum SettablePolicyStateValues: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [SettablePolicyStateValues] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SettablePolicyStateValues(rawValue: rawValue) ?? SettablePolicyStateValues.sdkUnknown(rawValue)
        }
    }
}

extension DlmClientTypes.ShareRule: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetAccounts = "TargetAccounts"
        case unshareInterval = "UnshareInterval"
        case unshareIntervalUnit = "UnshareIntervalUnit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetAccounts = targetAccounts {
            var targetAccountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetAccounts)
            for sharetargetaccountlist0 in targetAccounts {
                try targetAccountsContainer.encode(sharetargetaccountlist0)
            }
        }
        if unshareInterval != 0 {
            try encodeContainer.encode(unshareInterval, forKey: .unshareInterval)
        }
        if let unshareIntervalUnit = unshareIntervalUnit {
            try encodeContainer.encode(unshareIntervalUnit.rawValue, forKey: .unshareIntervalUnit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetAccountsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targetAccounts)
        var targetAccountsDecoded0:[Swift.String]? = nil
        if let targetAccountsContainer = targetAccountsContainer {
            targetAccountsDecoded0 = [Swift.String]()
            for string0 in targetAccountsContainer {
                if let string0 = string0 {
                    targetAccountsDecoded0?.append(string0)
                }
            }
        }
        targetAccounts = targetAccountsDecoded0
        let unshareIntervalDecoded = try containerValues.decode(Swift.Int.self, forKey: .unshareInterval)
        unshareInterval = unshareIntervalDecoded
        let unshareIntervalUnitDecoded = try containerValues.decodeIfPresent(DlmClientTypes.RetentionIntervalUnitValues.self, forKey: .unshareIntervalUnit)
        unshareIntervalUnit = unshareIntervalUnitDecoded
    }
}

extension DlmClientTypes.ShareRule: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ShareRule(targetAccounts: \(Swift.String(describing: targetAccounts)), unshareInterval: \(Swift.String(describing: unshareInterval)), unshareIntervalUnit: \(Swift.String(describing: unshareIntervalUnit)))"}
}

extension DlmClientTypes {
    /// Specifies a rule for sharing snapshots across Amazon Web Services accounts.
    public struct ShareRule: Swift.Equatable {
        /// The IDs of the Amazon Web Services accounts with which to share the snapshots.
        /// This member is required.
        public var targetAccounts: [Swift.String]?
        /// The period after which snapshots that are shared with other Amazon Web Services accounts are automatically unshared.
        public var unshareInterval: Swift.Int
        /// The unit of time for the automatic unsharing interval.
        public var unshareIntervalUnit: DlmClientTypes.RetentionIntervalUnitValues?

        public init (
            targetAccounts: [Swift.String]? = nil,
            unshareInterval: Swift.Int = 0,
            unshareIntervalUnit: DlmClientTypes.RetentionIntervalUnitValues? = nil
        )
        {
            self.targetAccounts = targetAccounts
            self.unshareInterval = unshareInterval
            self.unshareIntervalUnit = unshareIntervalUnit
        }
    }

}

extension DlmClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension DlmClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension DlmClientTypes {
    /// Specifies a tag for a resource.
    public struct Tag: Swift.Equatable {
        /// The tag key.
        /// This member is required.
        public var key: Swift.String?
        /// The tag value.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// One or more tags.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateLifecyclePolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLifecyclePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateLifecyclePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLifecyclePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateLifecyclePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLifecyclePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLifecyclePolicyOutputError>
}

extension UpdateLifecyclePolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateLifecyclePolicyInput(description: \(Swift.String(describing: description)), executionRoleArn: \(Swift.String(describing: executionRoleArn)), policyDetails: \(Swift.String(describing: policyDetails)), policyId: \(Swift.String(describing: policyId)), state: \(Swift.String(describing: state)))"}
}

extension UpdateLifecyclePolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case executionRoleArn = "ExecutionRoleArn"
        case policyDetails = "PolicyDetails"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let executionRoleArn = executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let policyDetails = policyDetails {
            try encodeContainer.encode(policyDetails, forKey: .policyDetails)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }
}

public struct UpdateLifecyclePolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLifecyclePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateLifecyclePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLifecyclePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateLifecyclePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLifecyclePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLifecyclePolicyOutputError>
}

public struct UpdateLifecyclePolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLifecyclePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateLifecyclePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLifecyclePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateLifecyclePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLifecyclePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLifecyclePolicyOutputError>
}

public struct UpdateLifecyclePolicyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLifecyclePolicyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateLifecyclePolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLifecyclePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateLifecyclePolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLifecyclePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLifecyclePolicyOutputError>
}

public struct UpdateLifecyclePolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLifecyclePolicyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateLifecyclePolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLifecyclePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let policyId = input.policyId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("policyId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/policies/\(policyId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateLifecyclePolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLifecyclePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLifecyclePolicyOutputError>
}

public struct UpdateLifecyclePolicyInput: Swift.Equatable {
    /// A description of the lifecycle policy.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role used to run the operations specified by
    /// 			the lifecycle policy.
    public var executionRoleArn: Swift.String?
    /// The configuration of the lifecycle policy. You cannot update the policy type or the
    /// 			resource type.
    public var policyDetails: DlmClientTypes.PolicyDetails?
    /// The identifier of the lifecycle policy.
    /// This member is required.
    public var policyId: Swift.String?
    /// The desired activation state of the lifecycle policy after creation.
    public var state: DlmClientTypes.SettablePolicyStateValues?

    public init (
        description: Swift.String? = nil,
        executionRoleArn: Swift.String? = nil,
        policyDetails: DlmClientTypes.PolicyDetails? = nil,
        policyId: Swift.String? = nil,
        state: DlmClientTypes.SettablePolicyStateValues? = nil
    )
    {
        self.description = description
        self.executionRoleArn = executionRoleArn
        self.policyDetails = policyDetails
        self.policyId = policyId
        self.state = state
    }
}

struct UpdateLifecyclePolicyInputBody: Swift.Equatable {
    public let executionRoleArn: Swift.String?
    public let state: DlmClientTypes.SettablePolicyStateValues?
    public let description: Swift.String?
    public let policyDetails: DlmClientTypes.PolicyDetails?
}

extension UpdateLifecyclePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case executionRoleArn = "ExecutionRoleArn"
        case policyDetails = "PolicyDetails"
        case state = "State"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(DlmClientTypes.SettablePolicyStateValues.self, forKey: .state)
        state = stateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let policyDetailsDecoded = try containerValues.decodeIfPresent(DlmClientTypes.PolicyDetails.self, forKey: .policyDetails)
        policyDetails = policyDetailsDecoded
    }
}

extension UpdateLifecyclePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateLifecyclePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateLifecyclePolicyOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateLifecyclePolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateLifecyclePolicyOutputResponse()"}
}

extension UpdateLifecyclePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateLifecyclePolicyOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateLifecyclePolicyOutputResponseBody: Swift.Equatable {
}

extension UpdateLifecyclePolicyOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}
