// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ForecastClientTypes {
    public enum AttributeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case float
        case geolocation
        case integer
        case string
        case timestamp
        case sdkUnknown(Swift.String)

        public static var allCases: [AttributeType] {
            return [
                .float,
                .geolocation,
                .integer,
                .string,
                .timestamp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .float: return "float"
            case .geolocation: return "geolocation"
            case .integer: return "integer"
            case .string: return "string"
            case .timestamp: return "timestamp"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AttributeType(rawValue: rawValue) ?? AttributeType.sdkUnknown(rawValue)
        }
    }
}

extension ForecastClientTypes {
    public enum AutoMLOverrideStrategy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case latencyoptimized
        case sdkUnknown(Swift.String)

        public static var allCases: [AutoMLOverrideStrategy] {
            return [
                .latencyoptimized,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .latencyoptimized: return "LatencyOptimized"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AutoMLOverrideStrategy(rawValue: rawValue) ?? AutoMLOverrideStrategy.sdkUnknown(rawValue)
        }
    }
}

extension ForecastClientTypes.CategoricalParameterRange: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for values0 in values {
                try valuesContainer.encode(values0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension ForecastClientTypes.CategoricalParameterRange: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CategoricalParameterRange(name: \(Swift.String(describing: name)), values: \(Swift.String(describing: values)))"}
}

extension ForecastClientTypes {
    /// Specifies a categorical hyperparameter and it's range of tunable values.
    ///       This object is part of the ParameterRanges object.
    public struct CategoricalParameterRange: Swift.Equatable {
        /// The name of the categorical hyperparameter to tune.
        /// This member is required.
        public var name: Swift.String?
        /// A list of the tunable categories for the hyperparameter.
        /// This member is required.
        public var values: [Swift.String]?

        public init (
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension ForecastClientTypes.ContinuousParameterRange: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxValue = "MaxValue"
        case minValue = "MinValue"
        case name = "Name"
        case scalingType = "ScalingType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxValue = maxValue {
            try encodeContainer.encode(maxValue, forKey: .maxValue)
        }
        if let minValue = minValue {
            try encodeContainer.encode(minValue, forKey: .minValue)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let scalingType = scalingType {
            try encodeContainer.encode(scalingType.rawValue, forKey: .scalingType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let maxValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .maxValue)
        maxValue = maxValueDecoded
        let minValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .minValue)
        minValue = minValueDecoded
        let scalingTypeDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.ScalingType.self, forKey: .scalingType)
        scalingType = scalingTypeDecoded
    }
}

extension ForecastClientTypes.ContinuousParameterRange: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ContinuousParameterRange(maxValue: \(Swift.String(describing: maxValue)), minValue: \(Swift.String(describing: minValue)), name: \(Swift.String(describing: name)), scalingType: \(Swift.String(describing: scalingType)))"}
}

extension ForecastClientTypes {
    /// Specifies a continuous hyperparameter and it's range of tunable values.
    ///       This object is part of the ParameterRanges object.
    public struct ContinuousParameterRange: Swift.Equatable {
        /// The maximum tunable value of the hyperparameter.
        /// This member is required.
        public var maxValue: Swift.Double?
        /// The minimum tunable value of the hyperparameter.
        /// This member is required.
        public var minValue: Swift.Double?
        /// The name of the hyperparameter to tune.
        /// This member is required.
        public var name: Swift.String?
        /// The scale that hyperparameter tuning uses to search the hyperparameter range.
        ///       Valid values:
        ///
        ///             Auto
        ///
        ///                Amazon Forecast hyperparameter tuning chooses the best scale for the hyperparameter.
        ///
        ///             Linear
        ///
        ///                Hyperparameter tuning searches the values in the hyperparameter range by using a
        ///             linear scale.
        ///
        ///             Logarithmic
        ///
        ///                Hyperparameter tuning searches the values in the hyperparameter range by using a
        ///             logarithmic scale.
        ///                Logarithmic scaling works only for ranges that have values greater than 0.
        ///
        ///             ReverseLogarithmic
        ///
        ///                hyperparameter tuning searches the values in the hyperparameter range by using a
        ///             reverse logarithmic scale.
        ///                Reverse logarithmic scaling works only for ranges that are entirely within the
        ///             range 0 <= x < 1.0.
        ///
        ///
        ///          For information about choosing a hyperparameter scale, see
        ///       <a href="http://docs.aws.amazon.com/sagemaker/latest/dg/automatic-model-tuning-define-ranges.html#scaling-type">Hyperparameter Scaling.
        ///       One of the following values:
        public var scalingType: ForecastClientTypes.ScalingType?

        public init (
            maxValue: Swift.Double? = nil,
            minValue: Swift.Double? = nil,
            name: Swift.String? = nil,
            scalingType: ForecastClientTypes.ScalingType? = nil
        )
        {
            self.maxValue = maxValue
            self.minValue = minValue
            self.name = name
            self.scalingType = scalingType
        }
    }

}

public struct CreateDatasetGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDatasetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDatasetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDatasetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDatasetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDatasetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDatasetGroupOutputError>
}

extension CreateDatasetGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDatasetGroupInput(datasetArns: \(Swift.String(describing: datasetArns)), datasetGroupName: \(Swift.String(describing: datasetGroupName)), domain: \(Swift.String(describing: domain)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateDatasetGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArns = "DatasetArns"
        case datasetGroupName = "DatasetGroupName"
        case domain = "Domain"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetArns = datasetArns {
            var datasetArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .datasetArns)
            for arnlist0 in datasetArns {
                try datasetArnsContainer.encode(arnlist0)
            }
        }
        if let datasetGroupName = datasetGroupName {
            try encodeContainer.encode(datasetGroupName, forKey: .datasetGroupName)
        }
        if let domain = domain {
            try encodeContainer.encode(domain.rawValue, forKey: .domain)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct CreateDatasetGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDatasetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDatasetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDatasetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDatasetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDatasetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDatasetGroupOutputError>
}

public struct CreateDatasetGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDatasetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDatasetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDatasetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDatasetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDatasetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDatasetGroupOutputError>
}

public struct CreateDatasetGroupInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDatasetGroupInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateDatasetGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDatasetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateDatasetGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDatasetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDatasetGroupOutputError>
}

public struct CreateDatasetGroupInput: Swift.Equatable {
    /// An array of Amazon Resource Names (ARNs) of the datasets that you want to include in the
    ///       dataset group.
    public var datasetArns: [Swift.String]?
    /// A name for the dataset group.
    /// This member is required.
    public var datasetGroupName: Swift.String?
    /// The domain associated with the dataset group. When you add a dataset to a dataset group,
    ///       this value and the value specified for the Domain parameter of the CreateDataset operation must match.
    ///          The Domain and DatasetType that you choose determine the fields
    ///       that must be present in training data that you import to a dataset. For example, if you choose
    ///       the RETAIL domain and TARGET_TIME_SERIES as the
    ///         DatasetType, Amazon Forecast requires that item_id,
    ///         timestamp, and demand fields are present in your data. For more
    ///       information, see howitworks-datasets-groups.
    /// This member is required.
    public var domain: ForecastClientTypes.Domain?
    /// The optional metadata that you apply to the dataset group to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define.
    ///          The following basic restrictions apply to tags:
    ///
    ///
    ///                Maximum number of tags per resource - 50.
    ///
    ///
    ///                For each resource, each tag key must be unique, and each tag key can have only one value.
    ///
    ///
    ///                Maximum key length - 128 Unicode characters in UTF-8.
    ///
    ///
    ///                Maximum value length - 256 Unicode characters in UTF-8.
    ///
    ///
    ///                If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.
    ///
    ///
    ///                Tag keys and values are case sensitive.
    ///
    ///
    ///                Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
    ///
    ///
    public var tags: [ForecastClientTypes.Tag]?

    public init (
        datasetArns: [Swift.String]? = nil,
        datasetGroupName: Swift.String? = nil,
        domain: ForecastClientTypes.Domain? = nil,
        tags: [ForecastClientTypes.Tag]? = nil
    )
    {
        self.datasetArns = datasetArns
        self.datasetGroupName = datasetGroupName
        self.domain = domain
        self.tags = tags
    }
}

struct CreateDatasetGroupInputBody: Swift.Equatable {
    public let datasetGroupName: Swift.String?
    public let domain: ForecastClientTypes.Domain?
    public let datasetArns: [Swift.String]?
    public let tags: [ForecastClientTypes.Tag]?
}

extension CreateDatasetGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArns = "DatasetArns"
        case datasetGroupName = "DatasetGroupName"
        case domain = "Domain"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupName)
        datasetGroupName = datasetGroupNameDecoded
        let domainDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
        let datasetArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .datasetArns)
        var datasetArnsDecoded0:[Swift.String]? = nil
        if let datasetArnsContainer = datasetArnsContainer {
            datasetArnsDecoded0 = [Swift.String]()
            for string0 in datasetArnsContainer {
                if let string0 = string0 {
                    datasetArnsDecoded0?.append(string0)
                }
            }
        }
        datasetArns = datasetArnsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ForecastClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ForecastClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDatasetGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDatasetGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDatasetGroupOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDatasetGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDatasetGroupOutputResponse(datasetGroupArn: \(Swift.String(describing: datasetGroupArn)))"}
}

extension CreateDatasetGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDatasetGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datasetGroupArn = output.datasetGroupArn
        } else {
            self.datasetGroupArn = nil
        }
    }
}

public struct CreateDatasetGroupOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset group.
    public var datasetGroupArn: Swift.String?

    public init (
        datasetGroupArn: Swift.String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
    }
}

struct CreateDatasetGroupOutputResponseBody: Swift.Equatable {
    public let datasetGroupArn: Swift.String?
}

extension CreateDatasetGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn = "DatasetGroupArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
    }
}

public struct CreateDatasetImportJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDatasetImportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDatasetImportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDatasetImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDatasetImportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDatasetImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDatasetImportJobOutputError>
}

extension CreateDatasetImportJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDatasetImportJobInput(dataSource: \(Swift.String(describing: dataSource)), datasetArn: \(Swift.String(describing: datasetArn)), datasetImportJobName: \(Swift.String(describing: datasetImportJobName)), geolocationFormat: \(Swift.String(describing: geolocationFormat)), tags: \(Swift.String(describing: tags)), timeZone: \(Swift.String(describing: timeZone)), timestampFormat: \(Swift.String(describing: timestampFormat)), useGeolocationForTimeZone: \(Swift.String(describing: useGeolocationForTimeZone)))"}
}

extension CreateDatasetImportJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource = "DataSource"
        case datasetArn = "DatasetArn"
        case datasetImportJobName = "DatasetImportJobName"
        case geolocationFormat = "GeolocationFormat"
        case tags = "Tags"
        case timeZone = "TimeZone"
        case timestampFormat = "TimestampFormat"
        case useGeolocationForTimeZone = "UseGeolocationForTimeZone"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSource = dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let datasetArn = datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
        if let datasetImportJobName = datasetImportJobName {
            try encodeContainer.encode(datasetImportJobName, forKey: .datasetImportJobName)
        }
        if let geolocationFormat = geolocationFormat {
            try encodeContainer.encode(geolocationFormat, forKey: .geolocationFormat)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let timeZone = timeZone {
            try encodeContainer.encode(timeZone, forKey: .timeZone)
        }
        if let timestampFormat = timestampFormat {
            try encodeContainer.encode(timestampFormat, forKey: .timestampFormat)
        }
        if useGeolocationForTimeZone != false {
            try encodeContainer.encode(useGeolocationForTimeZone, forKey: .useGeolocationForTimeZone)
        }
    }
}

public struct CreateDatasetImportJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDatasetImportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDatasetImportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDatasetImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDatasetImportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDatasetImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDatasetImportJobOutputError>
}

public struct CreateDatasetImportJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDatasetImportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDatasetImportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDatasetImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDatasetImportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDatasetImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDatasetImportJobOutputError>
}

public struct CreateDatasetImportJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDatasetImportJobInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateDatasetImportJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDatasetImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateDatasetImportJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDatasetImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDatasetImportJobOutputError>
}

public struct CreateDatasetImportJobInput: Swift.Equatable {
    /// The location of the training data to import and an AWS Identity and Access Management (IAM) role that Amazon Forecast
    ///       can assume to access the data. The training data must be stored in an Amazon S3 bucket.
    ///          If encryption is used, DataSource must include an AWS Key Management Service (KMS) key and the
    ///       IAM role must allow Amazon Forecast permission to access the key. The KMS key and IAM role must
    ///       match those specified in the EncryptionConfig parameter of the CreateDataset operation.
    /// This member is required.
    public var dataSource: ForecastClientTypes.DataSource?
    /// The Amazon Resource Name (ARN) of the Amazon Forecast dataset that you want to import data
    ///       to.
    /// This member is required.
    public var datasetArn: Swift.String?
    /// The name for the dataset import job. We recommend including the current timestamp in the
    ///       name, for example, 20190721DatasetImport. This can help you avoid getting a
    ///         ResourceAlreadyExistsException exception.
    /// This member is required.
    public var datasetImportJobName: Swift.String?
    /// The format of the geolocation attribute. The geolocation attribute can be formatted in
    ///             one of two ways:
    ///
    ///
    ///
    ///                   LAT_LONG - the latitude and longitude in decimal format (Example: 47.61_-122.33).
    ///
    ///
    ///
    ///                   CC_POSTALCODE (US Only) - the country code (US), followed by the 5-digit ZIP code (Example: US_98121).
    ///
    ///
    public var geolocationFormat: Swift.String?
    /// The optional metadata that you apply to the dataset import job to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define.
    ///          The following basic restrictions apply to tags:
    ///
    ///
    ///                Maximum number of tags per resource - 50.
    ///
    ///
    ///                For each resource, each tag key must be unique, and each tag key can have only one value.
    ///
    ///
    ///                Maximum key length - 128 Unicode characters in UTF-8.
    ///
    ///
    ///                Maximum value length - 256 Unicode characters in UTF-8.
    ///
    ///
    ///                If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.
    ///
    ///
    ///                Tag keys and values are case sensitive.
    ///
    ///
    ///                Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
    ///
    ///
    public var tags: [ForecastClientTypes.Tag]?
    /// A single time zone for every item in your dataset. This option is ideal for datasets
    ///             with all timestamps within a single time zone, or if all timestamps are normalized to a
    ///             single time zone.
    ///         Refer to the <a href="http://joda-time.sourceforge.net/timezones.html">Joda-Time
    ///                 API for a complete list of valid time zone names.
    public var timeZone: Swift.String?
    /// The format of timestamps in the dataset. The format that you specify depends on the
    ///         DataFrequency specified when the dataset was created. The following formats are
    ///       supported
    ///
    ///
    ///                "yyyy-MM-dd"
    ///                For the following data frequencies: Y, M, W, and D
    ///
    ///
    ///                "yyyy-MM-dd HH:mm:ss"
    ///                For the following data frequencies: H, 30min, 15min, and 1min; and optionally, for: Y,
    ///           M, W, and D
    ///
    ///
    ///          If the format isn't specified, Amazon Forecast expects the format to be "yyyy-MM-dd
    ///       HH:mm:ss".
    public var timestampFormat: Swift.String?
    /// Automatically derive time zone information from the geolocation attribute. This option
    ///             is ideal for datasets that contain timestamps in multiple time zones and those
    ///             timestamps are expressed in local time.
    public var useGeolocationForTimeZone: Swift.Bool

    public init (
        dataSource: ForecastClientTypes.DataSource? = nil,
        datasetArn: Swift.String? = nil,
        datasetImportJobName: Swift.String? = nil,
        geolocationFormat: Swift.String? = nil,
        tags: [ForecastClientTypes.Tag]? = nil,
        timeZone: Swift.String? = nil,
        timestampFormat: Swift.String? = nil,
        useGeolocationForTimeZone: Swift.Bool = false
    )
    {
        self.dataSource = dataSource
        self.datasetArn = datasetArn
        self.datasetImportJobName = datasetImportJobName
        self.geolocationFormat = geolocationFormat
        self.tags = tags
        self.timeZone = timeZone
        self.timestampFormat = timestampFormat
        self.useGeolocationForTimeZone = useGeolocationForTimeZone
    }
}

struct CreateDatasetImportJobInputBody: Swift.Equatable {
    public let datasetImportJobName: Swift.String?
    public let datasetArn: Swift.String?
    public let dataSource: ForecastClientTypes.DataSource?
    public let timestampFormat: Swift.String?
    public let timeZone: Swift.String?
    public let useGeolocationForTimeZone: Swift.Bool
    public let geolocationFormat: Swift.String?
    public let tags: [ForecastClientTypes.Tag]?
}

extension CreateDatasetImportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource = "DataSource"
        case datasetArn = "DatasetArn"
        case datasetImportJobName = "DatasetImportJobName"
        case geolocationFormat = "GeolocationFormat"
        case tags = "Tags"
        case timeZone = "TimeZone"
        case timestampFormat = "TimestampFormat"
        case useGeolocationForTimeZone = "UseGeolocationForTimeZone"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetImportJobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetImportJobName)
        datasetImportJobName = datasetImportJobNameDecoded
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let timestampFormatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timestampFormat)
        timestampFormat = timestampFormatDecoded
        let timeZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeZone)
        timeZone = timeZoneDecoded
        let useGeolocationForTimeZoneDecoded = try containerValues.decode(Swift.Bool.self, forKey: .useGeolocationForTimeZone)
        useGeolocationForTimeZone = useGeolocationForTimeZoneDecoded
        let geolocationFormatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .geolocationFormat)
        geolocationFormat = geolocationFormatDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ForecastClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ForecastClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDatasetImportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDatasetImportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDatasetImportJobOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDatasetImportJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDatasetImportJobOutputResponse(datasetImportJobArn: \(Swift.String(describing: datasetImportJobArn)))"}
}

extension CreateDatasetImportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDatasetImportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datasetImportJobArn = output.datasetImportJobArn
        } else {
            self.datasetImportJobArn = nil
        }
    }
}

public struct CreateDatasetImportJobOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset import job.
    public var datasetImportJobArn: Swift.String?

    public init (
        datasetImportJobArn: Swift.String? = nil
    )
    {
        self.datasetImportJobArn = datasetImportJobArn
    }
}

struct CreateDatasetImportJobOutputResponseBody: Swift.Equatable {
    public let datasetImportJobArn: Swift.String?
}

extension CreateDatasetImportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetImportJobArn = "DatasetImportJobArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetImportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetImportJobArn)
        datasetImportJobArn = datasetImportJobArnDecoded
    }
}

public struct CreateDatasetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDatasetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDatasetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDatasetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDatasetOutputError>
}

extension CreateDatasetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDatasetInput(dataFrequency: \(Swift.String(describing: dataFrequency)), datasetName: \(Swift.String(describing: datasetName)), datasetType: \(Swift.String(describing: datasetType)), domain: \(Swift.String(describing: domain)), encryptionConfig: \(Swift.String(describing: encryptionConfig)), schema: \(Swift.String(describing: schema)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateDatasetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataFrequency = "DataFrequency"
        case datasetName = "DatasetName"
        case datasetType = "DatasetType"
        case domain = "Domain"
        case encryptionConfig = "EncryptionConfig"
        case schema = "Schema"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataFrequency = dataFrequency {
            try encodeContainer.encode(dataFrequency, forKey: .dataFrequency)
        }
        if let datasetName = datasetName {
            try encodeContainer.encode(datasetName, forKey: .datasetName)
        }
        if let datasetType = datasetType {
            try encodeContainer.encode(datasetType.rawValue, forKey: .datasetType)
        }
        if let domain = domain {
            try encodeContainer.encode(domain.rawValue, forKey: .domain)
        }
        if let encryptionConfig = encryptionConfig {
            try encodeContainer.encode(encryptionConfig, forKey: .encryptionConfig)
        }
        if let schema = schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct CreateDatasetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDatasetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDatasetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDatasetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDatasetOutputError>
}

public struct CreateDatasetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDatasetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDatasetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDatasetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDatasetOutputError>
}

public struct CreateDatasetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDatasetInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateDatasetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateDatasetInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDatasetOutputError>
}

public struct CreateDatasetInput: Swift.Equatable {
    /// The frequency of data collection. This parameter is required for RELATED_TIME_SERIES
    ///       datasets.
    ///          Valid intervals are Y (Year), M (Month), W (Week), D (Day), H (Hour), 30min (30 minutes),
    ///       15min (15 minutes), 10min (10 minutes), 5min (5 minutes), and 1min (1 minute). For example,
    ///       "D" indicates every day and "15min" indicates every 15 minutes.
    public var dataFrequency: Swift.String?
    /// A name for the dataset.
    /// This member is required.
    public var datasetName: Swift.String?
    /// The dataset type. Valid values depend on the chosen Domain.
    /// This member is required.
    public var datasetType: ForecastClientTypes.DatasetType?
    /// The domain associated with the dataset. When you add a dataset to a dataset group, this
    ///       value and the value specified for the Domain parameter of the CreateDatasetGroup operation must match.
    ///          The Domain and DatasetType that you choose determine the fields
    ///       that must be present in the training data that you import to the dataset. For example, if you
    ///       choose the RETAIL domain and TARGET_TIME_SERIES as the
    ///         DatasetType, Amazon Forecast requires item_id, timestamp,
    ///       and demand fields to be present in your data. For more information, see howitworks-datasets-groups.
    /// This member is required.
    public var domain: ForecastClientTypes.Domain?
    /// An AWS Key Management Service (KMS) key and the AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access
    ///       the key.
    public var encryptionConfig: ForecastClientTypes.EncryptionConfig?
    /// The schema for the dataset. The schema attributes and their order must match the fields in
    ///       your data. The dataset Domain and DatasetType that you choose
    ///       determine the minimum required fields in your training data. For information about the
    ///       required fields for a specific dataset domain and type, see howitworks-domains-ds-types.
    /// This member is required.
    public var schema: ForecastClientTypes.Schema?
    /// The optional metadata that you apply to the dataset to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define.
    ///          The following basic restrictions apply to tags:
    ///
    ///
    ///                Maximum number of tags per resource - 50.
    ///
    ///
    ///                For each resource, each tag key must be unique, and each tag key can have only one value.
    ///
    ///
    ///                Maximum key length - 128 Unicode characters in UTF-8.
    ///
    ///
    ///                Maximum value length - 256 Unicode characters in UTF-8.
    ///
    ///
    ///                If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.
    ///
    ///
    ///                Tag keys and values are case sensitive.
    ///
    ///
    ///                Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
    ///
    ///
    public var tags: [ForecastClientTypes.Tag]?

    public init (
        dataFrequency: Swift.String? = nil,
        datasetName: Swift.String? = nil,
        datasetType: ForecastClientTypes.DatasetType? = nil,
        domain: ForecastClientTypes.Domain? = nil,
        encryptionConfig: ForecastClientTypes.EncryptionConfig? = nil,
        schema: ForecastClientTypes.Schema? = nil,
        tags: [ForecastClientTypes.Tag]? = nil
    )
    {
        self.dataFrequency = dataFrequency
        self.datasetName = datasetName
        self.datasetType = datasetType
        self.domain = domain
        self.encryptionConfig = encryptionConfig
        self.schema = schema
        self.tags = tags
    }
}

struct CreateDatasetInputBody: Swift.Equatable {
    public let datasetName: Swift.String?
    public let domain: ForecastClientTypes.Domain?
    public let datasetType: ForecastClientTypes.DatasetType?
    public let dataFrequency: Swift.String?
    public let schema: ForecastClientTypes.Schema?
    public let encryptionConfig: ForecastClientTypes.EncryptionConfig?
    public let tags: [ForecastClientTypes.Tag]?
}

extension CreateDatasetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataFrequency = "DataFrequency"
        case datasetName = "DatasetName"
        case datasetType = "DatasetType"
        case domain = "Domain"
        case encryptionConfig = "EncryptionConfig"
        case schema = "Schema"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetName)
        datasetName = datasetNameDecoded
        let domainDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
        let datasetTypeDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DatasetType.self, forKey: .datasetType)
        datasetType = datasetTypeDecoded
        let dataFrequencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataFrequency)
        dataFrequency = dataFrequencyDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.Schema.self, forKey: .schema)
        schema = schemaDecoded
        let encryptionConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.EncryptionConfig.self, forKey: .encryptionConfig)
        encryptionConfig = encryptionConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ForecastClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ForecastClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDatasetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDatasetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDatasetOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDatasetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDatasetOutputResponse(datasetArn: \(Swift.String(describing: datasetArn)))"}
}

extension CreateDatasetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDatasetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datasetArn = output.datasetArn
        } else {
            self.datasetArn = nil
        }
    }
}

public struct CreateDatasetOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset.
    public var datasetArn: Swift.String?

    public init (
        datasetArn: Swift.String? = nil
    )
    {
        self.datasetArn = datasetArn
    }
}

struct CreateDatasetOutputResponseBody: Swift.Equatable {
    public let datasetArn: Swift.String?
}

extension CreateDatasetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArn = "DatasetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
    }
}

public struct CreateForecastExportJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateForecastExportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateForecastExportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateForecastExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateForecastExportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateForecastExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateForecastExportJobOutputError>
}

extension CreateForecastExportJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateForecastExportJobInput(destination: \(Swift.String(describing: destination)), forecastArn: \(Swift.String(describing: forecastArn)), forecastExportJobName: \(Swift.String(describing: forecastExportJobName)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateForecastExportJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
        case forecastArn = "ForecastArn"
        case forecastExportJobName = "ForecastExportJobName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let forecastArn = forecastArn {
            try encodeContainer.encode(forecastArn, forKey: .forecastArn)
        }
        if let forecastExportJobName = forecastExportJobName {
            try encodeContainer.encode(forecastExportJobName, forKey: .forecastExportJobName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct CreateForecastExportJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateForecastExportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateForecastExportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateForecastExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateForecastExportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateForecastExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateForecastExportJobOutputError>
}

public struct CreateForecastExportJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateForecastExportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateForecastExportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateForecastExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateForecastExportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateForecastExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateForecastExportJobOutputError>
}

public struct CreateForecastExportJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateForecastExportJobInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateForecastExportJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateForecastExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateForecastExportJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateForecastExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateForecastExportJobOutputError>
}

public struct CreateForecastExportJobInput: Swift.Equatable {
    /// The location where you want to save the forecast and an AWS Identity and Access Management (IAM) role that
    ///       Amazon Forecast can assume to access the location. The forecast must be exported to an Amazon S3
    ///       bucket.
    ///          If encryption is used, Destination must include an AWS Key Management Service (KMS) key. The
    ///       IAM role must allow Amazon Forecast permission to access the key.
    /// This member is required.
    public var destination: ForecastClientTypes.DataDestination?
    /// The Amazon Resource Name (ARN) of the forecast that you want to export.
    /// This member is required.
    public var forecastArn: Swift.String?
    /// The name for the forecast export job.
    /// This member is required.
    public var forecastExportJobName: Swift.String?
    /// The optional metadata that you apply to the forecast export job to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define.
    ///          The following basic restrictions apply to tags:
    ///
    ///
    ///                Maximum number of tags per resource - 50.
    ///
    ///
    ///                For each resource, each tag key must be unique, and each tag key can have only one value.
    ///
    ///
    ///                Maximum key length - 128 Unicode characters in UTF-8.
    ///
    ///
    ///                Maximum value length - 256 Unicode characters in UTF-8.
    ///
    ///
    ///                If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.
    ///
    ///
    ///                Tag keys and values are case sensitive.
    ///
    ///
    ///                Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
    ///
    ///
    public var tags: [ForecastClientTypes.Tag]?

    public init (
        destination: ForecastClientTypes.DataDestination? = nil,
        forecastArn: Swift.String? = nil,
        forecastExportJobName: Swift.String? = nil,
        tags: [ForecastClientTypes.Tag]? = nil
    )
    {
        self.destination = destination
        self.forecastArn = forecastArn
        self.forecastExportJobName = forecastExportJobName
        self.tags = tags
    }
}

struct CreateForecastExportJobInputBody: Swift.Equatable {
    public let forecastExportJobName: Swift.String?
    public let forecastArn: Swift.String?
    public let destination: ForecastClientTypes.DataDestination?
    public let tags: [ForecastClientTypes.Tag]?
}

extension CreateForecastExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
        case forecastArn = "ForecastArn"
        case forecastExportJobName = "ForecastExportJobName"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastExportJobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastExportJobName)
        forecastExportJobName = forecastExportJobNameDecoded
        let forecastArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastArn)
        forecastArn = forecastArnDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataDestination.self, forKey: .destination)
        destination = destinationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ForecastClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ForecastClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateForecastExportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateForecastExportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateForecastExportJobOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateForecastExportJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateForecastExportJobOutputResponse(forecastExportJobArn: \(Swift.String(describing: forecastExportJobArn)))"}
}

extension CreateForecastExportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateForecastExportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.forecastExportJobArn = output.forecastExportJobArn
        } else {
            self.forecastExportJobArn = nil
        }
    }
}

public struct CreateForecastExportJobOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the export job.
    public var forecastExportJobArn: Swift.String?

    public init (
        forecastExportJobArn: Swift.String? = nil
    )
    {
        self.forecastExportJobArn = forecastExportJobArn
    }
}

struct CreateForecastExportJobOutputResponseBody: Swift.Equatable {
    public let forecastExportJobArn: Swift.String?
}

extension CreateForecastExportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastExportJobArn = "ForecastExportJobArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastExportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastExportJobArn)
        forecastExportJobArn = forecastExportJobArnDecoded
    }
}

public struct CreateForecastInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateForecastInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateForecastInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateForecastOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateForecastInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateForecastOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateForecastOutputError>
}

extension CreateForecastInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateForecastInput(forecastName: \(Swift.String(describing: forecastName)), forecastTypes: \(Swift.String(describing: forecastTypes)), predictorArn: \(Swift.String(describing: predictorArn)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateForecastInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastName = "ForecastName"
        case forecastTypes = "ForecastTypes"
        case predictorArn = "PredictorArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forecastName = forecastName {
            try encodeContainer.encode(forecastName, forKey: .forecastName)
        }
        if let forecastTypes = forecastTypes {
            var forecastTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .forecastTypes)
            for forecasttypes0 in forecastTypes {
                try forecastTypesContainer.encode(forecasttypes0)
            }
        }
        if let predictorArn = predictorArn {
            try encodeContainer.encode(predictorArn, forKey: .predictorArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct CreateForecastInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateForecastInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateForecastInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateForecastOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateForecastInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateForecastOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateForecastOutputError>
}

public struct CreateForecastInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateForecastInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateForecastInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateForecastOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateForecastInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateForecastOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateForecastOutputError>
}

public struct CreateForecastInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateForecastInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateForecastInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateForecastOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateForecastInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateForecastOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateForecastOutputError>
}

public struct CreateForecastInput: Swift.Equatable {
    /// A name for the forecast.
    /// This member is required.
    public var forecastName: Swift.String?
    /// The quantiles at which probabilistic forecasts are generated. You
    ///         can currently specify up to 5 quantiles per forecast. Accepted values include
    ///         0.01 to 0.99 (increments of .01 only) and mean. The mean forecast
    ///       is different from the median (0.50) when the distribution is not symmetric (for example, Beta
    ///       and Negative Binomial). The default value is ["0.1", "0.5", "0.9"].
    public var forecastTypes: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the predictor to use to generate the forecast.
    /// This member is required.
    public var predictorArn: Swift.String?
    /// The optional metadata that you apply to the forecast to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define.
    ///          The following basic restrictions apply to tags:
    ///
    ///
    ///                Maximum number of tags per resource - 50.
    ///
    ///
    ///                For each resource, each tag key must be unique, and each tag key can have only one value.
    ///
    ///
    ///                Maximum key length - 128 Unicode characters in UTF-8.
    ///
    ///
    ///                Maximum value length - 256 Unicode characters in UTF-8.
    ///
    ///
    ///                If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.
    ///
    ///
    ///                Tag keys and values are case sensitive.
    ///
    ///
    ///                Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
    ///
    ///
    public var tags: [ForecastClientTypes.Tag]?

    public init (
        forecastName: Swift.String? = nil,
        forecastTypes: [Swift.String]? = nil,
        predictorArn: Swift.String? = nil,
        tags: [ForecastClientTypes.Tag]? = nil
    )
    {
        self.forecastName = forecastName
        self.forecastTypes = forecastTypes
        self.predictorArn = predictorArn
        self.tags = tags
    }
}

struct CreateForecastInputBody: Swift.Equatable {
    public let forecastName: Swift.String?
    public let predictorArn: Swift.String?
    public let forecastTypes: [Swift.String]?
    public let tags: [ForecastClientTypes.Tag]?
}

extension CreateForecastInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastName = "ForecastName"
        case forecastTypes = "ForecastTypes"
        case predictorArn = "PredictorArn"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastName)
        forecastName = forecastNameDecoded
        let predictorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
        let forecastTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .forecastTypes)
        var forecastTypesDecoded0:[Swift.String]? = nil
        if let forecastTypesContainer = forecastTypesContainer {
            forecastTypesDecoded0 = [Swift.String]()
            for string0 in forecastTypesContainer {
                if let string0 = string0 {
                    forecastTypesDecoded0?.append(string0)
                }
            }
        }
        forecastTypes = forecastTypesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ForecastClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ForecastClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateForecastOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateForecastOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateForecastOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateForecastOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateForecastOutputResponse(forecastArn: \(Swift.String(describing: forecastArn)))"}
}

extension CreateForecastOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateForecastOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.forecastArn = output.forecastArn
        } else {
            self.forecastArn = nil
        }
    }
}

public struct CreateForecastOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the forecast.
    public var forecastArn: Swift.String?

    public init (
        forecastArn: Swift.String? = nil
    )
    {
        self.forecastArn = forecastArn
    }
}

struct CreateForecastOutputResponseBody: Swift.Equatable {
    public let forecastArn: Swift.String?
}

extension CreateForecastOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastArn = "ForecastArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastArn)
        forecastArn = forecastArnDecoded
    }
}

public struct CreatePredictorBacktestExportJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePredictorBacktestExportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePredictorBacktestExportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePredictorBacktestExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePredictorBacktestExportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePredictorBacktestExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePredictorBacktestExportJobOutputError>
}

extension CreatePredictorBacktestExportJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePredictorBacktestExportJobInput(destination: \(Swift.String(describing: destination)), predictorArn: \(Swift.String(describing: predictorArn)), predictorBacktestExportJobName: \(Swift.String(describing: predictorBacktestExportJobName)), tags: \(Swift.String(describing: tags)))"}
}

extension CreatePredictorBacktestExportJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
        case predictorArn = "PredictorArn"
        case predictorBacktestExportJobName = "PredictorBacktestExportJobName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let predictorArn = predictorArn {
            try encodeContainer.encode(predictorArn, forKey: .predictorArn)
        }
        if let predictorBacktestExportJobName = predictorBacktestExportJobName {
            try encodeContainer.encode(predictorBacktestExportJobName, forKey: .predictorBacktestExportJobName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct CreatePredictorBacktestExportJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePredictorBacktestExportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePredictorBacktestExportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePredictorBacktestExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePredictorBacktestExportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePredictorBacktestExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePredictorBacktestExportJobOutputError>
}

public struct CreatePredictorBacktestExportJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePredictorBacktestExportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePredictorBacktestExportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePredictorBacktestExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePredictorBacktestExportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePredictorBacktestExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePredictorBacktestExportJobOutputError>
}

public struct CreatePredictorBacktestExportJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePredictorBacktestExportJobInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreatePredictorBacktestExportJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePredictorBacktestExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreatePredictorBacktestExportJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePredictorBacktestExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePredictorBacktestExportJobOutputError>
}

public struct CreatePredictorBacktestExportJobInput: Swift.Equatable {
    /// The destination for an export job. Provide an S3 path, an AWS Identity and Access Management (IAM) role that allows Amazon Forecast
    ///       to access the location, and an AWS Key Management Service (KMS) key (optional).
    /// This member is required.
    public var destination: ForecastClientTypes.DataDestination?
    /// The Amazon Resource Name (ARN) of the predictor that you want to export.
    /// This member is required.
    public var predictorArn: Swift.String?
    /// The name for the backtest export job.
    /// This member is required.
    public var predictorBacktestExportJobName: Swift.String?
    /// Optional metadata to help you categorize and organize your backtests. Each tag consists
    ///             of a key and an optional value, both of which you define. Tag keys and values are case
    ///             sensitive.
    ///         The following restrictions apply to tags:
    ///
    ///
    ///                 For each resource, each tag key must be unique and each tag key must have one
    ///                     value.
    ///
    ///
    ///                 Maximum number of tags per resource: 50.
    ///
    ///
    ///                 Maximum key length: 128 Unicode characters in UTF-8.
    ///
    ///
    ///                 Maximum value length: 256 Unicode characters in UTF-8.
    ///
    ///
    ///                 Accepted characters: all letters and numbers, spaces representable in UTF-8, and +
    ///                     - = . _ : / @. If your tagging schema is used across other services and resources,
    ///                     the character restrictions of those services also apply.
    ///
    ///
    ///                 Key prefixes cannot include any upper or lowercase combination of
    ///                     aws: or AWS:. Values can have this prefix. If a tag
    ///                     value has aws as its prefix but the key does not, Forecast considers it
    ///                     to be a user tag and will count against the limit of 50 tags. Tags with only the key
    ///                     prefix of aws do not count against your tags per resource limit. You
    ///                     cannot edit or delete tag keys with this prefix.
    ///
    ///
    public var tags: [ForecastClientTypes.Tag]?

    public init (
        destination: ForecastClientTypes.DataDestination? = nil,
        predictorArn: Swift.String? = nil,
        predictorBacktestExportJobName: Swift.String? = nil,
        tags: [ForecastClientTypes.Tag]? = nil
    )
    {
        self.destination = destination
        self.predictorArn = predictorArn
        self.predictorBacktestExportJobName = predictorBacktestExportJobName
        self.tags = tags
    }
}

struct CreatePredictorBacktestExportJobInputBody: Swift.Equatable {
    public let predictorBacktestExportJobName: Swift.String?
    public let predictorArn: Swift.String?
    public let destination: ForecastClientTypes.DataDestination?
    public let tags: [ForecastClientTypes.Tag]?
}

extension CreatePredictorBacktestExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
        case predictorArn = "PredictorArn"
        case predictorBacktestExportJobName = "PredictorBacktestExportJobName"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorBacktestExportJobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorBacktestExportJobName)
        predictorBacktestExportJobName = predictorBacktestExportJobNameDecoded
        let predictorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataDestination.self, forKey: .destination)
        destination = destinationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ForecastClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ForecastClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreatePredictorBacktestExportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePredictorBacktestExportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePredictorBacktestExportJobOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePredictorBacktestExportJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePredictorBacktestExportJobOutputResponse(predictorBacktestExportJobArn: \(Swift.String(describing: predictorBacktestExportJobArn)))"}
}

extension CreatePredictorBacktestExportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreatePredictorBacktestExportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.predictorBacktestExportJobArn = output.predictorBacktestExportJobArn
        } else {
            self.predictorBacktestExportJobArn = nil
        }
    }
}

public struct CreatePredictorBacktestExportJobOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the predictor backtest export job that you want to
    ///             export.
    public var predictorBacktestExportJobArn: Swift.String?

    public init (
        predictorBacktestExportJobArn: Swift.String? = nil
    )
    {
        self.predictorBacktestExportJobArn = predictorBacktestExportJobArn
    }
}

struct CreatePredictorBacktestExportJobOutputResponseBody: Swift.Equatable {
    public let predictorBacktestExportJobArn: Swift.String?
}

extension CreatePredictorBacktestExportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorBacktestExportJobArn = "PredictorBacktestExportJobArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorBacktestExportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorBacktestExportJobArn)
        predictorBacktestExportJobArn = predictorBacktestExportJobArnDecoded
    }
}

public struct CreatePredictorInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePredictorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePredictorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePredictorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePredictorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePredictorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePredictorOutputError>
}

extension CreatePredictorInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePredictorInput(algorithmArn: \(Swift.String(describing: algorithmArn)), autoMLOverrideStrategy: \(Swift.String(describing: autoMLOverrideStrategy)), encryptionConfig: \(Swift.String(describing: encryptionConfig)), evaluationParameters: \(Swift.String(describing: evaluationParameters)), featurizationConfig: \(Swift.String(describing: featurizationConfig)), forecastHorizon: \(Swift.String(describing: forecastHorizon)), forecastTypes: \(Swift.String(describing: forecastTypes)), hPOConfig: \(Swift.String(describing: hPOConfig)), inputDataConfig: \(Swift.String(describing: inputDataConfig)), optimizationMetric: \(Swift.String(describing: optimizationMetric)), performAutoML: \(Swift.String(describing: performAutoML)), performHPO: \(Swift.String(describing: performHPO)), predictorName: \(Swift.String(describing: predictorName)), tags: \(Swift.String(describing: tags)), trainingParameters: \(Swift.String(describing: trainingParameters)))"}
}

extension CreatePredictorInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithmArn = "AlgorithmArn"
        case autoMLOverrideStrategy = "AutoMLOverrideStrategy"
        case encryptionConfig = "EncryptionConfig"
        case evaluationParameters = "EvaluationParameters"
        case featurizationConfig = "FeaturizationConfig"
        case forecastHorizon = "ForecastHorizon"
        case forecastTypes = "ForecastTypes"
        case hPOConfig = "HPOConfig"
        case inputDataConfig = "InputDataConfig"
        case optimizationMetric = "OptimizationMetric"
        case performAutoML = "PerformAutoML"
        case performHPO = "PerformHPO"
        case predictorName = "PredictorName"
        case tags = "Tags"
        case trainingParameters = "TrainingParameters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let algorithmArn = algorithmArn {
            try encodeContainer.encode(algorithmArn, forKey: .algorithmArn)
        }
        if let autoMLOverrideStrategy = autoMLOverrideStrategy {
            try encodeContainer.encode(autoMLOverrideStrategy.rawValue, forKey: .autoMLOverrideStrategy)
        }
        if let encryptionConfig = encryptionConfig {
            try encodeContainer.encode(encryptionConfig, forKey: .encryptionConfig)
        }
        if let evaluationParameters = evaluationParameters {
            try encodeContainer.encode(evaluationParameters, forKey: .evaluationParameters)
        }
        if let featurizationConfig = featurizationConfig {
            try encodeContainer.encode(featurizationConfig, forKey: .featurizationConfig)
        }
        if let forecastHorizon = forecastHorizon {
            try encodeContainer.encode(forecastHorizon, forKey: .forecastHorizon)
        }
        if let forecastTypes = forecastTypes {
            var forecastTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .forecastTypes)
            for forecasttypes0 in forecastTypes {
                try forecastTypesContainer.encode(forecasttypes0)
            }
        }
        if let hPOConfig = hPOConfig {
            try encodeContainer.encode(hPOConfig, forKey: .hPOConfig)
        }
        if let inputDataConfig = inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let optimizationMetric = optimizationMetric {
            try encodeContainer.encode(optimizationMetric.rawValue, forKey: .optimizationMetric)
        }
        if let performAutoML = performAutoML {
            try encodeContainer.encode(performAutoML, forKey: .performAutoML)
        }
        if let performHPO = performHPO {
            try encodeContainer.encode(performHPO, forKey: .performHPO)
        }
        if let predictorName = predictorName {
            try encodeContainer.encode(predictorName, forKey: .predictorName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let trainingParameters = trainingParameters {
            var trainingParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .trainingParameters)
            for (dictKey0, trainingparameters0) in trainingParameters {
                try trainingParametersContainer.encode(trainingparameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreatePredictorInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePredictorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePredictorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePredictorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePredictorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePredictorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePredictorOutputError>
}

public struct CreatePredictorInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePredictorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePredictorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePredictorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePredictorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePredictorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePredictorOutputError>
}

public struct CreatePredictorInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePredictorInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreatePredictorInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePredictorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreatePredictorInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePredictorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePredictorOutputError>
}

public struct CreatePredictorInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the algorithm to use for model training. Required if
    ///         PerformAutoML is not set to true.
    ///          <p class="title">
    ///             Supported algorithms:
    ///
    ///
    ///
    ///
    ///                   arn:aws:forecast:::algorithm/ARIMA
    ///
    ///
    ///
    ///
    ///                   arn:aws:forecast:::algorithm/CNN-QR
    ///
    ///
    ///
    ///
    ///                   arn:aws:forecast:::algorithm/Deep_AR_Plus
    ///
    ///
    ///
    ///
    ///                   arn:aws:forecast:::algorithm/ETS
    ///
    ///
    ///
    ///
    ///                   arn:aws:forecast:::algorithm/NPTS
    ///
    ///
    ///
    ///
    ///                   arn:aws:forecast:::algorithm/Prophet
    ///
    ///
    ///
    public var algorithmArn: Swift.String?
    ///
    ///              The LatencyOptimized AutoML override strategy is only available in private beta.
    ///                 Contact AWS Support or your account manager to learn more about access privileges.
    ///
    ///
    ///         Used to overide the default AutoML strategy, which is to optimize predictor accuracy.
    ///             To apply an AutoML strategy that minimizes training time, use
    ///                 LatencyOptimized.
    ///         This parameter is only valid for predictors trained using AutoML.
    public var autoMLOverrideStrategy: ForecastClientTypes.AutoMLOverrideStrategy?
    /// An AWS Key Management Service (KMS) key and the AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access
    ///       the key.
    public var encryptionConfig: ForecastClientTypes.EncryptionConfig?
    /// Used to override the default evaluation parameters of the specified algorithm. Amazon Forecast
    ///       evaluates a predictor by splitting a dataset into training data and testing data. The
    ///       evaluation parameters define how to perform the split and the number of iterations.
    public var evaluationParameters: ForecastClientTypes.EvaluationParameters?
    /// The featurization configuration.
    /// This member is required.
    public var featurizationConfig: ForecastClientTypes.FeaturizationConfig?
    /// Specifies the number of time-steps that the model is trained to predict. The forecast
    ///       horizon is also called the prediction length.
    ///          For example, if you configure a dataset for daily data collection (using the
    ///         DataFrequency parameter of the CreateDataset operation) and
    ///       set the forecast horizon to 10, the model returns predictions for 10 days.
    ///          The maximum forecast horizon is the lesser of 500 time-steps or 1/3 of the
    ///       TARGET_TIME_SERIES dataset length.
    /// This member is required.
    public var forecastHorizon: Swift.Int?
    /// Specifies the forecast types used to train a predictor. You can specify up to five forecast types.
    ///       Forecast types can be quantiles from 0.01 to 0.99, by increments of 0.01 or higher. You can also specify
    ///       the mean forecast with mean.
    ///
    ///          The default value is ["0.10", "0.50", "0.9"].
    public var forecastTypes: [Swift.String]?
    /// Provides hyperparameter override values for the algorithm. If you don't provide this
    ///       parameter, Amazon Forecast uses default values. The individual algorithms specify which
    ///       hyperparameters support hyperparameter optimization (HPO). For more information, see aws-forecast-choosing-recipes.
    ///          If you included the HPOConfig object, you must set PerformHPO to
    ///       true.
    public var hPOConfig: ForecastClientTypes.HyperParameterTuningJobConfig?
    /// Describes the dataset group that contains the data to use to train the predictor.
    /// This member is required.
    public var inputDataConfig: ForecastClientTypes.InputDataConfig?
    /// The accuracy metric used to optimize the predictor.
    public var optimizationMetric: ForecastClientTypes.OptimizationMetric?
    /// Whether to perform AutoML. When Amazon Forecast performs AutoML, it evaluates the algorithms it
    ///       provides and chooses the best algorithm and configuration for your training dataset.
    ///          The default value is false. In this case, you are required to specify an
    ///       algorithm.
    ///          Set PerformAutoML to true to have Amazon Forecast perform AutoML. This
    ///       is a good option if you aren't sure which algorithm is suitable for your training data. In
    ///       this case, PerformHPO must be false.
    public var performAutoML: Swift.Bool?
    /// Whether to perform hyperparameter optimization (HPO). HPO finds optimal hyperparameter
    ///       values for your training data. The process of performing HPO is known as running a
    ///       hyperparameter tuning job.
    ///          The default value is false. In this case, Amazon Forecast uses default
    ///       hyperparameter values from the chosen algorithm.
    ///          To override the default values, set PerformHPO to true and,
    ///       optionally, supply the HyperParameterTuningJobConfig object. The tuning job
    ///       specifies a metric to optimize, which hyperparameters participate in tuning, and the valid
    ///       range for each tunable hyperparameter. In this case, you are required to specify an algorithm
    ///       and PerformAutoML must be false.
    ///          The following algorithms support HPO:
    ///
    ///
    ///                DeepAR+
    ///
    ///
    ///                CNN-QR
    ///
    ///
    public var performHPO: Swift.Bool?
    /// A name for the predictor.
    /// This member is required.
    public var predictorName: Swift.String?
    /// The optional metadata that you apply to the predictor to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define.
    ///          The following basic restrictions apply to tags:
    ///
    ///
    ///                Maximum number of tags per resource - 50.
    ///
    ///
    ///                For each resource, each tag key must be unique, and each tag key can have only one value.
    ///
    ///
    ///                Maximum key length - 128 Unicode characters in UTF-8.
    ///
    ///
    ///                Maximum value length - 256 Unicode characters in UTF-8.
    ///
    ///
    ///                If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.
    ///
    ///
    ///                Tag keys and values are case sensitive.
    ///
    ///
    ///                Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
    ///
    ///
    public var tags: [ForecastClientTypes.Tag]?
    /// The hyperparameters to override for model training. The hyperparameters that you can
    ///       override are listed in the individual algorithms. For the list of supported algorithms, see
    ///         aws-forecast-choosing-recipes.
    public var trainingParameters: [Swift.String:Swift.String]?

    public init (
        algorithmArn: Swift.String? = nil,
        autoMLOverrideStrategy: ForecastClientTypes.AutoMLOverrideStrategy? = nil,
        encryptionConfig: ForecastClientTypes.EncryptionConfig? = nil,
        evaluationParameters: ForecastClientTypes.EvaluationParameters? = nil,
        featurizationConfig: ForecastClientTypes.FeaturizationConfig? = nil,
        forecastHorizon: Swift.Int? = nil,
        forecastTypes: [Swift.String]? = nil,
        hPOConfig: ForecastClientTypes.HyperParameterTuningJobConfig? = nil,
        inputDataConfig: ForecastClientTypes.InputDataConfig? = nil,
        optimizationMetric: ForecastClientTypes.OptimizationMetric? = nil,
        performAutoML: Swift.Bool? = nil,
        performHPO: Swift.Bool? = nil,
        predictorName: Swift.String? = nil,
        tags: [ForecastClientTypes.Tag]? = nil,
        trainingParameters: [Swift.String:Swift.String]? = nil
    )
    {
        self.algorithmArn = algorithmArn
        self.autoMLOverrideStrategy = autoMLOverrideStrategy
        self.encryptionConfig = encryptionConfig
        self.evaluationParameters = evaluationParameters
        self.featurizationConfig = featurizationConfig
        self.forecastHorizon = forecastHorizon
        self.forecastTypes = forecastTypes
        self.hPOConfig = hPOConfig
        self.inputDataConfig = inputDataConfig
        self.optimizationMetric = optimizationMetric
        self.performAutoML = performAutoML
        self.performHPO = performHPO
        self.predictorName = predictorName
        self.tags = tags
        self.trainingParameters = trainingParameters
    }
}

struct CreatePredictorInputBody: Swift.Equatable {
    public let predictorName: Swift.String?
    public let algorithmArn: Swift.String?
    public let forecastHorizon: Swift.Int?
    public let forecastTypes: [Swift.String]?
    public let performAutoML: Swift.Bool?
    public let autoMLOverrideStrategy: ForecastClientTypes.AutoMLOverrideStrategy?
    public let performHPO: Swift.Bool?
    public let trainingParameters: [Swift.String:Swift.String]?
    public let evaluationParameters: ForecastClientTypes.EvaluationParameters?
    public let hPOConfig: ForecastClientTypes.HyperParameterTuningJobConfig?
    public let inputDataConfig: ForecastClientTypes.InputDataConfig?
    public let featurizationConfig: ForecastClientTypes.FeaturizationConfig?
    public let encryptionConfig: ForecastClientTypes.EncryptionConfig?
    public let tags: [ForecastClientTypes.Tag]?
    public let optimizationMetric: ForecastClientTypes.OptimizationMetric?
}

extension CreatePredictorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithmArn = "AlgorithmArn"
        case autoMLOverrideStrategy = "AutoMLOverrideStrategy"
        case encryptionConfig = "EncryptionConfig"
        case evaluationParameters = "EvaluationParameters"
        case featurizationConfig = "FeaturizationConfig"
        case forecastHorizon = "ForecastHorizon"
        case forecastTypes = "ForecastTypes"
        case hPOConfig = "HPOConfig"
        case inputDataConfig = "InputDataConfig"
        case optimizationMetric = "OptimizationMetric"
        case performAutoML = "PerformAutoML"
        case performHPO = "PerformHPO"
        case predictorName = "PredictorName"
        case tags = "Tags"
        case trainingParameters = "TrainingParameters"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorName)
        predictorName = predictorNameDecoded
        let algorithmArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .algorithmArn)
        algorithmArn = algorithmArnDecoded
        let forecastHorizonDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .forecastHorizon)
        forecastHorizon = forecastHorizonDecoded
        let forecastTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .forecastTypes)
        var forecastTypesDecoded0:[Swift.String]? = nil
        if let forecastTypesContainer = forecastTypesContainer {
            forecastTypesDecoded0 = [Swift.String]()
            for string0 in forecastTypesContainer {
                if let string0 = string0 {
                    forecastTypesDecoded0?.append(string0)
                }
            }
        }
        forecastTypes = forecastTypesDecoded0
        let performAutoMLDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .performAutoML)
        performAutoML = performAutoMLDecoded
        let autoMLOverrideStrategyDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.AutoMLOverrideStrategy.self, forKey: .autoMLOverrideStrategy)
        autoMLOverrideStrategy = autoMLOverrideStrategyDecoded
        let performHPODecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .performHPO)
        performHPO = performHPODecoded
        let trainingParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .trainingParameters)
        var trainingParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let trainingParametersContainer = trainingParametersContainer {
            trainingParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametervalue0) in trainingParametersContainer {
                if let parametervalue0 = parametervalue0 {
                    trainingParametersDecoded0?[key0] = parametervalue0
                }
            }
        }
        trainingParameters = trainingParametersDecoded0
        let evaluationParametersDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.EvaluationParameters.self, forKey: .evaluationParameters)
        evaluationParameters = evaluationParametersDecoded
        let hPOConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.HyperParameterTuningJobConfig.self, forKey: .hPOConfig)
        hPOConfig = hPOConfigDecoded
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let featurizationConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.FeaturizationConfig.self, forKey: .featurizationConfig)
        featurizationConfig = featurizationConfigDecoded
        let encryptionConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.EncryptionConfig.self, forKey: .encryptionConfig)
        encryptionConfig = encryptionConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ForecastClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ForecastClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let optimizationMetricDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.OptimizationMetric.self, forKey: .optimizationMetric)
        optimizationMetric = optimizationMetricDecoded
    }
}

extension CreatePredictorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePredictorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePredictorOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePredictorOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePredictorOutputResponse(predictorArn: \(Swift.String(describing: predictorArn)))"}
}

extension CreatePredictorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreatePredictorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.predictorArn = output.predictorArn
        } else {
            self.predictorArn = nil
        }
    }
}

public struct CreatePredictorOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the predictor.
    public var predictorArn: Swift.String?

    public init (
        predictorArn: Swift.String? = nil
    )
    {
        self.predictorArn = predictorArn
    }
}

struct CreatePredictorOutputResponseBody: Swift.Equatable {
    public let predictorArn: Swift.String?
}

extension CreatePredictorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorArn = "PredictorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
    }
}

extension ForecastClientTypes.DataDestination: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Config = "S3Config"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Config = s3Config {
            try encodeContainer.encode(s3Config, forKey: .s3Config)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3ConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.S3Config.self, forKey: .s3Config)
        s3Config = s3ConfigDecoded
    }
}

extension ForecastClientTypes.DataDestination: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataDestination(s3Config: \(Swift.String(describing: s3Config)))"}
}

extension ForecastClientTypes {
    /// The destination for an export job. Provide an S3 path, an AWS Identity and Access Management (IAM) role that allows Amazon Forecast
    ///       to access the location, and an AWS Key Management Service (KMS) key (optional).
    public struct DataDestination: Swift.Equatable {
        /// The path to an Amazon Simple Storage Service (Amazon S3) bucket along with the credentials to access the
        ///       bucket.
        /// This member is required.
        public var s3Config: ForecastClientTypes.S3Config?

        public init (
            s3Config: ForecastClientTypes.S3Config? = nil
        )
        {
            self.s3Config = s3Config
        }
    }

}

extension ForecastClientTypes.DataSource: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Config = "S3Config"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Config = s3Config {
            try encodeContainer.encode(s3Config, forKey: .s3Config)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3ConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.S3Config.self, forKey: .s3Config)
        s3Config = s3ConfigDecoded
    }
}

extension ForecastClientTypes.DataSource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataSource(s3Config: \(Swift.String(describing: s3Config)))"}
}

extension ForecastClientTypes {
    /// The source of your training data, an AWS Identity and Access Management (IAM) role that allows Amazon Forecast to
    ///       access the data and, optionally, an AWS Key Management Service (KMS) key. This object is submitted in the
    ///       CreateDatasetImportJob request.
    public struct DataSource: Swift.Equatable {
        /// The path to the training data stored in an Amazon Simple Storage Service (Amazon S3) bucket along with the
        ///       credentials to access the data.
        /// This member is required.
        public var s3Config: ForecastClientTypes.S3Config?

        public init (
            s3Config: ForecastClientTypes.S3Config? = nil
        )
        {
            self.s3Config = s3Config
        }
    }

}

extension ForecastClientTypes.DatasetGroupSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case datasetGroupArn = "DatasetGroupArn"
        case datasetGroupName = "DatasetGroupName"
        case lastModificationTime = "LastModificationTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let datasetGroupArn = datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let datasetGroupName = datasetGroupName {
            try encodeContainer.encode(datasetGroupName, forKey: .datasetGroupName)
        }
        if let lastModificationTime = lastModificationTime {
            try encodeContainer.encode(lastModificationTime.timeIntervalSince1970, forKey: .lastModificationTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let datasetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupName)
        datasetGroupName = datasetGroupNameDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension ForecastClientTypes.DatasetGroupSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DatasetGroupSummary(creationTime: \(Swift.String(describing: creationTime)), datasetGroupArn: \(Swift.String(describing: datasetGroupArn)), datasetGroupName: \(Swift.String(describing: datasetGroupName)), lastModificationTime: \(Swift.String(describing: lastModificationTime)))"}
}

extension ForecastClientTypes {
    /// Provides a summary of the dataset group properties used in the ListDatasetGroups operation. To get the complete set of properties, call the
    ///         DescribeDatasetGroup operation, and provide the
    ///         DatasetGroupArn.
    public struct DatasetGroupSummary: Swift.Equatable {
        /// When the dataset group was created.
        public var creationTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the dataset group.
        public var datasetGroupArn: Swift.String?
        /// The name of the dataset group.
        public var datasetGroupName: Swift.String?
        /// When the dataset group was created or last updated from a call to the UpdateDatasetGroup operation. While the dataset group is being updated,
        ///         LastModificationTime is the current time of the ListDatasetGroups
        ///       call.
        public var lastModificationTime: ClientRuntime.Date?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            datasetGroupArn: Swift.String? = nil,
            datasetGroupName: Swift.String? = nil,
            lastModificationTime: ClientRuntime.Date? = nil
        )
        {
            self.creationTime = creationTime
            self.datasetGroupArn = datasetGroupArn
            self.datasetGroupName = datasetGroupName
            self.lastModificationTime = lastModificationTime
        }
    }

}

extension ForecastClientTypes.DatasetImportJobSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case dataSource = "DataSource"
        case datasetImportJobArn = "DatasetImportJobArn"
        case datasetImportJobName = "DatasetImportJobName"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let dataSource = dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let datasetImportJobArn = datasetImportJobArn {
            try encodeContainer.encode(datasetImportJobArn, forKey: .datasetImportJobArn)
        }
        if let datasetImportJobName = datasetImportJobName {
            try encodeContainer.encode(datasetImportJobName, forKey: .datasetImportJobName)
        }
        if let lastModificationTime = lastModificationTime {
            try encodeContainer.encode(lastModificationTime.timeIntervalSince1970, forKey: .lastModificationTime)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetImportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetImportJobArn)
        datasetImportJobArn = datasetImportJobArnDecoded
        let datasetImportJobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetImportJobName)
        datasetImportJobName = datasetImportJobNameDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension ForecastClientTypes.DatasetImportJobSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DatasetImportJobSummary(creationTime: \(Swift.String(describing: creationTime)), dataSource: \(Swift.String(describing: dataSource)), datasetImportJobArn: \(Swift.String(describing: datasetImportJobArn)), datasetImportJobName: \(Swift.String(describing: datasetImportJobName)), lastModificationTime: \(Swift.String(describing: lastModificationTime)), message: \(Swift.String(describing: message)), status: \(Swift.String(describing: status)))"}
}

extension ForecastClientTypes {
    /// Provides a summary of the dataset import job properties used in the ListDatasetImportJobs operation. To get the complete set of properties, call the
    ///         DescribeDatasetImportJob operation, and provide the
    ///         DatasetImportJobArn.
    public struct DatasetImportJobSummary: Swift.Equatable {
        /// When the dataset import job was created.
        public var creationTime: ClientRuntime.Date?
        /// The location of the training data to import and an AWS Identity and Access Management (IAM) role that Amazon Forecast
        ///       can assume to access the data. The training data must be stored in an Amazon S3 bucket.
        ///          If encryption is used, DataSource includes an AWS Key Management Service (KMS) key.
        public var dataSource: ForecastClientTypes.DataSource?
        /// The Amazon Resource Name (ARN) of the dataset import job.
        public var datasetImportJobArn: Swift.String?
        /// The name of the dataset import job.
        public var datasetImportJobName: Swift.String?
        /// The last time the resource was modified. The timestamp depends on the status of the
        ///       job:
        ///
        ///
        ///
        ///                   CREATE_PENDING - The CreationTime.
        ///
        ///
        ///
        ///                   CREATE_IN_PROGRESS - The current timestamp.
        ///
        ///
        ///
        ///                   CREATE_STOPPING - The current timestamp.
        ///
        ///
        ///
        ///                   CREATE_STOPPED - When the job stopped.
        ///
        ///
        ///
        ///                   ACTIVE or CREATE_FAILED - When the job finished or
        ///           failed.
        ///
        ///
        public var lastModificationTime: ClientRuntime.Date?
        /// If an error occurred, an informational message about the error.
        public var message: Swift.String?
        /// The status of the dataset import job. States include:
        ///
        ///
        ///
        ///                   ACTIVE
        ///
        ///
        ///
        ///
        ///                   CREATE_PENDING, CREATE_IN_PROGRESS,
        ///             CREATE_FAILED
        ///
        ///
        ///
        ///
        ///                   DELETE_PENDING, DELETE_IN_PROGRESS,
        ///             DELETE_FAILED
        ///
        ///
        ///
        ///
        ///                   CREATE_STOPPING, CREATE_STOPPED
        ///
        ///
        ///
        public var status: Swift.String?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            dataSource: ForecastClientTypes.DataSource? = nil,
            datasetImportJobArn: Swift.String? = nil,
            datasetImportJobName: Swift.String? = nil,
            lastModificationTime: ClientRuntime.Date? = nil,
            message: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.dataSource = dataSource
            self.datasetImportJobArn = datasetImportJobArn
            self.datasetImportJobName = datasetImportJobName
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.status = status
        }
    }

}

extension ForecastClientTypes.DatasetSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case datasetArn = "DatasetArn"
        case datasetName = "DatasetName"
        case datasetType = "DatasetType"
        case domain = "Domain"
        case lastModificationTime = "LastModificationTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let datasetArn = datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
        if let datasetName = datasetName {
            try encodeContainer.encode(datasetName, forKey: .datasetName)
        }
        if let datasetType = datasetType {
            try encodeContainer.encode(datasetType.rawValue, forKey: .datasetType)
        }
        if let domain = domain {
            try encodeContainer.encode(domain.rawValue, forKey: .domain)
        }
        if let lastModificationTime = lastModificationTime {
            try encodeContainer.encode(lastModificationTime.timeIntervalSince1970, forKey: .lastModificationTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let datasetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetName)
        datasetName = datasetNameDecoded
        let datasetTypeDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DatasetType.self, forKey: .datasetType)
        datasetType = datasetTypeDecoded
        let domainDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension ForecastClientTypes.DatasetSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DatasetSummary(creationTime: \(Swift.String(describing: creationTime)), datasetArn: \(Swift.String(describing: datasetArn)), datasetName: \(Swift.String(describing: datasetName)), datasetType: \(Swift.String(describing: datasetType)), domain: \(Swift.String(describing: domain)), lastModificationTime: \(Swift.String(describing: lastModificationTime)))"}
}

extension ForecastClientTypes {
    /// Provides a summary of the dataset properties used in the ListDatasets
    ///       operation. To get the complete set of properties, call the DescribeDataset
    ///       operation, and provide the DatasetArn.
    public struct DatasetSummary: Swift.Equatable {
        /// When the dataset was created.
        public var creationTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the dataset.
        public var datasetArn: Swift.String?
        /// The name of the dataset.
        public var datasetName: Swift.String?
        /// The dataset type.
        public var datasetType: ForecastClientTypes.DatasetType?
        /// The domain associated with the dataset.
        public var domain: ForecastClientTypes.Domain?
        /// When you create a dataset, LastModificationTime is the same as
        ///         CreationTime. While data is being imported to the dataset,
        ///         LastModificationTime is the current time of the ListDatasets call.
        ///       After a CreateDatasetImportJob operation has finished,
        ///         LastModificationTime is when the import job completed or failed.
        public var lastModificationTime: ClientRuntime.Date?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            datasetArn: Swift.String? = nil,
            datasetName: Swift.String? = nil,
            datasetType: ForecastClientTypes.DatasetType? = nil,
            domain: ForecastClientTypes.Domain? = nil,
            lastModificationTime: ClientRuntime.Date? = nil
        )
        {
            self.creationTime = creationTime
            self.datasetArn = datasetArn
            self.datasetName = datasetName
            self.datasetType = datasetType
            self.domain = domain
            self.lastModificationTime = lastModificationTime
        }
    }

}

extension ForecastClientTypes {
    public enum DatasetType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case itemMetadata
        case relatedTimeSeries
        case targetTimeSeries
        case sdkUnknown(Swift.String)

        public static var allCases: [DatasetType] {
            return [
                .itemMetadata,
                .relatedTimeSeries,
                .targetTimeSeries,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .itemMetadata: return "ITEM_METADATA"
            case .relatedTimeSeries: return "RELATED_TIME_SERIES"
            case .targetTimeSeries: return "TARGET_TIME_SERIES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DatasetType(rawValue: rawValue) ?? DatasetType.sdkUnknown(rawValue)
        }
    }
}

public struct DeleteDatasetGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDatasetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDatasetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDatasetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDatasetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDatasetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDatasetGroupOutputError>
}

extension DeleteDatasetGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDatasetGroupInput(datasetGroupArn: \(Swift.String(describing: datasetGroupArn)))"}
}

extension DeleteDatasetGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn = "DatasetGroupArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
    }
}

public struct DeleteDatasetGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDatasetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDatasetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDatasetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDatasetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDatasetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDatasetGroupOutputError>
}

public struct DeleteDatasetGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDatasetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDatasetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDatasetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDatasetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDatasetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDatasetGroupOutputError>
}

public struct DeleteDatasetGroupInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDatasetGroupInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteDatasetGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDatasetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteDatasetGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDatasetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDatasetGroupOutputError>
}

public struct DeleteDatasetGroupInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset group to delete.
    /// This member is required.
    public var datasetGroupArn: Swift.String?

    public init (
        datasetGroupArn: Swift.String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
    }
}

struct DeleteDatasetGroupInputBody: Swift.Equatable {
    public let datasetGroupArn: Swift.String?
}

extension DeleteDatasetGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn = "DatasetGroupArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
    }
}

extension DeleteDatasetGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDatasetGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDatasetGroupOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDatasetGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDatasetGroupOutputResponse()"}
}

extension DeleteDatasetGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDatasetGroupOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteDatasetGroupOutputResponseBody: Swift.Equatable {
}

extension DeleteDatasetGroupOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteDatasetImportJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDatasetImportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDatasetImportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDatasetImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDatasetImportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDatasetImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDatasetImportJobOutputError>
}

extension DeleteDatasetImportJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDatasetImportJobInput(datasetImportJobArn: \(Swift.String(describing: datasetImportJobArn)))"}
}

extension DeleteDatasetImportJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetImportJobArn = "DatasetImportJobArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetImportJobArn = datasetImportJobArn {
            try encodeContainer.encode(datasetImportJobArn, forKey: .datasetImportJobArn)
        }
    }
}

public struct DeleteDatasetImportJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDatasetImportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDatasetImportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDatasetImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDatasetImportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDatasetImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDatasetImportJobOutputError>
}

public struct DeleteDatasetImportJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDatasetImportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDatasetImportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDatasetImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDatasetImportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDatasetImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDatasetImportJobOutputError>
}

public struct DeleteDatasetImportJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDatasetImportJobInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteDatasetImportJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDatasetImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteDatasetImportJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDatasetImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDatasetImportJobOutputError>
}

public struct DeleteDatasetImportJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset import job to delete.
    /// This member is required.
    public var datasetImportJobArn: Swift.String?

    public init (
        datasetImportJobArn: Swift.String? = nil
    )
    {
        self.datasetImportJobArn = datasetImportJobArn
    }
}

struct DeleteDatasetImportJobInputBody: Swift.Equatable {
    public let datasetImportJobArn: Swift.String?
}

extension DeleteDatasetImportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetImportJobArn = "DatasetImportJobArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetImportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetImportJobArn)
        datasetImportJobArn = datasetImportJobArnDecoded
    }
}

extension DeleteDatasetImportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDatasetImportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDatasetImportJobOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDatasetImportJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDatasetImportJobOutputResponse()"}
}

extension DeleteDatasetImportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDatasetImportJobOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteDatasetImportJobOutputResponseBody: Swift.Equatable {
}

extension DeleteDatasetImportJobOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteDatasetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDatasetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDatasetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDatasetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDatasetOutputError>
}

extension DeleteDatasetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDatasetInput(datasetArn: \(Swift.String(describing: datasetArn)))"}
}

extension DeleteDatasetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArn = "DatasetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetArn = datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
    }
}

public struct DeleteDatasetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDatasetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDatasetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDatasetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDatasetOutputError>
}

public struct DeleteDatasetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDatasetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDatasetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDatasetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDatasetOutputError>
}

public struct DeleteDatasetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDatasetInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteDatasetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteDatasetInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDatasetOutputError>
}

public struct DeleteDatasetInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset to delete.
    /// This member is required.
    public var datasetArn: Swift.String?

    public init (
        datasetArn: Swift.String? = nil
    )
    {
        self.datasetArn = datasetArn
    }
}

struct DeleteDatasetInputBody: Swift.Equatable {
    public let datasetArn: Swift.String?
}

extension DeleteDatasetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArn = "DatasetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
    }
}

extension DeleteDatasetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDatasetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDatasetOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDatasetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDatasetOutputResponse()"}
}

extension DeleteDatasetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDatasetOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteDatasetOutputResponseBody: Swift.Equatable {
}

extension DeleteDatasetOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteForecastExportJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteForecastExportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteForecastExportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteForecastExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteForecastExportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteForecastExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteForecastExportJobOutputError>
}

extension DeleteForecastExportJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteForecastExportJobInput(forecastExportJobArn: \(Swift.String(describing: forecastExportJobArn)))"}
}

extension DeleteForecastExportJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastExportJobArn = "ForecastExportJobArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forecastExportJobArn = forecastExportJobArn {
            try encodeContainer.encode(forecastExportJobArn, forKey: .forecastExportJobArn)
        }
    }
}

public struct DeleteForecastExportJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteForecastExportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteForecastExportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteForecastExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteForecastExportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteForecastExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteForecastExportJobOutputError>
}

public struct DeleteForecastExportJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteForecastExportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteForecastExportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteForecastExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteForecastExportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteForecastExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteForecastExportJobOutputError>
}

public struct DeleteForecastExportJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteForecastExportJobInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteForecastExportJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteForecastExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteForecastExportJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteForecastExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteForecastExportJobOutputError>
}

public struct DeleteForecastExportJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the forecast export job to delete.
    /// This member is required.
    public var forecastExportJobArn: Swift.String?

    public init (
        forecastExportJobArn: Swift.String? = nil
    )
    {
        self.forecastExportJobArn = forecastExportJobArn
    }
}

struct DeleteForecastExportJobInputBody: Swift.Equatable {
    public let forecastExportJobArn: Swift.String?
}

extension DeleteForecastExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastExportJobArn = "ForecastExportJobArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastExportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastExportJobArn)
        forecastExportJobArn = forecastExportJobArnDecoded
    }
}

extension DeleteForecastExportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteForecastExportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteForecastExportJobOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteForecastExportJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteForecastExportJobOutputResponse()"}
}

extension DeleteForecastExportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteForecastExportJobOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteForecastExportJobOutputResponseBody: Swift.Equatable {
}

extension DeleteForecastExportJobOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteForecastInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteForecastInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteForecastInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteForecastOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteForecastInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteForecastOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteForecastOutputError>
}

extension DeleteForecastInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteForecastInput(forecastArn: \(Swift.String(describing: forecastArn)))"}
}

extension DeleteForecastInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastArn = "ForecastArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forecastArn = forecastArn {
            try encodeContainer.encode(forecastArn, forKey: .forecastArn)
        }
    }
}

public struct DeleteForecastInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteForecastInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteForecastInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteForecastOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteForecastInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteForecastOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteForecastOutputError>
}

public struct DeleteForecastInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteForecastInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteForecastInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteForecastOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteForecastInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteForecastOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteForecastOutputError>
}

public struct DeleteForecastInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteForecastInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteForecastInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteForecastOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteForecastInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteForecastOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteForecastOutputError>
}

public struct DeleteForecastInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the forecast to delete.
    /// This member is required.
    public var forecastArn: Swift.String?

    public init (
        forecastArn: Swift.String? = nil
    )
    {
        self.forecastArn = forecastArn
    }
}

struct DeleteForecastInputBody: Swift.Equatable {
    public let forecastArn: Swift.String?
}

extension DeleteForecastInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastArn = "ForecastArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastArn)
        forecastArn = forecastArnDecoded
    }
}

extension DeleteForecastOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteForecastOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteForecastOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteForecastOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteForecastOutputResponse()"}
}

extension DeleteForecastOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteForecastOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteForecastOutputResponseBody: Swift.Equatable {
}

extension DeleteForecastOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeletePredictorBacktestExportJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePredictorBacktestExportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePredictorBacktestExportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePredictorBacktestExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePredictorBacktestExportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePredictorBacktestExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePredictorBacktestExportJobOutputError>
}

extension DeletePredictorBacktestExportJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeletePredictorBacktestExportJobInput(predictorBacktestExportJobArn: \(Swift.String(describing: predictorBacktestExportJobArn)))"}
}

extension DeletePredictorBacktestExportJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorBacktestExportJobArn = "PredictorBacktestExportJobArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let predictorBacktestExportJobArn = predictorBacktestExportJobArn {
            try encodeContainer.encode(predictorBacktestExportJobArn, forKey: .predictorBacktestExportJobArn)
        }
    }
}

public struct DeletePredictorBacktestExportJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePredictorBacktestExportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePredictorBacktestExportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePredictorBacktestExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePredictorBacktestExportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePredictorBacktestExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePredictorBacktestExportJobOutputError>
}

public struct DeletePredictorBacktestExportJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePredictorBacktestExportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePredictorBacktestExportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePredictorBacktestExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePredictorBacktestExportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePredictorBacktestExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePredictorBacktestExportJobOutputError>
}

public struct DeletePredictorBacktestExportJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePredictorBacktestExportJobInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeletePredictorBacktestExportJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePredictorBacktestExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeletePredictorBacktestExportJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePredictorBacktestExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePredictorBacktestExportJobOutputError>
}

public struct DeletePredictorBacktestExportJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the predictor backtest export job to delete.
    /// This member is required.
    public var predictorBacktestExportJobArn: Swift.String?

    public init (
        predictorBacktestExportJobArn: Swift.String? = nil
    )
    {
        self.predictorBacktestExportJobArn = predictorBacktestExportJobArn
    }
}

struct DeletePredictorBacktestExportJobInputBody: Swift.Equatable {
    public let predictorBacktestExportJobArn: Swift.String?
}

extension DeletePredictorBacktestExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorBacktestExportJobArn = "PredictorBacktestExportJobArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorBacktestExportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorBacktestExportJobArn)
        predictorBacktestExportJobArn = predictorBacktestExportJobArnDecoded
    }
}

extension DeletePredictorBacktestExportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePredictorBacktestExportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePredictorBacktestExportJobOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePredictorBacktestExportJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeletePredictorBacktestExportJobOutputResponse()"}
}

extension DeletePredictorBacktestExportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeletePredictorBacktestExportJobOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeletePredictorBacktestExportJobOutputResponseBody: Swift.Equatable {
}

extension DeletePredictorBacktestExportJobOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeletePredictorInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePredictorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePredictorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePredictorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePredictorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePredictorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePredictorOutputError>
}

extension DeletePredictorInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeletePredictorInput(predictorArn: \(Swift.String(describing: predictorArn)))"}
}

extension DeletePredictorInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorArn = "PredictorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let predictorArn = predictorArn {
            try encodeContainer.encode(predictorArn, forKey: .predictorArn)
        }
    }
}

public struct DeletePredictorInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePredictorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePredictorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePredictorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePredictorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePredictorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePredictorOutputError>
}

public struct DeletePredictorInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePredictorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePredictorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePredictorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePredictorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePredictorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePredictorOutputError>
}

public struct DeletePredictorInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePredictorInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeletePredictorInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePredictorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeletePredictorInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePredictorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePredictorOutputError>
}

public struct DeletePredictorInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the predictor to delete.
    /// This member is required.
    public var predictorArn: Swift.String?

    public init (
        predictorArn: Swift.String? = nil
    )
    {
        self.predictorArn = predictorArn
    }
}

struct DeletePredictorInputBody: Swift.Equatable {
    public let predictorArn: Swift.String?
}

extension DeletePredictorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorArn = "PredictorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
    }
}

extension DeletePredictorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePredictorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePredictorOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePredictorOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeletePredictorOutputResponse()"}
}

extension DeletePredictorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeletePredictorOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeletePredictorOutputResponseBody: Swift.Equatable {
}

extension DeletePredictorOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteResourceTreeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteResourceTreeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteResourceTreeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteResourceTreeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteResourceTreeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteResourceTreeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteResourceTreeOutputError>
}

extension DeleteResourceTreeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteResourceTreeInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension DeleteResourceTreeInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct DeleteResourceTreeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteResourceTreeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteResourceTreeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteResourceTreeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteResourceTreeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteResourceTreeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteResourceTreeOutputError>
}

public struct DeleteResourceTreeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteResourceTreeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteResourceTreeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteResourceTreeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteResourceTreeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteResourceTreeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteResourceTreeOutputError>
}

public struct DeleteResourceTreeInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteResourceTreeInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteResourceTreeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteResourceTreeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteResourceTreeInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteResourceTreeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteResourceTreeOutputError>
}

public struct DeleteResourceTreeInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the parent resource to delete. All child resources
    ///             of the parent resource will also be deleted.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct DeleteResourceTreeInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
}

extension DeleteResourceTreeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension DeleteResourceTreeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteResourceTreeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteResourceTreeOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteResourceTreeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteResourceTreeOutputResponse()"}
}

extension DeleteResourceTreeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteResourceTreeOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteResourceTreeOutputResponseBody: Swift.Equatable {
}

extension DeleteResourceTreeOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DescribeDatasetGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDatasetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDatasetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDatasetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDatasetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDatasetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDatasetGroupOutputError>
}

extension DescribeDatasetGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDatasetGroupInput(datasetGroupArn: \(Swift.String(describing: datasetGroupArn)))"}
}

extension DescribeDatasetGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn = "DatasetGroupArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
    }
}

public struct DescribeDatasetGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDatasetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDatasetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDatasetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDatasetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDatasetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDatasetGroupOutputError>
}

public struct DescribeDatasetGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDatasetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDatasetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDatasetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDatasetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDatasetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDatasetGroupOutputError>
}

public struct DescribeDatasetGroupInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDatasetGroupInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeDatasetGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDatasetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeDatasetGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDatasetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDatasetGroupOutputError>
}

public struct DescribeDatasetGroupInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset group.
    /// This member is required.
    public var datasetGroupArn: Swift.String?

    public init (
        datasetGroupArn: Swift.String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
    }
}

struct DescribeDatasetGroupInputBody: Swift.Equatable {
    public let datasetGroupArn: Swift.String?
}

extension DescribeDatasetGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn = "DatasetGroupArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
    }
}

extension DescribeDatasetGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDatasetGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDatasetGroupOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDatasetGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDatasetGroupOutputResponse(creationTime: \(Swift.String(describing: creationTime)), datasetArns: \(Swift.String(describing: datasetArns)), datasetGroupArn: \(Swift.String(describing: datasetGroupArn)), datasetGroupName: \(Swift.String(describing: datasetGroupName)), domain: \(Swift.String(describing: domain)), lastModificationTime: \(Swift.String(describing: lastModificationTime)), status: \(Swift.String(describing: status)))"}
}

extension DescribeDatasetGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDatasetGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.datasetArns = output.datasetArns
            self.datasetGroupArn = output.datasetGroupArn
            self.datasetGroupName = output.datasetGroupName
            self.domain = output.domain
            self.lastModificationTime = output.lastModificationTime
            self.status = output.status
        } else {
            self.creationTime = nil
            self.datasetArns = nil
            self.datasetGroupArn = nil
            self.datasetGroupName = nil
            self.domain = nil
            self.lastModificationTime = nil
            self.status = nil
        }
    }
}

public struct DescribeDatasetGroupOutputResponse: Swift.Equatable {
    /// When the dataset group was created.
    public var creationTime: ClientRuntime.Date?
    /// An array of Amazon Resource Names (ARNs) of the datasets contained in the dataset
    ///       group.
    public var datasetArns: [Swift.String]?
    /// The ARN of the dataset group.
    public var datasetGroupArn: Swift.String?
    /// The name of the dataset group.
    public var datasetGroupName: Swift.String?
    /// The domain associated with the dataset group.
    public var domain: ForecastClientTypes.Domain?
    /// When the dataset group was created or last updated from a call to the UpdateDatasetGroup operation. While the dataset group is being updated,
    ///         LastModificationTime is the current time of the
    ///         DescribeDatasetGroup call.
    public var lastModificationTime: ClientRuntime.Date?
    /// The status of the dataset group. States include:
    ///
    ///
    ///
    ///                   ACTIVE
    ///
    ///
    ///
    ///
    ///                   CREATE_PENDING, CREATE_IN_PROGRESS,
    ///             CREATE_FAILED
    ///
    ///
    ///
    ///
    ///                   DELETE_PENDING, DELETE_IN_PROGRESS,
    ///             DELETE_FAILED
    ///
    ///
    ///
    ///
    ///                   UPDATE_PENDING, UPDATE_IN_PROGRESS,
    ///             UPDATE_FAILED
    ///
    ///
    ///
    ///          The UPDATE states apply when you call the UpdateDatasetGroup operation.
    ///
    ///             The Status of the dataset group must be ACTIVE before you can
    ///         use the dataset group to create a predictor.
    ///
    public var status: Swift.String?

    public init (
        creationTime: ClientRuntime.Date? = nil,
        datasetArns: [Swift.String]? = nil,
        datasetGroupArn: Swift.String? = nil,
        datasetGroupName: Swift.String? = nil,
        domain: ForecastClientTypes.Domain? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        status: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.datasetArns = datasetArns
        self.datasetGroupArn = datasetGroupArn
        self.datasetGroupName = datasetGroupName
        self.domain = domain
        self.lastModificationTime = lastModificationTime
        self.status = status
    }
}

struct DescribeDatasetGroupOutputResponseBody: Swift.Equatable {
    public let datasetGroupName: Swift.String?
    public let datasetGroupArn: Swift.String?
    public let datasetArns: [Swift.String]?
    public let domain: ForecastClientTypes.Domain?
    public let status: Swift.String?
    public let creationTime: ClientRuntime.Date?
    public let lastModificationTime: ClientRuntime.Date?
}

extension DescribeDatasetGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case datasetArns = "DatasetArns"
        case datasetGroupArn = "DatasetGroupArn"
        case datasetGroupName = "DatasetGroupName"
        case domain = "Domain"
        case lastModificationTime = "LastModificationTime"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupName)
        datasetGroupName = datasetGroupNameDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let datasetArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .datasetArns)
        var datasetArnsDecoded0:[Swift.String]? = nil
        if let datasetArnsContainer = datasetArnsContainer {
            datasetArnsDecoded0 = [Swift.String]()
            for string0 in datasetArnsContainer {
                if let string0 = string0 {
                    datasetArnsDecoded0?.append(string0)
                }
            }
        }
        datasetArns = datasetArnsDecoded0
        let domainDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

public struct DescribeDatasetImportJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDatasetImportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDatasetImportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDatasetImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDatasetImportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDatasetImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDatasetImportJobOutputError>
}

extension DescribeDatasetImportJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDatasetImportJobInput(datasetImportJobArn: \(Swift.String(describing: datasetImportJobArn)))"}
}

extension DescribeDatasetImportJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetImportJobArn = "DatasetImportJobArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetImportJobArn = datasetImportJobArn {
            try encodeContainer.encode(datasetImportJobArn, forKey: .datasetImportJobArn)
        }
    }
}

public struct DescribeDatasetImportJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDatasetImportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDatasetImportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDatasetImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDatasetImportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDatasetImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDatasetImportJobOutputError>
}

public struct DescribeDatasetImportJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDatasetImportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDatasetImportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDatasetImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDatasetImportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDatasetImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDatasetImportJobOutputError>
}

public struct DescribeDatasetImportJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDatasetImportJobInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeDatasetImportJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDatasetImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeDatasetImportJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDatasetImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDatasetImportJobOutputError>
}

public struct DescribeDatasetImportJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset import job.
    /// This member is required.
    public var datasetImportJobArn: Swift.String?

    public init (
        datasetImportJobArn: Swift.String? = nil
    )
    {
        self.datasetImportJobArn = datasetImportJobArn
    }
}

struct DescribeDatasetImportJobInputBody: Swift.Equatable {
    public let datasetImportJobArn: Swift.String?
}

extension DescribeDatasetImportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetImportJobArn = "DatasetImportJobArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetImportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetImportJobArn)
        datasetImportJobArn = datasetImportJobArnDecoded
    }
}

extension DescribeDatasetImportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDatasetImportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDatasetImportJobOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDatasetImportJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDatasetImportJobOutputResponse(creationTime: \(Swift.String(describing: creationTime)), dataSize: \(Swift.String(describing: dataSize)), dataSource: \(Swift.String(describing: dataSource)), datasetArn: \(Swift.String(describing: datasetArn)), datasetImportJobArn: \(Swift.String(describing: datasetImportJobArn)), datasetImportJobName: \(Swift.String(describing: datasetImportJobName)), estimatedTimeRemainingInMinutes: \(Swift.String(describing: estimatedTimeRemainingInMinutes)), fieldStatistics: \(Swift.String(describing: fieldStatistics)), geolocationFormat: \(Swift.String(describing: geolocationFormat)), lastModificationTime: \(Swift.String(describing: lastModificationTime)), message: \(Swift.String(describing: message)), status: \(Swift.String(describing: status)), timeZone: \(Swift.String(describing: timeZone)), timestampFormat: \(Swift.String(describing: timestampFormat)), useGeolocationForTimeZone: \(Swift.String(describing: useGeolocationForTimeZone)))"}
}

extension DescribeDatasetImportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDatasetImportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.dataSize = output.dataSize
            self.dataSource = output.dataSource
            self.datasetArn = output.datasetArn
            self.datasetImportJobArn = output.datasetImportJobArn
            self.datasetImportJobName = output.datasetImportJobName
            self.estimatedTimeRemainingInMinutes = output.estimatedTimeRemainingInMinutes
            self.fieldStatistics = output.fieldStatistics
            self.geolocationFormat = output.geolocationFormat
            self.lastModificationTime = output.lastModificationTime
            self.message = output.message
            self.status = output.status
            self.timeZone = output.timeZone
            self.timestampFormat = output.timestampFormat
            self.useGeolocationForTimeZone = output.useGeolocationForTimeZone
        } else {
            self.creationTime = nil
            self.dataSize = nil
            self.dataSource = nil
            self.datasetArn = nil
            self.datasetImportJobArn = nil
            self.datasetImportJobName = nil
            self.estimatedTimeRemainingInMinutes = nil
            self.fieldStatistics = nil
            self.geolocationFormat = nil
            self.lastModificationTime = nil
            self.message = nil
            self.status = nil
            self.timeZone = nil
            self.timestampFormat = nil
            self.useGeolocationForTimeZone = false
        }
    }
}

public struct DescribeDatasetImportJobOutputResponse: Swift.Equatable {
    /// When the dataset import job was created.
    public var creationTime: ClientRuntime.Date?
    /// The size of the dataset in gigabytes (GB) after the import job has finished.
    public var dataSize: Swift.Double?
    /// The location of the training data to import and an AWS Identity and Access Management (IAM) role that Amazon Forecast
    ///       can assume to access the data.
    ///          If encryption is used, DataSource includes an AWS Key Management Service (KMS) key.
    public var dataSource: ForecastClientTypes.DataSource?
    /// The Amazon Resource Name (ARN) of the dataset that the training data was imported
    ///       to.
    public var datasetArn: Swift.String?
    /// The ARN of the dataset import job.
    public var datasetImportJobArn: Swift.String?
    /// The name of the dataset import job.
    public var datasetImportJobName: Swift.String?
    /// The estimated time remaining in minutes for the dataset import job to complete.
    public var estimatedTimeRemainingInMinutes: Swift.Int?
    /// Statistical information about each field in the input data.
    public var fieldStatistics: [Swift.String:ForecastClientTypes.Statistics]?
    /// The format of the geolocation attribute. Valid Values:"LAT_LONG" and
    ///                 "CC_POSTALCODE".
    public var geolocationFormat: Swift.String?
    /// The last time the resource was modified. The timestamp depends on the status of the
    ///       job:
    ///
    ///
    ///
    ///                   CREATE_PENDING - The CreationTime.
    ///
    ///
    ///
    ///                   CREATE_IN_PROGRESS - The current timestamp.
    ///
    ///
    ///
    ///                   CREATE_STOPPING - The current timestamp.
    ///
    ///
    ///
    ///                   CREATE_STOPPED - When the job stopped.
    ///
    ///
    ///
    ///                   ACTIVE or CREATE_FAILED - When the job finished or
    ///           failed.
    ///
    ///
    public var lastModificationTime: ClientRuntime.Date?
    /// If an error occurred, an informational message about the error.
    public var message: Swift.String?
    /// The status of the dataset import job. States include:
    ///
    ///
    ///
    ///                   ACTIVE
    ///
    ///
    ///
    ///
    ///                   CREATE_PENDING, CREATE_IN_PROGRESS,
    ///             CREATE_FAILED
    ///
    ///
    ///
    ///
    ///                   DELETE_PENDING, DELETE_IN_PROGRESS,
    ///             DELETE_FAILED
    ///
    ///
    ///
    ///
    ///                   CREATE_STOPPING, CREATE_STOPPED
    ///
    ///
    ///
    public var status: Swift.String?
    /// The single time zone applied to every item in the dataset
    public var timeZone: Swift.String?
    /// The format of timestamps in the dataset. The format that you specify depends on the
    ///         DataFrequency specified when the dataset was created. The following formats are
    ///       supported
    ///
    ///
    ///                "yyyy-MM-dd"
    ///                For the following data frequencies: Y, M, W, and D
    ///
    ///
    ///                "yyyy-MM-dd HH:mm:ss"
    ///                For the following data frequencies: H, 30min, 15min, and 1min; and optionally, for: Y,
    ///           M, W, and D
    ///
    ///
    public var timestampFormat: Swift.String?
    /// Whether TimeZone is automatically derived from the geolocation
    ///             attribute.
    public var useGeolocationForTimeZone: Swift.Bool

    public init (
        creationTime: ClientRuntime.Date? = nil,
        dataSize: Swift.Double? = nil,
        dataSource: ForecastClientTypes.DataSource? = nil,
        datasetArn: Swift.String? = nil,
        datasetImportJobArn: Swift.String? = nil,
        datasetImportJobName: Swift.String? = nil,
        estimatedTimeRemainingInMinutes: Swift.Int? = nil,
        fieldStatistics: [Swift.String:ForecastClientTypes.Statistics]? = nil,
        geolocationFormat: Swift.String? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        message: Swift.String? = nil,
        status: Swift.String? = nil,
        timeZone: Swift.String? = nil,
        timestampFormat: Swift.String? = nil,
        useGeolocationForTimeZone: Swift.Bool = false
    )
    {
        self.creationTime = creationTime
        self.dataSize = dataSize
        self.dataSource = dataSource
        self.datasetArn = datasetArn
        self.datasetImportJobArn = datasetImportJobArn
        self.datasetImportJobName = datasetImportJobName
        self.estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutes
        self.fieldStatistics = fieldStatistics
        self.geolocationFormat = geolocationFormat
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.status = status
        self.timeZone = timeZone
        self.timestampFormat = timestampFormat
        self.useGeolocationForTimeZone = useGeolocationForTimeZone
    }
}

struct DescribeDatasetImportJobOutputResponseBody: Swift.Equatable {
    public let datasetImportJobName: Swift.String?
    public let datasetImportJobArn: Swift.String?
    public let datasetArn: Swift.String?
    public let timestampFormat: Swift.String?
    public let timeZone: Swift.String?
    public let useGeolocationForTimeZone: Swift.Bool
    public let geolocationFormat: Swift.String?
    public let dataSource: ForecastClientTypes.DataSource?
    public let estimatedTimeRemainingInMinutes: Swift.Int?
    public let fieldStatistics: [Swift.String:ForecastClientTypes.Statistics]?
    public let dataSize: Swift.Double?
    public let status: Swift.String?
    public let message: Swift.String?
    public let creationTime: ClientRuntime.Date?
    public let lastModificationTime: ClientRuntime.Date?
}

extension DescribeDatasetImportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case dataSize = "DataSize"
        case dataSource = "DataSource"
        case datasetArn = "DatasetArn"
        case datasetImportJobArn = "DatasetImportJobArn"
        case datasetImportJobName = "DatasetImportJobName"
        case estimatedTimeRemainingInMinutes = "EstimatedTimeRemainingInMinutes"
        case fieldStatistics = "FieldStatistics"
        case geolocationFormat = "GeolocationFormat"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case status = "Status"
        case timeZone = "TimeZone"
        case timestampFormat = "TimestampFormat"
        case useGeolocationForTimeZone = "UseGeolocationForTimeZone"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetImportJobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetImportJobName)
        datasetImportJobName = datasetImportJobNameDecoded
        let datasetImportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetImportJobArn)
        datasetImportJobArn = datasetImportJobArnDecoded
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let timestampFormatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timestampFormat)
        timestampFormat = timestampFormatDecoded
        let timeZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeZone)
        timeZone = timeZoneDecoded
        let useGeolocationForTimeZoneDecoded = try containerValues.decode(Swift.Bool.self, forKey: .useGeolocationForTimeZone)
        useGeolocationForTimeZone = useGeolocationForTimeZoneDecoded
        let geolocationFormatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .geolocationFormat)
        geolocationFormat = geolocationFormatDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let estimatedTimeRemainingInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .estimatedTimeRemainingInMinutes)
        estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutesDecoded
        let fieldStatisticsContainer = try containerValues.decodeIfPresent([Swift.String: ForecastClientTypes.Statistics?].self, forKey: .fieldStatistics)
        var fieldStatisticsDecoded0: [Swift.String:ForecastClientTypes.Statistics]? = nil
        if let fieldStatisticsContainer = fieldStatisticsContainer {
            fieldStatisticsDecoded0 = [Swift.String:ForecastClientTypes.Statistics]()
            for (key0, statistics0) in fieldStatisticsContainer {
                if let statistics0 = statistics0 {
                    fieldStatisticsDecoded0?[key0] = statistics0
                }
            }
        }
        fieldStatistics = fieldStatisticsDecoded0
        let dataSizeDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .dataSize)
        dataSize = dataSizeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

public struct DescribeDatasetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDatasetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDatasetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDatasetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDatasetOutputError>
}

extension DescribeDatasetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDatasetInput(datasetArn: \(Swift.String(describing: datasetArn)))"}
}

extension DescribeDatasetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArn = "DatasetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetArn = datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
    }
}

public struct DescribeDatasetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDatasetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDatasetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDatasetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDatasetOutputError>
}

public struct DescribeDatasetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDatasetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDatasetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDatasetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDatasetOutputError>
}

public struct DescribeDatasetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDatasetInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeDatasetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeDatasetInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDatasetOutputError>
}

public struct DescribeDatasetInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset.
    /// This member is required.
    public var datasetArn: Swift.String?

    public init (
        datasetArn: Swift.String? = nil
    )
    {
        self.datasetArn = datasetArn
    }
}

struct DescribeDatasetInputBody: Swift.Equatable {
    public let datasetArn: Swift.String?
}

extension DescribeDatasetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArn = "DatasetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
    }
}

extension DescribeDatasetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDatasetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDatasetOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDatasetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDatasetOutputResponse(creationTime: \(Swift.String(describing: creationTime)), dataFrequency: \(Swift.String(describing: dataFrequency)), datasetArn: \(Swift.String(describing: datasetArn)), datasetName: \(Swift.String(describing: datasetName)), datasetType: \(Swift.String(describing: datasetType)), domain: \(Swift.String(describing: domain)), encryptionConfig: \(Swift.String(describing: encryptionConfig)), lastModificationTime: \(Swift.String(describing: lastModificationTime)), schema: \(Swift.String(describing: schema)), status: \(Swift.String(describing: status)))"}
}

extension DescribeDatasetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDatasetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.dataFrequency = output.dataFrequency
            self.datasetArn = output.datasetArn
            self.datasetName = output.datasetName
            self.datasetType = output.datasetType
            self.domain = output.domain
            self.encryptionConfig = output.encryptionConfig
            self.lastModificationTime = output.lastModificationTime
            self.schema = output.schema
            self.status = output.status
        } else {
            self.creationTime = nil
            self.dataFrequency = nil
            self.datasetArn = nil
            self.datasetName = nil
            self.datasetType = nil
            self.domain = nil
            self.encryptionConfig = nil
            self.lastModificationTime = nil
            self.schema = nil
            self.status = nil
        }
    }
}

public struct DescribeDatasetOutputResponse: Swift.Equatable {
    /// When the dataset was created.
    public var creationTime: ClientRuntime.Date?
    /// The frequency of data collection.
    ///          Valid intervals are Y (Year), M (Month), W (Week), D (Day), H (Hour), 30min (30 minutes),
    ///       15min (15 minutes), 10min (10 minutes), 5min (5 minutes), and 1min (1 minute). For example,
    ///       "M" indicates every month and "30min" indicates every 30 minutes.
    public var dataFrequency: Swift.String?
    /// The Amazon Resource Name (ARN) of the dataset.
    public var datasetArn: Swift.String?
    /// The name of the dataset.
    public var datasetName: Swift.String?
    /// The dataset type.
    public var datasetType: ForecastClientTypes.DatasetType?
    /// The domain associated with the dataset.
    public var domain: ForecastClientTypes.Domain?
    /// The AWS Key Management Service (KMS) key and the AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access
    ///       the key.
    public var encryptionConfig: ForecastClientTypes.EncryptionConfig?
    /// When you create a dataset, LastModificationTime is the same as
    ///         CreationTime. While data is being imported to the dataset,
    ///         LastModificationTime is the current time of the DescribeDataset
    ///       call. After a CreateDatasetImportJob operation has finished,
    ///         LastModificationTime is when the import job completed or failed.
    public var lastModificationTime: ClientRuntime.Date?
    /// An array of SchemaAttribute objects that specify the dataset fields. Each
    ///         SchemaAttribute specifies the name and data type of a field.
    public var schema: ForecastClientTypes.Schema?
    /// The status of the dataset. States include:
    ///
    ///
    ///
    ///                   ACTIVE
    ///
    ///
    ///
    ///
    ///                   CREATE_PENDING, CREATE_IN_PROGRESS,
    ///             CREATE_FAILED
    ///
    ///
    ///
    ///
    ///                   DELETE_PENDING, DELETE_IN_PROGRESS,
    ///             DELETE_FAILED
    ///
    ///
    ///
    ///
    ///                   UPDATE_PENDING, UPDATE_IN_PROGRESS,
    ///             UPDATE_FAILED
    ///
    ///
    ///
    ///          The UPDATE states apply while data is imported to the dataset from a call to
    ///       the CreateDatasetImportJob operation and reflect the status of the dataset
    ///       import job. For example, when the import job status is CREATE_IN_PROGRESS, the
    ///       status of the dataset is UPDATE_IN_PROGRESS.
    ///
    ///             The Status of the dataset must be ACTIVE before you can import
    ///         training data.
    ///
    public var status: Swift.String?

    public init (
        creationTime: ClientRuntime.Date? = nil,
        dataFrequency: Swift.String? = nil,
        datasetArn: Swift.String? = nil,
        datasetName: Swift.String? = nil,
        datasetType: ForecastClientTypes.DatasetType? = nil,
        domain: ForecastClientTypes.Domain? = nil,
        encryptionConfig: ForecastClientTypes.EncryptionConfig? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        schema: ForecastClientTypes.Schema? = nil,
        status: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.dataFrequency = dataFrequency
        self.datasetArn = datasetArn
        self.datasetName = datasetName
        self.datasetType = datasetType
        self.domain = domain
        self.encryptionConfig = encryptionConfig
        self.lastModificationTime = lastModificationTime
        self.schema = schema
        self.status = status
    }
}

struct DescribeDatasetOutputResponseBody: Swift.Equatable {
    public let datasetArn: Swift.String?
    public let datasetName: Swift.String?
    public let domain: ForecastClientTypes.Domain?
    public let datasetType: ForecastClientTypes.DatasetType?
    public let dataFrequency: Swift.String?
    public let schema: ForecastClientTypes.Schema?
    public let encryptionConfig: ForecastClientTypes.EncryptionConfig?
    public let status: Swift.String?
    public let creationTime: ClientRuntime.Date?
    public let lastModificationTime: ClientRuntime.Date?
}

extension DescribeDatasetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case dataFrequency = "DataFrequency"
        case datasetArn = "DatasetArn"
        case datasetName = "DatasetName"
        case datasetType = "DatasetType"
        case domain = "Domain"
        case encryptionConfig = "EncryptionConfig"
        case lastModificationTime = "LastModificationTime"
        case schema = "Schema"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let datasetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetName)
        datasetName = datasetNameDecoded
        let domainDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
        let datasetTypeDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DatasetType.self, forKey: .datasetType)
        datasetType = datasetTypeDecoded
        let dataFrequencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataFrequency)
        dataFrequency = dataFrequencyDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.Schema.self, forKey: .schema)
        schema = schemaDecoded
        let encryptionConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.EncryptionConfig.self, forKey: .encryptionConfig)
        encryptionConfig = encryptionConfigDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

public struct DescribeForecastExportJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeForecastExportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeForecastExportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeForecastExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeForecastExportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeForecastExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeForecastExportJobOutputError>
}

extension DescribeForecastExportJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeForecastExportJobInput(forecastExportJobArn: \(Swift.String(describing: forecastExportJobArn)))"}
}

extension DescribeForecastExportJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastExportJobArn = "ForecastExportJobArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forecastExportJobArn = forecastExportJobArn {
            try encodeContainer.encode(forecastExportJobArn, forKey: .forecastExportJobArn)
        }
    }
}

public struct DescribeForecastExportJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeForecastExportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeForecastExportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeForecastExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeForecastExportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeForecastExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeForecastExportJobOutputError>
}

public struct DescribeForecastExportJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeForecastExportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeForecastExportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeForecastExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeForecastExportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeForecastExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeForecastExportJobOutputError>
}

public struct DescribeForecastExportJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeForecastExportJobInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeForecastExportJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeForecastExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeForecastExportJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeForecastExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeForecastExportJobOutputError>
}

public struct DescribeForecastExportJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the forecast export job.
    /// This member is required.
    public var forecastExportJobArn: Swift.String?

    public init (
        forecastExportJobArn: Swift.String? = nil
    )
    {
        self.forecastExportJobArn = forecastExportJobArn
    }
}

struct DescribeForecastExportJobInputBody: Swift.Equatable {
    public let forecastExportJobArn: Swift.String?
}

extension DescribeForecastExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastExportJobArn = "ForecastExportJobArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastExportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastExportJobArn)
        forecastExportJobArn = forecastExportJobArnDecoded
    }
}

extension DescribeForecastExportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeForecastExportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeForecastExportJobOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeForecastExportJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeForecastExportJobOutputResponse(creationTime: \(Swift.String(describing: creationTime)), destination: \(Swift.String(describing: destination)), forecastArn: \(Swift.String(describing: forecastArn)), forecastExportJobArn: \(Swift.String(describing: forecastExportJobArn)), forecastExportJobName: \(Swift.String(describing: forecastExportJobName)), lastModificationTime: \(Swift.String(describing: lastModificationTime)), message: \(Swift.String(describing: message)), status: \(Swift.String(describing: status)))"}
}

extension DescribeForecastExportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeForecastExportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.destination = output.destination
            self.forecastArn = output.forecastArn
            self.forecastExportJobArn = output.forecastExportJobArn
            self.forecastExportJobName = output.forecastExportJobName
            self.lastModificationTime = output.lastModificationTime
            self.message = output.message
            self.status = output.status
        } else {
            self.creationTime = nil
            self.destination = nil
            self.forecastArn = nil
            self.forecastExportJobArn = nil
            self.forecastExportJobName = nil
            self.lastModificationTime = nil
            self.message = nil
            self.status = nil
        }
    }
}

public struct DescribeForecastExportJobOutputResponse: Swift.Equatable {
    /// When the forecast export job was created.
    public var creationTime: ClientRuntime.Date?
    /// The path to the Amazon Simple Storage Service (Amazon S3) bucket where the forecast is exported.
    public var destination: ForecastClientTypes.DataDestination?
    /// The Amazon Resource Name (ARN) of the exported forecast.
    public var forecastArn: Swift.String?
    /// The ARN of the forecast export job.
    public var forecastExportJobArn: Swift.String?
    /// The name of the forecast export job.
    public var forecastExportJobName: Swift.String?
    /// The last time the resource was modified. The timestamp depends on the status of the job:
    ///
    ///
    ///
    ///                   CREATE_PENDING - The CreationTime.
    ///
    ///
    ///
    ///                   CREATE_IN_PROGRESS - The current timestamp.
    ///
    ///
    ///
    ///                   CREATE_STOPPING - The current timestamp.
    ///
    ///
    ///
    ///                   CREATE_STOPPED - When the job stopped.
    ///
    ///
    ///
    ///                   ACTIVE or CREATE_FAILED - When the job finished or
    ///           failed.
    ///
    ///
    public var lastModificationTime: ClientRuntime.Date?
    /// If an error occurred, an informational message about the error.
    public var message: Swift.String?
    /// The status of the forecast export job. States include:
    ///
    ///
    ///
    ///                   ACTIVE
    ///
    ///
    ///
    ///
    ///                   CREATE_PENDING, CREATE_IN_PROGRESS,
    ///           CREATE_FAILED
    ///
    ///
    ///
    ///
    ///                   CREATE_STOPPING, CREATE_STOPPED
    ///
    ///
    ///
    ///
    ///                   DELETE_PENDING, DELETE_IN_PROGRESS,
    ///           DELETE_FAILED
    ///
    ///
    ///
    ///
    ///             The Status of the forecast export job must be ACTIVE before
    ///         you can access the forecast in your S3 bucket.
    ///
    public var status: Swift.String?

    public init (
        creationTime: ClientRuntime.Date? = nil,
        destination: ForecastClientTypes.DataDestination? = nil,
        forecastArn: Swift.String? = nil,
        forecastExportJobArn: Swift.String? = nil,
        forecastExportJobName: Swift.String? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        message: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.destination = destination
        self.forecastArn = forecastArn
        self.forecastExportJobArn = forecastExportJobArn
        self.forecastExportJobName = forecastExportJobName
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.status = status
    }
}

struct DescribeForecastExportJobOutputResponseBody: Swift.Equatable {
    public let forecastExportJobArn: Swift.String?
    public let forecastExportJobName: Swift.String?
    public let forecastArn: Swift.String?
    public let destination: ForecastClientTypes.DataDestination?
    public let message: Swift.String?
    public let status: Swift.String?
    public let creationTime: ClientRuntime.Date?
    public let lastModificationTime: ClientRuntime.Date?
}

extension DescribeForecastExportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case destination = "Destination"
        case forecastArn = "ForecastArn"
        case forecastExportJobArn = "ForecastExportJobArn"
        case forecastExportJobName = "ForecastExportJobName"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastExportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastExportJobArn)
        forecastExportJobArn = forecastExportJobArnDecoded
        let forecastExportJobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastExportJobName)
        forecastExportJobName = forecastExportJobNameDecoded
        let forecastArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastArn)
        forecastArn = forecastArnDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataDestination.self, forKey: .destination)
        destination = destinationDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

public struct DescribeForecastInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeForecastInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeForecastInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeForecastOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeForecastInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeForecastOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeForecastOutputError>
}

extension DescribeForecastInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeForecastInput(forecastArn: \(Swift.String(describing: forecastArn)))"}
}

extension DescribeForecastInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastArn = "ForecastArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forecastArn = forecastArn {
            try encodeContainer.encode(forecastArn, forKey: .forecastArn)
        }
    }
}

public struct DescribeForecastInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeForecastInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeForecastInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeForecastOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeForecastInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeForecastOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeForecastOutputError>
}

public struct DescribeForecastInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeForecastInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeForecastInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeForecastOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeForecastInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeForecastOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeForecastOutputError>
}

public struct DescribeForecastInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeForecastInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeForecastInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeForecastOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeForecastInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeForecastOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeForecastOutputError>
}

public struct DescribeForecastInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the forecast.
    /// This member is required.
    public var forecastArn: Swift.String?

    public init (
        forecastArn: Swift.String? = nil
    )
    {
        self.forecastArn = forecastArn
    }
}

struct DescribeForecastInputBody: Swift.Equatable {
    public let forecastArn: Swift.String?
}

extension DescribeForecastInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastArn = "ForecastArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastArn)
        forecastArn = forecastArnDecoded
    }
}

extension DescribeForecastOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeForecastOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeForecastOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeForecastOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeForecastOutputResponse(creationTime: \(Swift.String(describing: creationTime)), datasetGroupArn: \(Swift.String(describing: datasetGroupArn)), estimatedTimeRemainingInMinutes: \(Swift.String(describing: estimatedTimeRemainingInMinutes)), forecastArn: \(Swift.String(describing: forecastArn)), forecastName: \(Swift.String(describing: forecastName)), forecastTypes: \(Swift.String(describing: forecastTypes)), lastModificationTime: \(Swift.String(describing: lastModificationTime)), message: \(Swift.String(describing: message)), predictorArn: \(Swift.String(describing: predictorArn)), status: \(Swift.String(describing: status)))"}
}

extension DescribeForecastOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeForecastOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.datasetGroupArn = output.datasetGroupArn
            self.estimatedTimeRemainingInMinutes = output.estimatedTimeRemainingInMinutes
            self.forecastArn = output.forecastArn
            self.forecastName = output.forecastName
            self.forecastTypes = output.forecastTypes
            self.lastModificationTime = output.lastModificationTime
            self.message = output.message
            self.predictorArn = output.predictorArn
            self.status = output.status
        } else {
            self.creationTime = nil
            self.datasetGroupArn = nil
            self.estimatedTimeRemainingInMinutes = nil
            self.forecastArn = nil
            self.forecastName = nil
            self.forecastTypes = nil
            self.lastModificationTime = nil
            self.message = nil
            self.predictorArn = nil
            self.status = nil
        }
    }
}

public struct DescribeForecastOutputResponse: Swift.Equatable {
    /// When the forecast creation task was created.
    public var creationTime: ClientRuntime.Date?
    /// The ARN of the dataset group that provided the data used to train the predictor.
    public var datasetGroupArn: Swift.String?
    /// The estimated time remaining in minutes for the forecast job to complete.
    public var estimatedTimeRemainingInMinutes: Swift.Int?
    /// The forecast ARN as specified in the request.
    public var forecastArn: Swift.String?
    /// The name of the forecast.
    public var forecastName: Swift.String?
    /// The quantiles at which probabilistic forecasts were generated.
    public var forecastTypes: [Swift.String]?
    /// The last time the resource was modified. The timestamp depends on the status of the job:
    ///
    ///
    ///
    ///                   CREATE_PENDING - The CreationTime.
    ///
    ///
    ///
    ///                   CREATE_IN_PROGRESS - The current timestamp.
    ///
    ///
    ///
    ///                   CREATE_STOPPING - The current timestamp.
    ///
    ///
    ///
    ///                   CREATE_STOPPED - When the job stopped.
    ///
    ///
    ///
    ///                   ACTIVE or CREATE_FAILED - When the job finished or
    ///           failed.
    ///
    ///
    public var lastModificationTime: ClientRuntime.Date?
    /// If an error occurred, an informational message about the error.
    public var message: Swift.String?
    /// The ARN of the predictor used to generate the forecast.
    public var predictorArn: Swift.String?
    /// The status of the forecast. States include:
    ///
    ///
    ///
    ///                   ACTIVE
    ///
    ///
    ///
    ///
    ///                   CREATE_PENDING, CREATE_IN_PROGRESS,
    ///           CREATE_FAILED
    ///
    ///
    ///
    ///
    ///                   CREATE_STOPPING, CREATE_STOPPED
    ///
    ///
    ///
    ///
    ///                   DELETE_PENDING, DELETE_IN_PROGRESS,
    ///           DELETE_FAILED
    ///
    ///
    ///
    ///
    ///             The Status of the forecast must be ACTIVE before you can query
    ///         or export the forecast.
    ///
    public var status: Swift.String?

    public init (
        creationTime: ClientRuntime.Date? = nil,
        datasetGroupArn: Swift.String? = nil,
        estimatedTimeRemainingInMinutes: Swift.Int? = nil,
        forecastArn: Swift.String? = nil,
        forecastName: Swift.String? = nil,
        forecastTypes: [Swift.String]? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        message: Swift.String? = nil,
        predictorArn: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.datasetGroupArn = datasetGroupArn
        self.estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutes
        self.forecastArn = forecastArn
        self.forecastName = forecastName
        self.forecastTypes = forecastTypes
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.predictorArn = predictorArn
        self.status = status
    }
}

struct DescribeForecastOutputResponseBody: Swift.Equatable {
    public let forecastArn: Swift.String?
    public let forecastName: Swift.String?
    public let forecastTypes: [Swift.String]?
    public let predictorArn: Swift.String?
    public let datasetGroupArn: Swift.String?
    public let estimatedTimeRemainingInMinutes: Swift.Int?
    public let status: Swift.String?
    public let message: Swift.String?
    public let creationTime: ClientRuntime.Date?
    public let lastModificationTime: ClientRuntime.Date?
}

extension DescribeForecastOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case datasetGroupArn = "DatasetGroupArn"
        case estimatedTimeRemainingInMinutes = "EstimatedTimeRemainingInMinutes"
        case forecastArn = "ForecastArn"
        case forecastName = "ForecastName"
        case forecastTypes = "ForecastTypes"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case predictorArn = "PredictorArn"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastArn)
        forecastArn = forecastArnDecoded
        let forecastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastName)
        forecastName = forecastNameDecoded
        let forecastTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .forecastTypes)
        var forecastTypesDecoded0:[Swift.String]? = nil
        if let forecastTypesContainer = forecastTypesContainer {
            forecastTypesDecoded0 = [Swift.String]()
            for string0 in forecastTypesContainer {
                if let string0 = string0 {
                    forecastTypesDecoded0?.append(string0)
                }
            }
        }
        forecastTypes = forecastTypesDecoded0
        let predictorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let estimatedTimeRemainingInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .estimatedTimeRemainingInMinutes)
        estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutesDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

public struct DescribePredictorBacktestExportJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePredictorBacktestExportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePredictorBacktestExportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePredictorBacktestExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePredictorBacktestExportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePredictorBacktestExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePredictorBacktestExportJobOutputError>
}

extension DescribePredictorBacktestExportJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribePredictorBacktestExportJobInput(predictorBacktestExportJobArn: \(Swift.String(describing: predictorBacktestExportJobArn)))"}
}

extension DescribePredictorBacktestExportJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorBacktestExportJobArn = "PredictorBacktestExportJobArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let predictorBacktestExportJobArn = predictorBacktestExportJobArn {
            try encodeContainer.encode(predictorBacktestExportJobArn, forKey: .predictorBacktestExportJobArn)
        }
    }
}

public struct DescribePredictorBacktestExportJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePredictorBacktestExportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePredictorBacktestExportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePredictorBacktestExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePredictorBacktestExportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePredictorBacktestExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePredictorBacktestExportJobOutputError>
}

public struct DescribePredictorBacktestExportJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePredictorBacktestExportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePredictorBacktestExportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePredictorBacktestExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePredictorBacktestExportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePredictorBacktestExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePredictorBacktestExportJobOutputError>
}

public struct DescribePredictorBacktestExportJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePredictorBacktestExportJobInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribePredictorBacktestExportJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePredictorBacktestExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribePredictorBacktestExportJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePredictorBacktestExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePredictorBacktestExportJobOutputError>
}

public struct DescribePredictorBacktestExportJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the predictor backtest export job.
    /// This member is required.
    public var predictorBacktestExportJobArn: Swift.String?

    public init (
        predictorBacktestExportJobArn: Swift.String? = nil
    )
    {
        self.predictorBacktestExportJobArn = predictorBacktestExportJobArn
    }
}

struct DescribePredictorBacktestExportJobInputBody: Swift.Equatable {
    public let predictorBacktestExportJobArn: Swift.String?
}

extension DescribePredictorBacktestExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorBacktestExportJobArn = "PredictorBacktestExportJobArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorBacktestExportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorBacktestExportJobArn)
        predictorBacktestExportJobArn = predictorBacktestExportJobArnDecoded
    }
}

extension DescribePredictorBacktestExportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePredictorBacktestExportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePredictorBacktestExportJobOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePredictorBacktestExportJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribePredictorBacktestExportJobOutputResponse(creationTime: \(Swift.String(describing: creationTime)), destination: \(Swift.String(describing: destination)), lastModificationTime: \(Swift.String(describing: lastModificationTime)), message: \(Swift.String(describing: message)), predictorArn: \(Swift.String(describing: predictorArn)), predictorBacktestExportJobArn: \(Swift.String(describing: predictorBacktestExportJobArn)), predictorBacktestExportJobName: \(Swift.String(describing: predictorBacktestExportJobName)), status: \(Swift.String(describing: status)))"}
}

extension DescribePredictorBacktestExportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribePredictorBacktestExportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.destination = output.destination
            self.lastModificationTime = output.lastModificationTime
            self.message = output.message
            self.predictorArn = output.predictorArn
            self.predictorBacktestExportJobArn = output.predictorBacktestExportJobArn
            self.predictorBacktestExportJobName = output.predictorBacktestExportJobName
            self.status = output.status
        } else {
            self.creationTime = nil
            self.destination = nil
            self.lastModificationTime = nil
            self.message = nil
            self.predictorArn = nil
            self.predictorBacktestExportJobArn = nil
            self.predictorBacktestExportJobName = nil
            self.status = nil
        }
    }
}

public struct DescribePredictorBacktestExportJobOutputResponse: Swift.Equatable {
    /// When the predictor backtest export job was created.
    public var creationTime: ClientRuntime.Date?
    /// The destination for an export job. Provide an S3 path, an AWS Identity and Access Management (IAM) role that allows Amazon Forecast
    ///       to access the location, and an AWS Key Management Service (KMS) key (optional).
    public var destination: ForecastClientTypes.DataDestination?
    /// The last time the resource was modified. The timestamp depends on the status of the job:
    ///
    ///
    ///
    ///                   CREATE_PENDING - The CreationTime.
    ///
    ///
    ///
    ///                   CREATE_IN_PROGRESS - The current timestamp.
    ///
    ///
    ///
    ///                   CREATE_STOPPING - The current timestamp.
    ///
    ///
    ///
    ///                   CREATE_STOPPED - When the job stopped.
    ///
    ///
    ///
    ///                   ACTIVE or CREATE_FAILED - When the job finished or
    ///                     failed.
    ///
    ///
    public var lastModificationTime: ClientRuntime.Date?
    /// Information about any errors that may have occurred during the backtest export.
    public var message: Swift.String?
    /// The Amazon Resource Name (ARN) of the predictor.
    public var predictorArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the predictor backtest export job.
    public var predictorBacktestExportJobArn: Swift.String?
    /// The name of the predictor backtest export job.
    public var predictorBacktestExportJobName: Swift.String?
    /// The status of the predictor backtest export job. States include:
    ///
    ///
    ///
    ///                   ACTIVE
    ///
    ///
    ///
    ///
    ///                   CREATE_PENDING, CREATE_IN_PROGRESS,
    ///                     CREATE_FAILED
    ///
    ///
    ///
    ///
    ///                     CREATE_STOPPING, CREATE_STOPPED
    ///
    ///
    ///
    ///
    ///                   DELETE_PENDING, DELETE_IN_PROGRESS,
    ///                     DELETE_FAILED
    ///
    ///
    ///
    public var status: Swift.String?

    public init (
        creationTime: ClientRuntime.Date? = nil,
        destination: ForecastClientTypes.DataDestination? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        message: Swift.String? = nil,
        predictorArn: Swift.String? = nil,
        predictorBacktestExportJobArn: Swift.String? = nil,
        predictorBacktestExportJobName: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.destination = destination
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.predictorArn = predictorArn
        self.predictorBacktestExportJobArn = predictorBacktestExportJobArn
        self.predictorBacktestExportJobName = predictorBacktestExportJobName
        self.status = status
    }
}

struct DescribePredictorBacktestExportJobOutputResponseBody: Swift.Equatable {
    public let predictorBacktestExportJobArn: Swift.String?
    public let predictorBacktestExportJobName: Swift.String?
    public let predictorArn: Swift.String?
    public let destination: ForecastClientTypes.DataDestination?
    public let message: Swift.String?
    public let status: Swift.String?
    public let creationTime: ClientRuntime.Date?
    public let lastModificationTime: ClientRuntime.Date?
}

extension DescribePredictorBacktestExportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case destination = "Destination"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case predictorArn = "PredictorArn"
        case predictorBacktestExportJobArn = "PredictorBacktestExportJobArn"
        case predictorBacktestExportJobName = "PredictorBacktestExportJobName"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorBacktestExportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorBacktestExportJobArn)
        predictorBacktestExportJobArn = predictorBacktestExportJobArnDecoded
        let predictorBacktestExportJobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorBacktestExportJobName)
        predictorBacktestExportJobName = predictorBacktestExportJobNameDecoded
        let predictorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataDestination.self, forKey: .destination)
        destination = destinationDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

public struct DescribePredictorInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePredictorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePredictorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePredictorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePredictorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePredictorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePredictorOutputError>
}

extension DescribePredictorInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribePredictorInput(predictorArn: \(Swift.String(describing: predictorArn)))"}
}

extension DescribePredictorInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorArn = "PredictorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let predictorArn = predictorArn {
            try encodeContainer.encode(predictorArn, forKey: .predictorArn)
        }
    }
}

public struct DescribePredictorInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePredictorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePredictorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePredictorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePredictorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePredictorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePredictorOutputError>
}

public struct DescribePredictorInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePredictorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePredictorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePredictorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePredictorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePredictorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePredictorOutputError>
}

public struct DescribePredictorInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePredictorInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribePredictorInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePredictorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribePredictorInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePredictorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePredictorOutputError>
}

public struct DescribePredictorInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the predictor that you want information about.
    /// This member is required.
    public var predictorArn: Swift.String?

    public init (
        predictorArn: Swift.String? = nil
    )
    {
        self.predictorArn = predictorArn
    }
}

struct DescribePredictorInputBody: Swift.Equatable {
    public let predictorArn: Swift.String?
}

extension DescribePredictorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorArn = "PredictorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
    }
}

extension DescribePredictorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePredictorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePredictorOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePredictorOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribePredictorOutputResponse(algorithmArn: \(Swift.String(describing: algorithmArn)), autoMLAlgorithmArns: \(Swift.String(describing: autoMLAlgorithmArns)), autoMLOverrideStrategy: \(Swift.String(describing: autoMLOverrideStrategy)), creationTime: \(Swift.String(describing: creationTime)), datasetImportJobArns: \(Swift.String(describing: datasetImportJobArns)), encryptionConfig: \(Swift.String(describing: encryptionConfig)), estimatedTimeRemainingInMinutes: \(Swift.String(describing: estimatedTimeRemainingInMinutes)), evaluationParameters: \(Swift.String(describing: evaluationParameters)), featurizationConfig: \(Swift.String(describing: featurizationConfig)), forecastHorizon: \(Swift.String(describing: forecastHorizon)), forecastTypes: \(Swift.String(describing: forecastTypes)), hPOConfig: \(Swift.String(describing: hPOConfig)), inputDataConfig: \(Swift.String(describing: inputDataConfig)), lastModificationTime: \(Swift.String(describing: lastModificationTime)), message: \(Swift.String(describing: message)), optimizationMetric: \(Swift.String(describing: optimizationMetric)), performAutoML: \(Swift.String(describing: performAutoML)), performHPO: \(Swift.String(describing: performHPO)), predictorArn: \(Swift.String(describing: predictorArn)), predictorExecutionDetails: \(Swift.String(describing: predictorExecutionDetails)), predictorName: \(Swift.String(describing: predictorName)), status: \(Swift.String(describing: status)), trainingParameters: \(Swift.String(describing: trainingParameters)))"}
}

extension DescribePredictorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribePredictorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.algorithmArn = output.algorithmArn
            self.autoMLAlgorithmArns = output.autoMLAlgorithmArns
            self.autoMLOverrideStrategy = output.autoMLOverrideStrategy
            self.creationTime = output.creationTime
            self.datasetImportJobArns = output.datasetImportJobArns
            self.encryptionConfig = output.encryptionConfig
            self.estimatedTimeRemainingInMinutes = output.estimatedTimeRemainingInMinutes
            self.evaluationParameters = output.evaluationParameters
            self.featurizationConfig = output.featurizationConfig
            self.forecastHorizon = output.forecastHorizon
            self.forecastTypes = output.forecastTypes
            self.hPOConfig = output.hPOConfig
            self.inputDataConfig = output.inputDataConfig
            self.lastModificationTime = output.lastModificationTime
            self.message = output.message
            self.optimizationMetric = output.optimizationMetric
            self.performAutoML = output.performAutoML
            self.performHPO = output.performHPO
            self.predictorArn = output.predictorArn
            self.predictorExecutionDetails = output.predictorExecutionDetails
            self.predictorName = output.predictorName
            self.status = output.status
            self.trainingParameters = output.trainingParameters
        } else {
            self.algorithmArn = nil
            self.autoMLAlgorithmArns = nil
            self.autoMLOverrideStrategy = nil
            self.creationTime = nil
            self.datasetImportJobArns = nil
            self.encryptionConfig = nil
            self.estimatedTimeRemainingInMinutes = nil
            self.evaluationParameters = nil
            self.featurizationConfig = nil
            self.forecastHorizon = nil
            self.forecastTypes = nil
            self.hPOConfig = nil
            self.inputDataConfig = nil
            self.lastModificationTime = nil
            self.message = nil
            self.optimizationMetric = nil
            self.performAutoML = nil
            self.performHPO = nil
            self.predictorArn = nil
            self.predictorExecutionDetails = nil
            self.predictorName = nil
            self.status = nil
            self.trainingParameters = nil
        }
    }
}

public struct DescribePredictorOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the algorithm used for model training.
    public var algorithmArn: Swift.String?
    /// When PerformAutoML is specified, the ARN of the chosen algorithm.
    public var autoMLAlgorithmArns: [Swift.String]?
    ///
    ///              The LatencyOptimized AutoML override strategy is only available in private beta.
    ///                 Contact AWS Support or your account manager to learn more about access privileges.
    ///
    ///
    ///         The AutoML strategy used to train the predictor. Unless LatencyOptimized
    ///             is specified, the AutoML strategy optimizes predictor accuracy.
    ///         This parameter is only valid for predictors trained using AutoML.
    public var autoMLOverrideStrategy: ForecastClientTypes.AutoMLOverrideStrategy?
    /// When the model training task was created.
    public var creationTime: ClientRuntime.Date?
    /// An array of the ARNs of the dataset import jobs used to import training data for the
    ///       predictor.
    public var datasetImportJobArns: [Swift.String]?
    /// An AWS Key Management Service (KMS) key and the AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access
    ///       the key.
    public var encryptionConfig: ForecastClientTypes.EncryptionConfig?
    /// The estimated time remaining in minutes for the predictor training job to complete.
    public var estimatedTimeRemainingInMinutes: Swift.Int?
    /// Used to override the default evaluation parameters of the specified algorithm. Amazon Forecast
    ///       evaluates a predictor by splitting a dataset into training data and testing data. The
    ///       evaluation parameters define how to perform the split and the number of iterations.
    public var evaluationParameters: ForecastClientTypes.EvaluationParameters?
    /// The featurization configuration.
    public var featurizationConfig: ForecastClientTypes.FeaturizationConfig?
    /// The number of time-steps of the forecast. The forecast horizon is also called the
    ///       prediction length.
    public var forecastHorizon: Swift.Int?
    /// The forecast types used during predictor training. Default value is ["0.1","0.5","0.9"]
    ///
    public var forecastTypes: [Swift.String]?
    /// The hyperparameter override values for the algorithm.
    public var hPOConfig: ForecastClientTypes.HyperParameterTuningJobConfig?
    /// Describes the dataset group that contains the data to use to train the predictor.
    public var inputDataConfig: ForecastClientTypes.InputDataConfig?
    /// The last time the resource was modified. The timestamp depends on the status of the job:
    ///
    ///
    ///
    ///                   CREATE_PENDING - The CreationTime.
    ///
    ///
    ///
    ///                   CREATE_IN_PROGRESS - The current timestamp.
    ///
    ///
    ///
    ///                   CREATE_STOPPING - The current timestamp.
    ///
    ///
    ///
    ///                   CREATE_STOPPED - When the job stopped.
    ///
    ///
    ///
    ///                   ACTIVE or CREATE_FAILED - When the job finished or
    ///           failed.
    ///
    ///
    public var lastModificationTime: ClientRuntime.Date?
    /// If an error occurred, an informational message about the error.
    public var message: Swift.String?
    /// The accuracy metric used to optimize the predictor.
    public var optimizationMetric: ForecastClientTypes.OptimizationMetric?
    /// Whether the predictor is set to perform AutoML.
    public var performAutoML: Swift.Bool?
    /// Whether the predictor is set to perform hyperparameter optimization (HPO).
    public var performHPO: Swift.Bool?
    /// The ARN of the predictor.
    public var predictorArn: Swift.String?
    /// Details on the the status and results of the backtests performed to evaluate the accuracy
    ///       of the predictor. You specify the number of backtests to perform when you call the  operation.
    public var predictorExecutionDetails: ForecastClientTypes.PredictorExecutionDetails?
    /// The name of the predictor.
    public var predictorName: Swift.String?
    /// The status of the predictor. States include:
    ///
    ///
    ///
    ///                   ACTIVE
    ///
    ///
    ///
    ///
    ///                   CREATE_PENDING, CREATE_IN_PROGRESS,
    ///           CREATE_FAILED
    ///
    ///
    ///
    ///
    ///                   DELETE_PENDING, DELETE_IN_PROGRESS,
    ///           DELETE_FAILED
    ///
    ///
    ///
    ///
    ///                   CREATE_STOPPING, CREATE_STOPPED
    ///
    ///
    ///
    ///
    ///             The Status of the predictor must be ACTIVE before you can use
    ///         the predictor to create a forecast.
    ///
    public var status: Swift.String?
    /// The default training parameters or overrides selected during model training. When running
    ///       AutoML or choosing HPO with CNN-QR or DeepAR+, the optimized values for the chosen
    ///       hyperparameters are returned. For more information, see aws-forecast-choosing-recipes.
    public var trainingParameters: [Swift.String:Swift.String]?

    public init (
        algorithmArn: Swift.String? = nil,
        autoMLAlgorithmArns: [Swift.String]? = nil,
        autoMLOverrideStrategy: ForecastClientTypes.AutoMLOverrideStrategy? = nil,
        creationTime: ClientRuntime.Date? = nil,
        datasetImportJobArns: [Swift.String]? = nil,
        encryptionConfig: ForecastClientTypes.EncryptionConfig? = nil,
        estimatedTimeRemainingInMinutes: Swift.Int? = nil,
        evaluationParameters: ForecastClientTypes.EvaluationParameters? = nil,
        featurizationConfig: ForecastClientTypes.FeaturizationConfig? = nil,
        forecastHorizon: Swift.Int? = nil,
        forecastTypes: [Swift.String]? = nil,
        hPOConfig: ForecastClientTypes.HyperParameterTuningJobConfig? = nil,
        inputDataConfig: ForecastClientTypes.InputDataConfig? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        message: Swift.String? = nil,
        optimizationMetric: ForecastClientTypes.OptimizationMetric? = nil,
        performAutoML: Swift.Bool? = nil,
        performHPO: Swift.Bool? = nil,
        predictorArn: Swift.String? = nil,
        predictorExecutionDetails: ForecastClientTypes.PredictorExecutionDetails? = nil,
        predictorName: Swift.String? = nil,
        status: Swift.String? = nil,
        trainingParameters: [Swift.String:Swift.String]? = nil
    )
    {
        self.algorithmArn = algorithmArn
        self.autoMLAlgorithmArns = autoMLAlgorithmArns
        self.autoMLOverrideStrategy = autoMLOverrideStrategy
        self.creationTime = creationTime
        self.datasetImportJobArns = datasetImportJobArns
        self.encryptionConfig = encryptionConfig
        self.estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutes
        self.evaluationParameters = evaluationParameters
        self.featurizationConfig = featurizationConfig
        self.forecastHorizon = forecastHorizon
        self.forecastTypes = forecastTypes
        self.hPOConfig = hPOConfig
        self.inputDataConfig = inputDataConfig
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.optimizationMetric = optimizationMetric
        self.performAutoML = performAutoML
        self.performHPO = performHPO
        self.predictorArn = predictorArn
        self.predictorExecutionDetails = predictorExecutionDetails
        self.predictorName = predictorName
        self.status = status
        self.trainingParameters = trainingParameters
    }
}

struct DescribePredictorOutputResponseBody: Swift.Equatable {
    public let predictorArn: Swift.String?
    public let predictorName: Swift.String?
    public let algorithmArn: Swift.String?
    public let forecastHorizon: Swift.Int?
    public let forecastTypes: [Swift.String]?
    public let performAutoML: Swift.Bool?
    public let autoMLOverrideStrategy: ForecastClientTypes.AutoMLOverrideStrategy?
    public let performHPO: Swift.Bool?
    public let trainingParameters: [Swift.String:Swift.String]?
    public let evaluationParameters: ForecastClientTypes.EvaluationParameters?
    public let hPOConfig: ForecastClientTypes.HyperParameterTuningJobConfig?
    public let inputDataConfig: ForecastClientTypes.InputDataConfig?
    public let featurizationConfig: ForecastClientTypes.FeaturizationConfig?
    public let encryptionConfig: ForecastClientTypes.EncryptionConfig?
    public let predictorExecutionDetails: ForecastClientTypes.PredictorExecutionDetails?
    public let estimatedTimeRemainingInMinutes: Swift.Int?
    public let datasetImportJobArns: [Swift.String]?
    public let autoMLAlgorithmArns: [Swift.String]?
    public let status: Swift.String?
    public let message: Swift.String?
    public let creationTime: ClientRuntime.Date?
    public let lastModificationTime: ClientRuntime.Date?
    public let optimizationMetric: ForecastClientTypes.OptimizationMetric?
}

extension DescribePredictorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithmArn = "AlgorithmArn"
        case autoMLAlgorithmArns = "AutoMLAlgorithmArns"
        case autoMLOverrideStrategy = "AutoMLOverrideStrategy"
        case creationTime = "CreationTime"
        case datasetImportJobArns = "DatasetImportJobArns"
        case encryptionConfig = "EncryptionConfig"
        case estimatedTimeRemainingInMinutes = "EstimatedTimeRemainingInMinutes"
        case evaluationParameters = "EvaluationParameters"
        case featurizationConfig = "FeaturizationConfig"
        case forecastHorizon = "ForecastHorizon"
        case forecastTypes = "ForecastTypes"
        case hPOConfig = "HPOConfig"
        case inputDataConfig = "InputDataConfig"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case optimizationMetric = "OptimizationMetric"
        case performAutoML = "PerformAutoML"
        case performHPO = "PerformHPO"
        case predictorArn = "PredictorArn"
        case predictorExecutionDetails = "PredictorExecutionDetails"
        case predictorName = "PredictorName"
        case status = "Status"
        case trainingParameters = "TrainingParameters"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
        let predictorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorName)
        predictorName = predictorNameDecoded
        let algorithmArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .algorithmArn)
        algorithmArn = algorithmArnDecoded
        let forecastHorizonDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .forecastHorizon)
        forecastHorizon = forecastHorizonDecoded
        let forecastTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .forecastTypes)
        var forecastTypesDecoded0:[Swift.String]? = nil
        if let forecastTypesContainer = forecastTypesContainer {
            forecastTypesDecoded0 = [Swift.String]()
            for string0 in forecastTypesContainer {
                if let string0 = string0 {
                    forecastTypesDecoded0?.append(string0)
                }
            }
        }
        forecastTypes = forecastTypesDecoded0
        let performAutoMLDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .performAutoML)
        performAutoML = performAutoMLDecoded
        let autoMLOverrideStrategyDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.AutoMLOverrideStrategy.self, forKey: .autoMLOverrideStrategy)
        autoMLOverrideStrategy = autoMLOverrideStrategyDecoded
        let performHPODecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .performHPO)
        performHPO = performHPODecoded
        let trainingParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .trainingParameters)
        var trainingParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let trainingParametersContainer = trainingParametersContainer {
            trainingParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametervalue0) in trainingParametersContainer {
                if let parametervalue0 = parametervalue0 {
                    trainingParametersDecoded0?[key0] = parametervalue0
                }
            }
        }
        trainingParameters = trainingParametersDecoded0
        let evaluationParametersDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.EvaluationParameters.self, forKey: .evaluationParameters)
        evaluationParameters = evaluationParametersDecoded
        let hPOConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.HyperParameterTuningJobConfig.self, forKey: .hPOConfig)
        hPOConfig = hPOConfigDecoded
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let featurizationConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.FeaturizationConfig.self, forKey: .featurizationConfig)
        featurizationConfig = featurizationConfigDecoded
        let encryptionConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.EncryptionConfig.self, forKey: .encryptionConfig)
        encryptionConfig = encryptionConfigDecoded
        let predictorExecutionDetailsDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.PredictorExecutionDetails.self, forKey: .predictorExecutionDetails)
        predictorExecutionDetails = predictorExecutionDetailsDecoded
        let estimatedTimeRemainingInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .estimatedTimeRemainingInMinutes)
        estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutesDecoded
        let datasetImportJobArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .datasetImportJobArns)
        var datasetImportJobArnsDecoded0:[Swift.String]? = nil
        if let datasetImportJobArnsContainer = datasetImportJobArnsContainer {
            datasetImportJobArnsDecoded0 = [Swift.String]()
            for string0 in datasetImportJobArnsContainer {
                if let string0 = string0 {
                    datasetImportJobArnsDecoded0?.append(string0)
                }
            }
        }
        datasetImportJobArns = datasetImportJobArnsDecoded0
        let autoMLAlgorithmArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .autoMLAlgorithmArns)
        var autoMLAlgorithmArnsDecoded0:[Swift.String]? = nil
        if let autoMLAlgorithmArnsContainer = autoMLAlgorithmArnsContainer {
            autoMLAlgorithmArnsDecoded0 = [Swift.String]()
            for string0 in autoMLAlgorithmArnsContainer {
                if let string0 = string0 {
                    autoMLAlgorithmArnsDecoded0?.append(string0)
                }
            }
        }
        autoMLAlgorithmArns = autoMLAlgorithmArnsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
        let optimizationMetricDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.OptimizationMetric.self, forKey: .optimizationMetric)
        optimizationMetric = optimizationMetricDecoded
    }
}

extension ForecastClientTypes {
    public enum Domain: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case custom
        case ec2Capacity
        case inventoryPlanning
        case metrics
        case retail
        case webTraffic
        case workForce
        case sdkUnknown(Swift.String)

        public static var allCases: [Domain] {
            return [
                .custom,
                .ec2Capacity,
                .inventoryPlanning,
                .metrics,
                .retail,
                .webTraffic,
                .workForce,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .custom: return "CUSTOM"
            case .ec2Capacity: return "EC2_CAPACITY"
            case .inventoryPlanning: return "INVENTORY_PLANNING"
            case .metrics: return "METRICS"
            case .retail: return "RETAIL"
            case .webTraffic: return "WEB_TRAFFIC"
            case .workForce: return "WORK_FORCE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Domain(rawValue: rawValue) ?? Domain.sdkUnknown(rawValue)
        }
    }
}

extension ForecastClientTypes.EncryptionConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kMSKeyArn = "KMSKeyArn"
        case roleArn = "RoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kMSKeyArn = kMSKeyArn {
            try encodeContainer.encode(kMSKeyArn, forKey: .kMSKeyArn)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let kMSKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSKeyArn)
        kMSKeyArn = kMSKeyArnDecoded
    }
}

extension ForecastClientTypes.EncryptionConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EncryptionConfig(kMSKeyArn: \(Swift.String(describing: kMSKeyArn)), roleArn: \(Swift.String(describing: roleArn)))"}
}

extension ForecastClientTypes {
    /// An AWS Key Management Service (KMS) key and an AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to
    ///       access the key. You can specify this optional object in the
    ///       CreateDataset and CreatePredictor requests.
    public struct EncryptionConfig: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the KMS key.
        /// This member is required.
        public var kMSKeyArn: Swift.String?
        /// The ARN of the IAM role that Amazon Forecast can assume to access the AWS KMS key.
        ///          Passing a role across AWS accounts is not allowed. If you pass a role that isn't in your
        ///       account, you get an InvalidInputException error.
        /// This member is required.
        public var roleArn: Swift.String?

        public init (
            kMSKeyArn: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.kMSKeyArn = kMSKeyArn
            self.roleArn = roleArn
        }
    }

}

extension ForecastClientTypes.ErrorMetric: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastType = "ForecastType"
        case mAPE = "MAPE"
        case mASE = "MASE"
        case rMSE = "RMSE"
        case wAPE = "WAPE"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forecastType = forecastType {
            try encodeContainer.encode(forecastType, forKey: .forecastType)
        }
        if let mAPE = mAPE {
            try encodeContainer.encode(mAPE, forKey: .mAPE)
        }
        if let mASE = mASE {
            try encodeContainer.encode(mASE, forKey: .mASE)
        }
        if let rMSE = rMSE {
            try encodeContainer.encode(rMSE, forKey: .rMSE)
        }
        if let wAPE = wAPE {
            try encodeContainer.encode(wAPE, forKey: .wAPE)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastType)
        forecastType = forecastTypeDecoded
        let wAPEDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .wAPE)
        wAPE = wAPEDecoded
        let rMSEDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .rMSE)
        rMSE = rMSEDecoded
        let mASEDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .mASE)
        mASE = mASEDecoded
        let mAPEDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .mAPE)
        mAPE = mAPEDecoded
    }
}

extension ForecastClientTypes.ErrorMetric: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ErrorMetric(forecastType: \(Swift.String(describing: forecastType)), mAPE: \(Swift.String(describing: mAPE)), mASE: \(Swift.String(describing: mASE)), rMSE: \(Swift.String(describing: rMSE)), wAPE: \(Swift.String(describing: wAPE)))"}
}

extension ForecastClientTypes {
    ///  Provides detailed error metrics to evaluate the performance of a predictor. This object
    ///       is part of the Metrics object.
    public struct ErrorMetric: Swift.Equatable {
        ///  The Forecast type used to compute WAPE, MAPE, MASE, and RMSE.
        public var forecastType: Swift.String?
        /// The Mean Absolute Percentage Error (MAPE)
        public var mAPE: Swift.Double?
        /// The Mean Absolute Scaled Error (MASE)
        public var mASE: Swift.Double?
        ///  The root-mean-square error (RMSE).
        public var rMSE: Swift.Double?
        ///  The weighted absolute percentage error (WAPE).
        public var wAPE: Swift.Double?

        public init (
            forecastType: Swift.String? = nil,
            mAPE: Swift.Double? = nil,
            mASE: Swift.Double? = nil,
            rMSE: Swift.Double? = nil,
            wAPE: Swift.Double? = nil
        )
        {
            self.forecastType = forecastType
            self.mAPE = mAPE
            self.mASE = mASE
            self.rMSE = rMSE
            self.wAPE = wAPE
        }
    }

}

extension ForecastClientTypes.EvaluationParameters: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backTestWindowOffset = "BackTestWindowOffset"
        case numberOfBacktestWindows = "NumberOfBacktestWindows"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backTestWindowOffset = backTestWindowOffset {
            try encodeContainer.encode(backTestWindowOffset, forKey: .backTestWindowOffset)
        }
        if let numberOfBacktestWindows = numberOfBacktestWindows {
            try encodeContainer.encode(numberOfBacktestWindows, forKey: .numberOfBacktestWindows)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let numberOfBacktestWindowsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfBacktestWindows)
        numberOfBacktestWindows = numberOfBacktestWindowsDecoded
        let backTestWindowOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backTestWindowOffset)
        backTestWindowOffset = backTestWindowOffsetDecoded
    }
}

extension ForecastClientTypes.EvaluationParameters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EvaluationParameters(backTestWindowOffset: \(Swift.String(describing: backTestWindowOffset)), numberOfBacktestWindows: \(Swift.String(describing: numberOfBacktestWindows)))"}
}

extension ForecastClientTypes {
    /// Parameters that define how to split a dataset into training data and testing data, and the
    ///       number of iterations to perform. These parameters are specified in the predefined algorithms
    ///       but you can override them in the CreatePredictor request.
    public struct EvaluationParameters: Swift.Equatable {
        /// The point from the end of the dataset where you want to split the data for model training
        ///       and testing (evaluation). Specify the value as the number of data points. The default is the
        ///       value of the forecast horizon. BackTestWindowOffset can be used to mimic a past
        ///       virtual forecast start date. This value must be greater than or equal to the forecast horizon
        ///       and less than half of the TARGET_TIME_SERIES dataset length.
        ///
        ///             ForecastHorizon <= BackTestWindowOffset < 1/2 *
        ///       TARGET_TIME_SERIES dataset length
        public var backTestWindowOffset: Swift.Int?
        /// The number of times to split the input data. The default is 1. Valid values are 1 through
        ///       5.
        public var numberOfBacktestWindows: Swift.Int?

        public init (
            backTestWindowOffset: Swift.Int? = nil,
            numberOfBacktestWindows: Swift.Int? = nil
        )
        {
            self.backTestWindowOffset = backTestWindowOffset
            self.numberOfBacktestWindows = numberOfBacktestWindows
        }
    }

}

extension ForecastClientTypes.EvaluationResult: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithmArn = "AlgorithmArn"
        case testWindows = "TestWindows"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let algorithmArn = algorithmArn {
            try encodeContainer.encode(algorithmArn, forKey: .algorithmArn)
        }
        if let testWindows = testWindows {
            var testWindowsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .testWindows)
            for testwindows0 in testWindows {
                try testWindowsContainer.encode(testwindows0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let algorithmArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .algorithmArn)
        algorithmArn = algorithmArnDecoded
        let testWindowsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.WindowSummary?].self, forKey: .testWindows)
        var testWindowsDecoded0:[ForecastClientTypes.WindowSummary]? = nil
        if let testWindowsContainer = testWindowsContainer {
            testWindowsDecoded0 = [ForecastClientTypes.WindowSummary]()
            for structure0 in testWindowsContainer {
                if let structure0 = structure0 {
                    testWindowsDecoded0?.append(structure0)
                }
            }
        }
        testWindows = testWindowsDecoded0
    }
}

extension ForecastClientTypes.EvaluationResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EvaluationResult(algorithmArn: \(Swift.String(describing: algorithmArn)), testWindows: \(Swift.String(describing: testWindows)))"}
}

extension ForecastClientTypes {
    /// The results of evaluating an algorithm. Returned as part of the GetAccuracyMetrics response.
    public struct EvaluationResult: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the algorithm that was evaluated.
        public var algorithmArn: Swift.String?
        /// The array of test windows used for evaluating the algorithm. The
        ///         NumberOfBacktestWindows from the EvaluationParameters object
        ///       determines the number of windows in the array.
        public var testWindows: [ForecastClientTypes.WindowSummary]?

        public init (
            algorithmArn: Swift.String? = nil,
            testWindows: [ForecastClientTypes.WindowSummary]? = nil
        )
        {
            self.algorithmArn = algorithmArn
            self.testWindows = testWindows
        }
    }

}

extension ForecastClientTypes {
    public enum EvaluationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case computed
        case summary
        case sdkUnknown(Swift.String)

        public static var allCases: [EvaluationType] {
            return [
                .computed,
                .summary,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .computed: return "COMPUTED"
            case .summary: return "SUMMARY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EvaluationType(rawValue: rawValue) ?? EvaluationType.sdkUnknown(rawValue)
        }
    }
}

extension ForecastClientTypes.Featurization: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "AttributeName"
        case featurizationPipeline = "FeaturizationPipeline"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = attributeName {
            try encodeContainer.encode(attributeName, forKey: .attributeName)
        }
        if let featurizationPipeline = featurizationPipeline {
            var featurizationPipelineContainer = encodeContainer.nestedUnkeyedContainer(forKey: .featurizationPipeline)
            for featurizationpipeline0 in featurizationPipeline {
                try featurizationPipelineContainer.encode(featurizationpipeline0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let featurizationPipelineContainer = try containerValues.decodeIfPresent([ForecastClientTypes.FeaturizationMethod?].self, forKey: .featurizationPipeline)
        var featurizationPipelineDecoded0:[ForecastClientTypes.FeaturizationMethod]? = nil
        if let featurizationPipelineContainer = featurizationPipelineContainer {
            featurizationPipelineDecoded0 = [ForecastClientTypes.FeaturizationMethod]()
            for structure0 in featurizationPipelineContainer {
                if let structure0 = structure0 {
                    featurizationPipelineDecoded0?.append(structure0)
                }
            }
        }
        featurizationPipeline = featurizationPipelineDecoded0
    }
}

extension ForecastClientTypes.Featurization: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Featurization(attributeName: \(Swift.String(describing: attributeName)), featurizationPipeline: \(Swift.String(describing: featurizationPipeline)))"}
}

extension ForecastClientTypes {
    /// Provides featurization (transformation) information for a dataset field. This object
    ///       is part of the FeaturizationConfig object.
    ///          For example:
    ///
    ///             {
    ///
    ///
    ///             "AttributeName": "demand",
    ///
    ///
    ///             FeaturizationPipeline [ {
    ///
    ///
    ///
    ///             "FeaturizationMethodName": "filling",
    ///
    ///
    ///             "FeaturizationMethodParameters": {"aggregation": "avg", "backfill": "nan"}
    ///
    ///
    ///             } ]
    ///
    ///
    ///             }
    ///
    public struct Featurization: Swift.Equatable {
        /// The name of the schema attribute that specifies the data field to be featurized. Amazon Forecast supports the target field of
        ///       the TARGET_TIME_SERIES and the RELATED_TIME_SERIES datasets. For example, for the RETAIL domain, the target is
        ///       demand, and for the CUSTOM domain, the target is
        ///       target_value.
        ///       For more information, see howitworks-missing-values.
        /// This member is required.
        public var attributeName: Swift.String?
        /// An array of one FeaturizationMethod object that specifies the feature
        ///       transformation method.
        public var featurizationPipeline: [ForecastClientTypes.FeaturizationMethod]?

        public init (
            attributeName: Swift.String? = nil,
            featurizationPipeline: [ForecastClientTypes.FeaturizationMethod]? = nil
        )
        {
            self.attributeName = attributeName
            self.featurizationPipeline = featurizationPipeline
        }
    }

}

extension ForecastClientTypes.FeaturizationConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case featurizations = "Featurizations"
        case forecastDimensions = "ForecastDimensions"
        case forecastFrequency = "ForecastFrequency"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let featurizations = featurizations {
            var featurizationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .featurizations)
            for featurizations0 in featurizations {
                try featurizationsContainer.encode(featurizations0)
            }
        }
        if let forecastDimensions = forecastDimensions {
            var forecastDimensionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .forecastDimensions)
            for forecastdimensions0 in forecastDimensions {
                try forecastDimensionsContainer.encode(forecastdimensions0)
            }
        }
        if let forecastFrequency = forecastFrequency {
            try encodeContainer.encode(forecastFrequency, forKey: .forecastFrequency)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastFrequencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastFrequency)
        forecastFrequency = forecastFrequencyDecoded
        let forecastDimensionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .forecastDimensions)
        var forecastDimensionsDecoded0:[Swift.String]? = nil
        if let forecastDimensionsContainer = forecastDimensionsContainer {
            forecastDimensionsDecoded0 = [Swift.String]()
            for string0 in forecastDimensionsContainer {
                if let string0 = string0 {
                    forecastDimensionsDecoded0?.append(string0)
                }
            }
        }
        forecastDimensions = forecastDimensionsDecoded0
        let featurizationsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Featurization?].self, forKey: .featurizations)
        var featurizationsDecoded0:[ForecastClientTypes.Featurization]? = nil
        if let featurizationsContainer = featurizationsContainer {
            featurizationsDecoded0 = [ForecastClientTypes.Featurization]()
            for structure0 in featurizationsContainer {
                if let structure0 = structure0 {
                    featurizationsDecoded0?.append(structure0)
                }
            }
        }
        featurizations = featurizationsDecoded0
    }
}

extension ForecastClientTypes.FeaturizationConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FeaturizationConfig(featurizations: \(Swift.String(describing: featurizations)), forecastDimensions: \(Swift.String(describing: forecastDimensions)), forecastFrequency: \(Swift.String(describing: forecastFrequency)))"}
}

extension ForecastClientTypes {
    /// In a CreatePredictor operation, the specified algorithm
    ///       trains a model using the specified dataset group. You can optionally tell the operation
    ///       to modify data fields prior to training a model. These modifications are referred to as
    ///       featurization.
    ///          You define featurization using the FeaturizationConfig object.
    ///       You specify an array of transformations, one for each field that you want to
    ///       featurize. You then include the FeaturizationConfig object in your
    ///       CreatePredictor request. Amazon Forecast applies the featurization to the
    ///       TARGET_TIME_SERIES and RELATED_TIME_SERIES datasets before model training.
    ///          You can create multiple featurization configurations. For example, you
    ///       might call the CreatePredictor operation twice by specifying different
    ///       featurization configurations.
    public struct FeaturizationConfig: Swift.Equatable {
        /// An array of featurization (transformation) information for the fields of a dataset.
        public var featurizations: [ForecastClientTypes.Featurization]?
        /// An array of dimension (field) names that specify how to group the generated forecast.
        ///          For example, suppose that you are generating a forecast for item sales across all of
        ///       your stores, and your dataset contains a store_id field. If you want the sales
        ///       forecast for each item by store, you would specify store_id as the dimension.
        ///          All forecast dimensions specified in the TARGET_TIME_SERIES dataset don't
        ///       need to be specified in the CreatePredictor request.
        ///       All forecast dimensions specified in the RELATED_TIME_SERIES dataset must
        ///       be specified in the CreatePredictor request.
        public var forecastDimensions: [Swift.String]?
        /// The frequency of predictions in a forecast.
        ///          Valid intervals are Y (Year), M (Month), W (Week), D (Day), H (Hour), 30min (30 minutes),
        ///       15min (15 minutes), 10min (10 minutes), 5min (5 minutes), and 1min (1 minute).
        ///       For example, "Y" indicates every year and "5min" indicates every five minutes.
        ///          The frequency must be greater than or equal to the TARGET_TIME_SERIES dataset
        ///       frequency.
        ///          When a RELATED_TIME_SERIES dataset is provided, the frequency must be equal to the
        ///       RELATED_TIME_SERIES dataset frequency.
        /// This member is required.
        public var forecastFrequency: Swift.String?

        public init (
            featurizations: [ForecastClientTypes.Featurization]? = nil,
            forecastDimensions: [Swift.String]? = nil,
            forecastFrequency: Swift.String? = nil
        )
        {
            self.featurizations = featurizations
            self.forecastDimensions = forecastDimensions
            self.forecastFrequency = forecastFrequency
        }
    }

}

extension ForecastClientTypes.FeaturizationMethod: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case featurizationMethodName = "FeaturizationMethodName"
        case featurizationMethodParameters = "FeaturizationMethodParameters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let featurizationMethodName = featurizationMethodName {
            try encodeContainer.encode(featurizationMethodName.rawValue, forKey: .featurizationMethodName)
        }
        if let featurizationMethodParameters = featurizationMethodParameters {
            var featurizationMethodParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .featurizationMethodParameters)
            for (dictKey0, featurizationmethodparameters0) in featurizationMethodParameters {
                try featurizationMethodParametersContainer.encode(featurizationmethodparameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let featurizationMethodNameDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.FeaturizationMethodName.self, forKey: .featurizationMethodName)
        featurizationMethodName = featurizationMethodNameDecoded
        let featurizationMethodParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .featurizationMethodParameters)
        var featurizationMethodParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let featurizationMethodParametersContainer = featurizationMethodParametersContainer {
            featurizationMethodParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametervalue0) in featurizationMethodParametersContainer {
                if let parametervalue0 = parametervalue0 {
                    featurizationMethodParametersDecoded0?[key0] = parametervalue0
                }
            }
        }
        featurizationMethodParameters = featurizationMethodParametersDecoded0
    }
}

extension ForecastClientTypes.FeaturizationMethod: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FeaturizationMethod(featurizationMethodName: \(Swift.String(describing: featurizationMethodName)), featurizationMethodParameters: \(Swift.String(describing: featurizationMethodParameters)))"}
}

extension ForecastClientTypes {
    /// Provides information about the method that featurizes (transforms) a dataset field.
    ///       The method is part of the FeaturizationPipeline of the
    ///       Featurization object.
    ///          The following is an example of how you specify a FeaturizationMethod object.
    ///
    ///             {
    ///
    ///
    ///             "FeaturizationMethodName": "filling",
    ///
    ///
    ///             "FeaturizationMethodParameters": {"aggregation": "sum", "middlefill": "zero", "backfill": "zero"}
    ///
    ///
    ///             }
    ///
    public struct FeaturizationMethod: Swift.Equatable {
        /// The name of the method. The "filling" method is the only supported method.
        /// This member is required.
        public var featurizationMethodName: ForecastClientTypes.FeaturizationMethodName?
        /// The method parameters (key-value pairs), which are a map of override parameters. Specify these parameters to override the default values.
        ///       Related Time Series attributes do not accept aggregation parameters.
        ///          The following list shows the parameters and their valid values for the "filling" featurization method for a Target Time Series dataset. Bold signifies the default
        ///       value.
        ///
        ///
        ///
        ///                   aggregation: sum, avg, first, min, max
        ///
        ///
        ///
        ///
        ///                   frontfill: none
        ///
        ///
        ///
        ///
        ///                   middlefill: zero, nan (not a number), value, median, mean, min, max
        ///
        ///
        ///
        ///
        ///                   backfill: zero, nan, value, median, mean, min, max
        ///
        ///
        ///
        ///
        ///          The following list shows the parameters and their valid values for a Related Time Series featurization method (there are no defaults):
        ///
        ///
        ///
        ///                   middlefill: zero, value, median, mean, min, max
        ///
        ///
        ///
        ///
        ///                   backfill: zero, value, median, mean, min, max
        ///
        ///
        ///
        ///
        ///                   futurefill: zero, value, median, mean, min, max
        ///
        ///
        ///
        ///          To set a filling method to a specific value, set the fill parameter to value
        ///       and define the value in a corresponding _value parameter. For example, to set
        ///       backfilling to a value of 2, include the following: "backfill": "value" and
        ///         "backfill_value":"2".
        public var featurizationMethodParameters: [Swift.String:Swift.String]?

        public init (
            featurizationMethodName: ForecastClientTypes.FeaturizationMethodName? = nil,
            featurizationMethodParameters: [Swift.String:Swift.String]? = nil
        )
        {
            self.featurizationMethodName = featurizationMethodName
            self.featurizationMethodParameters = featurizationMethodParameters
        }
    }

}

extension ForecastClientTypes {
    public enum FeaturizationMethodName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case filling
        case sdkUnknown(Swift.String)

        public static var allCases: [FeaturizationMethodName] {
            return [
                .filling,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .filling: return "filling"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FeaturizationMethodName(rawValue: rawValue) ?? FeaturizationMethodName.sdkUnknown(rawValue)
        }
    }
}

extension ForecastClientTypes.Filter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case condition = "Condition"
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let condition = condition {
            try encodeContainer.encode(condition.rawValue, forKey: .condition)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let conditionDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.FilterConditionString.self, forKey: .condition)
        condition = conditionDecoded
    }
}

extension ForecastClientTypes.Filter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Filter(condition: \(Swift.String(describing: condition)), key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension ForecastClientTypes {
    /// Describes a filter for choosing a subset of objects. Each filter consists of a
    ///       condition and a match statement. The condition is either IS or
    ///       IS_NOT, which specifies whether to include or exclude
    ///       the objects that match the statement, respectively. The match statement consists of a key and a
    ///       value.
    public struct Filter: Swift.Equatable {
        /// The condition to apply. To include the objects that match the statement, specify
        ///       IS. To exclude matching objects, specify IS_NOT.
        /// This member is required.
        public var condition: ForecastClientTypes.FilterConditionString?
        /// The name of the parameter to filter on.
        /// This member is required.
        public var key: Swift.String?
        /// The value to match.
        /// This member is required.
        public var value: Swift.String?

        public init (
            condition: ForecastClientTypes.FilterConditionString? = nil,
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.condition = condition
            self.key = key
            self.value = value
        }
    }

}

extension ForecastClientTypes {
    public enum FilterConditionString: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `is`
        case isNot
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterConditionString] {
            return [
                .is,
                .isNot,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .is: return "IS"
            case .isNot: return "IS_NOT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FilterConditionString(rawValue: rawValue) ?? FilterConditionString.sdkUnknown(rawValue)
        }
    }
}

extension ForecastClientTypes.ForecastExportJobSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case destination = "Destination"
        case forecastExportJobArn = "ForecastExportJobArn"
        case forecastExportJobName = "ForecastExportJobName"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let forecastExportJobArn = forecastExportJobArn {
            try encodeContainer.encode(forecastExportJobArn, forKey: .forecastExportJobArn)
        }
        if let forecastExportJobName = forecastExportJobName {
            try encodeContainer.encode(forecastExportJobName, forKey: .forecastExportJobName)
        }
        if let lastModificationTime = lastModificationTime {
            try encodeContainer.encode(lastModificationTime.timeIntervalSince1970, forKey: .lastModificationTime)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastExportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastExportJobArn)
        forecastExportJobArn = forecastExportJobArnDecoded
        let forecastExportJobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastExportJobName)
        forecastExportJobName = forecastExportJobNameDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataDestination.self, forKey: .destination)
        destination = destinationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension ForecastClientTypes.ForecastExportJobSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ForecastExportJobSummary(creationTime: \(Swift.String(describing: creationTime)), destination: \(Swift.String(describing: destination)), forecastExportJobArn: \(Swift.String(describing: forecastExportJobArn)), forecastExportJobName: \(Swift.String(describing: forecastExportJobName)), lastModificationTime: \(Swift.String(describing: lastModificationTime)), message: \(Swift.String(describing: message)), status: \(Swift.String(describing: status)))"}
}

extension ForecastClientTypes {
    /// Provides a summary of the forecast export job properties used in the ListForecastExportJobs operation. To get the complete set of properties, call
    ///       the DescribeForecastExportJob operation, and provide the listed
    ///         ForecastExportJobArn.
    public struct ForecastExportJobSummary: Swift.Equatable {
        /// When the forecast export job was created.
        public var creationTime: ClientRuntime.Date?
        /// The path to the Amazon Simple Storage Service (Amazon S3) bucket where the forecast is exported.
        public var destination: ForecastClientTypes.DataDestination?
        /// The Amazon Resource Name (ARN) of the forecast export job.
        public var forecastExportJobArn: Swift.String?
        /// The name of the forecast export job.
        public var forecastExportJobName: Swift.String?
        /// The last time the resource was modified. The timestamp depends on the status of the job:
        ///
        ///
        ///
        ///                   CREATE_PENDING - The CreationTime.
        ///
        ///
        ///
        ///                   CREATE_IN_PROGRESS - The current timestamp.
        ///
        ///
        ///
        ///                   CREATE_STOPPING - The current timestamp.
        ///
        ///
        ///
        ///                   CREATE_STOPPED - When the job stopped.
        ///
        ///
        ///
        ///                   ACTIVE or CREATE_FAILED - When the job finished or
        ///           failed.
        ///
        ///
        public var lastModificationTime: ClientRuntime.Date?
        /// If an error occurred, an informational message about the error.
        public var message: Swift.String?
        /// The status of the forecast export job. States include:
        ///
        ///
        ///
        ///                   ACTIVE
        ///
        ///
        ///
        ///
        ///                   CREATE_PENDING, CREATE_IN_PROGRESS,
        ///           CREATE_FAILED
        ///
        ///
        ///
        ///
        ///                   CREATE_STOPPING, CREATE_STOPPED
        ///
        ///
        ///
        ///
        ///                   DELETE_PENDING, DELETE_IN_PROGRESS,
        ///           DELETE_FAILED
        ///
        ///
        ///
        ///
        ///             The Status of the forecast export job must be ACTIVE before
        ///         you can access the forecast in your S3 bucket.
        ///
        public var status: Swift.String?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            destination: ForecastClientTypes.DataDestination? = nil,
            forecastExportJobArn: Swift.String? = nil,
            forecastExportJobName: Swift.String? = nil,
            lastModificationTime: ClientRuntime.Date? = nil,
            message: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.destination = destination
            self.forecastExportJobArn = forecastExportJobArn
            self.forecastExportJobName = forecastExportJobName
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.status = status
        }
    }

}

extension ForecastClientTypes.ForecastSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case datasetGroupArn = "DatasetGroupArn"
        case forecastArn = "ForecastArn"
        case forecastName = "ForecastName"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case predictorArn = "PredictorArn"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let datasetGroupArn = datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let forecastArn = forecastArn {
            try encodeContainer.encode(forecastArn, forKey: .forecastArn)
        }
        if let forecastName = forecastName {
            try encodeContainer.encode(forecastName, forKey: .forecastName)
        }
        if let lastModificationTime = lastModificationTime {
            try encodeContainer.encode(lastModificationTime.timeIntervalSince1970, forKey: .lastModificationTime)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let predictorArn = predictorArn {
            try encodeContainer.encode(predictorArn, forKey: .predictorArn)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastArn)
        forecastArn = forecastArnDecoded
        let forecastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastName)
        forecastName = forecastNameDecoded
        let predictorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension ForecastClientTypes.ForecastSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ForecastSummary(creationTime: \(Swift.String(describing: creationTime)), datasetGroupArn: \(Swift.String(describing: datasetGroupArn)), forecastArn: \(Swift.String(describing: forecastArn)), forecastName: \(Swift.String(describing: forecastName)), lastModificationTime: \(Swift.String(describing: lastModificationTime)), message: \(Swift.String(describing: message)), predictorArn: \(Swift.String(describing: predictorArn)), status: \(Swift.String(describing: status)))"}
}

extension ForecastClientTypes {
    /// Provides a summary of the forecast properties used in the ListForecasts
    ///       operation. To get the complete set of properties, call the DescribeForecast
    ///       operation, and provide the ForecastArn that is listed in the summary.
    public struct ForecastSummary: Swift.Equatable {
        /// When the forecast creation task was created.
        public var creationTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the dataset group that provided the data used to train
        ///       the predictor.
        public var datasetGroupArn: Swift.String?
        /// The ARN of the forecast.
        public var forecastArn: Swift.String?
        /// The name of the forecast.
        public var forecastName: Swift.String?
        /// The last time the resource was modified. The timestamp depends on the status of the job:
        ///
        ///
        ///
        ///                   CREATE_PENDING - The CreationTime.
        ///
        ///
        ///
        ///                   CREATE_IN_PROGRESS - The current timestamp.
        ///
        ///
        ///
        ///                   CREATE_STOPPING - The current timestamp.
        ///
        ///
        ///
        ///                   CREATE_STOPPED - When the job stopped.
        ///
        ///
        ///
        ///                   ACTIVE or CREATE_FAILED - When the job finished or
        ///           failed.
        ///
        ///
        public var lastModificationTime: ClientRuntime.Date?
        /// If an error occurred, an informational message about the error.
        public var message: Swift.String?
        /// The ARN of the predictor used to generate the forecast.
        public var predictorArn: Swift.String?
        /// The status of the forecast. States include:
        ///
        ///
        ///
        ///                   ACTIVE
        ///
        ///
        ///
        ///
        ///                   CREATE_PENDING, CREATE_IN_PROGRESS,
        ///           CREATE_FAILED
        ///
        ///
        ///
        ///
        ///                   CREATE_STOPPING, CREATE_STOPPED
        ///
        ///
        ///
        ///
        ///                   DELETE_PENDING, DELETE_IN_PROGRESS,
        ///           DELETE_FAILED
        ///
        ///
        ///
        ///
        ///             The Status of the forecast must be ACTIVE before you can query
        ///         or export the forecast.
        ///
        public var status: Swift.String?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            datasetGroupArn: Swift.String? = nil,
            forecastArn: Swift.String? = nil,
            forecastName: Swift.String? = nil,
            lastModificationTime: ClientRuntime.Date? = nil,
            message: Swift.String? = nil,
            predictorArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.datasetGroupArn = datasetGroupArn
            self.forecastArn = forecastArn
            self.forecastName = forecastName
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.predictorArn = predictorArn
            self.status = status
        }
    }

}

public struct GetAccuracyMetricsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAccuracyMetricsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAccuracyMetricsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAccuracyMetricsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAccuracyMetricsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAccuracyMetricsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAccuracyMetricsOutputError>
}

extension GetAccuracyMetricsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAccuracyMetricsInput(predictorArn: \(Swift.String(describing: predictorArn)))"}
}

extension GetAccuracyMetricsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorArn = "PredictorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let predictorArn = predictorArn {
            try encodeContainer.encode(predictorArn, forKey: .predictorArn)
        }
    }
}

public struct GetAccuracyMetricsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAccuracyMetricsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAccuracyMetricsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAccuracyMetricsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAccuracyMetricsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAccuracyMetricsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAccuracyMetricsOutputError>
}

public struct GetAccuracyMetricsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAccuracyMetricsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAccuracyMetricsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAccuracyMetricsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAccuracyMetricsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAccuracyMetricsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAccuracyMetricsOutputError>
}

public struct GetAccuracyMetricsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAccuracyMetricsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetAccuracyMetricsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAccuracyMetricsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetAccuracyMetricsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetAccuracyMetricsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAccuracyMetricsOutputError>
}

public struct GetAccuracyMetricsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the predictor to get metrics for.
    /// This member is required.
    public var predictorArn: Swift.String?

    public init (
        predictorArn: Swift.String? = nil
    )
    {
        self.predictorArn = predictorArn
    }
}

struct GetAccuracyMetricsInputBody: Swift.Equatable {
    public let predictorArn: Swift.String?
}

extension GetAccuracyMetricsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorArn = "PredictorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
    }
}

extension GetAccuracyMetricsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAccuracyMetricsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAccuracyMetricsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAccuracyMetricsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAccuracyMetricsOutputResponse(autoMLOverrideStrategy: \(Swift.String(describing: autoMLOverrideStrategy)), optimizationMetric: \(Swift.String(describing: optimizationMetric)), predictorEvaluationResults: \(Swift.String(describing: predictorEvaluationResults)))"}
}

extension GetAccuracyMetricsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAccuracyMetricsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.autoMLOverrideStrategy = output.autoMLOverrideStrategy
            self.optimizationMetric = output.optimizationMetric
            self.predictorEvaluationResults = output.predictorEvaluationResults
        } else {
            self.autoMLOverrideStrategy = nil
            self.optimizationMetric = nil
            self.predictorEvaluationResults = nil
        }
    }
}

public struct GetAccuracyMetricsOutputResponse: Swift.Equatable {
    ///
    ///              The LatencyOptimized AutoML override strategy is only available in private beta.
    ///                 Contact AWS Support or your account manager to learn more about access privileges.
    ///
    ///
    ///         The AutoML strategy used to train the predictor. Unless LatencyOptimized
    ///             is specified, the AutoML strategy optimizes predictor accuracy.
    ///         This parameter is only valid for predictors trained using AutoML.
    public var autoMLOverrideStrategy: ForecastClientTypes.AutoMLOverrideStrategy?
    /// The accuracy metric used to optimize the predictor.
    public var optimizationMetric: ForecastClientTypes.OptimizationMetric?
    /// An array of results from evaluating the predictor.
    public var predictorEvaluationResults: [ForecastClientTypes.EvaluationResult]?

    public init (
        autoMLOverrideStrategy: ForecastClientTypes.AutoMLOverrideStrategy? = nil,
        optimizationMetric: ForecastClientTypes.OptimizationMetric? = nil,
        predictorEvaluationResults: [ForecastClientTypes.EvaluationResult]? = nil
    )
    {
        self.autoMLOverrideStrategy = autoMLOverrideStrategy
        self.optimizationMetric = optimizationMetric
        self.predictorEvaluationResults = predictorEvaluationResults
    }
}

struct GetAccuracyMetricsOutputResponseBody: Swift.Equatable {
    public let predictorEvaluationResults: [ForecastClientTypes.EvaluationResult]?
    public let autoMLOverrideStrategy: ForecastClientTypes.AutoMLOverrideStrategy?
    public let optimizationMetric: ForecastClientTypes.OptimizationMetric?
}

extension GetAccuracyMetricsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoMLOverrideStrategy = "AutoMLOverrideStrategy"
        case optimizationMetric = "OptimizationMetric"
        case predictorEvaluationResults = "PredictorEvaluationResults"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorEvaluationResultsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.EvaluationResult?].self, forKey: .predictorEvaluationResults)
        var predictorEvaluationResultsDecoded0:[ForecastClientTypes.EvaluationResult]? = nil
        if let predictorEvaluationResultsContainer = predictorEvaluationResultsContainer {
            predictorEvaluationResultsDecoded0 = [ForecastClientTypes.EvaluationResult]()
            for structure0 in predictorEvaluationResultsContainer {
                if let structure0 = structure0 {
                    predictorEvaluationResultsDecoded0?.append(structure0)
                }
            }
        }
        predictorEvaluationResults = predictorEvaluationResultsDecoded0
        let autoMLOverrideStrategyDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.AutoMLOverrideStrategy.self, forKey: .autoMLOverrideStrategy)
        autoMLOverrideStrategy = autoMLOverrideStrategyDecoded
        let optimizationMetricDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.OptimizationMetric.self, forKey: .optimizationMetric)
        optimizationMetric = optimizationMetricDecoded
    }
}

extension ForecastClientTypes.HyperParameterTuningJobConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterRanges = "ParameterRanges"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameterRanges = parameterRanges {
            try encodeContainer.encode(parameterRanges, forKey: .parameterRanges)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterRangesDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.ParameterRanges.self, forKey: .parameterRanges)
        parameterRanges = parameterRangesDecoded
    }
}

extension ForecastClientTypes.HyperParameterTuningJobConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HyperParameterTuningJobConfig(parameterRanges: \(Swift.String(describing: parameterRanges)))"}
}

extension ForecastClientTypes {
    /// Configuration information for a hyperparameter tuning job. You specify this object in
    ///       the CreatePredictor request.
    ///          A hyperparameter is a parameter that governs the model training process. You set
    ///       hyperparameters before training starts, unlike model parameters, which are determined during
    ///       training. The values of the hyperparameters effect which values are chosen for the model parameters.
    ///          In a hyperparameter tuning job, Amazon Forecast chooses the set of hyperparameter
    ///       values that optimize a specified metric.  Forecast accomplishes this by running many training jobs
    ///       over a range of hyperparameter values. The optimum set of values depends on the
    ///       algorithm, the training data, and the specified metric objective.
    public struct HyperParameterTuningJobConfig: Swift.Equatable {
        /// Specifies the ranges of valid values for the hyperparameters.
        public var parameterRanges: ForecastClientTypes.ParameterRanges?

        public init (
            parameterRanges: ForecastClientTypes.ParameterRanges? = nil
        )
        {
            self.parameterRanges = parameterRanges
        }
    }

}

extension ForecastClientTypes.InputDataConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn = "DatasetGroupArn"
        case supplementaryFeatures = "SupplementaryFeatures"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let supplementaryFeatures = supplementaryFeatures {
            var supplementaryFeaturesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supplementaryFeatures)
            for supplementaryfeatures0 in supplementaryFeatures {
                try supplementaryFeaturesContainer.encode(supplementaryfeatures0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let supplementaryFeaturesContainer = try containerValues.decodeIfPresent([ForecastClientTypes.SupplementaryFeature?].self, forKey: .supplementaryFeatures)
        var supplementaryFeaturesDecoded0:[ForecastClientTypes.SupplementaryFeature]? = nil
        if let supplementaryFeaturesContainer = supplementaryFeaturesContainer {
            supplementaryFeaturesDecoded0 = [ForecastClientTypes.SupplementaryFeature]()
            for structure0 in supplementaryFeaturesContainer {
                if let structure0 = structure0 {
                    supplementaryFeaturesDecoded0?.append(structure0)
                }
            }
        }
        supplementaryFeatures = supplementaryFeaturesDecoded0
    }
}

extension ForecastClientTypes.InputDataConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InputDataConfig(datasetGroupArn: \(Swift.String(describing: datasetGroupArn)), supplementaryFeatures: \(Swift.String(describing: supplementaryFeatures)))"}
}

extension ForecastClientTypes {
    /// The data used to train a predictor. The data includes a dataset group and any
    ///       supplementary features. You specify this object in the CreatePredictor
    ///       request.
    public struct InputDataConfig: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the dataset group.
        /// This member is required.
        public var datasetGroupArn: Swift.String?
        /// An array of supplementary features. The only supported feature is a holiday
        ///       calendar.
        public var supplementaryFeatures: [ForecastClientTypes.SupplementaryFeature]?

        public init (
            datasetGroupArn: Swift.String? = nil,
            supplementaryFeatures: [ForecastClientTypes.SupplementaryFeature]? = nil
        )
        {
            self.datasetGroupArn = datasetGroupArn
            self.supplementaryFeatures = supplementaryFeatures
        }
    }

}

extension ForecastClientTypes.IntegerParameterRange: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxValue = "MaxValue"
        case minValue = "MinValue"
        case name = "Name"
        case scalingType = "ScalingType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxValue = maxValue {
            try encodeContainer.encode(maxValue, forKey: .maxValue)
        }
        if let minValue = minValue {
            try encodeContainer.encode(minValue, forKey: .minValue)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let scalingType = scalingType {
            try encodeContainer.encode(scalingType.rawValue, forKey: .scalingType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let maxValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxValue)
        maxValue = maxValueDecoded
        let minValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minValue)
        minValue = minValueDecoded
        let scalingTypeDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.ScalingType.self, forKey: .scalingType)
        scalingType = scalingTypeDecoded
    }
}

extension ForecastClientTypes.IntegerParameterRange: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IntegerParameterRange(maxValue: \(Swift.String(describing: maxValue)), minValue: \(Swift.String(describing: minValue)), name: \(Swift.String(describing: name)), scalingType: \(Swift.String(describing: scalingType)))"}
}

extension ForecastClientTypes {
    /// Specifies an integer hyperparameter and it's range of tunable values.
    ///       This object is part of the ParameterRanges object.
    public struct IntegerParameterRange: Swift.Equatable {
        /// The maximum tunable value of the hyperparameter.
        /// This member is required.
        public var maxValue: Swift.Int?
        /// The minimum tunable value of the hyperparameter.
        /// This member is required.
        public var minValue: Swift.Int?
        /// The name of the hyperparameter to tune.
        /// This member is required.
        public var name: Swift.String?
        /// The scale that hyperparameter tuning uses to search the hyperparameter range.
        ///       Valid values:
        ///
        ///             Auto
        ///
        ///                Amazon Forecast hyperparameter tuning chooses the best scale for the hyperparameter.
        ///
        ///             Linear
        ///
        ///                Hyperparameter tuning searches the values in the hyperparameter range by using a
        ///             linear scale.
        ///
        ///             Logarithmic
        ///
        ///                Hyperparameter tuning searches the values in the hyperparameter range by using a
        ///             logarithmic scale.
        ///                Logarithmic scaling works only for ranges that have values greater than 0.
        ///
        ///             ReverseLogarithmic
        ///
        ///                Not supported for IntegerParameterRange.
        ///                Reverse logarithmic scaling works only for ranges that are entirely within the
        ///             range 0 <= x < 1.0.
        ///
        ///
        ///          For information about choosing a hyperparameter scale, see
        ///       <a href="http://docs.aws.amazon.com/sagemaker/latest/dg/automatic-model-tuning-define-ranges.html#scaling-type">Hyperparameter Scaling.
        ///       One of the following values:
        public var scalingType: ForecastClientTypes.ScalingType?

        public init (
            maxValue: Swift.Int? = nil,
            minValue: Swift.Int? = nil,
            name: Swift.String? = nil,
            scalingType: ForecastClientTypes.ScalingType? = nil
        )
        {
            self.maxValue = maxValue
            self.minValue = minValue
            self.name = name
            self.scalingType = scalingType
        }
    }

}

extension InvalidInputException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidInputException(message: \(Swift.String(describing: message)))"}
}

extension InvalidInputException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidInputExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// We can't process the request because it includes an invalid value or a value that exceeds
///       the valid range.
public struct InvalidInputException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidInputExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidInputExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidNextTokenException(message: \(Swift.String(describing: message)))"}
}

extension InvalidNextTokenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The token is not valid. Tokens expire after 24 hours.
public struct InvalidNextTokenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The limit on the number of resources per account has been exceeded.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListDatasetGroupsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDatasetGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDatasetGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDatasetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDatasetGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDatasetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDatasetGroupsOutputError>
}

extension ListDatasetGroupsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDatasetGroupsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDatasetGroupsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListDatasetGroupsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDatasetGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDatasetGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDatasetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDatasetGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDatasetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDatasetGroupsOutputError>
}

public struct ListDatasetGroupsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDatasetGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDatasetGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDatasetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDatasetGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDatasetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDatasetGroupsOutputError>
}

public struct ListDatasetGroupsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDatasetGroupsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListDatasetGroupsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDatasetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDatasetGroupsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDatasetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDatasetGroupsOutputError>
}

public struct ListDatasetGroupsInput: Swift.Equatable {
    /// The number of items to return in the response.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a
    ///         NextToken. To retrieve the next set of results, use the token in the next
    ///       request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDatasetGroupsInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListDatasetGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDatasetGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDatasetGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDatasetGroupsOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDatasetGroupsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDatasetGroupsOutputResponse(datasetGroups: \(Swift.String(describing: datasetGroups)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDatasetGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDatasetGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datasetGroups = output.datasetGroups
            self.nextToken = output.nextToken
        } else {
            self.datasetGroups = nil
            self.nextToken = nil
        }
    }
}

public struct ListDatasetGroupsOutputResponse: Swift.Equatable {
    /// An array of objects that summarize each dataset group's properties.
    public var datasetGroups: [ForecastClientTypes.DatasetGroupSummary]?
    /// If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of
    ///       results, use the token in the next request.
    public var nextToken: Swift.String?

    public init (
        datasetGroups: [ForecastClientTypes.DatasetGroupSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetGroups = datasetGroups
        self.nextToken = nextToken
    }
}

struct ListDatasetGroupsOutputResponseBody: Swift.Equatable {
    public let datasetGroups: [ForecastClientTypes.DatasetGroupSummary]?
    public let nextToken: Swift.String?
}

extension ListDatasetGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroups = "DatasetGroups"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.DatasetGroupSummary?].self, forKey: .datasetGroups)
        var datasetGroupsDecoded0:[ForecastClientTypes.DatasetGroupSummary]? = nil
        if let datasetGroupsContainer = datasetGroupsContainer {
            datasetGroupsDecoded0 = [ForecastClientTypes.DatasetGroupSummary]()
            for structure0 in datasetGroupsContainer {
                if let structure0 = structure0 {
                    datasetGroupsDecoded0?.append(structure0)
                }
            }
        }
        datasetGroups = datasetGroupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListDatasetImportJobsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDatasetImportJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDatasetImportJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDatasetImportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDatasetImportJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDatasetImportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDatasetImportJobsOutputError>
}

extension ListDatasetImportJobsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDatasetImportJobsInput(filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDatasetImportJobsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListDatasetImportJobsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDatasetImportJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDatasetImportJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDatasetImportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDatasetImportJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDatasetImportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDatasetImportJobsOutputError>
}

public struct ListDatasetImportJobsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDatasetImportJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDatasetImportJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDatasetImportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDatasetImportJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDatasetImportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDatasetImportJobsOutputError>
}

public struct ListDatasetImportJobsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDatasetImportJobsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListDatasetImportJobsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDatasetImportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDatasetImportJobsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDatasetImportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDatasetImportJobsOutputError>
}

public struct ListDatasetImportJobsInput: Swift.Equatable {
    /// An array of filters. For each filter, you provide a condition and a match statement. The
    ///       condition is either IS or IS_NOT, which specifies whether to include
    ///       or exclude the datasets that match the statement from the list, respectively. The match
    ///       statement consists of a key and a value.
    ///
    ///             Filter properties
    ///
    ///
    ///
    ///
    ///                   Condition - The condition to apply. Valid values are IS and
    ///             IS_NOT. To include the datasets that match the statement, specify
    ///             IS. To exclude matching datasets, specify IS_NOT.
    ///
    ///
    ///
    ///                   Key - The name of the parameter to filter on. Valid values are
    ///             DatasetArn and Status.
    ///
    ///
    ///
    ///                   Value - The value to match.
    ///
    ///
    ///          For example, to list all dataset import jobs whose status is ACTIVE, you specify the
    ///       following filter:
    ///
    ///             "Filters": [ { "Condition": "IS", "Key": "Status", "Value": "ACTIVE" }
    ///       ]
    ///
    public var filters: [ForecastClientTypes.Filter]?
    /// The number of items to return in the response.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a
    ///         NextToken. To retrieve the next set of results, use the token in the next
    ///       request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init (
        filters: [ForecastClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDatasetImportJobsInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
    public let filters: [ForecastClientTypes.Filter]?
}

extension ListDatasetImportJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ForecastClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ForecastClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListDatasetImportJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDatasetImportJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDatasetImportJobsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDatasetImportJobsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDatasetImportJobsOutputResponse(datasetImportJobs: \(Swift.String(describing: datasetImportJobs)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDatasetImportJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDatasetImportJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datasetImportJobs = output.datasetImportJobs
            self.nextToken = output.nextToken
        } else {
            self.datasetImportJobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListDatasetImportJobsOutputResponse: Swift.Equatable {
    /// An array of objects that summarize each dataset import job's properties.
    public var datasetImportJobs: [ForecastClientTypes.DatasetImportJobSummary]?
    /// If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of
    ///       results, use the token in the next request.
    public var nextToken: Swift.String?

    public init (
        datasetImportJobs: [ForecastClientTypes.DatasetImportJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetImportJobs = datasetImportJobs
        self.nextToken = nextToken
    }
}

struct ListDatasetImportJobsOutputResponseBody: Swift.Equatable {
    public let datasetImportJobs: [ForecastClientTypes.DatasetImportJobSummary]?
    public let nextToken: Swift.String?
}

extension ListDatasetImportJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetImportJobs = "DatasetImportJobs"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetImportJobsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.DatasetImportJobSummary?].self, forKey: .datasetImportJobs)
        var datasetImportJobsDecoded0:[ForecastClientTypes.DatasetImportJobSummary]? = nil
        if let datasetImportJobsContainer = datasetImportJobsContainer {
            datasetImportJobsDecoded0 = [ForecastClientTypes.DatasetImportJobSummary]()
            for structure0 in datasetImportJobsContainer {
                if let structure0 = structure0 {
                    datasetImportJobsDecoded0?.append(structure0)
                }
            }
        }
        datasetImportJobs = datasetImportJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListDatasetsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDatasetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDatasetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDatasetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDatasetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDatasetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDatasetsOutputError>
}

extension ListDatasetsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDatasetsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDatasetsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListDatasetsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDatasetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDatasetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDatasetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDatasetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDatasetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDatasetsOutputError>
}

public struct ListDatasetsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDatasetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDatasetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDatasetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDatasetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDatasetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDatasetsOutputError>
}

public struct ListDatasetsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDatasetsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListDatasetsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDatasetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDatasetsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDatasetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDatasetsOutputError>
}

public struct ListDatasetsInput: Swift.Equatable {
    /// The number of items to return in the response.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a
    ///         NextToken. To retrieve the next set of results, use the token in the next
    ///       request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDatasetsInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListDatasetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDatasetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDatasetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDatasetsOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDatasetsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDatasetsOutputResponse(datasets: \(Swift.String(describing: datasets)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDatasetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDatasetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datasets = output.datasets
            self.nextToken = output.nextToken
        } else {
            self.datasets = nil
            self.nextToken = nil
        }
    }
}

public struct ListDatasetsOutputResponse: Swift.Equatable {
    /// An array of objects that summarize each dataset's properties.
    public var datasets: [ForecastClientTypes.DatasetSummary]?
    /// If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of
    ///       results, use the token in the next request.
    public var nextToken: Swift.String?

    public init (
        datasets: [ForecastClientTypes.DatasetSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasets = datasets
        self.nextToken = nextToken
    }
}

struct ListDatasetsOutputResponseBody: Swift.Equatable {
    public let datasets: [ForecastClientTypes.DatasetSummary]?
    public let nextToken: Swift.String?
}

extension ListDatasetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasets = "Datasets"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.DatasetSummary?].self, forKey: .datasets)
        var datasetsDecoded0:[ForecastClientTypes.DatasetSummary]? = nil
        if let datasetsContainer = datasetsContainer {
            datasetsDecoded0 = [ForecastClientTypes.DatasetSummary]()
            for structure0 in datasetsContainer {
                if let structure0 = structure0 {
                    datasetsDecoded0?.append(structure0)
                }
            }
        }
        datasets = datasetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListForecastExportJobsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListForecastExportJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListForecastExportJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListForecastExportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListForecastExportJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListForecastExportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListForecastExportJobsOutputError>
}

extension ListForecastExportJobsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListForecastExportJobsInput(filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListForecastExportJobsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListForecastExportJobsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListForecastExportJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListForecastExportJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListForecastExportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListForecastExportJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListForecastExportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListForecastExportJobsOutputError>
}

public struct ListForecastExportJobsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListForecastExportJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListForecastExportJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListForecastExportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListForecastExportJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListForecastExportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListForecastExportJobsOutputError>
}

public struct ListForecastExportJobsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListForecastExportJobsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListForecastExportJobsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListForecastExportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListForecastExportJobsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListForecastExportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListForecastExportJobsOutputError>
}

public struct ListForecastExportJobsInput: Swift.Equatable {
    /// An array of filters. For each filter, you provide a condition and a match statement. The
    ///       condition is either IS or IS_NOT, which specifies whether to include
    ///       or exclude the forecast export jobs that match the statement from the list, respectively. The
    ///       match statement consists of a key and a value.
    ///
    ///             Filter properties
    ///
    ///
    ///
    ///
    ///                   Condition - The condition to apply. Valid values are IS and
    ///             IS_NOT. To include the forecast export jobs that match the statement,
    ///           specify IS. To exclude matching forecast export jobs, specify
    ///             IS_NOT.
    ///
    ///
    ///
    ///                   Key - The name of the parameter to filter on. Valid values are
    ///             ForecastArn and Status.
    ///
    ///
    ///
    ///                   Value - The value to match.
    ///
    ///
    ///          For example, to list all jobs that export a forecast named
    ///         electricityforecast, specify the following filter:
    ///
    ///             "Filters": [ { "Condition": "IS", "Key": "ForecastArn", "Value":
    ///         "arn:aws:forecast:us-west-2:<acct-id>:forecast/electricityforecast" } ]
    ///
    public var filters: [ForecastClientTypes.Filter]?
    /// The number of items to return in the response.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a
    ///         NextToken. To retrieve the next set of results, use the token in the next
    ///       request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init (
        filters: [ForecastClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListForecastExportJobsInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
    public let filters: [ForecastClientTypes.Filter]?
}

extension ListForecastExportJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ForecastClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ForecastClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListForecastExportJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListForecastExportJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListForecastExportJobsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListForecastExportJobsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListForecastExportJobsOutputResponse(forecastExportJobs: \(Swift.String(describing: forecastExportJobs)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListForecastExportJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListForecastExportJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.forecastExportJobs = output.forecastExportJobs
            self.nextToken = output.nextToken
        } else {
            self.forecastExportJobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListForecastExportJobsOutputResponse: Swift.Equatable {
    /// An array of objects that summarize each export job's properties.
    public var forecastExportJobs: [ForecastClientTypes.ForecastExportJobSummary]?
    /// If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of
    ///       results, use the token in the next request.
    public var nextToken: Swift.String?

    public init (
        forecastExportJobs: [ForecastClientTypes.ForecastExportJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.forecastExportJobs = forecastExportJobs
        self.nextToken = nextToken
    }
}

struct ListForecastExportJobsOutputResponseBody: Swift.Equatable {
    public let forecastExportJobs: [ForecastClientTypes.ForecastExportJobSummary]?
    public let nextToken: Swift.String?
}

extension ListForecastExportJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastExportJobs = "ForecastExportJobs"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastExportJobsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.ForecastExportJobSummary?].self, forKey: .forecastExportJobs)
        var forecastExportJobsDecoded0:[ForecastClientTypes.ForecastExportJobSummary]? = nil
        if let forecastExportJobsContainer = forecastExportJobsContainer {
            forecastExportJobsDecoded0 = [ForecastClientTypes.ForecastExportJobSummary]()
            for structure0 in forecastExportJobsContainer {
                if let structure0 = structure0 {
                    forecastExportJobsDecoded0?.append(structure0)
                }
            }
        }
        forecastExportJobs = forecastExportJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListForecastsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListForecastsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListForecastsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListForecastsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListForecastsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListForecastsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListForecastsOutputError>
}

extension ListForecastsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListForecastsInput(filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListForecastsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListForecastsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListForecastsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListForecastsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListForecastsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListForecastsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListForecastsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListForecastsOutputError>
}

public struct ListForecastsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListForecastsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListForecastsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListForecastsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListForecastsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListForecastsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListForecastsOutputError>
}

public struct ListForecastsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListForecastsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListForecastsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListForecastsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListForecastsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListForecastsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListForecastsOutputError>
}

public struct ListForecastsInput: Swift.Equatable {
    /// An array of filters. For each filter, you provide a condition and a match statement. The
    ///       condition is either IS or IS_NOT, which specifies whether to include
    ///       or exclude the forecasts that match the statement from the list, respectively. The match
    ///       statement consists of a key and a value.
    ///
    ///             Filter properties
    ///
    ///
    ///
    ///
    ///                   Condition - The condition to apply. Valid values are IS and
    ///             IS_NOT. To include the forecasts that match the statement, specify
    ///             IS. To exclude matching forecasts, specify IS_NOT.
    ///
    ///
    ///
    ///                   Key - The name of the parameter to filter on. Valid values are
    ///             DatasetGroupArn, PredictorArn, and Status.
    ///
    ///
    ///
    ///                   Value - The value to match.
    ///
    ///
    ///          For example, to list all forecasts whose status is not ACTIVE, you would specify:
    ///
    ///             "Filters": [ { "Condition": "IS_NOT", "Key": "Status", "Value": "ACTIVE" }
    ///       ]
    ///
    public var filters: [ForecastClientTypes.Filter]?
    /// The number of items to return in the response.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a
    ///         NextToken. To retrieve the next set of results, use the token in the next
    ///       request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init (
        filters: [ForecastClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListForecastsInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
    public let filters: [ForecastClientTypes.Filter]?
}

extension ListForecastsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ForecastClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ForecastClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListForecastsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListForecastsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListForecastsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListForecastsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListForecastsOutputResponse(forecasts: \(Swift.String(describing: forecasts)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListForecastsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListForecastsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.forecasts = output.forecasts
            self.nextToken = output.nextToken
        } else {
            self.forecasts = nil
            self.nextToken = nil
        }
    }
}

public struct ListForecastsOutputResponse: Swift.Equatable {
    /// An array of objects that summarize each forecast's properties.
    public var forecasts: [ForecastClientTypes.ForecastSummary]?
    /// If the response is truncated, Amazon Forecast returns this token. To retrieve the next set
    ///       of results, use the token in the next request.
    public var nextToken: Swift.String?

    public init (
        forecasts: [ForecastClientTypes.ForecastSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.forecasts = forecasts
        self.nextToken = nextToken
    }
}

struct ListForecastsOutputResponseBody: Swift.Equatable {
    public let forecasts: [ForecastClientTypes.ForecastSummary]?
    public let nextToken: Swift.String?
}

extension ListForecastsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecasts = "Forecasts"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.ForecastSummary?].self, forKey: .forecasts)
        var forecastsDecoded0:[ForecastClientTypes.ForecastSummary]? = nil
        if let forecastsContainer = forecastsContainer {
            forecastsDecoded0 = [ForecastClientTypes.ForecastSummary]()
            for structure0 in forecastsContainer {
                if let structure0 = structure0 {
                    forecastsDecoded0?.append(structure0)
                }
            }
        }
        forecasts = forecastsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListPredictorBacktestExportJobsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPredictorBacktestExportJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPredictorBacktestExportJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPredictorBacktestExportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPredictorBacktestExportJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPredictorBacktestExportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPredictorBacktestExportJobsOutputError>
}

extension ListPredictorBacktestExportJobsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPredictorBacktestExportJobsInput(filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListPredictorBacktestExportJobsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListPredictorBacktestExportJobsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPredictorBacktestExportJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPredictorBacktestExportJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPredictorBacktestExportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPredictorBacktestExportJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPredictorBacktestExportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPredictorBacktestExportJobsOutputError>
}

public struct ListPredictorBacktestExportJobsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPredictorBacktestExportJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPredictorBacktestExportJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPredictorBacktestExportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPredictorBacktestExportJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPredictorBacktestExportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPredictorBacktestExportJobsOutputError>
}

public struct ListPredictorBacktestExportJobsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPredictorBacktestExportJobsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListPredictorBacktestExportJobsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPredictorBacktestExportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListPredictorBacktestExportJobsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListPredictorBacktestExportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPredictorBacktestExportJobsOutputError>
}

public struct ListPredictorBacktestExportJobsInput: Swift.Equatable {
    /// An array of filters. For each filter, provide a condition and a match statement. The
    ///                 condition is either IS or IS_NOT, which specifies whether to
    ///                 include or exclude the predictor backtest export jobs that match the statement from the
    ///                 list. The match statement consists of a key and a value.
    ///
    ///                 Filter properties
    ///
    ///
    ///
    ///
    ///                   Condition - The condition to apply. Valid values are
    ///                         IS and IS_NOT. To include the predictor backtest
    ///                         export jobs that match the statement, specify IS. To exclude matching
    ///                         predictor backtest export jobs, specify IS_NOT.
    ///
    ///
    ///
    ///                   Key - The name of the parameter to filter on. Valid values are
    ///                         PredictorArn and Status.
    ///
    ///
    ///
    ///                   Value - The value to match.
    ///
    ///
    public var filters: [ForecastClientTypes.Filter]?
    /// The number of items to return in the response.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a NextToken.
    ///             To retrieve the next set of results, use the token in the next request. Tokens expire after
    ///             24 hours.
    public var nextToken: Swift.String?

    public init (
        filters: [ForecastClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPredictorBacktestExportJobsInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
    public let filters: [ForecastClientTypes.Filter]?
}

extension ListPredictorBacktestExportJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ForecastClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ForecastClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListPredictorBacktestExportJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPredictorBacktestExportJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPredictorBacktestExportJobsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPredictorBacktestExportJobsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPredictorBacktestExportJobsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), predictorBacktestExportJobs: \(Swift.String(describing: predictorBacktestExportJobs)))"}
}

extension ListPredictorBacktestExportJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPredictorBacktestExportJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.predictorBacktestExportJobs = output.predictorBacktestExportJobs
        } else {
            self.nextToken = nil
            self.predictorBacktestExportJobs = nil
        }
    }
}

public struct ListPredictorBacktestExportJobsOutputResponse: Swift.Equatable {
    /// Returns this token if the response is truncated. To retrieve the next
    ///             set of results, use the token in the next request.
    public var nextToken: Swift.String?
    /// An array of objects that summarize the properties of each predictor backtest export
    ///             job.
    public var predictorBacktestExportJobs: [ForecastClientTypes.PredictorBacktestExportJobSummary]?

    public init (
        nextToken: Swift.String? = nil,
        predictorBacktestExportJobs: [ForecastClientTypes.PredictorBacktestExportJobSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.predictorBacktestExportJobs = predictorBacktestExportJobs
    }
}

struct ListPredictorBacktestExportJobsOutputResponseBody: Swift.Equatable {
    public let predictorBacktestExportJobs: [ForecastClientTypes.PredictorBacktestExportJobSummary]?
    public let nextToken: Swift.String?
}

extension ListPredictorBacktestExportJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case predictorBacktestExportJobs = "PredictorBacktestExportJobs"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorBacktestExportJobsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.PredictorBacktestExportJobSummary?].self, forKey: .predictorBacktestExportJobs)
        var predictorBacktestExportJobsDecoded0:[ForecastClientTypes.PredictorBacktestExportJobSummary]? = nil
        if let predictorBacktestExportJobsContainer = predictorBacktestExportJobsContainer {
            predictorBacktestExportJobsDecoded0 = [ForecastClientTypes.PredictorBacktestExportJobSummary]()
            for structure0 in predictorBacktestExportJobsContainer {
                if let structure0 = structure0 {
                    predictorBacktestExportJobsDecoded0?.append(structure0)
                }
            }
        }
        predictorBacktestExportJobs = predictorBacktestExportJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListPredictorsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPredictorsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPredictorsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPredictorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPredictorsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPredictorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPredictorsOutputError>
}

extension ListPredictorsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPredictorsInput(filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListPredictorsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListPredictorsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPredictorsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPredictorsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPredictorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPredictorsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPredictorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPredictorsOutputError>
}

public struct ListPredictorsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPredictorsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPredictorsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPredictorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPredictorsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPredictorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPredictorsOutputError>
}

public struct ListPredictorsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPredictorsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListPredictorsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPredictorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListPredictorsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListPredictorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPredictorsOutputError>
}

public struct ListPredictorsInput: Swift.Equatable {
    /// An array of filters. For each filter, you provide a condition and a match statement. The
    ///       condition is either IS or IS_NOT, which specifies whether to include
    ///       or exclude the predictors that match the statement from the list, respectively. The match
    ///       statement consists of a key and a value.
    ///
    ///             Filter properties
    ///
    ///
    ///
    ///
    ///                   Condition - The condition to apply. Valid values are IS and
    ///             IS_NOT. To include the predictors that match the statement, specify
    ///             IS. To exclude matching predictors, specify IS_NOT.
    ///
    ///
    ///
    ///                   Key - The name of the parameter to filter on. Valid values are
    ///             DatasetGroupArn and Status.
    ///
    ///
    ///
    ///                   Value - The value to match.
    ///
    ///
    ///          For example, to list all predictors whose status is ACTIVE, you would specify:
    ///
    ///             "Filters": [ { "Condition": "IS", "Key": "Status", "Value": "ACTIVE" }
    ///       ]
    ///
    public var filters: [ForecastClientTypes.Filter]?
    /// The number of items to return in the response.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a
    ///         NextToken. To retrieve the next set of results, use the token in the next
    ///       request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init (
        filters: [ForecastClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPredictorsInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
    public let filters: [ForecastClientTypes.Filter]?
}

extension ListPredictorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ForecastClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ForecastClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListPredictorsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPredictorsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPredictorsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPredictorsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPredictorsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), predictors: \(Swift.String(describing: predictors)))"}
}

extension ListPredictorsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPredictorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.predictors = output.predictors
        } else {
            self.nextToken = nil
            self.predictors = nil
        }
    }
}

public struct ListPredictorsOutputResponse: Swift.Equatable {
    /// If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of
    ///       results, use the token in the next request.
    public var nextToken: Swift.String?
    /// An array of objects that summarize each predictor's properties.
    public var predictors: [ForecastClientTypes.PredictorSummary]?

    public init (
        nextToken: Swift.String? = nil,
        predictors: [ForecastClientTypes.PredictorSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.predictors = predictors
    }
}

struct ListPredictorsOutputResponseBody: Swift.Equatable {
    public let predictors: [ForecastClientTypes.PredictorSummary]?
    public let nextToken: Swift.String?
}

extension ListPredictorsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case predictors = "Predictors"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.PredictorSummary?].self, forKey: .predictors)
        var predictorsDecoded0:[ForecastClientTypes.PredictorSummary]? = nil
        if let predictorsContainer = predictorsContainer {
            predictorsDecoded0 = [ForecastClientTypes.PredictorSummary]()
            for structure0 in predictorsContainer {
                if let structure0 = structure0 {
                    predictorsDecoded0?.append(structure0)
                }
            }
        }
        predictors = predictorsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that identifies the resource for which to list the tags. Currently, the supported resources are Forecast dataset groups, datasets, dataset import jobs, predictors, forecasts, and forecast export jobs.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags for the resource.
    public var tags: [ForecastClientTypes.Tag]?

    public init (
        tags: [ForecastClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [ForecastClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ForecastClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ForecastClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ForecastClientTypes.Metrics: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case averageWeightedQuantileLoss = "AverageWeightedQuantileLoss"
        case errorMetrics = "ErrorMetrics"
        case rMSE = "RMSE"
        case weightedQuantileLosses = "WeightedQuantileLosses"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let averageWeightedQuantileLoss = averageWeightedQuantileLoss {
            try encodeContainer.encode(averageWeightedQuantileLoss, forKey: .averageWeightedQuantileLoss)
        }
        if let errorMetrics = errorMetrics {
            var errorMetricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .errorMetrics)
            for errormetrics0 in errorMetrics {
                try errorMetricsContainer.encode(errormetrics0)
            }
        }
        if let rMSE = rMSE {
            try encodeContainer.encode(rMSE, forKey: .rMSE)
        }
        if let weightedQuantileLosses = weightedQuantileLosses {
            var weightedQuantileLossesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .weightedQuantileLosses)
            for weightedquantilelosses0 in weightedQuantileLosses {
                try weightedQuantileLossesContainer.encode(weightedquantilelosses0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rMSEDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .rMSE)
        rMSE = rMSEDecoded
        let weightedQuantileLossesContainer = try containerValues.decodeIfPresent([ForecastClientTypes.WeightedQuantileLoss?].self, forKey: .weightedQuantileLosses)
        var weightedQuantileLossesDecoded0:[ForecastClientTypes.WeightedQuantileLoss]? = nil
        if let weightedQuantileLossesContainer = weightedQuantileLossesContainer {
            weightedQuantileLossesDecoded0 = [ForecastClientTypes.WeightedQuantileLoss]()
            for structure0 in weightedQuantileLossesContainer {
                if let structure0 = structure0 {
                    weightedQuantileLossesDecoded0?.append(structure0)
                }
            }
        }
        weightedQuantileLosses = weightedQuantileLossesDecoded0
        let errorMetricsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.ErrorMetric?].self, forKey: .errorMetrics)
        var errorMetricsDecoded0:[ForecastClientTypes.ErrorMetric]? = nil
        if let errorMetricsContainer = errorMetricsContainer {
            errorMetricsDecoded0 = [ForecastClientTypes.ErrorMetric]()
            for structure0 in errorMetricsContainer {
                if let structure0 = structure0 {
                    errorMetricsDecoded0?.append(structure0)
                }
            }
        }
        errorMetrics = errorMetricsDecoded0
        let averageWeightedQuantileLossDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .averageWeightedQuantileLoss)
        averageWeightedQuantileLoss = averageWeightedQuantileLossDecoded
    }
}

extension ForecastClientTypes.Metrics: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Metrics(averageWeightedQuantileLoss: \(Swift.String(describing: averageWeightedQuantileLoss)), errorMetrics: \(Swift.String(describing: errorMetrics)), rMSE: \(Swift.String(describing: rMSE)), weightedQuantileLosses: \(Swift.String(describing: weightedQuantileLosses)))"}
}

extension ForecastClientTypes {
    /// Provides metrics that are used to evaluate the performance of a predictor. This object is
    ///       part of the WindowSummary object.
    public struct Metrics: Swift.Equatable {
        /// The average value of all weighted quantile losses.
        public var averageWeightedQuantileLoss: Swift.Double?
        ///  Provides detailed error metrics for each forecast type. Metrics include root-mean
        ///       square-error (RMSE), mean absolute percentage error (MAPE), mean absolute scaled error (MASE),
        ///       and weighted average percentage error (WAPE).
        public var errorMetrics: [ForecastClientTypes.ErrorMetric]?
        /// The root-mean-square error (RMSE).
        @available(*, deprecated, message: "This property is deprecated, please refer to ErrorMetrics for both RMSE and WAPE")
        public var rMSE: Swift.Double?
        /// An array of weighted quantile losses. Quantiles divide a probability distribution into
        ///       regions of equal probability. The distribution in this case is the loss function.
        public var weightedQuantileLosses: [ForecastClientTypes.WeightedQuantileLoss]?

        public init (
            averageWeightedQuantileLoss: Swift.Double? = nil,
            errorMetrics: [ForecastClientTypes.ErrorMetric]? = nil,
            rMSE: Swift.Double? = nil,
            weightedQuantileLosses: [ForecastClientTypes.WeightedQuantileLoss]? = nil
        )
        {
            self.averageWeightedQuantileLoss = averageWeightedQuantileLoss
            self.errorMetrics = errorMetrics
            self.rMSE = rMSE
            self.weightedQuantileLosses = weightedQuantileLosses
        }
    }

}

extension ForecastClientTypes {
    public enum OptimizationMetric: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case averageweightedquantileloss
        case mape
        case mase
        case rmse
        case wape
        case sdkUnknown(Swift.String)

        public static var allCases: [OptimizationMetric] {
            return [
                .averageweightedquantileloss,
                .mape,
                .mase,
                .rmse,
                .wape,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .averageweightedquantileloss: return "AverageWeightedQuantileLoss"
            case .mape: return "MAPE"
            case .mase: return "MASE"
            case .rmse: return "RMSE"
            case .wape: return "WAPE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OptimizationMetric(rawValue: rawValue) ?? OptimizationMetric.sdkUnknown(rawValue)
        }
    }
}

extension ForecastClientTypes.ParameterRanges: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case categoricalParameterRanges = "CategoricalParameterRanges"
        case continuousParameterRanges = "ContinuousParameterRanges"
        case integerParameterRanges = "IntegerParameterRanges"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categoricalParameterRanges = categoricalParameterRanges {
            var categoricalParameterRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .categoricalParameterRanges)
            for categoricalparameterranges0 in categoricalParameterRanges {
                try categoricalParameterRangesContainer.encode(categoricalparameterranges0)
            }
        }
        if let continuousParameterRanges = continuousParameterRanges {
            var continuousParameterRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .continuousParameterRanges)
            for continuousparameterranges0 in continuousParameterRanges {
                try continuousParameterRangesContainer.encode(continuousparameterranges0)
            }
        }
        if let integerParameterRanges = integerParameterRanges {
            var integerParameterRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .integerParameterRanges)
            for integerparameterranges0 in integerParameterRanges {
                try integerParameterRangesContainer.encode(integerparameterranges0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let categoricalParameterRangesContainer = try containerValues.decodeIfPresent([ForecastClientTypes.CategoricalParameterRange?].self, forKey: .categoricalParameterRanges)
        var categoricalParameterRangesDecoded0:[ForecastClientTypes.CategoricalParameterRange]? = nil
        if let categoricalParameterRangesContainer = categoricalParameterRangesContainer {
            categoricalParameterRangesDecoded0 = [ForecastClientTypes.CategoricalParameterRange]()
            for structure0 in categoricalParameterRangesContainer {
                if let structure0 = structure0 {
                    categoricalParameterRangesDecoded0?.append(structure0)
                }
            }
        }
        categoricalParameterRanges = categoricalParameterRangesDecoded0
        let continuousParameterRangesContainer = try containerValues.decodeIfPresent([ForecastClientTypes.ContinuousParameterRange?].self, forKey: .continuousParameterRanges)
        var continuousParameterRangesDecoded0:[ForecastClientTypes.ContinuousParameterRange]? = nil
        if let continuousParameterRangesContainer = continuousParameterRangesContainer {
            continuousParameterRangesDecoded0 = [ForecastClientTypes.ContinuousParameterRange]()
            for structure0 in continuousParameterRangesContainer {
                if let structure0 = structure0 {
                    continuousParameterRangesDecoded0?.append(structure0)
                }
            }
        }
        continuousParameterRanges = continuousParameterRangesDecoded0
        let integerParameterRangesContainer = try containerValues.decodeIfPresent([ForecastClientTypes.IntegerParameterRange?].self, forKey: .integerParameterRanges)
        var integerParameterRangesDecoded0:[ForecastClientTypes.IntegerParameterRange]? = nil
        if let integerParameterRangesContainer = integerParameterRangesContainer {
            integerParameterRangesDecoded0 = [ForecastClientTypes.IntegerParameterRange]()
            for structure0 in integerParameterRangesContainer {
                if let structure0 = structure0 {
                    integerParameterRangesDecoded0?.append(structure0)
                }
            }
        }
        integerParameterRanges = integerParameterRangesDecoded0
    }
}

extension ForecastClientTypes.ParameterRanges: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ParameterRanges(categoricalParameterRanges: \(Swift.String(describing: categoricalParameterRanges)), continuousParameterRanges: \(Swift.String(describing: continuousParameterRanges)), integerParameterRanges: \(Swift.String(describing: integerParameterRanges)))"}
}

extension ForecastClientTypes {
    /// Specifies the categorical, continuous, and integer hyperparameters, and their ranges of
    ///       tunable values. The range of tunable values determines which values that a hyperparameter
    ///       tuning job can choose for the specified hyperparameter. This object is part of the
    ///       HyperParameterTuningJobConfig object.
    public struct ParameterRanges: Swift.Equatable {
        /// Specifies the tunable range for each categorical hyperparameter.
        public var categoricalParameterRanges: [ForecastClientTypes.CategoricalParameterRange]?
        /// Specifies the tunable range for each continuous hyperparameter.
        public var continuousParameterRanges: [ForecastClientTypes.ContinuousParameterRange]?
        /// Specifies the tunable range for each integer hyperparameter.
        public var integerParameterRanges: [ForecastClientTypes.IntegerParameterRange]?

        public init (
            categoricalParameterRanges: [ForecastClientTypes.CategoricalParameterRange]? = nil,
            continuousParameterRanges: [ForecastClientTypes.ContinuousParameterRange]? = nil,
            integerParameterRanges: [ForecastClientTypes.IntegerParameterRange]? = nil
        )
        {
            self.categoricalParameterRanges = categoricalParameterRanges
            self.continuousParameterRanges = continuousParameterRanges
            self.integerParameterRanges = integerParameterRanges
        }
    }

}

extension ForecastClientTypes.PredictorBacktestExportJobSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case destination = "Destination"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case predictorBacktestExportJobArn = "PredictorBacktestExportJobArn"
        case predictorBacktestExportJobName = "PredictorBacktestExportJobName"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let lastModificationTime = lastModificationTime {
            try encodeContainer.encode(lastModificationTime.timeIntervalSince1970, forKey: .lastModificationTime)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let predictorBacktestExportJobArn = predictorBacktestExportJobArn {
            try encodeContainer.encode(predictorBacktestExportJobArn, forKey: .predictorBacktestExportJobArn)
        }
        if let predictorBacktestExportJobName = predictorBacktestExportJobName {
            try encodeContainer.encode(predictorBacktestExportJobName, forKey: .predictorBacktestExportJobName)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorBacktestExportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorBacktestExportJobArn)
        predictorBacktestExportJobArn = predictorBacktestExportJobArnDecoded
        let predictorBacktestExportJobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorBacktestExportJobName)
        predictorBacktestExportJobName = predictorBacktestExportJobNameDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataDestination.self, forKey: .destination)
        destination = destinationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension ForecastClientTypes.PredictorBacktestExportJobSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PredictorBacktestExportJobSummary(creationTime: \(Swift.String(describing: creationTime)), destination: \(Swift.String(describing: destination)), lastModificationTime: \(Swift.String(describing: lastModificationTime)), message: \(Swift.String(describing: message)), predictorBacktestExportJobArn: \(Swift.String(describing: predictorBacktestExportJobArn)), predictorBacktestExportJobName: \(Swift.String(describing: predictorBacktestExportJobName)), status: \(Swift.String(describing: status)))"}
}

extension ForecastClientTypes {
    /// Provides a summary of the predictor backtest export job properties used in the ListPredictorBacktestExportJobs operation. To get a complete set of properties, call
    ///             the DescribePredictorBacktestExportJob operation, and provide the listed
    ///             PredictorBacktestExportJobArn.
    public struct PredictorBacktestExportJobSummary: Swift.Equatable {
        /// When the predictor backtest export job was created.
        public var creationTime: ClientRuntime.Date?
        /// The destination for an export job. Provide an S3 path, an AWS Identity and Access Management (IAM) role that allows Amazon Forecast
        ///       to access the location, and an AWS Key Management Service (KMS) key (optional).
        public var destination: ForecastClientTypes.DataDestination?
        /// The last time the resource was modified. The timestamp depends on the status of the job:
        ///
        ///
        ///
        ///                   CREATE_PENDING - The CreationTime.
        ///
        ///
        ///
        ///                   CREATE_IN_PROGRESS - The current timestamp.
        ///
        ///
        ///
        ///                   CREATE_STOPPING - The current timestamp.
        ///
        ///
        ///
        ///                   CREATE_STOPPED - When the job stopped.
        ///
        ///
        ///
        ///                   ACTIVE or CREATE_FAILED - When the job finished or
        ///                     failed.
        ///
        ///
        public var lastModificationTime: ClientRuntime.Date?
        /// Information about any errors that may have occurred during the backtest export.
        public var message: Swift.String?
        /// The Amazon Resource Name (ARN) of the predictor backtest export job.
        public var predictorBacktestExportJobArn: Swift.String?
        /// The name of the predictor backtest export job.
        public var predictorBacktestExportJobName: Swift.String?
        /// The status of the predictor backtest export job. States include:
        ///
        ///
        ///
        ///                   ACTIVE
        ///
        ///
        ///
        ///
        ///                   CREATE_PENDING, CREATE_IN_PROGRESS,
        ///                     CREATE_FAILED
        ///
        ///
        ///
        ///
        ///                     CREATE_STOPPING, CREATE_STOPPED
        ///
        ///
        ///
        ///
        ///                   DELETE_PENDING, DELETE_IN_PROGRESS,
        ///                     DELETE_FAILED
        ///
        ///
        ///
        public var status: Swift.String?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            destination: ForecastClientTypes.DataDestination? = nil,
            lastModificationTime: ClientRuntime.Date? = nil,
            message: Swift.String? = nil,
            predictorBacktestExportJobArn: Swift.String? = nil,
            predictorBacktestExportJobName: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.destination = destination
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.predictorBacktestExportJobArn = predictorBacktestExportJobArn
            self.predictorBacktestExportJobName = predictorBacktestExportJobName
            self.status = status
        }
    }

}

extension ForecastClientTypes.PredictorExecution: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithmArn = "AlgorithmArn"
        case testWindows = "TestWindows"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let algorithmArn = algorithmArn {
            try encodeContainer.encode(algorithmArn, forKey: .algorithmArn)
        }
        if let testWindows = testWindows {
            var testWindowsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .testWindows)
            for testwindowdetails0 in testWindows {
                try testWindowsContainer.encode(testwindowdetails0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let algorithmArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .algorithmArn)
        algorithmArn = algorithmArnDecoded
        let testWindowsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.TestWindowSummary?].self, forKey: .testWindows)
        var testWindowsDecoded0:[ForecastClientTypes.TestWindowSummary]? = nil
        if let testWindowsContainer = testWindowsContainer {
            testWindowsDecoded0 = [ForecastClientTypes.TestWindowSummary]()
            for structure0 in testWindowsContainer {
                if let structure0 = structure0 {
                    testWindowsDecoded0?.append(structure0)
                }
            }
        }
        testWindows = testWindowsDecoded0
    }
}

extension ForecastClientTypes.PredictorExecution: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PredictorExecution(algorithmArn: \(Swift.String(describing: algorithmArn)), testWindows: \(Swift.String(describing: testWindows)))"}
}

extension ForecastClientTypes {
    /// The algorithm used to perform a backtest and the status of those tests.
    public struct PredictorExecution: Swift.Equatable {
        /// The ARN of the algorithm used to test the predictor.
        public var algorithmArn: Swift.String?
        /// An array of test windows used to evaluate the algorithm. The
        ///         NumberOfBacktestWindows from the
        ///       object determines the number of windows in the array.
        public var testWindows: [ForecastClientTypes.TestWindowSummary]?

        public init (
            algorithmArn: Swift.String? = nil,
            testWindows: [ForecastClientTypes.TestWindowSummary]? = nil
        )
        {
            self.algorithmArn = algorithmArn
            self.testWindows = testWindows
        }
    }

}

extension ForecastClientTypes.PredictorExecutionDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorExecutions = "PredictorExecutions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let predictorExecutions = predictorExecutions {
            var predictorExecutionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .predictorExecutions)
            for predictorexecutions0 in predictorExecutions {
                try predictorExecutionsContainer.encode(predictorexecutions0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorExecutionsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.PredictorExecution?].self, forKey: .predictorExecutions)
        var predictorExecutionsDecoded0:[ForecastClientTypes.PredictorExecution]? = nil
        if let predictorExecutionsContainer = predictorExecutionsContainer {
            predictorExecutionsDecoded0 = [ForecastClientTypes.PredictorExecution]()
            for structure0 in predictorExecutionsContainer {
                if let structure0 = structure0 {
                    predictorExecutionsDecoded0?.append(structure0)
                }
            }
        }
        predictorExecutions = predictorExecutionsDecoded0
    }
}

extension ForecastClientTypes.PredictorExecutionDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PredictorExecutionDetails(predictorExecutions: \(Swift.String(describing: predictorExecutions)))"}
}

extension ForecastClientTypes {
    /// Contains details on the backtests performed to evaluate the accuracy of the predictor. The
    ///       tests are returned in descending order of accuracy, with the most accurate backtest appearing
    ///       first. You specify the number of backtests to perform when you call the  operation.
    public struct PredictorExecutionDetails: Swift.Equatable {
        /// An array of the backtests performed to evaluate the accuracy of the predictor against a
        ///       particular algorithm. The NumberOfBacktestWindows from the  object determines the number of windows in the
        ///       array.
        public var predictorExecutions: [ForecastClientTypes.PredictorExecution]?

        public init (
            predictorExecutions: [ForecastClientTypes.PredictorExecution]? = nil
        )
        {
            self.predictorExecutions = predictorExecutions
        }
    }

}

extension ForecastClientTypes.PredictorSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case datasetGroupArn = "DatasetGroupArn"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case predictorArn = "PredictorArn"
        case predictorName = "PredictorName"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let datasetGroupArn = datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let lastModificationTime = lastModificationTime {
            try encodeContainer.encode(lastModificationTime.timeIntervalSince1970, forKey: .lastModificationTime)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let predictorArn = predictorArn {
            try encodeContainer.encode(predictorArn, forKey: .predictorArn)
        }
        if let predictorName = predictorName {
            try encodeContainer.encode(predictorName, forKey: .predictorName)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
        let predictorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorName)
        predictorName = predictorNameDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension ForecastClientTypes.PredictorSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PredictorSummary(creationTime: \(Swift.String(describing: creationTime)), datasetGroupArn: \(Swift.String(describing: datasetGroupArn)), lastModificationTime: \(Swift.String(describing: lastModificationTime)), message: \(Swift.String(describing: message)), predictorArn: \(Swift.String(describing: predictorArn)), predictorName: \(Swift.String(describing: predictorName)), status: \(Swift.String(describing: status)))"}
}

extension ForecastClientTypes {
    /// Provides a summary of the predictor properties that are used in the ListPredictors operation. To get the complete set of properties, call the DescribePredictor operation, and provide the listed
    ///       PredictorArn.
    public struct PredictorSummary: Swift.Equatable {
        /// When the model training task was created.
        public var creationTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the dataset group that contains the data used to train
        ///       the predictor.
        public var datasetGroupArn: Swift.String?
        /// The last time the resource was modified. The timestamp depends on the status of the job:
        ///
        ///
        ///
        ///                   CREATE_PENDING - The CreationTime.
        ///
        ///
        ///
        ///                   CREATE_IN_PROGRESS - The current timestamp.
        ///
        ///
        ///
        ///                   CREATE_STOPPING - The current timestamp.
        ///
        ///
        ///
        ///                   CREATE_STOPPED - When the job stopped.
        ///
        ///
        ///
        ///                   ACTIVE or CREATE_FAILED - When the job finished or
        ///           failed.
        ///
        ///
        public var lastModificationTime: ClientRuntime.Date?
        /// If an error occurred, an informational message about the error.
        public var message: Swift.String?
        /// The ARN of the predictor.
        public var predictorArn: Swift.String?
        /// The name of the predictor.
        public var predictorName: Swift.String?
        /// The status of the predictor. States include:
        ///
        ///
        ///
        ///                   ACTIVE
        ///
        ///
        ///
        ///
        ///                   CREATE_PENDING, CREATE_IN_PROGRESS,
        ///           CREATE_FAILED
        ///
        ///
        ///
        ///
        ///                   DELETE_PENDING, DELETE_IN_PROGRESS,
        ///           DELETE_FAILED
        ///
        ///
        ///
        ///
        ///                   CREATE_STOPPING, CREATE_STOPPED
        ///
        ///
        ///
        ///
        ///             The Status of the predictor must be ACTIVE before you can use
        ///         the predictor to create a forecast.
        ///
        public var status: Swift.String?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            datasetGroupArn: Swift.String? = nil,
            lastModificationTime: ClientRuntime.Date? = nil,
            message: Swift.String? = nil,
            predictorArn: Swift.String? = nil,
            predictorName: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.datasetGroupArn = datasetGroupArn
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.predictorArn = predictorArn
            self.predictorName = predictorName
            self.status = status
        }
    }

}

extension ResourceAlreadyExistsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceAlreadyExistsException(message: \(Swift.String(describing: message)))"}
}

extension ResourceAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There is already a resource with this name. Try again with a different name.
public struct ResourceAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceAlreadyExistsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceInUseException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceInUseException(message: \(Swift.String(describing: message)))"}
}

extension ResourceInUseException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource is in use.
public struct ResourceInUseException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// We can't find a resource with that Amazon Resource Name (ARN). Check the ARN and try
///       again.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ForecastClientTypes.S3Config: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kMSKeyArn = "KMSKeyArn"
        case path = "Path"
        case roleArn = "RoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kMSKeyArn = kMSKeyArn {
            try encodeContainer.encode(kMSKeyArn, forKey: .kMSKeyArn)
        }
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let kMSKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSKeyArn)
        kMSKeyArn = kMSKeyArnDecoded
    }
}

extension ForecastClientTypes.S3Config: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "S3Config(kMSKeyArn: \(Swift.String(describing: kMSKeyArn)), path: \(Swift.String(describing: path)), roleArn: \(Swift.String(describing: roleArn)))"}
}

extension ForecastClientTypes {
    /// The path to the file(s) in an Amazon Simple Storage Service (Amazon S3) bucket, and an AWS Identity and Access Management (IAM) role that
    ///       Amazon Forecast can assume to access the file(s). Optionally, includes an AWS Key Management Service (KMS) key. This
    ///       object is part of the DataSource object that is submitted in the CreateDatasetImportJob request, and part of the DataDestination object.
    public struct S3Config: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of an AWS Key Management Service (KMS) key.
        public var kMSKeyArn: Swift.String?
        /// The path to an Amazon Simple Storage Service (Amazon S3) bucket or file(s) in an Amazon S3 bucket.
        /// This member is required.
        public var path: Swift.String?
        /// The ARN of the AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the Amazon S3
        ///       bucket or files. If you provide a value for the KMSKeyArn key, the role must
        ///       allow access to the key.
        ///          Passing a role across AWS accounts is not allowed. If you pass a role that isn't in your
        ///       account, you get an InvalidInputException error.
        /// This member is required.
        public var roleArn: Swift.String?

        public init (
            kMSKeyArn: Swift.String? = nil,
            path: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.kMSKeyArn = kMSKeyArn
            self.path = path
            self.roleArn = roleArn
        }
    }

}

extension ForecastClientTypes {
    public enum ScalingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case auto
        case linear
        case logarithmic
        case reverselogarithmic
        case sdkUnknown(Swift.String)

        public static var allCases: [ScalingType] {
            return [
                .auto,
                .linear,
                .logarithmic,
                .reverselogarithmic,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .auto: return "Auto"
            case .linear: return "Linear"
            case .logarithmic: return "Logarithmic"
            case .reverselogarithmic: return "ReverseLogarithmic"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScalingType(rawValue: rawValue) ?? ScalingType.sdkUnknown(rawValue)
        }
    }
}

extension ForecastClientTypes.Schema: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for schemaattributes0 in attributes {
                try attributesContainer.encode(schemaattributes0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([ForecastClientTypes.SchemaAttribute?].self, forKey: .attributes)
        var attributesDecoded0:[ForecastClientTypes.SchemaAttribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [ForecastClientTypes.SchemaAttribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension ForecastClientTypes.Schema: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Schema(attributes: \(Swift.String(describing: attributes)))"}
}

extension ForecastClientTypes {
    /// Defines the fields of a dataset. You specify this object in the CreateDataset request.
    public struct Schema: Swift.Equatable {
        /// An array of attributes specifying the name and type of each field in a dataset.
        public var attributes: [ForecastClientTypes.SchemaAttribute]?

        public init (
            attributes: [ForecastClientTypes.SchemaAttribute]? = nil
        )
        {
            self.attributes = attributes
        }
    }

}

extension ForecastClientTypes.SchemaAttribute: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "AttributeName"
        case attributeType = "AttributeType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = attributeName {
            try encodeContainer.encode(attributeName, forKey: .attributeName)
        }
        if let attributeType = attributeType {
            try encodeContainer.encode(attributeType.rawValue, forKey: .attributeType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let attributeTypeDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.AttributeType.self, forKey: .attributeType)
        attributeType = attributeTypeDecoded
    }
}

extension ForecastClientTypes.SchemaAttribute: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SchemaAttribute(attributeName: \(Swift.String(describing: attributeName)), attributeType: \(Swift.String(describing: attributeType)))"}
}

extension ForecastClientTypes {
    /// An attribute of a schema, which defines a dataset field. A schema attribute is required
    ///       for every field in a dataset. The Schema object contains an array of
    ///         SchemaAttribute objects.
    public struct SchemaAttribute: Swift.Equatable {
        /// The name of the dataset field.
        public var attributeName: Swift.String?
        /// The data type of the field.
        public var attributeType: ForecastClientTypes.AttributeType?

        public init (
            attributeName: Swift.String? = nil,
            attributeType: ForecastClientTypes.AttributeType? = nil
        )
        {
            self.attributeName = attributeName
            self.attributeType = attributeType
        }
    }

}

extension ForecastClientTypes.Statistics: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case avg = "Avg"
        case count = "Count"
        case countDistinct = "CountDistinct"
        case countDistinctLong = "CountDistinctLong"
        case countLong = "CountLong"
        case countNan = "CountNan"
        case countNanLong = "CountNanLong"
        case countNull = "CountNull"
        case countNullLong = "CountNullLong"
        case max = "Max"
        case min = "Min"
        case stddev = "Stddev"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let avg = avg {
            try encodeContainer.encode(avg, forKey: .avg)
        }
        if let count = count {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let countDistinct = countDistinct {
            try encodeContainer.encode(countDistinct, forKey: .countDistinct)
        }
        if let countDistinctLong = countDistinctLong {
            try encodeContainer.encode(countDistinctLong, forKey: .countDistinctLong)
        }
        if let countLong = countLong {
            try encodeContainer.encode(countLong, forKey: .countLong)
        }
        if let countNan = countNan {
            try encodeContainer.encode(countNan, forKey: .countNan)
        }
        if let countNanLong = countNanLong {
            try encodeContainer.encode(countNanLong, forKey: .countNanLong)
        }
        if let countNull = countNull {
            try encodeContainer.encode(countNull, forKey: .countNull)
        }
        if let countNullLong = countNullLong {
            try encodeContainer.encode(countNullLong, forKey: .countNullLong)
        }
        if let max = max {
            try encodeContainer.encode(max, forKey: .max)
        }
        if let min = min {
            try encodeContainer.encode(min, forKey: .min)
        }
        if let stddev = stddev {
            try encodeContainer.encode(stddev, forKey: .stddev)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count)
        count = countDecoded
        let countDistinctDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .countDistinct)
        countDistinct = countDistinctDecoded
        let countNullDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .countNull)
        countNull = countNullDecoded
        let countNanDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .countNan)
        countNan = countNanDecoded
        let minDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .min)
        min = minDecoded
        let maxDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .max)
        max = maxDecoded
        let avgDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .avg)
        avg = avgDecoded
        let stddevDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .stddev)
        stddev = stddevDecoded
        let countLongDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .countLong)
        countLong = countLongDecoded
        let countDistinctLongDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .countDistinctLong)
        countDistinctLong = countDistinctLongDecoded
        let countNullLongDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .countNullLong)
        countNullLong = countNullLongDecoded
        let countNanLongDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .countNanLong)
        countNanLong = countNanLongDecoded
    }
}

extension ForecastClientTypes.Statistics: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Statistics(avg: \(Swift.String(describing: avg)), count: \(Swift.String(describing: count)), countDistinct: \(Swift.String(describing: countDistinct)), countDistinctLong: \(Swift.String(describing: countDistinctLong)), countLong: \(Swift.String(describing: countLong)), countNan: \(Swift.String(describing: countNan)), countNanLong: \(Swift.String(describing: countNanLong)), countNull: \(Swift.String(describing: countNull)), countNullLong: \(Swift.String(describing: countNullLong)), max: \(Swift.String(describing: max)), min: \(Swift.String(describing: min)), stddev: \(Swift.String(describing: stddev)))"}
}

extension ForecastClientTypes {
    /// Provides statistics for each data field imported into to an Amazon Forecast dataset with
    ///       the CreateDatasetImportJob operation.
    public struct Statistics: Swift.Equatable {
        /// For a numeric field, the average value in the field.
        public var avg: Swift.Double?
        /// The number of values in the field. If the response value is -1, refer to
        ///         CountLong.
        public var count: Swift.Int?
        /// The number of distinct values in the field. If the response value is -1, refer to
        ///       CountDistinctLong.
        public var countDistinct: Swift.Int?
        /// The number of distinct values in the field. CountDistinctLong is used instead
        ///       of CountDistinct if the value is greater than 2,147,483,647.
        public var countDistinctLong: Swift.Int?
        /// The number of values in the field. CountLong is used instead of
        ///         Count if the value is greater than 2,147,483,647.
        public var countLong: Swift.Int?
        /// The number of NAN (not a number) values in the field. If the response value is -1, refer to
        ///       CountNanLong.
        public var countNan: Swift.Int?
        /// The number of NAN (not a number) values in the field. CountNanLong is used
        ///       instead of CountNan if the value is greater than 2,147,483,647.
        public var countNanLong: Swift.Int?
        /// The number of null values in the field. If the response value is -1, refer to
        ///       CountNullLong.
        public var countNull: Swift.Int?
        /// The number of null values in the field. CountNullLong is used instead of
        ///         CountNull if the value is greater than 2,147,483,647.
        public var countNullLong: Swift.Int?
        /// For a numeric field, the maximum value in the field.
        public var max: Swift.String?
        /// For a numeric field, the minimum value in the field.
        public var min: Swift.String?
        /// For a numeric field, the standard deviation.
        public var stddev: Swift.Double?

        public init (
            avg: Swift.Double? = nil,
            count: Swift.Int? = nil,
            countDistinct: Swift.Int? = nil,
            countDistinctLong: Swift.Int? = nil,
            countLong: Swift.Int? = nil,
            countNan: Swift.Int? = nil,
            countNanLong: Swift.Int? = nil,
            countNull: Swift.Int? = nil,
            countNullLong: Swift.Int? = nil,
            max: Swift.String? = nil,
            min: Swift.String? = nil,
            stddev: Swift.Double? = nil
        )
        {
            self.avg = avg
            self.count = count
            self.countDistinct = countDistinct
            self.countDistinctLong = countDistinctLong
            self.countLong = countLong
            self.countNan = countNan
            self.countNanLong = countNanLong
            self.countNull = countNull
            self.countNullLong = countNullLong
            self.max = max
            self.min = min
            self.stddev = stddev
        }
    }

}

public struct StopResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopResourceOutputError>
}

extension StopResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension StopResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct StopResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopResourceOutputError>
}

public struct StopResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopResourceOutputError>
}

public struct StopResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: StopResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StopResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<StopResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopResourceOutputError>
}

public struct StopResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that identifies the resource to stop. The supported ARNs
    ///          are DatasetImportJobArn, PredictorArn,
    ///             PredictorBacktestExportJobArn, ForecastArn, and
    ///             ForecastExportJobArn.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct StopResourceInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
}

extension StopResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension StopResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopResourceOutputResponse()"}
}

extension StopResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StopResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct StopResourceOutputResponseBody: Swift.Equatable {
}

extension StopResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ForecastClientTypes.SupplementaryFeature: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ForecastClientTypes.SupplementaryFeature: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SupplementaryFeature(name: \(Swift.String(describing: name)), value: \(Swift.String(describing: value)))"}
}

extension ForecastClientTypes {
    /// Describes a supplementary feature of a dataset group. This object is part of the InputDataConfig object. Forecast supports the Weather Index and Holidays built-in
    ///       featurizations.
    ///
    ///             Weather Index
    ///
    ///          The Amazon Forecast Weather Index is a built-in featurization that incorporates historical and
    ///       projected weather information into your model. The Weather Index supplements your datasets
    ///       with over two years of historical weather data and up to 14 days of projected weather data.
    ///       For more information, see <a href="https://docs.aws.amazon.com/forecast/latest/dg/weather.html">Amazon Forecast Weather Index.
    ///
    ///             Holidays
    ///
    ///          Holidays is a built-in featurization that incorporates a feature-engineered dataset of
    ///       national holiday information into your model. It provides native support for the holiday
    ///       calendars of 66 countries. To view the holiday calendars, refer to the <a href="http://jollyday.sourceforge.net/data.html">Jollyday library. For more
    ///       information, see <a href="https://docs.aws.amazon.com/forecast/latest/dg/holidays.html">Holidays Featurization.
    public struct SupplementaryFeature: Swift.Equatable {
        /// The name of the feature. Valid values: "holiday" and "weather".
        /// This member is required.
        public var name: Swift.String?
        ///
        ///             Weather Index
        ///
        ///          To enable the Weather Index, set the value to "true"
        ///
        ///
        ///             Holidays
        ///
        ///          To enable Holidays, specify a country with one of the following two-letter country
        ///       codes:
        ///
        ///
        ///                "AL" - ALBANIA
        ///
        ///
        ///                "AR" - ARGENTINA
        ///
        ///
        ///                "AT" - AUSTRIA
        ///
        ///
        ///                "AU" - AUSTRALIA
        ///
        ///
        ///                "BA" - BOSNIA HERZEGOVINA
        ///
        ///
        ///                "BE" - BELGIUM
        ///
        ///
        ///                "BG" - BULGARIA
        ///
        ///
        ///                "BO" - BOLIVIA
        ///
        ///
        ///                "BR" - BRAZIL
        ///
        ///
        ///                "BY" - BELARUS
        ///
        ///
        ///                "CA" - CANADA
        ///
        ///
        ///                "CL" - CHILE
        ///
        ///
        ///                "CO" - COLOMBIA
        ///
        ///
        ///                "CR" - COSTA RICA
        ///
        ///
        ///                "HR" - CROATIA
        ///
        ///
        ///                "CZ" - CZECH REPUBLIC
        ///
        ///
        ///                "DK" - DENMARK
        ///
        ///
        ///                "EC" - ECUADOR
        ///
        ///
        ///                "EE" - ESTONIA
        ///
        ///
        ///                "ET" - ETHIOPIA
        ///
        ///
        ///                "FI" - FINLAND
        ///
        ///
        ///                "FR" - FRANCE
        ///
        ///
        ///                "DE" - GERMANY
        ///
        ///
        ///                "GR" - GREECE
        ///
        ///
        ///                "HU" - HUNGARY
        ///
        ///
        ///                "IS" - ICELAND
        ///
        ///
        ///                "IN" - INDIA
        ///
        ///
        ///                "IE" - IRELAND
        ///
        ///
        ///                "IT" - ITALY
        ///
        ///
        ///                "JP" - JAPAN
        ///
        ///
        ///                "KZ" - KAZAKHSTAN
        ///
        ///
        ///                "KR" - KOREA
        ///
        ///
        ///                "LV" - LATVIA
        ///
        ///
        ///                "LI" - LIECHTENSTEIN
        ///
        ///
        ///                "LT" - LITHUANIA
        ///
        ///
        ///                "LU" - LUXEMBOURG
        ///
        ///
        ///                "MK" - MACEDONIA
        ///
        ///
        ///                "MT" - MALTA
        ///
        ///
        ///                "MX" - MEXICO
        ///
        ///
        ///                "MD" - MOLDOVA
        ///
        ///
        ///                "ME" - MONTENEGRO
        ///
        ///
        ///                "NL" - NETHERLANDS
        ///
        ///
        ///                "NZ" - NEW ZEALAND
        ///
        ///
        ///                "NI" - NICARAGUA
        ///
        ///
        ///                "NG" - NIGERIA
        ///
        ///
        ///                "NO" - NORWAY
        ///
        ///
        ///                "PA" - PANAMA
        ///
        ///
        ///                "PY" - PARAGUAY
        ///
        ///
        ///                "PE" - PERU
        ///
        ///
        ///                "PL" - POLAND
        ///
        ///
        ///                "PT" - PORTUGAL
        ///
        ///
        ///                "RO" - ROMANIA
        ///
        ///
        ///                "RU" - RUSSIA
        ///
        ///
        ///                "RS" - SERBIA
        ///
        ///
        ///                "SK" - SLOVAKIA
        ///
        ///
        ///                "SI" - SLOVENIA
        ///
        ///
        ///                "ZA" - SOUTH AFRICA
        ///
        ///
        ///                "ES" - SPAIN
        ///
        ///
        ///                "SE" - SWEDEN
        ///
        ///
        ///                "CH" - SWITZERLAND
        ///
        ///
        ///                "UA" - UKRAINE
        ///
        ///
        ///                "AE" - UNITED ARAB EMIRATES
        ///
        ///
        ///                "US" - UNITED STATES
        ///
        ///
        ///                "UK" - UNITED KINGDOM
        ///
        ///
        ///                "UY" - URUGUAY
        ///
        ///
        ///                "VE" - VENEZUELA
        ///
        ///
        /// This member is required.
        public var value: Swift.String?

        public init (
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension ForecastClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ForecastClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension ForecastClientTypes {
    /// The optional metadata that you apply to a resource to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define.
    ///          The following basic restrictions apply to tags:
    ///
    ///
    ///                Maximum number of tags per resource - 50.
    ///
    ///
    ///                For each resource, each tag key must be unique, and each tag key can have only one value.
    ///
    ///
    ///                Maximum key length - 128 Unicode characters in UTF-8.
    ///
    ///
    ///                Maximum value length - 256 Unicode characters in UTF-8.
    ///
    ///
    ///                If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.
    ///
    ///
    ///                Tag keys and values are case sensitive.
    ///
    ///
    ///                Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
    ///
    ///
    public struct Tag: Swift.Equatable {
        /// One part of a key-value pair that makes up a tag. A key is a general label that acts like a category for more specific tag values.
        /// This member is required.
        public var key: Swift.String?
        /// The optional part of a key-value pair that makes up a tag. A value acts as a descriptor within a tag category (key).
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that identifies the resource for which to list the tags. Currently, the supported resources are Forecast dataset groups, datasets, dataset import jobs, predictors, forecasts, and forecast export jobs.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to add to the resource. A tag is an array of key-value pairs.
    ///          The following basic restrictions apply to tags:
    ///
    ///
    ///                Maximum number of tags per resource - 50.
    ///
    ///
    ///                For each resource, each tag key must be unique, and each tag key can have only one value.
    ///
    ///
    ///                Maximum key length - 128 Unicode characters in UTF-8.
    ///
    ///
    ///                Maximum value length - 256 Unicode characters in UTF-8.
    ///
    ///
    ///                If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.
    ///
    ///
    ///                Tag keys and values are case sensitive.
    ///
    ///
    ///                Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
    ///
    ///
    /// This member is required.
    public var tags: [ForecastClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [ForecastClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
    public let tags: [ForecastClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ForecastClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ForecastClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ForecastClientTypes.TestWindowSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case status = "Status"
        case testWindowEnd = "TestWindowEnd"
        case testWindowStart = "TestWindowStart"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let testWindowEnd = testWindowEnd {
            try encodeContainer.encode(testWindowEnd.timeIntervalSince1970, forKey: .testWindowEnd)
        }
        if let testWindowStart = testWindowStart {
            try encodeContainer.encode(testWindowStart.timeIntervalSince1970, forKey: .testWindowStart)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testWindowStartDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .testWindowStart)
        testWindowStart = testWindowStartDecoded
        let testWindowEndDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .testWindowEnd)
        testWindowEnd = testWindowEndDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ForecastClientTypes.TestWindowSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TestWindowSummary(message: \(Swift.String(describing: message)), status: \(Swift.String(describing: status)), testWindowEnd: \(Swift.String(describing: testWindowEnd)), testWindowStart: \(Swift.String(describing: testWindowStart)))"}
}

extension ForecastClientTypes {
    /// The status, start time, and end time of a backtest, as well as a failure reason if
    ///       applicable.
    public struct TestWindowSummary: Swift.Equatable {
        /// If the test failed, the reason why it failed.
        public var message: Swift.String?
        /// The status of the test. Possible status values are:
        ///
        ///
        ///
        ///                   ACTIVE
        ///
        ///
        ///
        ///
        ///                   CREATE_IN_PROGRESS
        ///
        ///
        ///
        ///
        ///                   CREATE_FAILED
        ///
        ///
        ///
        public var status: Swift.String?
        /// The time at which the test ended.
        public var testWindowEnd: ClientRuntime.Date?
        /// The time at which the test began.
        public var testWindowStart: ClientRuntime.Date?

        public init (
            message: Swift.String? = nil,
            status: Swift.String? = nil,
            testWindowEnd: ClientRuntime.Date? = nil,
            testWindowStart: ClientRuntime.Date? = nil
        )
        {
            self.message = message
            self.status = status
            self.testWindowEnd = testWindowEnd
            self.testWindowStart = testWindowStart
        }
    }

}

public struct UntagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeys0 in tagKeys {
                try tagKeysContainer.encode(tagkeys0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that identifies the resource for which to list the tags. Currently, the supported resources are Forecast dataset groups, datasets, dataset import jobs, predictors, forecasts, and forecast exports.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of the tags to be removed.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
    public let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateDatasetGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDatasetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDatasetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDatasetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDatasetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDatasetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDatasetGroupOutputError>
}

extension UpdateDatasetGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDatasetGroupInput(datasetArns: \(Swift.String(describing: datasetArns)), datasetGroupArn: \(Swift.String(describing: datasetGroupArn)))"}
}

extension UpdateDatasetGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArns = "DatasetArns"
        case datasetGroupArn = "DatasetGroupArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetArns = datasetArns {
            var datasetArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .datasetArns)
            for arnlist0 in datasetArns {
                try datasetArnsContainer.encode(arnlist0)
            }
        }
        if let datasetGroupArn = datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
    }
}

public struct UpdateDatasetGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDatasetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDatasetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDatasetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDatasetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDatasetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDatasetGroupOutputError>
}

public struct UpdateDatasetGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDatasetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDatasetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDatasetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDatasetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDatasetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDatasetGroupOutputError>
}

public struct UpdateDatasetGroupInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDatasetGroupInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateDatasetGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDatasetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateDatasetGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDatasetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDatasetGroupOutputError>
}

public struct UpdateDatasetGroupInput: Swift.Equatable {
    /// An array of the Amazon Resource Names (ARNs) of the datasets to add to the dataset
    ///       group.
    /// This member is required.
    public var datasetArns: [Swift.String]?
    /// The ARN of the dataset group.
    /// This member is required.
    public var datasetGroupArn: Swift.String?

    public init (
        datasetArns: [Swift.String]? = nil,
        datasetGroupArn: Swift.String? = nil
    )
    {
        self.datasetArns = datasetArns
        self.datasetGroupArn = datasetGroupArn
    }
}

struct UpdateDatasetGroupInputBody: Swift.Equatable {
    public let datasetGroupArn: Swift.String?
    public let datasetArns: [Swift.String]?
}

extension UpdateDatasetGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArns = "DatasetArns"
        case datasetGroupArn = "DatasetGroupArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let datasetArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .datasetArns)
        var datasetArnsDecoded0:[Swift.String]? = nil
        if let datasetArnsContainer = datasetArnsContainer {
            datasetArnsDecoded0 = [Swift.String]()
            for string0 in datasetArnsContainer {
                if let string0 = string0 {
                    datasetArnsDecoded0?.append(string0)
                }
            }
        }
        datasetArns = datasetArnsDecoded0
    }
}

extension UpdateDatasetGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDatasetGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDatasetGroupOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDatasetGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDatasetGroupOutputResponse()"}
}

extension UpdateDatasetGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDatasetGroupOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateDatasetGroupOutputResponseBody: Swift.Equatable {
}

extension UpdateDatasetGroupOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ForecastClientTypes.WeightedQuantileLoss: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lossValue = "LossValue"
        case quantile = "Quantile"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lossValue = lossValue {
            try encodeContainer.encode(lossValue, forKey: .lossValue)
        }
        if let quantile = quantile {
            try encodeContainer.encode(quantile, forKey: .quantile)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantileDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .quantile)
        quantile = quantileDecoded
        let lossValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .lossValue)
        lossValue = lossValueDecoded
    }
}

extension ForecastClientTypes.WeightedQuantileLoss: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "WeightedQuantileLoss(lossValue: \(Swift.String(describing: lossValue)), quantile: \(Swift.String(describing: quantile)))"}
}

extension ForecastClientTypes {
    /// The weighted loss value for a quantile. This object is part of the Metrics object.
    public struct WeightedQuantileLoss: Swift.Equatable {
        /// The difference between the predicted value and the actual value over the quantile,
        ///       weighted (normalized) by dividing by the sum over all quantiles.
        public var lossValue: Swift.Double?
        /// The quantile. Quantiles divide a probability distribution into regions of equal
        ///       probability. For example, if the distribution was divided into 5 regions of equal probability,
        ///       the quantiles would be 0.2, 0.4, 0.6, and 0.8.
        public var quantile: Swift.Double?

        public init (
            lossValue: Swift.Double? = nil,
            quantile: Swift.Double? = nil
        )
        {
            self.lossValue = lossValue
            self.quantile = quantile
        }
    }

}

extension ForecastClientTypes.WindowSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evaluationType = "EvaluationType"
        case itemCount = "ItemCount"
        case metrics = "Metrics"
        case testWindowEnd = "TestWindowEnd"
        case testWindowStart = "TestWindowStart"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let evaluationType = evaluationType {
            try encodeContainer.encode(evaluationType.rawValue, forKey: .evaluationType)
        }
        if let itemCount = itemCount {
            try encodeContainer.encode(itemCount, forKey: .itemCount)
        }
        if let metrics = metrics {
            try encodeContainer.encode(metrics, forKey: .metrics)
        }
        if let testWindowEnd = testWindowEnd {
            try encodeContainer.encode(testWindowEnd.timeIntervalSince1970, forKey: .testWindowEnd)
        }
        if let testWindowStart = testWindowStart {
            try encodeContainer.encode(testWindowStart.timeIntervalSince1970, forKey: .testWindowStart)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testWindowStartDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .testWindowStart)
        testWindowStart = testWindowStartDecoded
        let testWindowEndDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .testWindowEnd)
        testWindowEnd = testWindowEndDecoded
        let itemCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .itemCount)
        itemCount = itemCountDecoded
        let evaluationTypeDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.EvaluationType.self, forKey: .evaluationType)
        evaluationType = evaluationTypeDecoded
        let metricsDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.Metrics.self, forKey: .metrics)
        metrics = metricsDecoded
    }
}

extension ForecastClientTypes.WindowSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "WindowSummary(evaluationType: \(Swift.String(describing: evaluationType)), itemCount: \(Swift.String(describing: itemCount)), metrics: \(Swift.String(describing: metrics)), testWindowEnd: \(Swift.String(describing: testWindowEnd)), testWindowStart: \(Swift.String(describing: testWindowStart)))"}
}

extension ForecastClientTypes {
    /// The metrics for a time range within the evaluation portion of a dataset. This object is
    ///       part of the EvaluationResult object.
    ///          The TestWindowStart and TestWindowEnd parameters are determined
    ///       by the BackTestWindowOffset parameter of the EvaluationParameters object.
    public struct WindowSummary: Swift.Equatable {
        /// The type of evaluation.
        ///
        ///
        ///
        ///                   SUMMARY - The average metrics across all windows.
        ///
        ///
        ///
        ///                   COMPUTED - The metrics for the specified window.
        ///
        ///
        public var evaluationType: ForecastClientTypes.EvaluationType?
        /// The number of data points within the window.
        public var itemCount: Swift.Int?
        /// Provides metrics used to evaluate the performance of a predictor.
        public var metrics: ForecastClientTypes.Metrics?
        /// The timestamp that defines the end of the window.
        public var testWindowEnd: ClientRuntime.Date?
        /// The timestamp that defines the start of the window.
        public var testWindowStart: ClientRuntime.Date?

        public init (
            evaluationType: ForecastClientTypes.EvaluationType? = nil,
            itemCount: Swift.Int? = nil,
            metrics: ForecastClientTypes.Metrics? = nil,
            testWindowEnd: ClientRuntime.Date? = nil,
            testWindowStart: ClientRuntime.Date? = nil
        )
        {
            self.evaluationType = evaluationType
            self.itemCount = itemCount
            self.metrics = metrics
            self.testWindowEnd = testWindowEnd
            self.testWindowStart = testWindowStart
        }
    }

}
