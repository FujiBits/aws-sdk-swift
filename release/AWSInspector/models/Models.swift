// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension InspectorClientTypes {
    public enum AccessDeniedErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessDeniedToAssessmentRun
        case accessDeniedToAssessmentTarget
        case accessDeniedToAssessmentTemplate
        case accessDeniedToFinding
        case accessDeniedToIamRole
        case accessDeniedToResourceGroup
        case accessDeniedToRulesPackage
        case accessDeniedToSnsTopic
        case sdkUnknown(Swift.String)

        public static var allCases: [AccessDeniedErrorCode] {
            return [
                .accessDeniedToAssessmentRun,
                .accessDeniedToAssessmentTarget,
                .accessDeniedToAssessmentTemplate,
                .accessDeniedToFinding,
                .accessDeniedToIamRole,
                .accessDeniedToResourceGroup,
                .accessDeniedToRulesPackage,
                .accessDeniedToSnsTopic,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessDeniedToAssessmentRun: return "ACCESS_DENIED_TO_ASSESSMENT_RUN"
            case .accessDeniedToAssessmentTarget: return "ACCESS_DENIED_TO_ASSESSMENT_TARGET"
            case .accessDeniedToAssessmentTemplate: return "ACCESS_DENIED_TO_ASSESSMENT_TEMPLATE"
            case .accessDeniedToFinding: return "ACCESS_DENIED_TO_FINDING"
            case .accessDeniedToIamRole: return "ACCESS_DENIED_TO_IAM_ROLE"
            case .accessDeniedToResourceGroup: return "ACCESS_DENIED_TO_RESOURCE_GROUP"
            case .accessDeniedToRulesPackage: return "ACCESS_DENIED_TO_RULES_PACKAGE"
            case .accessDeniedToSnsTopic: return "ACCESS_DENIED_TO_SNS_TOPIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AccessDeniedErrorCode(rawValue: rawValue) ?? AccessDeniedErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension AccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessDeniedException(canRetry: \(Swift.String(describing: canRetry)), errorCode: \(Swift.String(describing: errorCode)), message: \(Swift.String(describing: message)))"}
}

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.canRetry = output.canRetry
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.canRetry = nil
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You do not have required permissions to access the requested resource.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// You can immediately retry your request.
    /// This member is required.
    public var canRetry: Swift.Bool?
    /// Code that indicates the type of error that is generated.
    /// This member is required.
    public var errorCode: InspectorClientTypes.AccessDeniedErrorCode?
    /// Details of the exception error.
    /// This member is required.
    public var message: Swift.String?

    public init (
        canRetry: Swift.Bool? = nil,
        errorCode: InspectorClientTypes.AccessDeniedErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.canRetry = canRetry
        self.errorCode = errorCode
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let errorCode: InspectorClientTypes.AccessDeniedErrorCode?
    public let canRetry: Swift.Bool?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case canRetry
        case errorCode
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.AccessDeniedErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let canRetryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .canRetry)
        canRetry = canRetryDecoded
    }
}

public struct AddAttributesToFindingsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddAttributesToFindingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddAttributesToFindingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddAttributesToFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddAttributesToFindingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddAttributesToFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddAttributesToFindingsOutputError>
}

extension AddAttributesToFindingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddAttributesToFindingsInput(attributes: \(Swift.String(describing: attributes)), findingArns: \(Swift.String(describing: findingArns)))"}
}

extension AddAttributesToFindingsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case findingArns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for userattributelist0 in attributes {
                try attributesContainer.encode(userattributelist0)
            }
        }
        if let findingArns = findingArns {
            var findingArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingArns)
            for addremoveattributesfindingarnlist0 in findingArns {
                try findingArnsContainer.encode(addremoveattributesfindingarnlist0)
            }
        }
    }
}

public struct AddAttributesToFindingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddAttributesToFindingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddAttributesToFindingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddAttributesToFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddAttributesToFindingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddAttributesToFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddAttributesToFindingsOutputError>
}

public struct AddAttributesToFindingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddAttributesToFindingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddAttributesToFindingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddAttributesToFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddAttributesToFindingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddAttributesToFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddAttributesToFindingsOutputError>
}

public struct AddAttributesToFindingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddAttributesToFindingsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: AddAttributesToFindingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddAttributesToFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AddAttributesToFindingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<AddAttributesToFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddAttributesToFindingsOutputError>
}

public struct AddAttributesToFindingsInput: Swift.Equatable {
    /// The array of attributes that you want to assign to specified findings.
    /// This member is required.
    public var attributes: [InspectorClientTypes.Attribute]?
    /// The ARNs that specify the findings that you want to assign attributes to.
    /// This member is required.
    public var findingArns: [Swift.String]?

    public init (
        attributes: [InspectorClientTypes.Attribute]? = nil,
        findingArns: [Swift.String]? = nil
    )
    {
        self.attributes = attributes
        self.findingArns = findingArns
    }
}

struct AddAttributesToFindingsInputBody: Swift.Equatable {
    public let findingArns: [Swift.String]?
    public let attributes: [InspectorClientTypes.Attribute]?
}

extension AddAttributesToFindingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case findingArns
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .findingArns)
        var findingArnsDecoded0:[Swift.String]? = nil
        if let findingArnsContainer = findingArnsContainer {
            findingArnsDecoded0 = [Swift.String]()
            for string0 in findingArnsContainer {
                if let string0 = string0 {
                    findingArnsDecoded0?.append(string0)
                }
            }
        }
        findingArns = findingArnsDecoded0
        let attributesContainer = try containerValues.decodeIfPresent([InspectorClientTypes.Attribute?].self, forKey: .attributes)
        var attributesDecoded0:[InspectorClientTypes.Attribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [InspectorClientTypes.Attribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension AddAttributesToFindingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddAttributesToFindingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceTemporarilyUnavailableException" : self = .serviceTemporarilyUnavailableException(try ServiceTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddAttributesToFindingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceTemporarilyUnavailableException(ServiceTemporarilyUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddAttributesToFindingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddAttributesToFindingsOutputResponse(failedItems: \(Swift.String(describing: failedItems)))"}
}

extension AddAttributesToFindingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AddAttributesToFindingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failedItems = output.failedItems
        } else {
            self.failedItems = nil
        }
    }
}

public struct AddAttributesToFindingsOutputResponse: Swift.Equatable {
    /// Attribute details that cannot be described. An error code is provided for each failed
    ///          item.
    /// This member is required.
    public var failedItems: [Swift.String:InspectorClientTypes.FailedItemDetails]?

    public init (
        failedItems: [Swift.String:InspectorClientTypes.FailedItemDetails]? = nil
    )
    {
        self.failedItems = failedItems
    }
}

struct AddAttributesToFindingsOutputResponseBody: Swift.Equatable {
    public let failedItems: [Swift.String:InspectorClientTypes.FailedItemDetails]?
}

extension AddAttributesToFindingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedItems
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedItemsContainer = try containerValues.decodeIfPresent([Swift.String: InspectorClientTypes.FailedItemDetails?].self, forKey: .failedItems)
        var failedItemsDecoded0: [Swift.String:InspectorClientTypes.FailedItemDetails]? = nil
        if let failedItemsContainer = failedItemsContainer {
            failedItemsDecoded0 = [Swift.String:InspectorClientTypes.FailedItemDetails]()
            for (key0, faileditemdetails0) in failedItemsContainer {
                if let faileditemdetails0 = faileditemdetails0 {
                    failedItemsDecoded0?[key0] = faileditemdetails0
                }
            }
        }
        failedItems = failedItemsDecoded0
    }
}

extension InspectorClientTypes.AgentAlreadyRunningAssessment: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentId
        case assessmentRunArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentId = agentId {
            try encodeContainer.encode(agentId, forKey: .agentId)
        }
        if let assessmentRunArn = assessmentRunArn {
            try encodeContainer.encode(assessmentRunArn, forKey: .assessmentRunArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentId)
        agentId = agentIdDecoded
        let assessmentRunArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentRunArn)
        assessmentRunArn = assessmentRunArnDecoded
    }
}

extension InspectorClientTypes.AgentAlreadyRunningAssessment: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AgentAlreadyRunningAssessment(agentId: \(Swift.String(describing: agentId)), assessmentRunArn: \(Swift.String(describing: assessmentRunArn)))"}
}

extension InspectorClientTypes {
    /// Used in the exception error that is thrown if you start an assessment run for an
    ///          assessment target that includes an EC2 instance that is already participating in another
    ///          started assessment run.
    public struct AgentAlreadyRunningAssessment: Swift.Equatable {
        /// ID of the agent that is running on an EC2 instance that is already participating in
        ///          another started assessment run.
        /// This member is required.
        public var agentId: Swift.String?
        /// The ARN of the assessment run that has already been started.
        /// This member is required.
        public var assessmentRunArn: Swift.String?

        public init (
            agentId: Swift.String? = nil,
            assessmentRunArn: Swift.String? = nil
        )
        {
            self.agentId = agentId
            self.assessmentRunArn = assessmentRunArn
        }
    }

}

extension InspectorClientTypes.AgentFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentHealthCodes
        case agentHealths
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentHealthCodes = agentHealthCodes {
            var agentHealthCodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .agentHealthCodes)
            for agenthealthcodelist0 in agentHealthCodes {
                try agentHealthCodesContainer.encode(agenthealthcodelist0.rawValue)
            }
        }
        if let agentHealths = agentHealths {
            var agentHealthsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .agentHealths)
            for agenthealthlist0 in agentHealths {
                try agentHealthsContainer.encode(agenthealthlist0.rawValue)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentHealthsContainer = try containerValues.decodeIfPresent([InspectorClientTypes.AgentHealth?].self, forKey: .agentHealths)
        var agentHealthsDecoded0:[InspectorClientTypes.AgentHealth]? = nil
        if let agentHealthsContainer = agentHealthsContainer {
            agentHealthsDecoded0 = [InspectorClientTypes.AgentHealth]()
            for string0 in agentHealthsContainer {
                if let string0 = string0 {
                    agentHealthsDecoded0?.append(string0)
                }
            }
        }
        agentHealths = agentHealthsDecoded0
        let agentHealthCodesContainer = try containerValues.decodeIfPresent([InspectorClientTypes.AgentHealthCode?].self, forKey: .agentHealthCodes)
        var agentHealthCodesDecoded0:[InspectorClientTypes.AgentHealthCode]? = nil
        if let agentHealthCodesContainer = agentHealthCodesContainer {
            agentHealthCodesDecoded0 = [InspectorClientTypes.AgentHealthCode]()
            for string0 in agentHealthCodesContainer {
                if let string0 = string0 {
                    agentHealthCodesDecoded0?.append(string0)
                }
            }
        }
        agentHealthCodes = agentHealthCodesDecoded0
    }
}

extension InspectorClientTypes.AgentFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AgentFilter(agentHealthCodes: \(Swift.String(describing: agentHealthCodes)), agentHealths: \(Swift.String(describing: agentHealths)))"}
}

extension InspectorClientTypes {
    /// Contains information about an Amazon Inspector agent. This data type is used as a
    ///          request parameter in the ListAssessmentRunAgents action.
    public struct AgentFilter: Swift.Equatable {
        /// The detailed health state of the agent. Values can be set to IDLE, RUNNING, SHUTDOWN, UNHEALTHY, THROTTLED, and UNKNOWN.
        /// This member is required.
        public var agentHealthCodes: [InspectorClientTypes.AgentHealthCode]?
        /// The current health state of the agent. Values can be set to HEALTHY or UNHEALTHY.
        /// This member is required.
        public var agentHealths: [InspectorClientTypes.AgentHealth]?

        public init (
            agentHealthCodes: [InspectorClientTypes.AgentHealthCode]? = nil,
            agentHealths: [InspectorClientTypes.AgentHealth]? = nil
        )
        {
            self.agentHealthCodes = agentHealthCodes
            self.agentHealths = agentHealths
        }
    }

}

extension InspectorClientTypes {
    public enum AgentHealth: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case healthy
        case unhealthy
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [AgentHealth] {
            return [
                .healthy,
                .unhealthy,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .healthy: return "HEALTHY"
            case .unhealthy: return "UNHEALTHY"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AgentHealth(rawValue: rawValue) ?? AgentHealth.sdkUnknown(rawValue)
        }
    }
}

extension InspectorClientTypes {
    public enum AgentHealthCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case idle
        case running
        case shutdown
        case throttled
        case unhealthy
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [AgentHealthCode] {
            return [
                .idle,
                .running,
                .shutdown,
                .throttled,
                .unhealthy,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .idle: return "IDLE"
            case .running: return "RUNNING"
            case .shutdown: return "SHUTDOWN"
            case .throttled: return "THROTTLED"
            case .unhealthy: return "UNHEALTHY"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AgentHealthCode(rawValue: rawValue) ?? AgentHealthCode.sdkUnknown(rawValue)
        }
    }
}

extension InspectorClientTypes.AgentPreview: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentHealth
        case agentId
        case agentVersion
        case autoScalingGroup
        case hostname
        case ipv4Address
        case kernelVersion
        case operatingSystem
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentHealth = agentHealth {
            try encodeContainer.encode(agentHealth.rawValue, forKey: .agentHealth)
        }
        if let agentId = agentId {
            try encodeContainer.encode(agentId, forKey: .agentId)
        }
        if let agentVersion = agentVersion {
            try encodeContainer.encode(agentVersion, forKey: .agentVersion)
        }
        if let autoScalingGroup = autoScalingGroup {
            try encodeContainer.encode(autoScalingGroup, forKey: .autoScalingGroup)
        }
        if let hostname = hostname {
            try encodeContainer.encode(hostname, forKey: .hostname)
        }
        if let ipv4Address = ipv4Address {
            try encodeContainer.encode(ipv4Address, forKey: .ipv4Address)
        }
        if let kernelVersion = kernelVersion {
            try encodeContainer.encode(kernelVersion, forKey: .kernelVersion)
        }
        if let operatingSystem = operatingSystem {
            try encodeContainer.encode(operatingSystem, forKey: .operatingSystem)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostname)
        hostname = hostnameDecoded
        let agentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentId)
        agentId = agentIdDecoded
        let autoScalingGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .autoScalingGroup)
        autoScalingGroup = autoScalingGroupDecoded
        let agentHealthDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.AgentHealth.self, forKey: .agentHealth)
        agentHealth = agentHealthDecoded
        let agentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentVersion)
        agentVersion = agentVersionDecoded
        let operatingSystemDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operatingSystem)
        operatingSystem = operatingSystemDecoded
        let kernelVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kernelVersion)
        kernelVersion = kernelVersionDecoded
        let ipv4AddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipv4Address)
        ipv4Address = ipv4AddressDecoded
    }
}

extension InspectorClientTypes.AgentPreview: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AgentPreview(agentHealth: \(Swift.String(describing: agentHealth)), agentId: \(Swift.String(describing: agentId)), agentVersion: \(Swift.String(describing: agentVersion)), autoScalingGroup: \(Swift.String(describing: autoScalingGroup)), hostname: \(Swift.String(describing: hostname)), ipv4Address: \(Swift.String(describing: ipv4Address)), kernelVersion: \(Swift.String(describing: kernelVersion)), operatingSystem: \(Swift.String(describing: operatingSystem)))"}
}

extension InspectorClientTypes {
    /// Used as a response element in the PreviewAgents action.
    public struct AgentPreview: Swift.Equatable {
        /// The health status of the Amazon Inspector Agent.
        public var agentHealth: InspectorClientTypes.AgentHealth?
        /// The ID of the EC2 instance where the agent is installed.
        /// This member is required.
        public var agentId: Swift.String?
        /// The version of the Amazon Inspector Agent.
        public var agentVersion: Swift.String?
        /// The Auto Scaling group for the EC2 instance where the agent is installed.
        public var autoScalingGroup: Swift.String?
        /// The hostname of the EC2 instance on which the Amazon Inspector Agent is
        ///          installed.
        public var hostname: Swift.String?
        /// The IP address of the EC2 instance on which the Amazon Inspector Agent is
        ///          installed.
        public var ipv4Address: Swift.String?
        /// The kernel version of the operating system running on the EC2 instance on which the
        ///          Amazon Inspector Agent is installed.
        public var kernelVersion: Swift.String?
        /// The operating system running on the EC2 instance on which the Amazon Inspector Agent
        ///          is installed.
        public var operatingSystem: Swift.String?

        public init (
            agentHealth: InspectorClientTypes.AgentHealth? = nil,
            agentId: Swift.String? = nil,
            agentVersion: Swift.String? = nil,
            autoScalingGroup: Swift.String? = nil,
            hostname: Swift.String? = nil,
            ipv4Address: Swift.String? = nil,
            kernelVersion: Swift.String? = nil,
            operatingSystem: Swift.String? = nil
        )
        {
            self.agentHealth = agentHealth
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.autoScalingGroup = autoScalingGroup
            self.hostname = hostname
            self.ipv4Address = ipv4Address
            self.kernelVersion = kernelVersion
            self.operatingSystem = operatingSystem
        }
    }

}

extension AgentsAlreadyRunningAssessmentException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AgentsAlreadyRunningAssessmentException(agents: \(Swift.String(describing: agents)), agentsTruncated: \(Swift.String(describing: agentsTruncated)), canRetry: \(Swift.String(describing: canRetry)), message: \(Swift.String(describing: message)))"}
}

extension AgentsAlreadyRunningAssessmentException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AgentsAlreadyRunningAssessmentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.agents = output.agents
            self.agentsTruncated = output.agentsTruncated
            self.canRetry = output.canRetry
            self.message = output.message
        } else {
            self.agents = nil
            self.agentsTruncated = nil
            self.canRetry = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You started an assessment run, but one of the instances is already participating in
///          another assessment run.
public struct AgentsAlreadyRunningAssessmentException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    ///
    /// This member is required.
    public var agents: [InspectorClientTypes.AgentAlreadyRunningAssessment]?
    ///
    /// This member is required.
    public var agentsTruncated: Swift.Bool?
    /// You can immediately retry your request.
    /// This member is required.
    public var canRetry: Swift.Bool?
    /// Details of the exception error.
    /// This member is required.
    public var message: Swift.String?

    public init (
        agents: [InspectorClientTypes.AgentAlreadyRunningAssessment]? = nil,
        agentsTruncated: Swift.Bool? = nil,
        canRetry: Swift.Bool? = nil,
        message: Swift.String? = nil
    )
    {
        self.agents = agents
        self.agentsTruncated = agentsTruncated
        self.canRetry = canRetry
        self.message = message
    }
}

struct AgentsAlreadyRunningAssessmentExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let agents: [InspectorClientTypes.AgentAlreadyRunningAssessment]?
    public let agentsTruncated: Swift.Bool?
    public let canRetry: Swift.Bool?
}

extension AgentsAlreadyRunningAssessmentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agents
        case agentsTruncated
        case canRetry
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let agentsContainer = try containerValues.decodeIfPresent([InspectorClientTypes.AgentAlreadyRunningAssessment?].self, forKey: .agents)
        var agentsDecoded0:[InspectorClientTypes.AgentAlreadyRunningAssessment]? = nil
        if let agentsContainer = agentsContainer {
            agentsDecoded0 = [InspectorClientTypes.AgentAlreadyRunningAssessment]()
            for structure0 in agentsContainer {
                if let structure0 = structure0 {
                    agentsDecoded0?.append(structure0)
                }
            }
        }
        agents = agentsDecoded0
        let agentsTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .agentsTruncated)
        agentsTruncated = agentsTruncatedDecoded
        let canRetryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .canRetry)
        canRetry = canRetryDecoded
    }
}

extension InspectorClientTypes.AssessmentRun: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case assessmentTemplateArn
        case completedAt
        case createdAt
        case dataCollected
        case durationInSeconds
        case findingCounts
        case name
        case notifications
        case rulesPackageArns
        case startedAt
        case state
        case stateChangedAt
        case stateChanges
        case userAttributesForFindings
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let assessmentTemplateArn = assessmentTemplateArn {
            try encodeContainer.encode(assessmentTemplateArn, forKey: .assessmentTemplateArn)
        }
        if let completedAt = completedAt {
            try encodeContainer.encode(completedAt.timeIntervalSince1970, forKey: .completedAt)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let dataCollected = dataCollected {
            try encodeContainer.encode(dataCollected, forKey: .dataCollected)
        }
        if durationInSeconds != 0 {
            try encodeContainer.encode(durationInSeconds, forKey: .durationInSeconds)
        }
        if let findingCounts = findingCounts {
            var findingCountsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .findingCounts)
            for (dictKey0, assessmentrunfindingcounts0) in findingCounts {
                try findingCountsContainer.encode(assessmentrunfindingcounts0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let notifications = notifications {
            var notificationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notifications)
            for assessmentrunnotificationlist0 in notifications {
                try notificationsContainer.encode(assessmentrunnotificationlist0)
            }
        }
        if let rulesPackageArns = rulesPackageArns {
            var rulesPackageArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rulesPackageArns)
            for assessmentrulespackagearnlist0 in rulesPackageArns {
                try rulesPackageArnsContainer.encode(assessmentrulespackagearnlist0)
            }
        }
        if let startedAt = startedAt {
            try encodeContainer.encode(startedAt.timeIntervalSince1970, forKey: .startedAt)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateChangedAt = stateChangedAt {
            try encodeContainer.encode(stateChangedAt.timeIntervalSince1970, forKey: .stateChangedAt)
        }
        if let stateChanges = stateChanges {
            var stateChangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stateChanges)
            for assessmentrunstatechangelist0 in stateChanges {
                try stateChangesContainer.encode(assessmentrunstatechangelist0)
            }
        }
        if let userAttributesForFindings = userAttributesForFindings {
            var userAttributesForFindingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userAttributesForFindings)
            for userattributelist0 in userAttributesForFindings {
                try userAttributesForFindingsContainer.encode(userattributelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let assessmentTemplateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentTemplateArn)
        assessmentTemplateArn = assessmentTemplateArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.AssessmentRunState.self, forKey: .state)
        state = stateDecoded
        let durationInSecondsDecoded = try containerValues.decode(Swift.Int.self, forKey: .durationInSeconds)
        durationInSeconds = durationInSecondsDecoded
        let rulesPackageArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .rulesPackageArns)
        var rulesPackageArnsDecoded0:[Swift.String]? = nil
        if let rulesPackageArnsContainer = rulesPackageArnsContainer {
            rulesPackageArnsDecoded0 = [Swift.String]()
            for string0 in rulesPackageArnsContainer {
                if let string0 = string0 {
                    rulesPackageArnsDecoded0?.append(string0)
                }
            }
        }
        rulesPackageArns = rulesPackageArnsDecoded0
        let userAttributesForFindingsContainer = try containerValues.decodeIfPresent([InspectorClientTypes.Attribute?].self, forKey: .userAttributesForFindings)
        var userAttributesForFindingsDecoded0:[InspectorClientTypes.Attribute]? = nil
        if let userAttributesForFindingsContainer = userAttributesForFindingsContainer {
            userAttributesForFindingsDecoded0 = [InspectorClientTypes.Attribute]()
            for structure0 in userAttributesForFindingsContainer {
                if let structure0 = structure0 {
                    userAttributesForFindingsDecoded0?.append(structure0)
                }
            }
        }
        userAttributesForFindings = userAttributesForFindingsDecoded0
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let startedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startedAt)
        startedAt = startedAtDecoded
        let completedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .completedAt)
        completedAt = completedAtDecoded
        let stateChangedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .stateChangedAt)
        stateChangedAt = stateChangedAtDecoded
        let dataCollectedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dataCollected)
        dataCollected = dataCollectedDecoded
        let stateChangesContainer = try containerValues.decodeIfPresent([InspectorClientTypes.AssessmentRunStateChange?].self, forKey: .stateChanges)
        var stateChangesDecoded0:[InspectorClientTypes.AssessmentRunStateChange]? = nil
        if let stateChangesContainer = stateChangesContainer {
            stateChangesDecoded0 = [InspectorClientTypes.AssessmentRunStateChange]()
            for structure0 in stateChangesContainer {
                if let structure0 = structure0 {
                    stateChangesDecoded0?.append(structure0)
                }
            }
        }
        stateChanges = stateChangesDecoded0
        let notificationsContainer = try containerValues.decodeIfPresent([InspectorClientTypes.AssessmentRunNotification?].self, forKey: .notifications)
        var notificationsDecoded0:[InspectorClientTypes.AssessmentRunNotification]? = nil
        if let notificationsContainer = notificationsContainer {
            notificationsDecoded0 = [InspectorClientTypes.AssessmentRunNotification]()
            for structure0 in notificationsContainer {
                if let structure0 = structure0 {
                    notificationsDecoded0?.append(structure0)
                }
            }
        }
        notifications = notificationsDecoded0
        let findingCountsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .findingCounts)
        var findingCountsDecoded0: [Swift.String:Swift.Int]? = nil
        if let findingCountsContainer = findingCountsContainer {
            findingCountsDecoded0 = [Swift.String:Swift.Int]()
            for (key0, findingcount0) in findingCountsContainer {
                if let findingcount0 = findingcount0 {
                    findingCountsDecoded0?[key0] = findingcount0
                }
            }
        }
        findingCounts = findingCountsDecoded0
    }
}

extension InspectorClientTypes.AssessmentRun: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssessmentRun(arn: \(Swift.String(describing: arn)), assessmentTemplateArn: \(Swift.String(describing: assessmentTemplateArn)), completedAt: \(Swift.String(describing: completedAt)), createdAt: \(Swift.String(describing: createdAt)), dataCollected: \(Swift.String(describing: dataCollected)), durationInSeconds: \(Swift.String(describing: durationInSeconds)), findingCounts: \(Swift.String(describing: findingCounts)), name: \(Swift.String(describing: name)), notifications: \(Swift.String(describing: notifications)), rulesPackageArns: \(Swift.String(describing: rulesPackageArns)), startedAt: \(Swift.String(describing: startedAt)), state: \(Swift.String(describing: state)), stateChangedAt: \(Swift.String(describing: stateChangedAt)), stateChanges: \(Swift.String(describing: stateChanges)), userAttributesForFindings: \(Swift.String(describing: userAttributesForFindings)))"}
}

extension InspectorClientTypes {
    /// A snapshot of an Amazon Inspector assessment run that contains the findings of the
    ///          assessment run .
    ///          Used as the response element in the DescribeAssessmentRuns
    ///          action.
    public struct AssessmentRun: Swift.Equatable {
        /// The ARN of the assessment run.
        /// This member is required.
        public var arn: Swift.String?
        /// The ARN of the assessment template that is associated with the assessment
        ///          run.
        /// This member is required.
        public var assessmentTemplateArn: Swift.String?
        /// The assessment run completion time that corresponds to the rules packages evaluation
        ///          completion time or failure.
        public var completedAt: ClientRuntime.Date?
        /// The time when StartAssessmentRun was called.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// A Boolean value (true or false) that specifies whether the process of collecting data
        ///          from the agents is completed.
        /// This member is required.
        public var dataCollected: Swift.Bool?
        /// The duration of the assessment run.
        /// This member is required.
        public var durationInSeconds: Swift.Int
        /// Provides a total count of generated findings per severity.
        /// This member is required.
        public var findingCounts: [Swift.String:Swift.Int]?
        /// The auto-generated name for the assessment run.
        /// This member is required.
        public var name: Swift.String?
        /// A list of notifications for the event subscriptions. A notification about a
        ///          particular generated finding is added to this list only once.
        /// This member is required.
        public var notifications: [InspectorClientTypes.AssessmentRunNotification]?
        /// The rules packages selected for the assessment run.
        /// This member is required.
        public var rulesPackageArns: [Swift.String]?
        /// The time when StartAssessmentRun was called.
        public var startedAt: ClientRuntime.Date?
        /// The state of the assessment run.
        /// This member is required.
        public var state: InspectorClientTypes.AssessmentRunState?
        /// The last time when the assessment run's state changed.
        /// This member is required.
        public var stateChangedAt: ClientRuntime.Date?
        /// A list of the assessment run state changes.
        /// This member is required.
        public var stateChanges: [InspectorClientTypes.AssessmentRunStateChange]?
        /// The user-defined attributes that are assigned to every generated finding.
        /// This member is required.
        public var userAttributesForFindings: [InspectorClientTypes.Attribute]?

        public init (
            arn: Swift.String? = nil,
            assessmentTemplateArn: Swift.String? = nil,
            completedAt: ClientRuntime.Date? = nil,
            createdAt: ClientRuntime.Date? = nil,
            dataCollected: Swift.Bool? = nil,
            durationInSeconds: Swift.Int = 0,
            findingCounts: [Swift.String:Swift.Int]? = nil,
            name: Swift.String? = nil,
            notifications: [InspectorClientTypes.AssessmentRunNotification]? = nil,
            rulesPackageArns: [Swift.String]? = nil,
            startedAt: ClientRuntime.Date? = nil,
            state: InspectorClientTypes.AssessmentRunState? = nil,
            stateChangedAt: ClientRuntime.Date? = nil,
            stateChanges: [InspectorClientTypes.AssessmentRunStateChange]? = nil,
            userAttributesForFindings: [InspectorClientTypes.Attribute]? = nil
        )
        {
            self.arn = arn
            self.assessmentTemplateArn = assessmentTemplateArn
            self.completedAt = completedAt
            self.createdAt = createdAt
            self.dataCollected = dataCollected
            self.durationInSeconds = durationInSeconds
            self.findingCounts = findingCounts
            self.name = name
            self.notifications = notifications
            self.rulesPackageArns = rulesPackageArns
            self.startedAt = startedAt
            self.state = state
            self.stateChangedAt = stateChangedAt
            self.stateChanges = stateChanges
            self.userAttributesForFindings = userAttributesForFindings
        }
    }

}

extension InspectorClientTypes.AssessmentRunAgent: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentHealth
        case agentHealthCode
        case agentHealthDetails
        case agentId
        case assessmentRunArn
        case autoScalingGroup
        case telemetryMetadata
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentHealth = agentHealth {
            try encodeContainer.encode(agentHealth.rawValue, forKey: .agentHealth)
        }
        if let agentHealthCode = agentHealthCode {
            try encodeContainer.encode(agentHealthCode.rawValue, forKey: .agentHealthCode)
        }
        if let agentHealthDetails = agentHealthDetails {
            try encodeContainer.encode(agentHealthDetails, forKey: .agentHealthDetails)
        }
        if let agentId = agentId {
            try encodeContainer.encode(agentId, forKey: .agentId)
        }
        if let assessmentRunArn = assessmentRunArn {
            try encodeContainer.encode(assessmentRunArn, forKey: .assessmentRunArn)
        }
        if let autoScalingGroup = autoScalingGroup {
            try encodeContainer.encode(autoScalingGroup, forKey: .autoScalingGroup)
        }
        if let telemetryMetadata = telemetryMetadata {
            var telemetryMetadataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .telemetryMetadata)
            for telemetrymetadatalist0 in telemetryMetadata {
                try telemetryMetadataContainer.encode(telemetrymetadatalist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentId)
        agentId = agentIdDecoded
        let assessmentRunArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentRunArn)
        assessmentRunArn = assessmentRunArnDecoded
        let agentHealthDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.AgentHealth.self, forKey: .agentHealth)
        agentHealth = agentHealthDecoded
        let agentHealthCodeDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.AgentHealthCode.self, forKey: .agentHealthCode)
        agentHealthCode = agentHealthCodeDecoded
        let agentHealthDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentHealthDetails)
        agentHealthDetails = agentHealthDetailsDecoded
        let autoScalingGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .autoScalingGroup)
        autoScalingGroup = autoScalingGroupDecoded
        let telemetryMetadataContainer = try containerValues.decodeIfPresent([InspectorClientTypes.TelemetryMetadata?].self, forKey: .telemetryMetadata)
        var telemetryMetadataDecoded0:[InspectorClientTypes.TelemetryMetadata]? = nil
        if let telemetryMetadataContainer = telemetryMetadataContainer {
            telemetryMetadataDecoded0 = [InspectorClientTypes.TelemetryMetadata]()
            for structure0 in telemetryMetadataContainer {
                if let structure0 = structure0 {
                    telemetryMetadataDecoded0?.append(structure0)
                }
            }
        }
        telemetryMetadata = telemetryMetadataDecoded0
    }
}

extension InspectorClientTypes.AssessmentRunAgent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssessmentRunAgent(agentHealth: \(Swift.String(describing: agentHealth)), agentHealthCode: \(Swift.String(describing: agentHealthCode)), agentHealthDetails: \(Swift.String(describing: agentHealthDetails)), agentId: \(Swift.String(describing: agentId)), assessmentRunArn: \(Swift.String(describing: assessmentRunArn)), autoScalingGroup: \(Swift.String(describing: autoScalingGroup)), telemetryMetadata: \(Swift.String(describing: telemetryMetadata)))"}
}

extension InspectorClientTypes {
    /// Contains information about an Amazon Inspector agent. This data type is used as a
    ///          response element in the ListAssessmentRunAgents action.
    public struct AssessmentRunAgent: Swift.Equatable {
        /// The current health state of the agent.
        /// This member is required.
        public var agentHealth: InspectorClientTypes.AgentHealth?
        /// The detailed health state of the agent.
        /// This member is required.
        public var agentHealthCode: InspectorClientTypes.AgentHealthCode?
        /// The description for the agent health code.
        public var agentHealthDetails: Swift.String?
        /// The AWS account of the EC2 instance where the agent is installed.
        /// This member is required.
        public var agentId: Swift.String?
        /// The ARN of the assessment run that is associated with the agent.
        /// This member is required.
        public var assessmentRunArn: Swift.String?
        /// The Auto Scaling group of the EC2 instance that is specified by the agent
        ///          ID.
        public var autoScalingGroup: Swift.String?
        /// The Amazon Inspector application data metrics that are collected by the
        ///          agent.
        /// This member is required.
        public var telemetryMetadata: [InspectorClientTypes.TelemetryMetadata]?

        public init (
            agentHealth: InspectorClientTypes.AgentHealth? = nil,
            agentHealthCode: InspectorClientTypes.AgentHealthCode? = nil,
            agentHealthDetails: Swift.String? = nil,
            agentId: Swift.String? = nil,
            assessmentRunArn: Swift.String? = nil,
            autoScalingGroup: Swift.String? = nil,
            telemetryMetadata: [InspectorClientTypes.TelemetryMetadata]? = nil
        )
        {
            self.agentHealth = agentHealth
            self.agentHealthCode = agentHealthCode
            self.agentHealthDetails = agentHealthDetails
            self.agentId = agentId
            self.assessmentRunArn = assessmentRunArn
            self.autoScalingGroup = autoScalingGroup
            self.telemetryMetadata = telemetryMetadata
        }
    }

}

extension InspectorClientTypes.AssessmentRunFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completionTimeRange
        case durationRange
        case namePattern
        case rulesPackageArns
        case startTimeRange
        case stateChangeTimeRange
        case states
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completionTimeRange = completionTimeRange {
            try encodeContainer.encode(completionTimeRange, forKey: .completionTimeRange)
        }
        if let durationRange = durationRange {
            try encodeContainer.encode(durationRange, forKey: .durationRange)
        }
        if let namePattern = namePattern {
            try encodeContainer.encode(namePattern, forKey: .namePattern)
        }
        if let rulesPackageArns = rulesPackageArns {
            var rulesPackageArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rulesPackageArns)
            for filterrulespackagearnlist0 in rulesPackageArns {
                try rulesPackageArnsContainer.encode(filterrulespackagearnlist0)
            }
        }
        if let startTimeRange = startTimeRange {
            try encodeContainer.encode(startTimeRange, forKey: .startTimeRange)
        }
        if let stateChangeTimeRange = stateChangeTimeRange {
            try encodeContainer.encode(stateChangeTimeRange, forKey: .stateChangeTimeRange)
        }
        if let states = states {
            var statesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .states)
            for assessmentrunstatelist0 in states {
                try statesContainer.encode(assessmentrunstatelist0.rawValue)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namePatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namePattern)
        namePattern = namePatternDecoded
        let statesContainer = try containerValues.decodeIfPresent([InspectorClientTypes.AssessmentRunState?].self, forKey: .states)
        var statesDecoded0:[InspectorClientTypes.AssessmentRunState]? = nil
        if let statesContainer = statesContainer {
            statesDecoded0 = [InspectorClientTypes.AssessmentRunState]()
            for string0 in statesContainer {
                if let string0 = string0 {
                    statesDecoded0?.append(string0)
                }
            }
        }
        states = statesDecoded0
        let durationRangeDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.DurationRange.self, forKey: .durationRange)
        durationRange = durationRangeDecoded
        let rulesPackageArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .rulesPackageArns)
        var rulesPackageArnsDecoded0:[Swift.String]? = nil
        if let rulesPackageArnsContainer = rulesPackageArnsContainer {
            rulesPackageArnsDecoded0 = [Swift.String]()
            for string0 in rulesPackageArnsContainer {
                if let string0 = string0 {
                    rulesPackageArnsDecoded0?.append(string0)
                }
            }
        }
        rulesPackageArns = rulesPackageArnsDecoded0
        let startTimeRangeDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.TimestampRange.self, forKey: .startTimeRange)
        startTimeRange = startTimeRangeDecoded
        let completionTimeRangeDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.TimestampRange.self, forKey: .completionTimeRange)
        completionTimeRange = completionTimeRangeDecoded
        let stateChangeTimeRangeDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.TimestampRange.self, forKey: .stateChangeTimeRange)
        stateChangeTimeRange = stateChangeTimeRangeDecoded
    }
}

extension InspectorClientTypes.AssessmentRunFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssessmentRunFilter(completionTimeRange: \(Swift.String(describing: completionTimeRange)), durationRange: \(Swift.String(describing: durationRange)), namePattern: \(Swift.String(describing: namePattern)), rulesPackageArns: \(Swift.String(describing: rulesPackageArns)), startTimeRange: \(Swift.String(describing: startTimeRange)), stateChangeTimeRange: \(Swift.String(describing: stateChangeTimeRange)), states: \(Swift.String(describing: states)))"}
}

extension InspectorClientTypes {
    /// Used as the request parameter in the ListAssessmentRuns
    ///          action.
    public struct AssessmentRunFilter: Swift.Equatable {
        /// For a record to match a filter, the value that is specified for this data type
        ///          property must inclusively match any value between the specified minimum and maximum values
        ///          of the completedAt property of the AssessmentRun data type.
        public var completionTimeRange: InspectorClientTypes.TimestampRange?
        /// For a record to match a filter, the value that is specified for this data type
        ///          property must inclusively match any value between the specified minimum and maximum values
        ///          of the durationInSeconds property of the AssessmentRun data type.
        public var durationRange: InspectorClientTypes.DurationRange?
        /// For a record to match a filter, an explicit value or a string containing a wildcard
        ///          that is specified for this data type property must match the value of the assessmentRunName property of the AssessmentRun
        ///          data type.
        public var namePattern: Swift.String?
        /// For a record to match a filter, the value that is specified for this data type
        ///          property must be contained in the list of values of the rulesPackages property of the AssessmentRun data
        ///          type.
        public var rulesPackageArns: [Swift.String]?
        /// For a record to match a filter, the value that is specified for this data type
        ///          property must inclusively match any value between the specified minimum and maximum values
        ///          of the startTime property of the AssessmentRun data type.
        public var startTimeRange: InspectorClientTypes.TimestampRange?
        /// For a record to match a filter, the value that is specified for this data type
        ///          property must match the stateChangedAt property of the
        ///             AssessmentRun data type.
        public var stateChangeTimeRange: InspectorClientTypes.TimestampRange?
        /// For a record to match a filter, one of the values specified for this data type
        ///          property must be the exact match of the value of the assessmentRunState property of the AssessmentRun data
        ///          type.
        public var states: [InspectorClientTypes.AssessmentRunState]?

        public init (
            completionTimeRange: InspectorClientTypes.TimestampRange? = nil,
            durationRange: InspectorClientTypes.DurationRange? = nil,
            namePattern: Swift.String? = nil,
            rulesPackageArns: [Swift.String]? = nil,
            startTimeRange: InspectorClientTypes.TimestampRange? = nil,
            stateChangeTimeRange: InspectorClientTypes.TimestampRange? = nil,
            states: [InspectorClientTypes.AssessmentRunState]? = nil
        )
        {
            self.completionTimeRange = completionTimeRange
            self.durationRange = durationRange
            self.namePattern = namePattern
            self.rulesPackageArns = rulesPackageArns
            self.startTimeRange = startTimeRange
            self.stateChangeTimeRange = stateChangeTimeRange
            self.states = states
        }
    }

}

extension AssessmentRunInProgressException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssessmentRunInProgressException(assessmentRunArns: \(Swift.String(describing: assessmentRunArns)), assessmentRunArnsTruncated: \(Swift.String(describing: assessmentRunArnsTruncated)), canRetry: \(Swift.String(describing: canRetry)), message: \(Swift.String(describing: message)))"}
}

extension AssessmentRunInProgressException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssessmentRunInProgressExceptionBody = try responseDecoder.decode(responseBody: data)
            self.assessmentRunArns = output.assessmentRunArns
            self.assessmentRunArnsTruncated = output.assessmentRunArnsTruncated
            self.canRetry = output.canRetry
            self.message = output.message
        } else {
            self.assessmentRunArns = nil
            self.assessmentRunArnsTruncated = nil
            self.canRetry = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You cannot perform a specified action if an assessment run is currently in
///          progress.
public struct AssessmentRunInProgressException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The ARNs of the assessment runs that are currently in progress.
    /// This member is required.
    public var assessmentRunArns: [Swift.String]?
    /// Boolean value that indicates whether the ARN list of the assessment runs is
    ///          truncated.
    /// This member is required.
    public var assessmentRunArnsTruncated: Swift.Bool?
    /// You can immediately retry your request.
    /// This member is required.
    public var canRetry: Swift.Bool?
    /// Details of the exception error.
    /// This member is required.
    public var message: Swift.String?

    public init (
        assessmentRunArns: [Swift.String]? = nil,
        assessmentRunArnsTruncated: Swift.Bool? = nil,
        canRetry: Swift.Bool? = nil,
        message: Swift.String? = nil
    )
    {
        self.assessmentRunArns = assessmentRunArns
        self.assessmentRunArnsTruncated = assessmentRunArnsTruncated
        self.canRetry = canRetry
        self.message = message
    }
}

struct AssessmentRunInProgressExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let assessmentRunArns: [Swift.String]?
    public let assessmentRunArnsTruncated: Swift.Bool?
    public let canRetry: Swift.Bool?
}

extension AssessmentRunInProgressExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentRunArns
        case assessmentRunArnsTruncated
        case canRetry
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let assessmentRunArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .assessmentRunArns)
        var assessmentRunArnsDecoded0:[Swift.String]? = nil
        if let assessmentRunArnsContainer = assessmentRunArnsContainer {
            assessmentRunArnsDecoded0 = [Swift.String]()
            for string0 in assessmentRunArnsContainer {
                if let string0 = string0 {
                    assessmentRunArnsDecoded0?.append(string0)
                }
            }
        }
        assessmentRunArns = assessmentRunArnsDecoded0
        let assessmentRunArnsTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .assessmentRunArnsTruncated)
        assessmentRunArnsTruncated = assessmentRunArnsTruncatedDecoded
        let canRetryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .canRetry)
        canRetry = canRetryDecoded
    }
}

extension InspectorClientTypes.AssessmentRunNotification: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case date
        case error
        case event
        case message
        case snsPublishStatusCode
        case snsTopicArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let date = date {
            try encodeContainer.encode(date.timeIntervalSince1970, forKey: .date)
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let event = event {
            try encodeContainer.encode(event.rawValue, forKey: .event)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let snsPublishStatusCode = snsPublishStatusCode {
            try encodeContainer.encode(snsPublishStatusCode.rawValue, forKey: .snsPublishStatusCode)
        }
        if let snsTopicArn = snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .date)
        date = dateDecoded
        let eventDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.InspectorEvent.self, forKey: .event)
        event = eventDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .error)
        error = errorDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let snsPublishStatusCodeDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.AssessmentRunNotificationSnsStatusCode.self, forKey: .snsPublishStatusCode)
        snsPublishStatusCode = snsPublishStatusCodeDecoded
    }
}

extension InspectorClientTypes.AssessmentRunNotification: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssessmentRunNotification(date: \(Swift.String(describing: date)), error: \(Swift.String(describing: error)), event: \(Swift.String(describing: event)), message: \(Swift.String(describing: message)), snsPublishStatusCode: \(Swift.String(describing: snsPublishStatusCode)), snsTopicArn: \(Swift.String(describing: snsTopicArn)))"}
}

extension InspectorClientTypes {
    /// Used as one of the elements of the AssessmentRun data
    ///          type.
    public struct AssessmentRunNotification: Swift.Equatable {
        /// The date of the notification.
        /// This member is required.
        public var date: ClientRuntime.Date?
        /// The Boolean value that specifies whether the notification represents an
        ///          error.
        /// This member is required.
        public var error: Swift.Bool?
        /// The event for which a notification is sent.
        /// This member is required.
        public var event: InspectorClientTypes.InspectorEvent?
        /// The message included in the notification.
        public var message: Swift.String?
        /// The status code of the SNS notification.
        public var snsPublishStatusCode: InspectorClientTypes.AssessmentRunNotificationSnsStatusCode?
        /// The SNS topic to which the SNS notification is sent.
        public var snsTopicArn: Swift.String?

        public init (
            date: ClientRuntime.Date? = nil,
            error: Swift.Bool? = nil,
            event: InspectorClientTypes.InspectorEvent? = nil,
            message: Swift.String? = nil,
            snsPublishStatusCode: InspectorClientTypes.AssessmentRunNotificationSnsStatusCode? = nil,
            snsTopicArn: Swift.String? = nil
        )
        {
            self.date = date
            self.error = error
            self.event = event
            self.message = message
            self.snsPublishStatusCode = snsPublishStatusCode
            self.snsTopicArn = snsTopicArn
        }
    }

}

extension InspectorClientTypes {
    public enum AssessmentRunNotificationSnsStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessDenied
        case internalError
        case success
        case topicDoesNotExist
        case sdkUnknown(Swift.String)

        public static var allCases: [AssessmentRunNotificationSnsStatusCode] {
            return [
                .accessDenied,
                .internalError,
                .success,
                .topicDoesNotExist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .internalError: return "INTERNAL_ERROR"
            case .success: return "SUCCESS"
            case .topicDoesNotExist: return "TOPIC_DOES_NOT_EXIST"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssessmentRunNotificationSnsStatusCode(rawValue: rawValue) ?? AssessmentRunNotificationSnsStatusCode.sdkUnknown(rawValue)
        }
    }
}

extension InspectorClientTypes {
    public enum AssessmentRunState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canceled
        case collectingData
        case completed
        case completedWithErrors
        case created
        case dataCollected
        case error
        case evaluatingRules
        case failed
        case startDataCollectionInProgress
        case startDataCollectionPending
        case startEvaluatingRulesPending
        case stopDataCollectionPending
        case sdkUnknown(Swift.String)

        public static var allCases: [AssessmentRunState] {
            return [
                .canceled,
                .collectingData,
                .completed,
                .completedWithErrors,
                .created,
                .dataCollected,
                .error,
                .evaluatingRules,
                .failed,
                .startDataCollectionInProgress,
                .startDataCollectionPending,
                .startEvaluatingRulesPending,
                .stopDataCollectionPending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .collectingData: return "COLLECTING_DATA"
            case .completed: return "COMPLETED"
            case .completedWithErrors: return "COMPLETED_WITH_ERRORS"
            case .created: return "CREATED"
            case .dataCollected: return "DATA_COLLECTED"
            case .error: return "ERROR"
            case .evaluatingRules: return "EVALUATING_RULES"
            case .failed: return "FAILED"
            case .startDataCollectionInProgress: return "START_DATA_COLLECTION_IN_PROGRESS"
            case .startDataCollectionPending: return "START_DATA_COLLECTION_PENDING"
            case .startEvaluatingRulesPending: return "START_EVALUATING_RULES_PENDING"
            case .stopDataCollectionPending: return "STOP_DATA_COLLECTION_PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssessmentRunState(rawValue: rawValue) ?? AssessmentRunState.sdkUnknown(rawValue)
        }
    }
}

extension InspectorClientTypes.AssessmentRunStateChange: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case state
        case stateChangedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateChangedAt = stateChangedAt {
            try encodeContainer.encode(stateChangedAt.timeIntervalSince1970, forKey: .stateChangedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateChangedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .stateChangedAt)
        stateChangedAt = stateChangedAtDecoded
        let stateDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.AssessmentRunState.self, forKey: .state)
        state = stateDecoded
    }
}

extension InspectorClientTypes.AssessmentRunStateChange: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssessmentRunStateChange(state: \(Swift.String(describing: state)), stateChangedAt: \(Swift.String(describing: stateChangedAt)))"}
}

extension InspectorClientTypes {
    /// Used as one of the elements of the AssessmentRun data
    ///          type.
    public struct AssessmentRunStateChange: Swift.Equatable {
        /// The assessment run state.
        /// This member is required.
        public var state: InspectorClientTypes.AssessmentRunState?
        /// The last time the assessment run state changed.
        /// This member is required.
        public var stateChangedAt: ClientRuntime.Date?

        public init (
            state: InspectorClientTypes.AssessmentRunState? = nil,
            stateChangedAt: ClientRuntime.Date? = nil
        )
        {
            self.state = state
            self.stateChangedAt = stateChangedAt
        }
    }

}

extension InspectorClientTypes.AssessmentTarget: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case name
        case resourceGroupArn
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceGroupArn = resourceGroupArn {
            try encodeContainer.encode(resourceGroupArn, forKey: .resourceGroupArn)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let resourceGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupArn)
        resourceGroupArn = resourceGroupArnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension InspectorClientTypes.AssessmentTarget: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssessmentTarget(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), name: \(Swift.String(describing: name)), resourceGroupArn: \(Swift.String(describing: resourceGroupArn)), updatedAt: \(Swift.String(describing: updatedAt)))"}
}

extension InspectorClientTypes {
    /// Contains information about an Amazon Inspector application. This data type is used as
    ///          the response element in the DescribeAssessmentTargets action.
    public struct AssessmentTarget: Swift.Equatable {
        /// The ARN that specifies the Amazon Inspector assessment target.
        /// This member is required.
        public var arn: Swift.String?
        /// The time at which the assessment target is created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The name of the Amazon Inspector assessment target.
        /// This member is required.
        public var name: Swift.String?
        /// The ARN that specifies the resource group that is associated with the assessment
        ///          target.
        public var resourceGroupArn: Swift.String?
        /// The time at which UpdateAssessmentTarget is called.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            resourceGroupArn: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.name = name
            self.resourceGroupArn = resourceGroupArn
            self.updatedAt = updatedAt
        }
    }

}

extension InspectorClientTypes.AssessmentTargetFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTargetNamePattern
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentTargetNamePattern = assessmentTargetNamePattern {
            try encodeContainer.encode(assessmentTargetNamePattern, forKey: .assessmentTargetNamePattern)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentTargetNamePatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentTargetNamePattern)
        assessmentTargetNamePattern = assessmentTargetNamePatternDecoded
    }
}

extension InspectorClientTypes.AssessmentTargetFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssessmentTargetFilter(assessmentTargetNamePattern: \(Swift.String(describing: assessmentTargetNamePattern)))"}
}

extension InspectorClientTypes {
    /// Used as the request parameter in the ListAssessmentTargets
    ///          action.
    public struct AssessmentTargetFilter: Swift.Equatable {
        /// For a record to match a filter, an explicit value or a string that contains a
        ///          wildcard that is specified for this data type property must match the value of the
        ///             assessmentTargetName property of the AssessmentTarget data type.
        public var assessmentTargetNamePattern: Swift.String?

        public init (
            assessmentTargetNamePattern: Swift.String? = nil
        )
        {
            self.assessmentTargetNamePattern = assessmentTargetNamePattern
        }
    }

}

extension InspectorClientTypes.AssessmentTemplate: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case assessmentRunCount
        case assessmentTargetArn
        case createdAt
        case durationInSeconds
        case lastAssessmentRunArn
        case name
        case rulesPackageArns
        case userAttributesForFindings
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let assessmentRunCount = assessmentRunCount {
            try encodeContainer.encode(assessmentRunCount, forKey: .assessmentRunCount)
        }
        if let assessmentTargetArn = assessmentTargetArn {
            try encodeContainer.encode(assessmentTargetArn, forKey: .assessmentTargetArn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if durationInSeconds != 0 {
            try encodeContainer.encode(durationInSeconds, forKey: .durationInSeconds)
        }
        if let lastAssessmentRunArn = lastAssessmentRunArn {
            try encodeContainer.encode(lastAssessmentRunArn, forKey: .lastAssessmentRunArn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let rulesPackageArns = rulesPackageArns {
            var rulesPackageArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rulesPackageArns)
            for assessmenttemplaterulespackagearnlist0 in rulesPackageArns {
                try rulesPackageArnsContainer.encode(assessmenttemplaterulespackagearnlist0)
            }
        }
        if let userAttributesForFindings = userAttributesForFindings {
            var userAttributesForFindingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userAttributesForFindings)
            for userattributelist0 in userAttributesForFindings {
                try userAttributesForFindingsContainer.encode(userattributelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let assessmentTargetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentTargetArn)
        assessmentTargetArn = assessmentTargetArnDecoded
        let durationInSecondsDecoded = try containerValues.decode(Swift.Int.self, forKey: .durationInSeconds)
        durationInSeconds = durationInSecondsDecoded
        let rulesPackageArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .rulesPackageArns)
        var rulesPackageArnsDecoded0:[Swift.String]? = nil
        if let rulesPackageArnsContainer = rulesPackageArnsContainer {
            rulesPackageArnsDecoded0 = [Swift.String]()
            for string0 in rulesPackageArnsContainer {
                if let string0 = string0 {
                    rulesPackageArnsDecoded0?.append(string0)
                }
            }
        }
        rulesPackageArns = rulesPackageArnsDecoded0
        let userAttributesForFindingsContainer = try containerValues.decodeIfPresent([InspectorClientTypes.Attribute?].self, forKey: .userAttributesForFindings)
        var userAttributesForFindingsDecoded0:[InspectorClientTypes.Attribute]? = nil
        if let userAttributesForFindingsContainer = userAttributesForFindingsContainer {
            userAttributesForFindingsDecoded0 = [InspectorClientTypes.Attribute]()
            for structure0 in userAttributesForFindingsContainer {
                if let structure0 = structure0 {
                    userAttributesForFindingsDecoded0?.append(structure0)
                }
            }
        }
        userAttributesForFindings = userAttributesForFindingsDecoded0
        let lastAssessmentRunArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastAssessmentRunArn)
        lastAssessmentRunArn = lastAssessmentRunArnDecoded
        let assessmentRunCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .assessmentRunCount)
        assessmentRunCount = assessmentRunCountDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension InspectorClientTypes.AssessmentTemplate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssessmentTemplate(arn: \(Swift.String(describing: arn)), assessmentRunCount: \(Swift.String(describing: assessmentRunCount)), assessmentTargetArn: \(Swift.String(describing: assessmentTargetArn)), createdAt: \(Swift.String(describing: createdAt)), durationInSeconds: \(Swift.String(describing: durationInSeconds)), lastAssessmentRunArn: \(Swift.String(describing: lastAssessmentRunArn)), name: \(Swift.String(describing: name)), rulesPackageArns: \(Swift.String(describing: rulesPackageArns)), userAttributesForFindings: \(Swift.String(describing: userAttributesForFindings)))"}
}

extension InspectorClientTypes {
    /// Contains information about an Amazon Inspector assessment template. This data type is
    ///          used as the response element in the DescribeAssessmentTemplates
    ///          action.
    public struct AssessmentTemplate: Swift.Equatable {
        /// The ARN of the assessment template.
        /// This member is required.
        public var arn: Swift.String?
        /// The number of existing assessment runs associated with this assessment template. This
        ///          value can be zero or a positive integer.
        /// This member is required.
        public var assessmentRunCount: Swift.Int?
        /// The ARN of the assessment target that corresponds to this assessment
        ///          template.
        /// This member is required.
        public var assessmentTargetArn: Swift.String?
        /// The time at which the assessment template is created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The duration in seconds specified for this assessment template. The default value is
        ///          3600 seconds (one hour). The maximum value is 86400 seconds (one day).
        /// This member is required.
        public var durationInSeconds: Swift.Int
        /// The Amazon Resource Name (ARN) of the most recent assessment run associated with this
        ///          assessment template. This value exists only when the value of assessmentRunCount is
        ///          greaterpa than zero.
        public var lastAssessmentRunArn: Swift.String?
        /// The name of the assessment template.
        /// This member is required.
        public var name: Swift.String?
        /// The rules packages that are specified for this assessment template.
        /// This member is required.
        public var rulesPackageArns: [Swift.String]?
        /// The user-defined attributes that are assigned to every generated finding from the
        ///          assessment run that uses this assessment template.
        /// This member is required.
        public var userAttributesForFindings: [InspectorClientTypes.Attribute]?

        public init (
            arn: Swift.String? = nil,
            assessmentRunCount: Swift.Int? = nil,
            assessmentTargetArn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            durationInSeconds: Swift.Int = 0,
            lastAssessmentRunArn: Swift.String? = nil,
            name: Swift.String? = nil,
            rulesPackageArns: [Swift.String]? = nil,
            userAttributesForFindings: [InspectorClientTypes.Attribute]? = nil
        )
        {
            self.arn = arn
            self.assessmentRunCount = assessmentRunCount
            self.assessmentTargetArn = assessmentTargetArn
            self.createdAt = createdAt
            self.durationInSeconds = durationInSeconds
            self.lastAssessmentRunArn = lastAssessmentRunArn
            self.name = name
            self.rulesPackageArns = rulesPackageArns
            self.userAttributesForFindings = userAttributesForFindings
        }
    }

}

extension InspectorClientTypes.AssessmentTemplateFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case durationRange
        case namePattern
        case rulesPackageArns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let durationRange = durationRange {
            try encodeContainer.encode(durationRange, forKey: .durationRange)
        }
        if let namePattern = namePattern {
            try encodeContainer.encode(namePattern, forKey: .namePattern)
        }
        if let rulesPackageArns = rulesPackageArns {
            var rulesPackageArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rulesPackageArns)
            for filterrulespackagearnlist0 in rulesPackageArns {
                try rulesPackageArnsContainer.encode(filterrulespackagearnlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namePatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namePattern)
        namePattern = namePatternDecoded
        let durationRangeDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.DurationRange.self, forKey: .durationRange)
        durationRange = durationRangeDecoded
        let rulesPackageArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .rulesPackageArns)
        var rulesPackageArnsDecoded0:[Swift.String]? = nil
        if let rulesPackageArnsContainer = rulesPackageArnsContainer {
            rulesPackageArnsDecoded0 = [Swift.String]()
            for string0 in rulesPackageArnsContainer {
                if let string0 = string0 {
                    rulesPackageArnsDecoded0?.append(string0)
                }
            }
        }
        rulesPackageArns = rulesPackageArnsDecoded0
    }
}

extension InspectorClientTypes.AssessmentTemplateFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssessmentTemplateFilter(durationRange: \(Swift.String(describing: durationRange)), namePattern: \(Swift.String(describing: namePattern)), rulesPackageArns: \(Swift.String(describing: rulesPackageArns)))"}
}

extension InspectorClientTypes {
    /// Used as the request parameter in the ListAssessmentTemplates
    ///          action.
    public struct AssessmentTemplateFilter: Swift.Equatable {
        /// For a record to match a filter, the value specified for this data type property must
        ///          inclusively match any value between the specified minimum and maximum values of the
        ///             durationInSeconds property of the AssessmentTemplate data type.
        public var durationRange: InspectorClientTypes.DurationRange?
        /// For a record to match a filter, an explicit value or a string that contains a
        ///          wildcard that is specified for this data type property must match the value of the
        ///             assessmentTemplateName property of the AssessmentTemplate data type.
        public var namePattern: Swift.String?
        /// For a record to match a filter, the values that are specified for this data type
        ///          property must be contained in the list of values of the rulesPackageArns property of the AssessmentTemplate data
        ///          type.
        public var rulesPackageArns: [Swift.String]?

        public init (
            durationRange: InspectorClientTypes.DurationRange? = nil,
            namePattern: Swift.String? = nil,
            rulesPackageArns: [Swift.String]? = nil
        )
        {
            self.durationRange = durationRange
            self.namePattern = namePattern
            self.rulesPackageArns = rulesPackageArns
        }
    }

}

extension InspectorClientTypes.AssetAttributes: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentId
        case amiId
        case autoScalingGroup
        case hostname
        case ipv4Addresses
        case networkInterfaces
        case schemaVersion
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentId = agentId {
            try encodeContainer.encode(agentId, forKey: .agentId)
        }
        if let amiId = amiId {
            try encodeContainer.encode(amiId, forKey: .amiId)
        }
        if let autoScalingGroup = autoScalingGroup {
            try encodeContainer.encode(autoScalingGroup, forKey: .autoScalingGroup)
        }
        if let hostname = hostname {
            try encodeContainer.encode(hostname, forKey: .hostname)
        }
        if let ipv4Addresses = ipv4Addresses {
            var ipv4AddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipv4Addresses)
            for ipv4addresslist0 in ipv4Addresses {
                try ipv4AddressesContainer.encode(ipv4addresslist0)
            }
        }
        if let networkInterfaces = networkInterfaces {
            var networkInterfacesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkInterfaces)
            for networkinterfaces0 in networkInterfaces {
                try networkInterfacesContainer.encode(networkinterfaces0)
            }
        }
        if schemaVersion != 0 {
            try encodeContainer.encode(schemaVersion, forKey: .schemaVersion)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaVersionDecoded = try containerValues.decode(Swift.Int.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let agentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentId)
        agentId = agentIdDecoded
        let autoScalingGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .autoScalingGroup)
        autoScalingGroup = autoScalingGroupDecoded
        let amiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amiId)
        amiId = amiIdDecoded
        let hostnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostname)
        hostname = hostnameDecoded
        let ipv4AddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ipv4Addresses)
        var ipv4AddressesDecoded0:[Swift.String]? = nil
        if let ipv4AddressesContainer = ipv4AddressesContainer {
            ipv4AddressesDecoded0 = [Swift.String]()
            for string0 in ipv4AddressesContainer {
                if let string0 = string0 {
                    ipv4AddressesDecoded0?.append(string0)
                }
            }
        }
        ipv4Addresses = ipv4AddressesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([InspectorClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[InspectorClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [InspectorClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let networkInterfacesContainer = try containerValues.decodeIfPresent([InspectorClientTypes.NetworkInterface?].self, forKey: .networkInterfaces)
        var networkInterfacesDecoded0:[InspectorClientTypes.NetworkInterface]? = nil
        if let networkInterfacesContainer = networkInterfacesContainer {
            networkInterfacesDecoded0 = [InspectorClientTypes.NetworkInterface]()
            for structure0 in networkInterfacesContainer {
                if let structure0 = structure0 {
                    networkInterfacesDecoded0?.append(structure0)
                }
            }
        }
        networkInterfaces = networkInterfacesDecoded0
    }
}

extension InspectorClientTypes.AssetAttributes: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssetAttributes(agentId: \(Swift.String(describing: agentId)), amiId: \(Swift.String(describing: amiId)), autoScalingGroup: \(Swift.String(describing: autoScalingGroup)), hostname: \(Swift.String(describing: hostname)), ipv4Addresses: \(Swift.String(describing: ipv4Addresses)), networkInterfaces: \(Swift.String(describing: networkInterfaces)), schemaVersion: \(Swift.String(describing: schemaVersion)), tags: \(Swift.String(describing: tags)))"}
}

extension InspectorClientTypes {
    /// A collection of attributes of the host from which the finding is generated.
    public struct AssetAttributes: Swift.Equatable {
        /// The ID of the agent that is installed on the EC2 instance where the finding is
        ///          generated.
        public var agentId: Swift.String?
        /// The ID of the Amazon Machine Image (AMI) that is installed on the EC2 instance where
        ///          the finding is generated.
        public var amiId: Swift.String?
        /// The Auto Scaling group of the EC2 instance where the finding is generated.
        public var autoScalingGroup: Swift.String?
        /// The hostname of the EC2 instance where the finding is generated.
        public var hostname: Swift.String?
        /// The list of IP v4 addresses of the EC2 instance where the finding is
        ///          generated.
        public var ipv4Addresses: [Swift.String]?
        /// An array of the network interfaces interacting with the EC2 instance where the
        ///          finding is generated.
        public var networkInterfaces: [InspectorClientTypes.NetworkInterface]?
        /// The schema version of this data type.
        /// This member is required.
        public var schemaVersion: Swift.Int
        /// The tags related to the EC2 instance where the finding is generated.
        public var tags: [InspectorClientTypes.Tag]?

        public init (
            agentId: Swift.String? = nil,
            amiId: Swift.String? = nil,
            autoScalingGroup: Swift.String? = nil,
            hostname: Swift.String? = nil,
            ipv4Addresses: [Swift.String]? = nil,
            networkInterfaces: [InspectorClientTypes.NetworkInterface]? = nil,
            schemaVersion: Swift.Int = 0,
            tags: [InspectorClientTypes.Tag]? = nil
        )
        {
            self.agentId = agentId
            self.amiId = amiId
            self.autoScalingGroup = autoScalingGroup
            self.hostname = hostname
            self.ipv4Addresses = ipv4Addresses
            self.networkInterfaces = networkInterfaces
            self.schemaVersion = schemaVersion
            self.tags = tags
        }
    }

}

extension InspectorClientTypes {
    public enum AssetType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ec2Instance
        case sdkUnknown(Swift.String)

        public static var allCases: [AssetType] {
            return [
                .ec2Instance,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ec2Instance: return "ec2-instance"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssetType(rawValue: rawValue) ?? AssetType.sdkUnknown(rawValue)
        }
    }
}

extension InspectorClientTypes.Attribute: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension InspectorClientTypes.Attribute: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Attribute(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension InspectorClientTypes {
    /// This data type is used as a request parameter in the AddAttributesToFindings and CreateAssessmentTemplate
    ///          actions.
    public struct Attribute: Swift.Equatable {
        /// The attribute key.
        /// This member is required.
        public var key: Swift.String?
        /// The value assigned to the attribute key.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct CreateAssessmentTargetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAssessmentTargetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAssessmentTargetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAssessmentTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAssessmentTargetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAssessmentTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAssessmentTargetOutputError>
}

extension CreateAssessmentTargetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAssessmentTargetInput(assessmentTargetName: \(Swift.String(describing: assessmentTargetName)), resourceGroupArn: \(Swift.String(describing: resourceGroupArn)))"}
}

extension CreateAssessmentTargetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTargetName
        case resourceGroupArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentTargetName = assessmentTargetName {
            try encodeContainer.encode(assessmentTargetName, forKey: .assessmentTargetName)
        }
        if let resourceGroupArn = resourceGroupArn {
            try encodeContainer.encode(resourceGroupArn, forKey: .resourceGroupArn)
        }
    }
}

public struct CreateAssessmentTargetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAssessmentTargetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAssessmentTargetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAssessmentTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAssessmentTargetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAssessmentTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAssessmentTargetOutputError>
}

public struct CreateAssessmentTargetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAssessmentTargetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAssessmentTargetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAssessmentTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAssessmentTargetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAssessmentTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAssessmentTargetOutputError>
}

public struct CreateAssessmentTargetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAssessmentTargetInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateAssessmentTargetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAssessmentTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateAssessmentTargetInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAssessmentTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAssessmentTargetOutputError>
}

public struct CreateAssessmentTargetInput: Swift.Equatable {
    /// The user-defined name that identifies the assessment target that you want to create.
    ///          The name must be unique within the AWS account.
    /// This member is required.
    public var assessmentTargetName: Swift.String?
    /// The ARN that specifies the resource group that is used to create the assessment
    ///          target. If resourceGroupArn is not specified, all EC2 instances in the current AWS account
    ///          and region are included in the assessment target.
    public var resourceGroupArn: Swift.String?

    public init (
        assessmentTargetName: Swift.String? = nil,
        resourceGroupArn: Swift.String? = nil
    )
    {
        self.assessmentTargetName = assessmentTargetName
        self.resourceGroupArn = resourceGroupArn
    }
}

struct CreateAssessmentTargetInputBody: Swift.Equatable {
    public let assessmentTargetName: Swift.String?
    public let resourceGroupArn: Swift.String?
}

extension CreateAssessmentTargetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTargetName
        case resourceGroupArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentTargetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentTargetName)
        assessmentTargetName = assessmentTargetNameDecoded
        let resourceGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupArn)
        resourceGroupArn = resourceGroupArnDecoded
    }
}

extension CreateAssessmentTargetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAssessmentTargetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCrossAccountRoleException" : self = .invalidCrossAccountRoleException(try InvalidCrossAccountRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceTemporarilyUnavailableException" : self = .serviceTemporarilyUnavailableException(try ServiceTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAssessmentTargetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidCrossAccountRoleException(InvalidCrossAccountRoleException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceTemporarilyUnavailableException(ServiceTemporarilyUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAssessmentTargetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAssessmentTargetOutputResponse(assessmentTargetArn: \(Swift.String(describing: assessmentTargetArn)))"}
}

extension CreateAssessmentTargetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateAssessmentTargetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assessmentTargetArn = output.assessmentTargetArn
        } else {
            self.assessmentTargetArn = nil
        }
    }
}

public struct CreateAssessmentTargetOutputResponse: Swift.Equatable {
    /// The ARN that specifies the assessment target that is created.
    /// This member is required.
    public var assessmentTargetArn: Swift.String?

    public init (
        assessmentTargetArn: Swift.String? = nil
    )
    {
        self.assessmentTargetArn = assessmentTargetArn
    }
}

struct CreateAssessmentTargetOutputResponseBody: Swift.Equatable {
    public let assessmentTargetArn: Swift.String?
}

extension CreateAssessmentTargetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTargetArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentTargetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentTargetArn)
        assessmentTargetArn = assessmentTargetArnDecoded
    }
}

public struct CreateAssessmentTemplateInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAssessmentTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAssessmentTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAssessmentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAssessmentTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAssessmentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAssessmentTemplateOutputError>
}

extension CreateAssessmentTemplateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAssessmentTemplateInput(assessmentTargetArn: \(Swift.String(describing: assessmentTargetArn)), assessmentTemplateName: \(Swift.String(describing: assessmentTemplateName)), durationInSeconds: \(Swift.String(describing: durationInSeconds)), rulesPackageArns: \(Swift.String(describing: rulesPackageArns)), userAttributesForFindings: \(Swift.String(describing: userAttributesForFindings)))"}
}

extension CreateAssessmentTemplateInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTargetArn
        case assessmentTemplateName
        case durationInSeconds
        case rulesPackageArns
        case userAttributesForFindings
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentTargetArn = assessmentTargetArn {
            try encodeContainer.encode(assessmentTargetArn, forKey: .assessmentTargetArn)
        }
        if let assessmentTemplateName = assessmentTemplateName {
            try encodeContainer.encode(assessmentTemplateName, forKey: .assessmentTemplateName)
        }
        if durationInSeconds != 0 {
            try encodeContainer.encode(durationInSeconds, forKey: .durationInSeconds)
        }
        if let rulesPackageArns = rulesPackageArns {
            var rulesPackageArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rulesPackageArns)
            for assessmenttemplaterulespackagearnlist0 in rulesPackageArns {
                try rulesPackageArnsContainer.encode(assessmenttemplaterulespackagearnlist0)
            }
        }
        if let userAttributesForFindings = userAttributesForFindings {
            var userAttributesForFindingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userAttributesForFindings)
            for userattributelist0 in userAttributesForFindings {
                try userAttributesForFindingsContainer.encode(userattributelist0)
            }
        }
    }
}

public struct CreateAssessmentTemplateInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAssessmentTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAssessmentTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAssessmentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAssessmentTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAssessmentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAssessmentTemplateOutputError>
}

public struct CreateAssessmentTemplateInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAssessmentTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAssessmentTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAssessmentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAssessmentTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAssessmentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAssessmentTemplateOutputError>
}

public struct CreateAssessmentTemplateInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAssessmentTemplateInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateAssessmentTemplateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAssessmentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateAssessmentTemplateInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAssessmentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAssessmentTemplateOutputError>
}

public struct CreateAssessmentTemplateInput: Swift.Equatable {
    /// The ARN that specifies the assessment target for which you want to create the
    ///          assessment template.
    /// This member is required.
    public var assessmentTargetArn: Swift.String?
    /// The user-defined name that identifies the assessment template that you want to
    ///          create. You can create several assessment templates for an assessment target. The names of
    ///          the assessment templates that correspond to a particular assessment target must be
    ///          unique.
    /// This member is required.
    public var assessmentTemplateName: Swift.String?
    /// The duration of the assessment run in seconds.
    /// This member is required.
    public var durationInSeconds: Swift.Int
    /// The ARNs that specify the rules packages that you want to attach to the assessment
    ///          template.
    /// This member is required.
    public var rulesPackageArns: [Swift.String]?
    /// The user-defined attributes that are assigned to every finding that is generated by
    ///          the assessment run that uses this assessment template. An attribute is a key and value pair
    ///          (an Attribute object). Within an assessment template, each key must be
    ///          unique.
    public var userAttributesForFindings: [InspectorClientTypes.Attribute]?

    public init (
        assessmentTargetArn: Swift.String? = nil,
        assessmentTemplateName: Swift.String? = nil,
        durationInSeconds: Swift.Int = 0,
        rulesPackageArns: [Swift.String]? = nil,
        userAttributesForFindings: [InspectorClientTypes.Attribute]? = nil
    )
    {
        self.assessmentTargetArn = assessmentTargetArn
        self.assessmentTemplateName = assessmentTemplateName
        self.durationInSeconds = durationInSeconds
        self.rulesPackageArns = rulesPackageArns
        self.userAttributesForFindings = userAttributesForFindings
    }
}

struct CreateAssessmentTemplateInputBody: Swift.Equatable {
    public let assessmentTargetArn: Swift.String?
    public let assessmentTemplateName: Swift.String?
    public let durationInSeconds: Swift.Int
    public let rulesPackageArns: [Swift.String]?
    public let userAttributesForFindings: [InspectorClientTypes.Attribute]?
}

extension CreateAssessmentTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTargetArn
        case assessmentTemplateName
        case durationInSeconds
        case rulesPackageArns
        case userAttributesForFindings
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentTargetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentTargetArn)
        assessmentTargetArn = assessmentTargetArnDecoded
        let assessmentTemplateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentTemplateName)
        assessmentTemplateName = assessmentTemplateNameDecoded
        let durationInSecondsDecoded = try containerValues.decode(Swift.Int.self, forKey: .durationInSeconds)
        durationInSeconds = durationInSecondsDecoded
        let rulesPackageArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .rulesPackageArns)
        var rulesPackageArnsDecoded0:[Swift.String]? = nil
        if let rulesPackageArnsContainer = rulesPackageArnsContainer {
            rulesPackageArnsDecoded0 = [Swift.String]()
            for string0 in rulesPackageArnsContainer {
                if let string0 = string0 {
                    rulesPackageArnsDecoded0?.append(string0)
                }
            }
        }
        rulesPackageArns = rulesPackageArnsDecoded0
        let userAttributesForFindingsContainer = try containerValues.decodeIfPresent([InspectorClientTypes.Attribute?].self, forKey: .userAttributesForFindings)
        var userAttributesForFindingsDecoded0:[InspectorClientTypes.Attribute]? = nil
        if let userAttributesForFindingsContainer = userAttributesForFindingsContainer {
            userAttributesForFindingsDecoded0 = [InspectorClientTypes.Attribute]()
            for structure0 in userAttributesForFindingsContainer {
                if let structure0 = structure0 {
                    userAttributesForFindingsDecoded0?.append(structure0)
                }
            }
        }
        userAttributesForFindings = userAttributesForFindingsDecoded0
    }
}

extension CreateAssessmentTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAssessmentTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceTemporarilyUnavailableException" : self = .serviceTemporarilyUnavailableException(try ServiceTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAssessmentTemplateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceTemporarilyUnavailableException(ServiceTemporarilyUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAssessmentTemplateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAssessmentTemplateOutputResponse(assessmentTemplateArn: \(Swift.String(describing: assessmentTemplateArn)))"}
}

extension CreateAssessmentTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateAssessmentTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assessmentTemplateArn = output.assessmentTemplateArn
        } else {
            self.assessmentTemplateArn = nil
        }
    }
}

public struct CreateAssessmentTemplateOutputResponse: Swift.Equatable {
    /// The ARN that specifies the assessment template that is created.
    /// This member is required.
    public var assessmentTemplateArn: Swift.String?

    public init (
        assessmentTemplateArn: Swift.String? = nil
    )
    {
        self.assessmentTemplateArn = assessmentTemplateArn
    }
}

struct CreateAssessmentTemplateOutputResponseBody: Swift.Equatable {
    public let assessmentTemplateArn: Swift.String?
}

extension CreateAssessmentTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTemplateArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentTemplateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentTemplateArn)
        assessmentTemplateArn = assessmentTemplateArnDecoded
    }
}

public struct CreateExclusionsPreviewInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateExclusionsPreviewInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateExclusionsPreviewInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateExclusionsPreviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateExclusionsPreviewInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateExclusionsPreviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateExclusionsPreviewOutputError>
}

extension CreateExclusionsPreviewInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateExclusionsPreviewInput(assessmentTemplateArn: \(Swift.String(describing: assessmentTemplateArn)))"}
}

extension CreateExclusionsPreviewInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTemplateArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentTemplateArn = assessmentTemplateArn {
            try encodeContainer.encode(assessmentTemplateArn, forKey: .assessmentTemplateArn)
        }
    }
}

public struct CreateExclusionsPreviewInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateExclusionsPreviewInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateExclusionsPreviewInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateExclusionsPreviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateExclusionsPreviewInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateExclusionsPreviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateExclusionsPreviewOutputError>
}

public struct CreateExclusionsPreviewInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateExclusionsPreviewInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateExclusionsPreviewInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateExclusionsPreviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateExclusionsPreviewInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateExclusionsPreviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateExclusionsPreviewOutputError>
}

public struct CreateExclusionsPreviewInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateExclusionsPreviewInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateExclusionsPreviewInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateExclusionsPreviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateExclusionsPreviewInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateExclusionsPreviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateExclusionsPreviewOutputError>
}

public struct CreateExclusionsPreviewInput: Swift.Equatable {
    /// The ARN that specifies the assessment template for which you want to create an
    ///          exclusions preview.
    /// This member is required.
    public var assessmentTemplateArn: Swift.String?

    public init (
        assessmentTemplateArn: Swift.String? = nil
    )
    {
        self.assessmentTemplateArn = assessmentTemplateArn
    }
}

struct CreateExclusionsPreviewInputBody: Swift.Equatable {
    public let assessmentTemplateArn: Swift.String?
}

extension CreateExclusionsPreviewInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTemplateArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentTemplateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentTemplateArn)
        assessmentTemplateArn = assessmentTemplateArnDecoded
    }
}

extension CreateExclusionsPreviewOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateExclusionsPreviewOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreviewGenerationInProgressException" : self = .previewGenerationInProgressException(try PreviewGenerationInProgressException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceTemporarilyUnavailableException" : self = .serviceTemporarilyUnavailableException(try ServiceTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateExclusionsPreviewOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case previewGenerationInProgressException(PreviewGenerationInProgressException)
    case serviceTemporarilyUnavailableException(ServiceTemporarilyUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateExclusionsPreviewOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateExclusionsPreviewOutputResponse(previewToken: \(Swift.String(describing: previewToken)))"}
}

extension CreateExclusionsPreviewOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateExclusionsPreviewOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.previewToken = output.previewToken
        } else {
            self.previewToken = nil
        }
    }
}

public struct CreateExclusionsPreviewOutputResponse: Swift.Equatable {
    /// Specifies the unique identifier of the requested exclusions preview. You can use the
    ///          unique identifier to retrieve the exclusions preview when running the GetExclusionsPreview
    ///          API.
    /// This member is required.
    public var previewToken: Swift.String?

    public init (
        previewToken: Swift.String? = nil
    )
    {
        self.previewToken = previewToken
    }
}

struct CreateExclusionsPreviewOutputResponseBody: Swift.Equatable {
    public let previewToken: Swift.String?
}

extension CreateExclusionsPreviewOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case previewToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let previewTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .previewToken)
        previewToken = previewTokenDecoded
    }
}

public struct CreateResourceGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateResourceGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateResourceGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateResourceGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateResourceGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateResourceGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateResourceGroupOutputError>
}

extension CreateResourceGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateResourceGroupInput(resourceGroupTags: \(Swift.String(describing: resourceGroupTags)))"}
}

extension CreateResourceGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceGroupTags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceGroupTags = resourceGroupTags {
            var resourceGroupTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceGroupTags)
            for resourcegrouptags0 in resourceGroupTags {
                try resourceGroupTagsContainer.encode(resourcegrouptags0)
            }
        }
    }
}

public struct CreateResourceGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateResourceGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateResourceGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateResourceGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateResourceGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateResourceGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateResourceGroupOutputError>
}

public struct CreateResourceGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateResourceGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateResourceGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateResourceGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateResourceGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateResourceGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateResourceGroupOutputError>
}

public struct CreateResourceGroupInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateResourceGroupInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateResourceGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateResourceGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateResourceGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateResourceGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateResourceGroupOutputError>
}

public struct CreateResourceGroupInput: Swift.Equatable {
    /// A collection of keys and an array of possible values,
    ///          '[{"key":"key1","values":["Value1","Value2"]},{"key":"Key2","values":["Value3"]}]'.
    ///          For example,'[{"key":"Name","values":["TestEC2Instance"]}]'.
    /// This member is required.
    public var resourceGroupTags: [InspectorClientTypes.ResourceGroupTag]?

    public init (
        resourceGroupTags: [InspectorClientTypes.ResourceGroupTag]? = nil
    )
    {
        self.resourceGroupTags = resourceGroupTags
    }
}

struct CreateResourceGroupInputBody: Swift.Equatable {
    public let resourceGroupTags: [InspectorClientTypes.ResourceGroupTag]?
}

extension CreateResourceGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceGroupTags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupTagsContainer = try containerValues.decodeIfPresent([InspectorClientTypes.ResourceGroupTag?].self, forKey: .resourceGroupTags)
        var resourceGroupTagsDecoded0:[InspectorClientTypes.ResourceGroupTag]? = nil
        if let resourceGroupTagsContainer = resourceGroupTagsContainer {
            resourceGroupTagsDecoded0 = [InspectorClientTypes.ResourceGroupTag]()
            for structure0 in resourceGroupTagsContainer {
                if let structure0 = structure0 {
                    resourceGroupTagsDecoded0?.append(structure0)
                }
            }
        }
        resourceGroupTags = resourceGroupTagsDecoded0
    }
}

extension CreateResourceGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateResourceGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceTemporarilyUnavailableException" : self = .serviceTemporarilyUnavailableException(try ServiceTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateResourceGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case serviceTemporarilyUnavailableException(ServiceTemporarilyUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateResourceGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateResourceGroupOutputResponse(resourceGroupArn: \(Swift.String(describing: resourceGroupArn)))"}
}

extension CreateResourceGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateResourceGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resourceGroupArn = output.resourceGroupArn
        } else {
            self.resourceGroupArn = nil
        }
    }
}

public struct CreateResourceGroupOutputResponse: Swift.Equatable {
    /// The ARN that specifies the resource group that is created.
    /// This member is required.
    public var resourceGroupArn: Swift.String?

    public init (
        resourceGroupArn: Swift.String? = nil
    )
    {
        self.resourceGroupArn = resourceGroupArn
    }
}

struct CreateResourceGroupOutputResponseBody: Swift.Equatable {
    public let resourceGroupArn: Swift.String?
}

extension CreateResourceGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceGroupArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupArn)
        resourceGroupArn = resourceGroupArnDecoded
    }
}

public struct DeleteAssessmentRunInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAssessmentRunInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAssessmentRunInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAssessmentRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAssessmentRunInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAssessmentRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAssessmentRunOutputError>
}

extension DeleteAssessmentRunInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAssessmentRunInput(assessmentRunArn: \(Swift.String(describing: assessmentRunArn)))"}
}

extension DeleteAssessmentRunInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentRunArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentRunArn = assessmentRunArn {
            try encodeContainer.encode(assessmentRunArn, forKey: .assessmentRunArn)
        }
    }
}

public struct DeleteAssessmentRunInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAssessmentRunInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAssessmentRunInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAssessmentRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAssessmentRunInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAssessmentRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAssessmentRunOutputError>
}

public struct DeleteAssessmentRunInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAssessmentRunInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAssessmentRunInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAssessmentRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAssessmentRunInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAssessmentRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAssessmentRunOutputError>
}

public struct DeleteAssessmentRunInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAssessmentRunInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteAssessmentRunInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAssessmentRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteAssessmentRunInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAssessmentRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAssessmentRunOutputError>
}

public struct DeleteAssessmentRunInput: Swift.Equatable {
    /// The ARN that specifies the assessment run that you want to delete.
    /// This member is required.
    public var assessmentRunArn: Swift.String?

    public init (
        assessmentRunArn: Swift.String? = nil
    )
    {
        self.assessmentRunArn = assessmentRunArn
    }
}

struct DeleteAssessmentRunInputBody: Swift.Equatable {
    public let assessmentRunArn: Swift.String?
}

extension DeleteAssessmentRunInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentRunArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentRunArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentRunArn)
        assessmentRunArn = assessmentRunArnDecoded
    }
}

extension DeleteAssessmentRunOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAssessmentRunOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AssessmentRunInProgressException" : self = .assessmentRunInProgressException(try AssessmentRunInProgressException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceTemporarilyUnavailableException" : self = .serviceTemporarilyUnavailableException(try ServiceTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAssessmentRunOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case assessmentRunInProgressException(AssessmentRunInProgressException)
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceTemporarilyUnavailableException(ServiceTemporarilyUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAssessmentRunOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAssessmentRunOutputResponse()"}
}

extension DeleteAssessmentRunOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAssessmentRunOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteAssessmentRunOutputResponseBody: Swift.Equatable {
}

extension DeleteAssessmentRunOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteAssessmentTargetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAssessmentTargetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAssessmentTargetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAssessmentTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAssessmentTargetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAssessmentTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAssessmentTargetOutputError>
}

extension DeleteAssessmentTargetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAssessmentTargetInput(assessmentTargetArn: \(Swift.String(describing: assessmentTargetArn)))"}
}

extension DeleteAssessmentTargetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTargetArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentTargetArn = assessmentTargetArn {
            try encodeContainer.encode(assessmentTargetArn, forKey: .assessmentTargetArn)
        }
    }
}

public struct DeleteAssessmentTargetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAssessmentTargetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAssessmentTargetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAssessmentTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAssessmentTargetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAssessmentTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAssessmentTargetOutputError>
}

public struct DeleteAssessmentTargetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAssessmentTargetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAssessmentTargetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAssessmentTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAssessmentTargetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAssessmentTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAssessmentTargetOutputError>
}

public struct DeleteAssessmentTargetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAssessmentTargetInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteAssessmentTargetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAssessmentTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteAssessmentTargetInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAssessmentTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAssessmentTargetOutputError>
}

public struct DeleteAssessmentTargetInput: Swift.Equatable {
    /// The ARN that specifies the assessment target that you want to delete.
    /// This member is required.
    public var assessmentTargetArn: Swift.String?

    public init (
        assessmentTargetArn: Swift.String? = nil
    )
    {
        self.assessmentTargetArn = assessmentTargetArn
    }
}

struct DeleteAssessmentTargetInputBody: Swift.Equatable {
    public let assessmentTargetArn: Swift.String?
}

extension DeleteAssessmentTargetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTargetArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentTargetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentTargetArn)
        assessmentTargetArn = assessmentTargetArnDecoded
    }
}

extension DeleteAssessmentTargetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAssessmentTargetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AssessmentRunInProgressException" : self = .assessmentRunInProgressException(try AssessmentRunInProgressException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceTemporarilyUnavailableException" : self = .serviceTemporarilyUnavailableException(try ServiceTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAssessmentTargetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case assessmentRunInProgressException(AssessmentRunInProgressException)
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceTemporarilyUnavailableException(ServiceTemporarilyUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAssessmentTargetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAssessmentTargetOutputResponse()"}
}

extension DeleteAssessmentTargetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAssessmentTargetOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteAssessmentTargetOutputResponseBody: Swift.Equatable {
}

extension DeleteAssessmentTargetOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteAssessmentTemplateInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAssessmentTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAssessmentTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAssessmentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAssessmentTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAssessmentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAssessmentTemplateOutputError>
}

extension DeleteAssessmentTemplateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAssessmentTemplateInput(assessmentTemplateArn: \(Swift.String(describing: assessmentTemplateArn)))"}
}

extension DeleteAssessmentTemplateInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTemplateArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentTemplateArn = assessmentTemplateArn {
            try encodeContainer.encode(assessmentTemplateArn, forKey: .assessmentTemplateArn)
        }
    }
}

public struct DeleteAssessmentTemplateInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAssessmentTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAssessmentTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAssessmentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAssessmentTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAssessmentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAssessmentTemplateOutputError>
}

public struct DeleteAssessmentTemplateInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAssessmentTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAssessmentTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAssessmentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAssessmentTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAssessmentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAssessmentTemplateOutputError>
}

public struct DeleteAssessmentTemplateInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAssessmentTemplateInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteAssessmentTemplateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAssessmentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteAssessmentTemplateInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAssessmentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAssessmentTemplateOutputError>
}

public struct DeleteAssessmentTemplateInput: Swift.Equatable {
    /// The ARN that specifies the assessment template that you want to delete.
    /// This member is required.
    public var assessmentTemplateArn: Swift.String?

    public init (
        assessmentTemplateArn: Swift.String? = nil
    )
    {
        self.assessmentTemplateArn = assessmentTemplateArn
    }
}

struct DeleteAssessmentTemplateInputBody: Swift.Equatable {
    public let assessmentTemplateArn: Swift.String?
}

extension DeleteAssessmentTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTemplateArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentTemplateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentTemplateArn)
        assessmentTemplateArn = assessmentTemplateArnDecoded
    }
}

extension DeleteAssessmentTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAssessmentTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AssessmentRunInProgressException" : self = .assessmentRunInProgressException(try AssessmentRunInProgressException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceTemporarilyUnavailableException" : self = .serviceTemporarilyUnavailableException(try ServiceTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAssessmentTemplateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case assessmentRunInProgressException(AssessmentRunInProgressException)
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceTemporarilyUnavailableException(ServiceTemporarilyUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAssessmentTemplateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAssessmentTemplateOutputResponse()"}
}

extension DeleteAssessmentTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAssessmentTemplateOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteAssessmentTemplateOutputResponseBody: Swift.Equatable {
}

extension DeleteAssessmentTemplateOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DescribeAssessmentRunsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAssessmentRunsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAssessmentRunsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAssessmentRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAssessmentRunsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAssessmentRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAssessmentRunsOutputError>
}

extension DescribeAssessmentRunsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAssessmentRunsInput(assessmentRunArns: \(Swift.String(describing: assessmentRunArns)))"}
}

extension DescribeAssessmentRunsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentRunArns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentRunArns = assessmentRunArns {
            var assessmentRunArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assessmentRunArns)
            for batchdescribearnlist0 in assessmentRunArns {
                try assessmentRunArnsContainer.encode(batchdescribearnlist0)
            }
        }
    }
}

public struct DescribeAssessmentRunsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAssessmentRunsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAssessmentRunsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAssessmentRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAssessmentRunsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAssessmentRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAssessmentRunsOutputError>
}

public struct DescribeAssessmentRunsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAssessmentRunsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAssessmentRunsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAssessmentRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAssessmentRunsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAssessmentRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAssessmentRunsOutputError>
}

public struct DescribeAssessmentRunsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAssessmentRunsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeAssessmentRunsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAssessmentRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeAssessmentRunsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAssessmentRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAssessmentRunsOutputError>
}

public struct DescribeAssessmentRunsInput: Swift.Equatable {
    /// The ARN that specifies the assessment run that you want to describe.
    /// This member is required.
    public var assessmentRunArns: [Swift.String]?

    public init (
        assessmentRunArns: [Swift.String]? = nil
    )
    {
        self.assessmentRunArns = assessmentRunArns
    }
}

struct DescribeAssessmentRunsInputBody: Swift.Equatable {
    public let assessmentRunArns: [Swift.String]?
}

extension DescribeAssessmentRunsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentRunArns
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentRunArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .assessmentRunArns)
        var assessmentRunArnsDecoded0:[Swift.String]? = nil
        if let assessmentRunArnsContainer = assessmentRunArnsContainer {
            assessmentRunArnsDecoded0 = [Swift.String]()
            for string0 in assessmentRunArnsContainer {
                if let string0 = string0 {
                    assessmentRunArnsDecoded0?.append(string0)
                }
            }
        }
        assessmentRunArns = assessmentRunArnsDecoded0
    }
}

extension DescribeAssessmentRunsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAssessmentRunsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAssessmentRunsOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAssessmentRunsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAssessmentRunsOutputResponse(assessmentRuns: \(Swift.String(describing: assessmentRuns)), failedItems: \(Swift.String(describing: failedItems)))"}
}

extension DescribeAssessmentRunsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAssessmentRunsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assessmentRuns = output.assessmentRuns
            self.failedItems = output.failedItems
        } else {
            self.assessmentRuns = nil
            self.failedItems = nil
        }
    }
}

public struct DescribeAssessmentRunsOutputResponse: Swift.Equatable {
    /// Information about the assessment run.
    /// This member is required.
    public var assessmentRuns: [InspectorClientTypes.AssessmentRun]?
    /// Assessment run details that cannot be described. An error code is provided for each
    ///          failed item.
    /// This member is required.
    public var failedItems: [Swift.String:InspectorClientTypes.FailedItemDetails]?

    public init (
        assessmentRuns: [InspectorClientTypes.AssessmentRun]? = nil,
        failedItems: [Swift.String:InspectorClientTypes.FailedItemDetails]? = nil
    )
    {
        self.assessmentRuns = assessmentRuns
        self.failedItems = failedItems
    }
}

struct DescribeAssessmentRunsOutputResponseBody: Swift.Equatable {
    public let assessmentRuns: [InspectorClientTypes.AssessmentRun]?
    public let failedItems: [Swift.String:InspectorClientTypes.FailedItemDetails]?
}

extension DescribeAssessmentRunsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentRuns
        case failedItems
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentRunsContainer = try containerValues.decodeIfPresent([InspectorClientTypes.AssessmentRun?].self, forKey: .assessmentRuns)
        var assessmentRunsDecoded0:[InspectorClientTypes.AssessmentRun]? = nil
        if let assessmentRunsContainer = assessmentRunsContainer {
            assessmentRunsDecoded0 = [InspectorClientTypes.AssessmentRun]()
            for structure0 in assessmentRunsContainer {
                if let structure0 = structure0 {
                    assessmentRunsDecoded0?.append(structure0)
                }
            }
        }
        assessmentRuns = assessmentRunsDecoded0
        let failedItemsContainer = try containerValues.decodeIfPresent([Swift.String: InspectorClientTypes.FailedItemDetails?].self, forKey: .failedItems)
        var failedItemsDecoded0: [Swift.String:InspectorClientTypes.FailedItemDetails]? = nil
        if let failedItemsContainer = failedItemsContainer {
            failedItemsDecoded0 = [Swift.String:InspectorClientTypes.FailedItemDetails]()
            for (key0, faileditemdetails0) in failedItemsContainer {
                if let faileditemdetails0 = faileditemdetails0 {
                    failedItemsDecoded0?[key0] = faileditemdetails0
                }
            }
        }
        failedItems = failedItemsDecoded0
    }
}

public struct DescribeAssessmentTargetsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAssessmentTargetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAssessmentTargetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAssessmentTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAssessmentTargetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAssessmentTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAssessmentTargetsOutputError>
}

extension DescribeAssessmentTargetsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAssessmentTargetsInput(assessmentTargetArns: \(Swift.String(describing: assessmentTargetArns)))"}
}

extension DescribeAssessmentTargetsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTargetArns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentTargetArns = assessmentTargetArns {
            var assessmentTargetArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assessmentTargetArns)
            for batchdescribearnlist0 in assessmentTargetArns {
                try assessmentTargetArnsContainer.encode(batchdescribearnlist0)
            }
        }
    }
}

public struct DescribeAssessmentTargetsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAssessmentTargetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAssessmentTargetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAssessmentTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAssessmentTargetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAssessmentTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAssessmentTargetsOutputError>
}

public struct DescribeAssessmentTargetsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAssessmentTargetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAssessmentTargetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAssessmentTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAssessmentTargetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAssessmentTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAssessmentTargetsOutputError>
}

public struct DescribeAssessmentTargetsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAssessmentTargetsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeAssessmentTargetsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAssessmentTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeAssessmentTargetsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAssessmentTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAssessmentTargetsOutputError>
}

public struct DescribeAssessmentTargetsInput: Swift.Equatable {
    /// The ARNs that specifies the assessment targets that you want to describe.
    /// This member is required.
    public var assessmentTargetArns: [Swift.String]?

    public init (
        assessmentTargetArns: [Swift.String]? = nil
    )
    {
        self.assessmentTargetArns = assessmentTargetArns
    }
}

struct DescribeAssessmentTargetsInputBody: Swift.Equatable {
    public let assessmentTargetArns: [Swift.String]?
}

extension DescribeAssessmentTargetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTargetArns
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentTargetArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .assessmentTargetArns)
        var assessmentTargetArnsDecoded0:[Swift.String]? = nil
        if let assessmentTargetArnsContainer = assessmentTargetArnsContainer {
            assessmentTargetArnsDecoded0 = [Swift.String]()
            for string0 in assessmentTargetArnsContainer {
                if let string0 = string0 {
                    assessmentTargetArnsDecoded0?.append(string0)
                }
            }
        }
        assessmentTargetArns = assessmentTargetArnsDecoded0
    }
}

extension DescribeAssessmentTargetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAssessmentTargetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAssessmentTargetsOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAssessmentTargetsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAssessmentTargetsOutputResponse(assessmentTargets: \(Swift.String(describing: assessmentTargets)), failedItems: \(Swift.String(describing: failedItems)))"}
}

extension DescribeAssessmentTargetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAssessmentTargetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assessmentTargets = output.assessmentTargets
            self.failedItems = output.failedItems
        } else {
            self.assessmentTargets = nil
            self.failedItems = nil
        }
    }
}

public struct DescribeAssessmentTargetsOutputResponse: Swift.Equatable {
    /// Information about the assessment targets.
    /// This member is required.
    public var assessmentTargets: [InspectorClientTypes.AssessmentTarget]?
    /// Assessment target details that cannot be described. An error code is provided for
    ///          each failed item.
    /// This member is required.
    public var failedItems: [Swift.String:InspectorClientTypes.FailedItemDetails]?

    public init (
        assessmentTargets: [InspectorClientTypes.AssessmentTarget]? = nil,
        failedItems: [Swift.String:InspectorClientTypes.FailedItemDetails]? = nil
    )
    {
        self.assessmentTargets = assessmentTargets
        self.failedItems = failedItems
    }
}

struct DescribeAssessmentTargetsOutputResponseBody: Swift.Equatable {
    public let assessmentTargets: [InspectorClientTypes.AssessmentTarget]?
    public let failedItems: [Swift.String:InspectorClientTypes.FailedItemDetails]?
}

extension DescribeAssessmentTargetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTargets
        case failedItems
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentTargetsContainer = try containerValues.decodeIfPresent([InspectorClientTypes.AssessmentTarget?].self, forKey: .assessmentTargets)
        var assessmentTargetsDecoded0:[InspectorClientTypes.AssessmentTarget]? = nil
        if let assessmentTargetsContainer = assessmentTargetsContainer {
            assessmentTargetsDecoded0 = [InspectorClientTypes.AssessmentTarget]()
            for structure0 in assessmentTargetsContainer {
                if let structure0 = structure0 {
                    assessmentTargetsDecoded0?.append(structure0)
                }
            }
        }
        assessmentTargets = assessmentTargetsDecoded0
        let failedItemsContainer = try containerValues.decodeIfPresent([Swift.String: InspectorClientTypes.FailedItemDetails?].self, forKey: .failedItems)
        var failedItemsDecoded0: [Swift.String:InspectorClientTypes.FailedItemDetails]? = nil
        if let failedItemsContainer = failedItemsContainer {
            failedItemsDecoded0 = [Swift.String:InspectorClientTypes.FailedItemDetails]()
            for (key0, faileditemdetails0) in failedItemsContainer {
                if let faileditemdetails0 = faileditemdetails0 {
                    failedItemsDecoded0?[key0] = faileditemdetails0
                }
            }
        }
        failedItems = failedItemsDecoded0
    }
}

public struct DescribeAssessmentTemplatesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAssessmentTemplatesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAssessmentTemplatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAssessmentTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAssessmentTemplatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAssessmentTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAssessmentTemplatesOutputError>
}

extension DescribeAssessmentTemplatesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAssessmentTemplatesInput(assessmentTemplateArns: \(Swift.String(describing: assessmentTemplateArns)))"}
}

extension DescribeAssessmentTemplatesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTemplateArns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentTemplateArns = assessmentTemplateArns {
            var assessmentTemplateArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assessmentTemplateArns)
            for batchdescribearnlist0 in assessmentTemplateArns {
                try assessmentTemplateArnsContainer.encode(batchdescribearnlist0)
            }
        }
    }
}

public struct DescribeAssessmentTemplatesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAssessmentTemplatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAssessmentTemplatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAssessmentTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAssessmentTemplatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAssessmentTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAssessmentTemplatesOutputError>
}

public struct DescribeAssessmentTemplatesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAssessmentTemplatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAssessmentTemplatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAssessmentTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAssessmentTemplatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAssessmentTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAssessmentTemplatesOutputError>
}

public struct DescribeAssessmentTemplatesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAssessmentTemplatesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeAssessmentTemplatesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAssessmentTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeAssessmentTemplatesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAssessmentTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAssessmentTemplatesOutputError>
}

public struct DescribeAssessmentTemplatesInput: Swift.Equatable {
    /// This member is required.
    public var assessmentTemplateArns: [Swift.String]?

    public init (
        assessmentTemplateArns: [Swift.String]? = nil
    )
    {
        self.assessmentTemplateArns = assessmentTemplateArns
    }
}

struct DescribeAssessmentTemplatesInputBody: Swift.Equatable {
    public let assessmentTemplateArns: [Swift.String]?
}

extension DescribeAssessmentTemplatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTemplateArns
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentTemplateArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .assessmentTemplateArns)
        var assessmentTemplateArnsDecoded0:[Swift.String]? = nil
        if let assessmentTemplateArnsContainer = assessmentTemplateArnsContainer {
            assessmentTemplateArnsDecoded0 = [Swift.String]()
            for string0 in assessmentTemplateArnsContainer {
                if let string0 = string0 {
                    assessmentTemplateArnsDecoded0?.append(string0)
                }
            }
        }
        assessmentTemplateArns = assessmentTemplateArnsDecoded0
    }
}

extension DescribeAssessmentTemplatesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAssessmentTemplatesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAssessmentTemplatesOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAssessmentTemplatesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAssessmentTemplatesOutputResponse(assessmentTemplates: \(Swift.String(describing: assessmentTemplates)), failedItems: \(Swift.String(describing: failedItems)))"}
}

extension DescribeAssessmentTemplatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAssessmentTemplatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assessmentTemplates = output.assessmentTemplates
            self.failedItems = output.failedItems
        } else {
            self.assessmentTemplates = nil
            self.failedItems = nil
        }
    }
}

public struct DescribeAssessmentTemplatesOutputResponse: Swift.Equatable {
    /// Information about the assessment templates.
    /// This member is required.
    public var assessmentTemplates: [InspectorClientTypes.AssessmentTemplate]?
    /// Assessment template details that cannot be described. An error code is provided for
    ///          each failed item.
    /// This member is required.
    public var failedItems: [Swift.String:InspectorClientTypes.FailedItemDetails]?

    public init (
        assessmentTemplates: [InspectorClientTypes.AssessmentTemplate]? = nil,
        failedItems: [Swift.String:InspectorClientTypes.FailedItemDetails]? = nil
    )
    {
        self.assessmentTemplates = assessmentTemplates
        self.failedItems = failedItems
    }
}

struct DescribeAssessmentTemplatesOutputResponseBody: Swift.Equatable {
    public let assessmentTemplates: [InspectorClientTypes.AssessmentTemplate]?
    public let failedItems: [Swift.String:InspectorClientTypes.FailedItemDetails]?
}

extension DescribeAssessmentTemplatesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTemplates
        case failedItems
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentTemplatesContainer = try containerValues.decodeIfPresent([InspectorClientTypes.AssessmentTemplate?].self, forKey: .assessmentTemplates)
        var assessmentTemplatesDecoded0:[InspectorClientTypes.AssessmentTemplate]? = nil
        if let assessmentTemplatesContainer = assessmentTemplatesContainer {
            assessmentTemplatesDecoded0 = [InspectorClientTypes.AssessmentTemplate]()
            for structure0 in assessmentTemplatesContainer {
                if let structure0 = structure0 {
                    assessmentTemplatesDecoded0?.append(structure0)
                }
            }
        }
        assessmentTemplates = assessmentTemplatesDecoded0
        let failedItemsContainer = try containerValues.decodeIfPresent([Swift.String: InspectorClientTypes.FailedItemDetails?].self, forKey: .failedItems)
        var failedItemsDecoded0: [Swift.String:InspectorClientTypes.FailedItemDetails]? = nil
        if let failedItemsContainer = failedItemsContainer {
            failedItemsDecoded0 = [Swift.String:InspectorClientTypes.FailedItemDetails]()
            for (key0, faileditemdetails0) in failedItemsContainer {
                if let faileditemdetails0 = faileditemdetails0 {
                    failedItemsDecoded0?[key0] = faileditemdetails0
                }
            }
        }
        failedItems = failedItemsDecoded0
    }
}

extension DescribeCrossAccountAccessRoleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeCrossAccountAccessRoleInput()"}
}

extension DescribeCrossAccountAccessRoleInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeCrossAccountAccessRoleInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCrossAccountAccessRoleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCrossAccountAccessRoleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCrossAccountAccessRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCrossAccountAccessRoleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCrossAccountAccessRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCrossAccountAccessRoleOutputError>
}

public struct DescribeCrossAccountAccessRoleInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCrossAccountAccessRoleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCrossAccountAccessRoleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCrossAccountAccessRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCrossAccountAccessRoleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCrossAccountAccessRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCrossAccountAccessRoleOutputError>
}

public struct DescribeCrossAccountAccessRoleInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCrossAccountAccessRoleInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeCrossAccountAccessRoleInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCrossAccountAccessRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeCrossAccountAccessRoleInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCrossAccountAccessRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCrossAccountAccessRoleOutputError>
}

public struct DescribeCrossAccountAccessRoleInput: Swift.Equatable {

    public init() {}
}

struct DescribeCrossAccountAccessRoleInputBody: Swift.Equatable {
}

extension DescribeCrossAccountAccessRoleInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeCrossAccountAccessRoleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCrossAccountAccessRoleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCrossAccountAccessRoleOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCrossAccountAccessRoleOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeCrossAccountAccessRoleOutputResponse(registeredAt: \(Swift.String(describing: registeredAt)), roleArn: \(Swift.String(describing: roleArn)), valid: \(Swift.String(describing: valid)))"}
}

extension DescribeCrossAccountAccessRoleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeCrossAccountAccessRoleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.registeredAt = output.registeredAt
            self.roleArn = output.roleArn
            self.valid = output.valid
        } else {
            self.registeredAt = nil
            self.roleArn = nil
            self.valid = nil
        }
    }
}

public struct DescribeCrossAccountAccessRoleOutputResponse: Swift.Equatable {
    /// The date when the cross-account access role was registered.
    /// This member is required.
    public var registeredAt: ClientRuntime.Date?
    /// The ARN that specifies the IAM role that Amazon Inspector uses to access your AWS
    ///          account.
    /// This member is required.
    public var roleArn: Swift.String?
    /// A Boolean value that specifies whether the IAM role has the necessary policies
    ///          attached to enable Amazon Inspector to access your AWS account.
    /// This member is required.
    public var valid: Swift.Bool?

    public init (
        registeredAt: ClientRuntime.Date? = nil,
        roleArn: Swift.String? = nil,
        valid: Swift.Bool? = nil
    )
    {
        self.registeredAt = registeredAt
        self.roleArn = roleArn
        self.valid = valid
    }
}

struct DescribeCrossAccountAccessRoleOutputResponseBody: Swift.Equatable {
    public let roleArn: Swift.String?
    public let valid: Swift.Bool?
    public let registeredAt: ClientRuntime.Date?
}

extension DescribeCrossAccountAccessRoleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registeredAt
        case roleArn
        case valid
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let validDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .valid)
        valid = validDecoded
        let registeredAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .registeredAt)
        registeredAt = registeredAtDecoded
    }
}

public struct DescribeExclusionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeExclusionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeExclusionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeExclusionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeExclusionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeExclusionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeExclusionsOutputError>
}

extension DescribeExclusionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeExclusionsInput(exclusionArns: \(Swift.String(describing: exclusionArns)), locale: \(Swift.String(describing: locale)))"}
}

extension DescribeExclusionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exclusionArns
        case locale
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exclusionArns = exclusionArns {
            var exclusionArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .exclusionArns)
            for batchdescribeexclusionsarnlist0 in exclusionArns {
                try exclusionArnsContainer.encode(batchdescribeexclusionsarnlist0)
            }
        }
        if let locale = locale {
            try encodeContainer.encode(locale.rawValue, forKey: .locale)
        }
    }
}

public struct DescribeExclusionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeExclusionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeExclusionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeExclusionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeExclusionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeExclusionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeExclusionsOutputError>
}

public struct DescribeExclusionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeExclusionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeExclusionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeExclusionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeExclusionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeExclusionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeExclusionsOutputError>
}

public struct DescribeExclusionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeExclusionsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeExclusionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeExclusionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeExclusionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeExclusionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeExclusionsOutputError>
}

public struct DescribeExclusionsInput: Swift.Equatable {
    /// The list of ARNs that specify the exclusions that you want to describe.
    /// This member is required.
    public var exclusionArns: [Swift.String]?
    /// The locale into which you want to translate the exclusion's title, description, and
    ///          recommendation.
    public var locale: InspectorClientTypes.Locale?

    public init (
        exclusionArns: [Swift.String]? = nil,
        locale: InspectorClientTypes.Locale? = nil
    )
    {
        self.exclusionArns = exclusionArns
        self.locale = locale
    }
}

struct DescribeExclusionsInputBody: Swift.Equatable {
    public let exclusionArns: [Swift.String]?
    public let locale: InspectorClientTypes.Locale?
}

extension DescribeExclusionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exclusionArns
        case locale
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exclusionArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .exclusionArns)
        var exclusionArnsDecoded0:[Swift.String]? = nil
        if let exclusionArnsContainer = exclusionArnsContainer {
            exclusionArnsDecoded0 = [Swift.String]()
            for string0 in exclusionArnsContainer {
                if let string0 = string0 {
                    exclusionArnsDecoded0?.append(string0)
                }
            }
        }
        exclusionArns = exclusionArnsDecoded0
        let localeDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.Locale.self, forKey: .locale)
        locale = localeDecoded
    }
}

extension DescribeExclusionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeExclusionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeExclusionsOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeExclusionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeExclusionsOutputResponse(exclusions: \(Swift.String(describing: exclusions)), failedItems: \(Swift.String(describing: failedItems)))"}
}

extension DescribeExclusionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeExclusionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.exclusions = output.exclusions
            self.failedItems = output.failedItems
        } else {
            self.exclusions = nil
            self.failedItems = nil
        }
    }
}

public struct DescribeExclusionsOutputResponse: Swift.Equatable {
    /// Information about the exclusions.
    /// This member is required.
    public var exclusions: [Swift.String:InspectorClientTypes.Exclusion]?
    /// Exclusion details that cannot be described. An error code is provided for each failed
    ///          item.
    /// This member is required.
    public var failedItems: [Swift.String:InspectorClientTypes.FailedItemDetails]?

    public init (
        exclusions: [Swift.String:InspectorClientTypes.Exclusion]? = nil,
        failedItems: [Swift.String:InspectorClientTypes.FailedItemDetails]? = nil
    )
    {
        self.exclusions = exclusions
        self.failedItems = failedItems
    }
}

struct DescribeExclusionsOutputResponseBody: Swift.Equatable {
    public let exclusions: [Swift.String:InspectorClientTypes.Exclusion]?
    public let failedItems: [Swift.String:InspectorClientTypes.FailedItemDetails]?
}

extension DescribeExclusionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exclusions
        case failedItems
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exclusionsContainer = try containerValues.decodeIfPresent([Swift.String: InspectorClientTypes.Exclusion?].self, forKey: .exclusions)
        var exclusionsDecoded0: [Swift.String:InspectorClientTypes.Exclusion]? = nil
        if let exclusionsContainer = exclusionsContainer {
            exclusionsDecoded0 = [Swift.String:InspectorClientTypes.Exclusion]()
            for (key0, exclusion0) in exclusionsContainer {
                if let exclusion0 = exclusion0 {
                    exclusionsDecoded0?[key0] = exclusion0
                }
            }
        }
        exclusions = exclusionsDecoded0
        let failedItemsContainer = try containerValues.decodeIfPresent([Swift.String: InspectorClientTypes.FailedItemDetails?].self, forKey: .failedItems)
        var failedItemsDecoded0: [Swift.String:InspectorClientTypes.FailedItemDetails]? = nil
        if let failedItemsContainer = failedItemsContainer {
            failedItemsDecoded0 = [Swift.String:InspectorClientTypes.FailedItemDetails]()
            for (key0, faileditemdetails0) in failedItemsContainer {
                if let faileditemdetails0 = faileditemdetails0 {
                    failedItemsDecoded0?[key0] = faileditemdetails0
                }
            }
        }
        failedItems = failedItemsDecoded0
    }
}

public struct DescribeFindingsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFindingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFindingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFindingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFindingsOutputError>
}

extension DescribeFindingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeFindingsInput(findingArns: \(Swift.String(describing: findingArns)), locale: \(Swift.String(describing: locale)))"}
}

extension DescribeFindingsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingArns
        case locale
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingArns = findingArns {
            var findingArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingArns)
            for batchdescribearnlist0 in findingArns {
                try findingArnsContainer.encode(batchdescribearnlist0)
            }
        }
        if let locale = locale {
            try encodeContainer.encode(locale.rawValue, forKey: .locale)
        }
    }
}

public struct DescribeFindingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFindingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFindingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFindingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFindingsOutputError>
}

public struct DescribeFindingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFindingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFindingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFindingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFindingsOutputError>
}

public struct DescribeFindingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFindingsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeFindingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeFindingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFindingsOutputError>
}

public struct DescribeFindingsInput: Swift.Equatable {
    /// The ARN that specifies the finding that you want to describe.
    /// This member is required.
    public var findingArns: [Swift.String]?
    /// The locale into which you want to translate a finding description, recommendation,
    ///          and the short description that identifies the finding.
    public var locale: InspectorClientTypes.Locale?

    public init (
        findingArns: [Swift.String]? = nil,
        locale: InspectorClientTypes.Locale? = nil
    )
    {
        self.findingArns = findingArns
        self.locale = locale
    }
}

struct DescribeFindingsInputBody: Swift.Equatable {
    public let findingArns: [Swift.String]?
    public let locale: InspectorClientTypes.Locale?
}

extension DescribeFindingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingArns
        case locale
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .findingArns)
        var findingArnsDecoded0:[Swift.String]? = nil
        if let findingArnsContainer = findingArnsContainer {
            findingArnsDecoded0 = [Swift.String]()
            for string0 in findingArnsContainer {
                if let string0 = string0 {
                    findingArnsDecoded0?.append(string0)
                }
            }
        }
        findingArns = findingArnsDecoded0
        let localeDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.Locale.self, forKey: .locale)
        locale = localeDecoded
    }
}

extension DescribeFindingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFindingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFindingsOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFindingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeFindingsOutputResponse(failedItems: \(Swift.String(describing: failedItems)), findings: \(Swift.String(describing: findings)))"}
}

extension DescribeFindingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeFindingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failedItems = output.failedItems
            self.findings = output.findings
        } else {
            self.failedItems = nil
            self.findings = nil
        }
    }
}

public struct DescribeFindingsOutputResponse: Swift.Equatable {
    /// Finding details that cannot be described. An error code is provided for each failed
    ///          item.
    /// This member is required.
    public var failedItems: [Swift.String:InspectorClientTypes.FailedItemDetails]?
    /// Information about the finding.
    /// This member is required.
    public var findings: [InspectorClientTypes.Finding]?

    public init (
        failedItems: [Swift.String:InspectorClientTypes.FailedItemDetails]? = nil,
        findings: [InspectorClientTypes.Finding]? = nil
    )
    {
        self.failedItems = failedItems
        self.findings = findings
    }
}

struct DescribeFindingsOutputResponseBody: Swift.Equatable {
    public let findings: [InspectorClientTypes.Finding]?
    public let failedItems: [Swift.String:InspectorClientTypes.FailedItemDetails]?
}

extension DescribeFindingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedItems
        case findings
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingsContainer = try containerValues.decodeIfPresent([InspectorClientTypes.Finding?].self, forKey: .findings)
        var findingsDecoded0:[InspectorClientTypes.Finding]? = nil
        if let findingsContainer = findingsContainer {
            findingsDecoded0 = [InspectorClientTypes.Finding]()
            for structure0 in findingsContainer {
                if let structure0 = structure0 {
                    findingsDecoded0?.append(structure0)
                }
            }
        }
        findings = findingsDecoded0
        let failedItemsContainer = try containerValues.decodeIfPresent([Swift.String: InspectorClientTypes.FailedItemDetails?].self, forKey: .failedItems)
        var failedItemsDecoded0: [Swift.String:InspectorClientTypes.FailedItemDetails]? = nil
        if let failedItemsContainer = failedItemsContainer {
            failedItemsDecoded0 = [Swift.String:InspectorClientTypes.FailedItemDetails]()
            for (key0, faileditemdetails0) in failedItemsContainer {
                if let faileditemdetails0 = faileditemdetails0 {
                    failedItemsDecoded0?[key0] = faileditemdetails0
                }
            }
        }
        failedItems = failedItemsDecoded0
    }
}

public struct DescribeResourceGroupsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeResourceGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeResourceGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeResourceGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeResourceGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeResourceGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeResourceGroupsOutputError>
}

extension DescribeResourceGroupsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeResourceGroupsInput(resourceGroupArns: \(Swift.String(describing: resourceGroupArns)))"}
}

extension DescribeResourceGroupsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceGroupArns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceGroupArns = resourceGroupArns {
            var resourceGroupArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceGroupArns)
            for batchdescribearnlist0 in resourceGroupArns {
                try resourceGroupArnsContainer.encode(batchdescribearnlist0)
            }
        }
    }
}

public struct DescribeResourceGroupsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeResourceGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeResourceGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeResourceGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeResourceGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeResourceGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeResourceGroupsOutputError>
}

public struct DescribeResourceGroupsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeResourceGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeResourceGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeResourceGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeResourceGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeResourceGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeResourceGroupsOutputError>
}

public struct DescribeResourceGroupsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeResourceGroupsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeResourceGroupsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeResourceGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeResourceGroupsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeResourceGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeResourceGroupsOutputError>
}

public struct DescribeResourceGroupsInput: Swift.Equatable {
    /// The ARN that specifies the resource group that you want to describe.
    /// This member is required.
    public var resourceGroupArns: [Swift.String]?

    public init (
        resourceGroupArns: [Swift.String]? = nil
    )
    {
        self.resourceGroupArns = resourceGroupArns
    }
}

struct DescribeResourceGroupsInputBody: Swift.Equatable {
    public let resourceGroupArns: [Swift.String]?
}

extension DescribeResourceGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceGroupArns
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceGroupArns)
        var resourceGroupArnsDecoded0:[Swift.String]? = nil
        if let resourceGroupArnsContainer = resourceGroupArnsContainer {
            resourceGroupArnsDecoded0 = [Swift.String]()
            for string0 in resourceGroupArnsContainer {
                if let string0 = string0 {
                    resourceGroupArnsDecoded0?.append(string0)
                }
            }
        }
        resourceGroupArns = resourceGroupArnsDecoded0
    }
}

extension DescribeResourceGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeResourceGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeResourceGroupsOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeResourceGroupsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeResourceGroupsOutputResponse(failedItems: \(Swift.String(describing: failedItems)), resourceGroups: \(Swift.String(describing: resourceGroups)))"}
}

extension DescribeResourceGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeResourceGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failedItems = output.failedItems
            self.resourceGroups = output.resourceGroups
        } else {
            self.failedItems = nil
            self.resourceGroups = nil
        }
    }
}

public struct DescribeResourceGroupsOutputResponse: Swift.Equatable {
    /// Resource group details that cannot be described. An error code is provided for each
    ///          failed item.
    /// This member is required.
    public var failedItems: [Swift.String:InspectorClientTypes.FailedItemDetails]?
    /// Information about a resource group.
    /// This member is required.
    public var resourceGroups: [InspectorClientTypes.ResourceGroup]?

    public init (
        failedItems: [Swift.String:InspectorClientTypes.FailedItemDetails]? = nil,
        resourceGroups: [InspectorClientTypes.ResourceGroup]? = nil
    )
    {
        self.failedItems = failedItems
        self.resourceGroups = resourceGroups
    }
}

struct DescribeResourceGroupsOutputResponseBody: Swift.Equatable {
    public let resourceGroups: [InspectorClientTypes.ResourceGroup]?
    public let failedItems: [Swift.String:InspectorClientTypes.FailedItemDetails]?
}

extension DescribeResourceGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedItems
        case resourceGroups
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupsContainer = try containerValues.decodeIfPresent([InspectorClientTypes.ResourceGroup?].self, forKey: .resourceGroups)
        var resourceGroupsDecoded0:[InspectorClientTypes.ResourceGroup]? = nil
        if let resourceGroupsContainer = resourceGroupsContainer {
            resourceGroupsDecoded0 = [InspectorClientTypes.ResourceGroup]()
            for structure0 in resourceGroupsContainer {
                if let structure0 = structure0 {
                    resourceGroupsDecoded0?.append(structure0)
                }
            }
        }
        resourceGroups = resourceGroupsDecoded0
        let failedItemsContainer = try containerValues.decodeIfPresent([Swift.String: InspectorClientTypes.FailedItemDetails?].self, forKey: .failedItems)
        var failedItemsDecoded0: [Swift.String:InspectorClientTypes.FailedItemDetails]? = nil
        if let failedItemsContainer = failedItemsContainer {
            failedItemsDecoded0 = [Swift.String:InspectorClientTypes.FailedItemDetails]()
            for (key0, faileditemdetails0) in failedItemsContainer {
                if let faileditemdetails0 = faileditemdetails0 {
                    failedItemsDecoded0?[key0] = faileditemdetails0
                }
            }
        }
        failedItems = failedItemsDecoded0
    }
}

public struct DescribeRulesPackagesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRulesPackagesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRulesPackagesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRulesPackagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRulesPackagesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRulesPackagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRulesPackagesOutputError>
}

extension DescribeRulesPackagesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeRulesPackagesInput(locale: \(Swift.String(describing: locale)), rulesPackageArns: \(Swift.String(describing: rulesPackageArns)))"}
}

extension DescribeRulesPackagesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case locale
        case rulesPackageArns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let locale = locale {
            try encodeContainer.encode(locale.rawValue, forKey: .locale)
        }
        if let rulesPackageArns = rulesPackageArns {
            var rulesPackageArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rulesPackageArns)
            for batchdescribearnlist0 in rulesPackageArns {
                try rulesPackageArnsContainer.encode(batchdescribearnlist0)
            }
        }
    }
}

public struct DescribeRulesPackagesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRulesPackagesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRulesPackagesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRulesPackagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRulesPackagesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRulesPackagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRulesPackagesOutputError>
}

public struct DescribeRulesPackagesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRulesPackagesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRulesPackagesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRulesPackagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRulesPackagesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRulesPackagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRulesPackagesOutputError>
}

public struct DescribeRulesPackagesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRulesPackagesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeRulesPackagesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRulesPackagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeRulesPackagesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRulesPackagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRulesPackagesOutputError>
}

public struct DescribeRulesPackagesInput: Swift.Equatable {
    /// The locale that you want to translate a rules package description into.
    public var locale: InspectorClientTypes.Locale?
    /// The ARN that specifies the rules package that you want to describe.
    /// This member is required.
    public var rulesPackageArns: [Swift.String]?

    public init (
        locale: InspectorClientTypes.Locale? = nil,
        rulesPackageArns: [Swift.String]? = nil
    )
    {
        self.locale = locale
        self.rulesPackageArns = rulesPackageArns
    }
}

struct DescribeRulesPackagesInputBody: Swift.Equatable {
    public let rulesPackageArns: [Swift.String]?
    public let locale: InspectorClientTypes.Locale?
}

extension DescribeRulesPackagesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case locale
        case rulesPackageArns
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rulesPackageArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .rulesPackageArns)
        var rulesPackageArnsDecoded0:[Swift.String]? = nil
        if let rulesPackageArnsContainer = rulesPackageArnsContainer {
            rulesPackageArnsDecoded0 = [Swift.String]()
            for string0 in rulesPackageArnsContainer {
                if let string0 = string0 {
                    rulesPackageArnsDecoded0?.append(string0)
                }
            }
        }
        rulesPackageArns = rulesPackageArnsDecoded0
        let localeDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.Locale.self, forKey: .locale)
        locale = localeDecoded
    }
}

extension DescribeRulesPackagesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRulesPackagesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRulesPackagesOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRulesPackagesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeRulesPackagesOutputResponse(failedItems: \(Swift.String(describing: failedItems)), rulesPackages: \(Swift.String(describing: rulesPackages)))"}
}

extension DescribeRulesPackagesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeRulesPackagesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failedItems = output.failedItems
            self.rulesPackages = output.rulesPackages
        } else {
            self.failedItems = nil
            self.rulesPackages = nil
        }
    }
}

public struct DescribeRulesPackagesOutputResponse: Swift.Equatable {
    /// Rules package details that cannot be described. An error code is provided for each
    ///          failed item.
    /// This member is required.
    public var failedItems: [Swift.String:InspectorClientTypes.FailedItemDetails]?
    /// Information about the rules package.
    /// This member is required.
    public var rulesPackages: [InspectorClientTypes.RulesPackage]?

    public init (
        failedItems: [Swift.String:InspectorClientTypes.FailedItemDetails]? = nil,
        rulesPackages: [InspectorClientTypes.RulesPackage]? = nil
    )
    {
        self.failedItems = failedItems
        self.rulesPackages = rulesPackages
    }
}

struct DescribeRulesPackagesOutputResponseBody: Swift.Equatable {
    public let rulesPackages: [InspectorClientTypes.RulesPackage]?
    public let failedItems: [Swift.String:InspectorClientTypes.FailedItemDetails]?
}

extension DescribeRulesPackagesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedItems
        case rulesPackages
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rulesPackagesContainer = try containerValues.decodeIfPresent([InspectorClientTypes.RulesPackage?].self, forKey: .rulesPackages)
        var rulesPackagesDecoded0:[InspectorClientTypes.RulesPackage]? = nil
        if let rulesPackagesContainer = rulesPackagesContainer {
            rulesPackagesDecoded0 = [InspectorClientTypes.RulesPackage]()
            for structure0 in rulesPackagesContainer {
                if let structure0 = structure0 {
                    rulesPackagesDecoded0?.append(structure0)
                }
            }
        }
        rulesPackages = rulesPackagesDecoded0
        let failedItemsContainer = try containerValues.decodeIfPresent([Swift.String: InspectorClientTypes.FailedItemDetails?].self, forKey: .failedItems)
        var failedItemsDecoded0: [Swift.String:InspectorClientTypes.FailedItemDetails]? = nil
        if let failedItemsContainer = failedItemsContainer {
            failedItemsDecoded0 = [Swift.String:InspectorClientTypes.FailedItemDetails]()
            for (key0, faileditemdetails0) in failedItemsContainer {
                if let faileditemdetails0 = faileditemdetails0 {
                    failedItemsDecoded0?[key0] = faileditemdetails0
                }
            }
        }
        failedItems = failedItemsDecoded0
    }
}

extension InspectorClientTypes.DurationRange: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxSeconds
        case minSeconds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxSeconds != 0 {
            try encodeContainer.encode(maxSeconds, forKey: .maxSeconds)
        }
        if minSeconds != 0 {
            try encodeContainer.encode(minSeconds, forKey: .minSeconds)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let minSecondsDecoded = try containerValues.decode(Swift.Int.self, forKey: .minSeconds)
        minSeconds = minSecondsDecoded
        let maxSecondsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxSeconds)
        maxSeconds = maxSecondsDecoded
    }
}

extension InspectorClientTypes.DurationRange: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DurationRange(maxSeconds: \(Swift.String(describing: maxSeconds)), minSeconds: \(Swift.String(describing: minSeconds)))"}
}

extension InspectorClientTypes {
    /// This data type is used in the AssessmentTemplateFilter data
    ///          type.
    public struct DurationRange: Swift.Equatable {
        /// The maximum value of the duration range. Must be less than or equal to 604800 seconds
        ///          (1 week).
        public var maxSeconds: Swift.Int
        /// The minimum value of the duration range. Must be greater than zero.
        public var minSeconds: Swift.Int

        public init (
            maxSeconds: Swift.Int = 0,
            minSeconds: Swift.Int = 0
        )
        {
            self.maxSeconds = maxSeconds
            self.minSeconds = minSeconds
        }
    }

}

extension InspectorClientTypes.EventSubscription: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case event
        case subscribedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let event = event {
            try encodeContainer.encode(event.rawValue, forKey: .event)
        }
        if let subscribedAt = subscribedAt {
            try encodeContainer.encode(subscribedAt.timeIntervalSince1970, forKey: .subscribedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.InspectorEvent.self, forKey: .event)
        event = eventDecoded
        let subscribedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .subscribedAt)
        subscribedAt = subscribedAtDecoded
    }
}

extension InspectorClientTypes.EventSubscription: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EventSubscription(event: \(Swift.String(describing: event)), subscribedAt: \(Swift.String(describing: subscribedAt)))"}
}

extension InspectorClientTypes {
    /// This data type is used in the Subscription data type.
    public struct EventSubscription: Swift.Equatable {
        /// The event for which Amazon Simple Notification Service (SNS) notifications are
        ///          sent.
        /// This member is required.
        public var event: InspectorClientTypes.InspectorEvent?
        /// The time at which SubscribeToEvent is called.
        /// This member is required.
        public var subscribedAt: ClientRuntime.Date?

        public init (
            event: InspectorClientTypes.InspectorEvent? = nil,
            subscribedAt: ClientRuntime.Date? = nil
        )
        {
            self.event = event
            self.subscribedAt = subscribedAt
        }
    }

}

extension InspectorClientTypes.Exclusion: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case attributes
        case description
        case recommendation
        case scopes
        case title
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for attributelist0 in attributes {
                try attributesContainer.encode(attributelist0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let recommendation = recommendation {
            try encodeContainer.encode(recommendation, forKey: .recommendation)
        }
        if let scopes = scopes {
            var scopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .scopes)
            for scopelist0 in scopes {
                try scopesContainer.encode(scopelist0)
            }
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let recommendationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendation)
        recommendation = recommendationDecoded
        let scopesContainer = try containerValues.decodeIfPresent([InspectorClientTypes.Scope?].self, forKey: .scopes)
        var scopesDecoded0:[InspectorClientTypes.Scope]? = nil
        if let scopesContainer = scopesContainer {
            scopesDecoded0 = [InspectorClientTypes.Scope]()
            for structure0 in scopesContainer {
                if let structure0 = structure0 {
                    scopesDecoded0?.append(structure0)
                }
            }
        }
        scopes = scopesDecoded0
        let attributesContainer = try containerValues.decodeIfPresent([InspectorClientTypes.Attribute?].self, forKey: .attributes)
        var attributesDecoded0:[InspectorClientTypes.Attribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [InspectorClientTypes.Attribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension InspectorClientTypes.Exclusion: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Exclusion(arn: \(Swift.String(describing: arn)), attributes: \(Swift.String(describing: attributes)), description: \(Swift.String(describing: description)), recommendation: \(Swift.String(describing: recommendation)), scopes: \(Swift.String(describing: scopes)), title: \(Swift.String(describing: title)))"}
}

extension InspectorClientTypes {
    /// Contains information about what was excluded from an assessment run.
    public struct Exclusion: Swift.Equatable {
        /// The ARN that specifies the exclusion.
        /// This member is required.
        public var arn: Swift.String?
        /// The system-defined attributes for the exclusion.
        public var attributes: [InspectorClientTypes.Attribute]?
        /// The description of the exclusion.
        /// This member is required.
        public var description: Swift.String?
        /// The recommendation for the exclusion.
        /// This member is required.
        public var recommendation: Swift.String?
        /// The AWS resources for which the exclusion pertains.
        /// This member is required.
        public var scopes: [InspectorClientTypes.Scope]?
        /// The name of the exclusion.
        /// This member is required.
        public var title: Swift.String?

        public init (
            arn: Swift.String? = nil,
            attributes: [InspectorClientTypes.Attribute]? = nil,
            description: Swift.String? = nil,
            recommendation: Swift.String? = nil,
            scopes: [InspectorClientTypes.Scope]? = nil,
            title: Swift.String? = nil
        )
        {
            self.arn = arn
            self.attributes = attributes
            self.description = description
            self.recommendation = recommendation
            self.scopes = scopes
            self.title = title
        }
    }

}

extension InspectorClientTypes.ExclusionPreview: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case description
        case recommendation
        case scopes
        case title
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for attributelist0 in attributes {
                try attributesContainer.encode(attributelist0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let recommendation = recommendation {
            try encodeContainer.encode(recommendation, forKey: .recommendation)
        }
        if let scopes = scopes {
            var scopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .scopes)
            for scopelist0 in scopes {
                try scopesContainer.encode(scopelist0)
            }
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let recommendationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendation)
        recommendation = recommendationDecoded
        let scopesContainer = try containerValues.decodeIfPresent([InspectorClientTypes.Scope?].self, forKey: .scopes)
        var scopesDecoded0:[InspectorClientTypes.Scope]? = nil
        if let scopesContainer = scopesContainer {
            scopesDecoded0 = [InspectorClientTypes.Scope]()
            for structure0 in scopesContainer {
                if let structure0 = structure0 {
                    scopesDecoded0?.append(structure0)
                }
            }
        }
        scopes = scopesDecoded0
        let attributesContainer = try containerValues.decodeIfPresent([InspectorClientTypes.Attribute?].self, forKey: .attributes)
        var attributesDecoded0:[InspectorClientTypes.Attribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [InspectorClientTypes.Attribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension InspectorClientTypes.ExclusionPreview: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExclusionPreview(attributes: \(Swift.String(describing: attributes)), description: \(Swift.String(describing: description)), recommendation: \(Swift.String(describing: recommendation)), scopes: \(Swift.String(describing: scopes)), title: \(Swift.String(describing: title)))"}
}

extension InspectorClientTypes {
    /// Contains information about what is excluded from an assessment run given the current
    ///          state of the assessment template.
    public struct ExclusionPreview: Swift.Equatable {
        /// The system-defined attributes for the exclusion preview.
        public var attributes: [InspectorClientTypes.Attribute]?
        /// The description of the exclusion preview.
        /// This member is required.
        public var description: Swift.String?
        /// The recommendation for the exclusion preview.
        /// This member is required.
        public var recommendation: Swift.String?
        /// The AWS resources for which the exclusion preview pertains.
        /// This member is required.
        public var scopes: [InspectorClientTypes.Scope]?
        /// The name of the exclusion preview.
        /// This member is required.
        public var title: Swift.String?

        public init (
            attributes: [InspectorClientTypes.Attribute]? = nil,
            description: Swift.String? = nil,
            recommendation: Swift.String? = nil,
            scopes: [InspectorClientTypes.Scope]? = nil,
            title: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.description = description
            self.recommendation = recommendation
            self.scopes = scopes
            self.title = title
        }
    }

}

extension InspectorClientTypes.FailedItemDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureCode
        case retryable
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureCode = failureCode {
            try encodeContainer.encode(failureCode.rawValue, forKey: .failureCode)
        }
        if let retryable = retryable {
            try encodeContainer.encode(retryable, forKey: .retryable)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failureCodeDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.FailedItemErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let retryableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .retryable)
        retryable = retryableDecoded
    }
}

extension InspectorClientTypes.FailedItemDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FailedItemDetails(failureCode: \(Swift.String(describing: failureCode)), retryable: \(Swift.String(describing: retryable)))"}
}

extension InspectorClientTypes {
    /// Includes details about the failed items.
    public struct FailedItemDetails: Swift.Equatable {
        /// The status code of a failed item.
        /// This member is required.
        public var failureCode: InspectorClientTypes.FailedItemErrorCode?
        /// Indicates whether you can immediately retry a request for this item for a specified
        ///          resource.
        /// This member is required.
        public var retryable: Swift.Bool?

        public init (
            failureCode: InspectorClientTypes.FailedItemErrorCode? = nil,
            retryable: Swift.Bool? = nil
        )
        {
            self.failureCode = failureCode
            self.retryable = retryable
        }
    }

}

extension InspectorClientTypes {
    public enum FailedItemErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessDenied
        case duplicateArn
        case internalError
        case invalidArn
        case itemDoesNotExist
        case limitExceeded
        case sdkUnknown(Swift.String)

        public static var allCases: [FailedItemErrorCode] {
            return [
                .accessDenied,
                .duplicateArn,
                .internalError,
                .invalidArn,
                .itemDoesNotExist,
                .limitExceeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .duplicateArn: return "DUPLICATE_ARN"
            case .internalError: return "INTERNAL_ERROR"
            case .invalidArn: return "INVALID_ARN"
            case .itemDoesNotExist: return "ITEM_DOES_NOT_EXIST"
            case .limitExceeded: return "LIMIT_EXCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FailedItemErrorCode(rawValue: rawValue) ?? FailedItemErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension InspectorClientTypes.Finding: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case assetAttributes
        case assetType
        case attributes
        case confidence
        case createdAt
        case description
        case id
        case indicatorOfCompromise
        case numericSeverity
        case recommendation
        case schemaVersion
        case service
        case serviceAttributes
        case severity
        case title
        case updatedAt
        case userAttributes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let assetAttributes = assetAttributes {
            try encodeContainer.encode(assetAttributes, forKey: .assetAttributes)
        }
        if let assetType = assetType {
            try encodeContainer.encode(assetType.rawValue, forKey: .assetType)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for attributelist0 in attributes {
                try attributesContainer.encode(attributelist0)
            }
        }
        if confidence != 0 {
            try encodeContainer.encode(confidence, forKey: .confidence)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let indicatorOfCompromise = indicatorOfCompromise {
            try encodeContainer.encode(indicatorOfCompromise, forKey: .indicatorOfCompromise)
        }
        if numericSeverity != 0.0 {
            try encodeContainer.encode(numericSeverity, forKey: .numericSeverity)
        }
        if let recommendation = recommendation {
            try encodeContainer.encode(recommendation, forKey: .recommendation)
        }
        if schemaVersion != 0 {
            try encodeContainer.encode(schemaVersion, forKey: .schemaVersion)
        }
        if let service = service {
            try encodeContainer.encode(service, forKey: .service)
        }
        if let serviceAttributes = serviceAttributes {
            try encodeContainer.encode(serviceAttributes, forKey: .serviceAttributes)
        }
        if let severity = severity {
            try encodeContainer.encode(severity.rawValue, forKey: .severity)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
        if let userAttributes = userAttributes {
            var userAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userAttributes)
            for userattributelist0 in userAttributes {
                try userAttributesContainer.encode(userattributelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let schemaVersionDecoded = try containerValues.decode(Swift.Int.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let serviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .service)
        service = serviceDecoded
        let serviceAttributesDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.InspectorServiceAttributes.self, forKey: .serviceAttributes)
        serviceAttributes = serviceAttributesDecoded
        let assetTypeDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.AssetType.self, forKey: .assetType)
        assetType = assetTypeDecoded
        let assetAttributesDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.AssetAttributes.self, forKey: .assetAttributes)
        assetAttributes = assetAttributesDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let recommendationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendation)
        recommendation = recommendationDecoded
        let severityDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.Severity.self, forKey: .severity)
        severity = severityDecoded
        let numericSeverityDecoded = try containerValues.decode(Swift.Double.self, forKey: .numericSeverity)
        numericSeverity = numericSeverityDecoded
        let confidenceDecoded = try containerValues.decode(Swift.Int.self, forKey: .confidence)
        confidence = confidenceDecoded
        let indicatorOfCompromiseDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .indicatorOfCompromise)
        indicatorOfCompromise = indicatorOfCompromiseDecoded
        let attributesContainer = try containerValues.decodeIfPresent([InspectorClientTypes.Attribute?].self, forKey: .attributes)
        var attributesDecoded0:[InspectorClientTypes.Attribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [InspectorClientTypes.Attribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
        let userAttributesContainer = try containerValues.decodeIfPresent([InspectorClientTypes.Attribute?].self, forKey: .userAttributes)
        var userAttributesDecoded0:[InspectorClientTypes.Attribute]? = nil
        if let userAttributesContainer = userAttributesContainer {
            userAttributesDecoded0 = [InspectorClientTypes.Attribute]()
            for structure0 in userAttributesContainer {
                if let structure0 = structure0 {
                    userAttributesDecoded0?.append(structure0)
                }
            }
        }
        userAttributes = userAttributesDecoded0
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension InspectorClientTypes.Finding: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Finding(arn: \(Swift.String(describing: arn)), assetAttributes: \(Swift.String(describing: assetAttributes)), assetType: \(Swift.String(describing: assetType)), attributes: \(Swift.String(describing: attributes)), confidence: \(Swift.String(describing: confidence)), createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), indicatorOfCompromise: \(Swift.String(describing: indicatorOfCompromise)), numericSeverity: \(Swift.String(describing: numericSeverity)), recommendation: \(Swift.String(describing: recommendation)), schemaVersion: \(Swift.String(describing: schemaVersion)), service: \(Swift.String(describing: service)), serviceAttributes: \(Swift.String(describing: serviceAttributes)), severity: \(Swift.String(describing: severity)), title: \(Swift.String(describing: title)), updatedAt: \(Swift.String(describing: updatedAt)), userAttributes: \(Swift.String(describing: userAttributes)))"}
}

extension InspectorClientTypes {
    /// Contains information about an Amazon Inspector finding. This data type is used as the
    ///          response element in the DescribeFindings action.
    public struct Finding: Swift.Equatable {
        /// The ARN that specifies the finding.
        /// This member is required.
        public var arn: Swift.String?
        /// A collection of attributes of the host from which the finding is generated.
        public var assetAttributes: InspectorClientTypes.AssetAttributes?
        /// The type of the host from which the finding is generated.
        public var assetType: InspectorClientTypes.AssetType?
        /// The system-defined attributes for the finding.
        /// This member is required.
        public var attributes: [InspectorClientTypes.Attribute]?
        /// This data element is currently not used.
        public var confidence: Swift.Int
        /// The time when the finding was generated.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The description of the finding.
        public var description: Swift.String?
        /// The ID of the finding.
        public var id: Swift.String?
        /// This data element is currently not used.
        public var indicatorOfCompromise: Swift.Bool?
        /// The numeric value of the finding severity.
        public var numericSeverity: Swift.Double
        /// The recommendation for the finding.
        public var recommendation: Swift.String?
        /// The schema version of this data type.
        public var schemaVersion: Swift.Int
        /// The data element is set to "Inspector".
        public var service: Swift.String?
        /// This data type is used in the Finding data type.
        public var serviceAttributes: InspectorClientTypes.InspectorServiceAttributes?
        /// The finding severity. Values can be set to High, Medium, Low, and
        ///          Informational.
        public var severity: InspectorClientTypes.Severity?
        /// The name of the finding.
        public var title: Swift.String?
        /// The time when AddAttributesToFindings is called.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?
        /// The user-defined attributes that are assigned to the finding.
        /// This member is required.
        public var userAttributes: [InspectorClientTypes.Attribute]?

        public init (
            arn: Swift.String? = nil,
            assetAttributes: InspectorClientTypes.AssetAttributes? = nil,
            assetType: InspectorClientTypes.AssetType? = nil,
            attributes: [InspectorClientTypes.Attribute]? = nil,
            confidence: Swift.Int = 0,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            indicatorOfCompromise: Swift.Bool? = nil,
            numericSeverity: Swift.Double = 0.0,
            recommendation: Swift.String? = nil,
            schemaVersion: Swift.Int = 0,
            service: Swift.String? = nil,
            serviceAttributes: InspectorClientTypes.InspectorServiceAttributes? = nil,
            severity: InspectorClientTypes.Severity? = nil,
            title: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            userAttributes: [InspectorClientTypes.Attribute]? = nil
        )
        {
            self.arn = arn
            self.assetAttributes = assetAttributes
            self.assetType = assetType
            self.attributes = attributes
            self.confidence = confidence
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.indicatorOfCompromise = indicatorOfCompromise
            self.numericSeverity = numericSeverity
            self.recommendation = recommendation
            self.schemaVersion = schemaVersion
            self.service = service
            self.serviceAttributes = serviceAttributes
            self.severity = severity
            self.title = title
            self.updatedAt = updatedAt
            self.userAttributes = userAttributes
        }
    }

}

extension InspectorClientTypes.FindingFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentIds
        case attributes
        case autoScalingGroups
        case creationTimeRange
        case ruleNames
        case rulesPackageArns
        case severities
        case userAttributes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentIds = agentIds {
            var agentIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .agentIds)
            for agentidlist0 in agentIds {
                try agentIdsContainer.encode(agentidlist0)
            }
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for attributelist0 in attributes {
                try attributesContainer.encode(attributelist0)
            }
        }
        if let autoScalingGroups = autoScalingGroups {
            var autoScalingGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .autoScalingGroups)
            for autoscalinggrouplist0 in autoScalingGroups {
                try autoScalingGroupsContainer.encode(autoscalinggrouplist0)
            }
        }
        if let creationTimeRange = creationTimeRange {
            try encodeContainer.encode(creationTimeRange, forKey: .creationTimeRange)
        }
        if let ruleNames = ruleNames {
            var ruleNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ruleNames)
            for rulenamelist0 in ruleNames {
                try ruleNamesContainer.encode(rulenamelist0)
            }
        }
        if let rulesPackageArns = rulesPackageArns {
            var rulesPackageArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rulesPackageArns)
            for filterrulespackagearnlist0 in rulesPackageArns {
                try rulesPackageArnsContainer.encode(filterrulespackagearnlist0)
            }
        }
        if let severities = severities {
            var severitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .severities)
            for severitylist0 in severities {
                try severitiesContainer.encode(severitylist0.rawValue)
            }
        }
        if let userAttributes = userAttributes {
            var userAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userAttributes)
            for attributelist0 in userAttributes {
                try userAttributesContainer.encode(attributelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .agentIds)
        var agentIdsDecoded0:[Swift.String]? = nil
        if let agentIdsContainer = agentIdsContainer {
            agentIdsDecoded0 = [Swift.String]()
            for string0 in agentIdsContainer {
                if let string0 = string0 {
                    agentIdsDecoded0?.append(string0)
                }
            }
        }
        agentIds = agentIdsDecoded0
        let autoScalingGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .autoScalingGroups)
        var autoScalingGroupsDecoded0:[Swift.String]? = nil
        if let autoScalingGroupsContainer = autoScalingGroupsContainer {
            autoScalingGroupsDecoded0 = [Swift.String]()
            for string0 in autoScalingGroupsContainer {
                if let string0 = string0 {
                    autoScalingGroupsDecoded0?.append(string0)
                }
            }
        }
        autoScalingGroups = autoScalingGroupsDecoded0
        let ruleNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ruleNames)
        var ruleNamesDecoded0:[Swift.String]? = nil
        if let ruleNamesContainer = ruleNamesContainer {
            ruleNamesDecoded0 = [Swift.String]()
            for string0 in ruleNamesContainer {
                if let string0 = string0 {
                    ruleNamesDecoded0?.append(string0)
                }
            }
        }
        ruleNames = ruleNamesDecoded0
        let severitiesContainer = try containerValues.decodeIfPresent([InspectorClientTypes.Severity?].self, forKey: .severities)
        var severitiesDecoded0:[InspectorClientTypes.Severity]? = nil
        if let severitiesContainer = severitiesContainer {
            severitiesDecoded0 = [InspectorClientTypes.Severity]()
            for string0 in severitiesContainer {
                if let string0 = string0 {
                    severitiesDecoded0?.append(string0)
                }
            }
        }
        severities = severitiesDecoded0
        let rulesPackageArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .rulesPackageArns)
        var rulesPackageArnsDecoded0:[Swift.String]? = nil
        if let rulesPackageArnsContainer = rulesPackageArnsContainer {
            rulesPackageArnsDecoded0 = [Swift.String]()
            for string0 in rulesPackageArnsContainer {
                if let string0 = string0 {
                    rulesPackageArnsDecoded0?.append(string0)
                }
            }
        }
        rulesPackageArns = rulesPackageArnsDecoded0
        let attributesContainer = try containerValues.decodeIfPresent([InspectorClientTypes.Attribute?].self, forKey: .attributes)
        var attributesDecoded0:[InspectorClientTypes.Attribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [InspectorClientTypes.Attribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
        let userAttributesContainer = try containerValues.decodeIfPresent([InspectorClientTypes.Attribute?].self, forKey: .userAttributes)
        var userAttributesDecoded0:[InspectorClientTypes.Attribute]? = nil
        if let userAttributesContainer = userAttributesContainer {
            userAttributesDecoded0 = [InspectorClientTypes.Attribute]()
            for structure0 in userAttributesContainer {
                if let structure0 = structure0 {
                    userAttributesDecoded0?.append(structure0)
                }
            }
        }
        userAttributes = userAttributesDecoded0
        let creationTimeRangeDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.TimestampRange.self, forKey: .creationTimeRange)
        creationTimeRange = creationTimeRangeDecoded
    }
}

extension InspectorClientTypes.FindingFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FindingFilter(agentIds: \(Swift.String(describing: agentIds)), attributes: \(Swift.String(describing: attributes)), autoScalingGroups: \(Swift.String(describing: autoScalingGroups)), creationTimeRange: \(Swift.String(describing: creationTimeRange)), ruleNames: \(Swift.String(describing: ruleNames)), rulesPackageArns: \(Swift.String(describing: rulesPackageArns)), severities: \(Swift.String(describing: severities)), userAttributes: \(Swift.String(describing: userAttributes)))"}
}

extension InspectorClientTypes {
    /// This data type is used as a request parameter in the ListFindings
    ///          action.
    public struct FindingFilter: Swift.Equatable {
        /// For a record to match a filter, one of the values that is specified for this data
        ///          type property must be the exact match of the value of the agentId property of the Finding data type.
        public var agentIds: [Swift.String]?
        /// For a record to match a filter, the list of values that are specified for this data
        ///          type property must be contained in the list of values of the attributes property of the Finding data type.
        public var attributes: [InspectorClientTypes.Attribute]?
        /// For a record to match a filter, one of the values that is specified for this data
        ///          type property must be the exact match of the value of the autoScalingGroup property of the Finding data
        ///          type.
        public var autoScalingGroups: [Swift.String]?
        /// The time range during which the finding is generated.
        public var creationTimeRange: InspectorClientTypes.TimestampRange?
        /// For a record to match a filter, one of the values that is specified for this data
        ///          type property must be the exact match of the value of the ruleName property of the Finding data type.
        public var ruleNames: [Swift.String]?
        /// For a record to match a filter, one of the values that is specified for this data
        ///          type property must be the exact match of the value of the rulesPackageArn property of the Finding data
        ///          type.
        public var rulesPackageArns: [Swift.String]?
        /// For a record to match a filter, one of the values that is specified for this data
        ///          type property must be the exact match of the value of the severity property of the Finding data type.
        public var severities: [InspectorClientTypes.Severity]?
        /// For a record to match a filter, the value that is specified for this data type
        ///          property must be contained in the list of values of the userAttributes property of the Finding data
        ///          type.
        public var userAttributes: [InspectorClientTypes.Attribute]?

        public init (
            agentIds: [Swift.String]? = nil,
            attributes: [InspectorClientTypes.Attribute]? = nil,
            autoScalingGroups: [Swift.String]? = nil,
            creationTimeRange: InspectorClientTypes.TimestampRange? = nil,
            ruleNames: [Swift.String]? = nil,
            rulesPackageArns: [Swift.String]? = nil,
            severities: [InspectorClientTypes.Severity]? = nil,
            userAttributes: [InspectorClientTypes.Attribute]? = nil
        )
        {
            self.agentIds = agentIds
            self.attributes = attributes
            self.autoScalingGroups = autoScalingGroups
            self.creationTimeRange = creationTimeRange
            self.ruleNames = ruleNames
            self.rulesPackageArns = rulesPackageArns
            self.severities = severities
            self.userAttributes = userAttributes
        }
    }

}

public struct GetAssessmentReportInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAssessmentReportInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAssessmentReportInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAssessmentReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAssessmentReportInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAssessmentReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAssessmentReportOutputError>
}

extension GetAssessmentReportInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAssessmentReportInput(assessmentRunArn: \(Swift.String(describing: assessmentRunArn)), reportFileFormat: \(Swift.String(describing: reportFileFormat)), reportType: \(Swift.String(describing: reportType)))"}
}

extension GetAssessmentReportInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentRunArn
        case reportFileFormat
        case reportType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentRunArn = assessmentRunArn {
            try encodeContainer.encode(assessmentRunArn, forKey: .assessmentRunArn)
        }
        if let reportFileFormat = reportFileFormat {
            try encodeContainer.encode(reportFileFormat.rawValue, forKey: .reportFileFormat)
        }
        if let reportType = reportType {
            try encodeContainer.encode(reportType.rawValue, forKey: .reportType)
        }
    }
}

public struct GetAssessmentReportInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAssessmentReportInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAssessmentReportInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAssessmentReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAssessmentReportInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAssessmentReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAssessmentReportOutputError>
}

public struct GetAssessmentReportInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAssessmentReportInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAssessmentReportInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAssessmentReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAssessmentReportInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAssessmentReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAssessmentReportOutputError>
}

public struct GetAssessmentReportInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAssessmentReportInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetAssessmentReportInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAssessmentReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetAssessmentReportInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetAssessmentReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAssessmentReportOutputError>
}

public struct GetAssessmentReportInput: Swift.Equatable {
    /// The ARN that specifies the assessment run for which you want to generate a
    ///          report.
    /// This member is required.
    public var assessmentRunArn: Swift.String?
    /// Specifies the file format (html or pdf) of the assessment report that you want to
    ///          generate.
    /// This member is required.
    public var reportFileFormat: InspectorClientTypes.ReportFileFormat?
    /// Specifies the type of the assessment report that you want to generate. There are two
    ///          types of assessment reports: a finding report and a full report. For more information, see
    ///             <a href="https://docs.aws.amazon.com/inspector/latest/userguide/inspector_reports.html">Assessment Reports.
    /// This member is required.
    public var reportType: InspectorClientTypes.ReportType?

    public init (
        assessmentRunArn: Swift.String? = nil,
        reportFileFormat: InspectorClientTypes.ReportFileFormat? = nil,
        reportType: InspectorClientTypes.ReportType? = nil
    )
    {
        self.assessmentRunArn = assessmentRunArn
        self.reportFileFormat = reportFileFormat
        self.reportType = reportType
    }
}

struct GetAssessmentReportInputBody: Swift.Equatable {
    public let assessmentRunArn: Swift.String?
    public let reportFileFormat: InspectorClientTypes.ReportFileFormat?
    public let reportType: InspectorClientTypes.ReportType?
}

extension GetAssessmentReportInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentRunArn
        case reportFileFormat
        case reportType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentRunArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentRunArn)
        assessmentRunArn = assessmentRunArnDecoded
        let reportFileFormatDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.ReportFileFormat.self, forKey: .reportFileFormat)
        reportFileFormat = reportFileFormatDecoded
        let reportTypeDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.ReportType.self, forKey: .reportType)
        reportType = reportTypeDecoded
    }
}

extension GetAssessmentReportOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAssessmentReportOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AssessmentRunInProgressException" : self = .assessmentRunInProgressException(try AssessmentRunInProgressException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceTemporarilyUnavailableException" : self = .serviceTemporarilyUnavailableException(try ServiceTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedFeatureException" : self = .unsupportedFeatureException(try UnsupportedFeatureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAssessmentReportOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case assessmentRunInProgressException(AssessmentRunInProgressException)
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceTemporarilyUnavailableException(ServiceTemporarilyUnavailableException)
    case unsupportedFeatureException(UnsupportedFeatureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAssessmentReportOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAssessmentReportOutputResponse(status: \(Swift.String(describing: status)), url: \(Swift.String(describing: url)))"}
}

extension GetAssessmentReportOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAssessmentReportOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
            self.url = output.url
        } else {
            self.status = nil
            self.url = nil
        }
    }
}

public struct GetAssessmentReportOutputResponse: Swift.Equatable {
    /// Specifies the status of the request to generate an assessment report.
    /// This member is required.
    public var status: InspectorClientTypes.ReportStatus?
    /// Specifies the URL where you can find the generated assessment report. This parameter
    ///          is only returned if the report is successfully generated.
    public var url: Swift.String?

    public init (
        status: InspectorClientTypes.ReportStatus? = nil,
        url: Swift.String? = nil
    )
    {
        self.status = status
        self.url = url
    }
}

struct GetAssessmentReportOutputResponseBody: Swift.Equatable {
    public let status: InspectorClientTypes.ReportStatus?
    public let url: Swift.String?
}

extension GetAssessmentReportOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
        case url
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.ReportStatus.self, forKey: .status)
        status = statusDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

public struct GetExclusionsPreviewInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetExclusionsPreviewInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetExclusionsPreviewInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetExclusionsPreviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetExclusionsPreviewInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetExclusionsPreviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetExclusionsPreviewOutputError>
}

extension GetExclusionsPreviewInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetExclusionsPreviewInput(assessmentTemplateArn: \(Swift.String(describing: assessmentTemplateArn)), locale: \(Swift.String(describing: locale)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), previewToken: \(Swift.String(describing: previewToken)))"}
}

extension GetExclusionsPreviewInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTemplateArn
        case locale
        case maxResults
        case nextToken
        case previewToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentTemplateArn = assessmentTemplateArn {
            try encodeContainer.encode(assessmentTemplateArn, forKey: .assessmentTemplateArn)
        }
        if let locale = locale {
            try encodeContainer.encode(locale.rawValue, forKey: .locale)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let previewToken = previewToken {
            try encodeContainer.encode(previewToken, forKey: .previewToken)
        }
    }
}

public struct GetExclusionsPreviewInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetExclusionsPreviewInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetExclusionsPreviewInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetExclusionsPreviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetExclusionsPreviewInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetExclusionsPreviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetExclusionsPreviewOutputError>
}

public struct GetExclusionsPreviewInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetExclusionsPreviewInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetExclusionsPreviewInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetExclusionsPreviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetExclusionsPreviewInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetExclusionsPreviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetExclusionsPreviewOutputError>
}

public struct GetExclusionsPreviewInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetExclusionsPreviewInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetExclusionsPreviewInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetExclusionsPreviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetExclusionsPreviewInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetExclusionsPreviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetExclusionsPreviewOutputError>
}

public struct GetExclusionsPreviewInput: Swift.Equatable {
    /// The ARN that specifies the assessment template for which the exclusions preview was
    ///          requested.
    /// This member is required.
    public var assessmentTemplateArn: Swift.String?
    /// The locale into which you want to translate the exclusion's title, description, and
    ///          recommendation.
    public var locale: InspectorClientTypes.Locale?
    /// You can use this parameter to indicate the maximum number of items you want in the
    ///          response. The default value is 100. The maximum value is 500.
    public var maxResults: Swift.Int?
    /// You can use this parameter when paginating results. Set the value of this parameter
    ///          to null on your first call to the GetExclusionsPreviewRequest action. Subsequent calls to
    ///          the action fill nextToken in the request with the value of nextToken from the previous
    ///          response to continue listing data.
    public var nextToken: Swift.String?
    /// The unique identifier associated of the exclusions preview.
    /// This member is required.
    public var previewToken: Swift.String?

    public init (
        assessmentTemplateArn: Swift.String? = nil,
        locale: InspectorClientTypes.Locale? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        previewToken: Swift.String? = nil
    )
    {
        self.assessmentTemplateArn = assessmentTemplateArn
        self.locale = locale
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.previewToken = previewToken
    }
}

struct GetExclusionsPreviewInputBody: Swift.Equatable {
    public let assessmentTemplateArn: Swift.String?
    public let previewToken: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
    public let locale: InspectorClientTypes.Locale?
}

extension GetExclusionsPreviewInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTemplateArn
        case locale
        case maxResults
        case nextToken
        case previewToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentTemplateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentTemplateArn)
        assessmentTemplateArn = assessmentTemplateArnDecoded
        let previewTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .previewToken)
        previewToken = previewTokenDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let localeDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.Locale.self, forKey: .locale)
        locale = localeDecoded
    }
}

extension GetExclusionsPreviewOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetExclusionsPreviewOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetExclusionsPreviewOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetExclusionsPreviewOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetExclusionsPreviewOutputResponse(exclusionPreviews: \(Swift.String(describing: exclusionPreviews)), nextToken: \(Swift.String(describing: nextToken)), previewStatus: \(Swift.String(describing: previewStatus)))"}
}

extension GetExclusionsPreviewOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetExclusionsPreviewOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.exclusionPreviews = output.exclusionPreviews
            self.nextToken = output.nextToken
            self.previewStatus = output.previewStatus
        } else {
            self.exclusionPreviews = nil
            self.nextToken = nil
            self.previewStatus = nil
        }
    }
}

public struct GetExclusionsPreviewOutputResponse: Swift.Equatable {
    /// Information about the exclusions included in the preview.
    public var exclusionPreviews: [InspectorClientTypes.ExclusionPreview]?
    /// When a response is generated, if there is more data to be listed, this parameters is
    ///          present in the response and contains the value to use for the nextToken parameter in a
    ///          subsequent pagination request. If there is no more data to be listed, this parameter is set
    ///          to null.
    public var nextToken: Swift.String?
    /// Specifies the status of the request to generate an exclusions preview.
    /// This member is required.
    public var previewStatus: InspectorClientTypes.PreviewStatus?

    public init (
        exclusionPreviews: [InspectorClientTypes.ExclusionPreview]? = nil,
        nextToken: Swift.String? = nil,
        previewStatus: InspectorClientTypes.PreviewStatus? = nil
    )
    {
        self.exclusionPreviews = exclusionPreviews
        self.nextToken = nextToken
        self.previewStatus = previewStatus
    }
}

struct GetExclusionsPreviewOutputResponseBody: Swift.Equatable {
    public let previewStatus: InspectorClientTypes.PreviewStatus?
    public let exclusionPreviews: [InspectorClientTypes.ExclusionPreview]?
    public let nextToken: Swift.String?
}

extension GetExclusionsPreviewOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exclusionPreviews
        case nextToken
        case previewStatus
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let previewStatusDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.PreviewStatus.self, forKey: .previewStatus)
        previewStatus = previewStatusDecoded
        let exclusionPreviewsContainer = try containerValues.decodeIfPresent([InspectorClientTypes.ExclusionPreview?].self, forKey: .exclusionPreviews)
        var exclusionPreviewsDecoded0:[InspectorClientTypes.ExclusionPreview]? = nil
        if let exclusionPreviewsContainer = exclusionPreviewsContainer {
            exclusionPreviewsDecoded0 = [InspectorClientTypes.ExclusionPreview]()
            for structure0 in exclusionPreviewsContainer {
                if let structure0 = structure0 {
                    exclusionPreviewsDecoded0?.append(structure0)
                }
            }
        }
        exclusionPreviews = exclusionPreviewsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetTelemetryMetadataInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTelemetryMetadataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetTelemetryMetadataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTelemetryMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetTelemetryMetadataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetTelemetryMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTelemetryMetadataOutputError>
}

extension GetTelemetryMetadataInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetTelemetryMetadataInput(assessmentRunArn: \(Swift.String(describing: assessmentRunArn)))"}
}

extension GetTelemetryMetadataInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentRunArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentRunArn = assessmentRunArn {
            try encodeContainer.encode(assessmentRunArn, forKey: .assessmentRunArn)
        }
    }
}

public struct GetTelemetryMetadataInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTelemetryMetadataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetTelemetryMetadataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTelemetryMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetTelemetryMetadataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetTelemetryMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTelemetryMetadataOutputError>
}

public struct GetTelemetryMetadataInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTelemetryMetadataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetTelemetryMetadataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTelemetryMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetTelemetryMetadataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetTelemetryMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTelemetryMetadataOutputError>
}

public struct GetTelemetryMetadataInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTelemetryMetadataInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetTelemetryMetadataInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTelemetryMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetTelemetryMetadataInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetTelemetryMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTelemetryMetadataOutputError>
}

public struct GetTelemetryMetadataInput: Swift.Equatable {
    /// The ARN that specifies the assessment run that has the telemetry data that you want
    ///          to obtain.
    /// This member is required.
    public var assessmentRunArn: Swift.String?

    public init (
        assessmentRunArn: Swift.String? = nil
    )
    {
        self.assessmentRunArn = assessmentRunArn
    }
}

struct GetTelemetryMetadataInputBody: Swift.Equatable {
    public let assessmentRunArn: Swift.String?
}

extension GetTelemetryMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentRunArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentRunArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentRunArn)
        assessmentRunArn = assessmentRunArnDecoded
    }
}

extension GetTelemetryMetadataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTelemetryMetadataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTelemetryMetadataOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTelemetryMetadataOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetTelemetryMetadataOutputResponse(telemetryMetadata: \(Swift.String(describing: telemetryMetadata)))"}
}

extension GetTelemetryMetadataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetTelemetryMetadataOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.telemetryMetadata = output.telemetryMetadata
        } else {
            self.telemetryMetadata = nil
        }
    }
}

public struct GetTelemetryMetadataOutputResponse: Swift.Equatable {
    /// Telemetry details.
    /// This member is required.
    public var telemetryMetadata: [InspectorClientTypes.TelemetryMetadata]?

    public init (
        telemetryMetadata: [InspectorClientTypes.TelemetryMetadata]? = nil
    )
    {
        self.telemetryMetadata = telemetryMetadata
    }
}

struct GetTelemetryMetadataOutputResponseBody: Swift.Equatable {
    public let telemetryMetadata: [InspectorClientTypes.TelemetryMetadata]?
}

extension GetTelemetryMetadataOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case telemetryMetadata
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let telemetryMetadataContainer = try containerValues.decodeIfPresent([InspectorClientTypes.TelemetryMetadata?].self, forKey: .telemetryMetadata)
        var telemetryMetadataDecoded0:[InspectorClientTypes.TelemetryMetadata]? = nil
        if let telemetryMetadataContainer = telemetryMetadataContainer {
            telemetryMetadataDecoded0 = [InspectorClientTypes.TelemetryMetadata]()
            for structure0 in telemetryMetadataContainer {
                if let structure0 = structure0 {
                    telemetryMetadataDecoded0?.append(structure0)
                }
            }
        }
        telemetryMetadata = telemetryMetadataDecoded0
    }
}

extension InspectorClientTypes {
    public enum InspectorEvent: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case assessmentRunCompleted
        case assessmentRunStarted
        case assessmentRunStateChanged
        case findingReported
        case other
        case sdkUnknown(Swift.String)

        public static var allCases: [InspectorEvent] {
            return [
                .assessmentRunCompleted,
                .assessmentRunStarted,
                .assessmentRunStateChanged,
                .findingReported,
                .other,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .assessmentRunCompleted: return "ASSESSMENT_RUN_COMPLETED"
            case .assessmentRunStarted: return "ASSESSMENT_RUN_STARTED"
            case .assessmentRunStateChanged: return "ASSESSMENT_RUN_STATE_CHANGED"
            case .findingReported: return "FINDING_REPORTED"
            case .other: return "OTHER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InspectorEvent(rawValue: rawValue) ?? InspectorEvent.sdkUnknown(rawValue)
        }
    }
}

extension InspectorClientTypes.InspectorServiceAttributes: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentRunArn
        case rulesPackageArn
        case schemaVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentRunArn = assessmentRunArn {
            try encodeContainer.encode(assessmentRunArn, forKey: .assessmentRunArn)
        }
        if let rulesPackageArn = rulesPackageArn {
            try encodeContainer.encode(rulesPackageArn, forKey: .rulesPackageArn)
        }
        if schemaVersion != 0 {
            try encodeContainer.encode(schemaVersion, forKey: .schemaVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaVersionDecoded = try containerValues.decode(Swift.Int.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let assessmentRunArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentRunArn)
        assessmentRunArn = assessmentRunArnDecoded
        let rulesPackageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rulesPackageArn)
        rulesPackageArn = rulesPackageArnDecoded
    }
}

extension InspectorClientTypes.InspectorServiceAttributes: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InspectorServiceAttributes(assessmentRunArn: \(Swift.String(describing: assessmentRunArn)), rulesPackageArn: \(Swift.String(describing: rulesPackageArn)), schemaVersion: \(Swift.String(describing: schemaVersion)))"}
}

extension InspectorClientTypes {
    /// This data type is used in the Finding data type.
    public struct InspectorServiceAttributes: Swift.Equatable {
        /// The ARN of the assessment run during which the finding is generated.
        public var assessmentRunArn: Swift.String?
        /// The ARN of the rules package that is used to generate the finding.
        public var rulesPackageArn: Swift.String?
        /// The schema version of this data type.
        /// This member is required.
        public var schemaVersion: Swift.Int

        public init (
            assessmentRunArn: Swift.String? = nil,
            rulesPackageArn: Swift.String? = nil,
            schemaVersion: Swift.Int = 0
        )
        {
            self.assessmentRunArn = assessmentRunArn
            self.rulesPackageArn = rulesPackageArn
            self.schemaVersion = schemaVersion
        }
    }

}

extension InternalException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalException(canRetry: \(Swift.String(describing: canRetry)), message: \(Swift.String(describing: message)))"}
}

extension InternalException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalExceptionBody = try responseDecoder.decode(responseBody: data)
            self.canRetry = output.canRetry
            self.message = output.message
        } else {
            self.canRetry = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Internal server error.
public struct InternalException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// You can immediately retry your request.
    /// This member is required.
    public var canRetry: Swift.Bool?
    /// Details of the exception error.
    /// This member is required.
    public var message: Swift.String?

    public init (
        canRetry: Swift.Bool? = nil,
        message: Swift.String? = nil
    )
    {
        self.canRetry = canRetry
        self.message = message
    }
}

struct InternalExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let canRetry: Swift.Bool?
}

extension InternalExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case canRetry
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let canRetryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .canRetry)
        canRetry = canRetryDecoded
    }
}

extension InspectorClientTypes {
    public enum InvalidCrossAccountRoleErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case roleDoesNotExistOrInvalidTrustRelationship
        case roleDoesNotHaveCorrectPolicy
        case sdkUnknown(Swift.String)

        public static var allCases: [InvalidCrossAccountRoleErrorCode] {
            return [
                .roleDoesNotExistOrInvalidTrustRelationship,
                .roleDoesNotHaveCorrectPolicy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .roleDoesNotExistOrInvalidTrustRelationship: return "ROLE_DOES_NOT_EXIST_OR_INVALID_TRUST_RELATIONSHIP"
            case .roleDoesNotHaveCorrectPolicy: return "ROLE_DOES_NOT_HAVE_CORRECT_POLICY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InvalidCrossAccountRoleErrorCode(rawValue: rawValue) ?? InvalidCrossAccountRoleErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension InvalidCrossAccountRoleException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidCrossAccountRoleException(canRetry: \(Swift.String(describing: canRetry)), errorCode: \(Swift.String(describing: errorCode)), message: \(Swift.String(describing: message)))"}
}

extension InvalidCrossAccountRoleException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidCrossAccountRoleExceptionBody = try responseDecoder.decode(responseBody: data)
            self.canRetry = output.canRetry
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.canRetry = nil
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Amazon Inspector cannot assume the cross-account role that it needs to list your EC2
///          instances during the assessment run.
public struct InvalidCrossAccountRoleException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// You can immediately retry your request.
    /// This member is required.
    public var canRetry: Swift.Bool?
    /// Code that indicates the type of error that is generated.
    /// This member is required.
    public var errorCode: InspectorClientTypes.InvalidCrossAccountRoleErrorCode?
    /// Details of the exception error.
    /// This member is required.
    public var message: Swift.String?

    public init (
        canRetry: Swift.Bool? = nil,
        errorCode: InspectorClientTypes.InvalidCrossAccountRoleErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.canRetry = canRetry
        self.errorCode = errorCode
        self.message = message
    }
}

struct InvalidCrossAccountRoleExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let errorCode: InspectorClientTypes.InvalidCrossAccountRoleErrorCode?
    public let canRetry: Swift.Bool?
}

extension InvalidCrossAccountRoleExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case canRetry
        case errorCode
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.InvalidCrossAccountRoleErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let canRetryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .canRetry)
        canRetry = canRetryDecoded
    }
}

extension InspectorClientTypes {
    public enum InvalidInputErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case assessmentTargetNameAlreadyTaken
        case assessmentTemplateNameAlreadyTaken
        case invalidAgentId
        case invalidAssessmentRunArn
        case invalidAssessmentRunCompletionTimeRange
        case invalidAssessmentRunDurationRange
        case invalidAssessmentRunStartTimeRange
        case invalidAssessmentRunState
        case invalidAssessmentRunStateChangeTimeRange
        case invalidAssessmentTargetArn
        case invalidAssessmentTargetName
        case invalidAssessmentTargetNamePattern
        case invalidAssessmentTemplateArn
        case invalidAssessmentTemplateDuration
        case invalidAssessmentTemplateDurationRange
        case invalidAssessmentTemplateName
        case invalidAssessmentTemplateNamePattern
        case invalidAttribute
        case invalidAutoScalingGroup
        case invalidEvent
        case invalidFindingArn
        case invalidIamRoleArn
        case invalidLocale
        case invalidMaxResults
        case invalidNumberOfAgentIds
        case invalidNumberOfAssessmentRunArns
        case invalidNumberOfAssessmentRunStates
        case invalidNumberOfAssessmentTargetArns
        case invalidNumberOfAssessmentTemplateArns
        case invalidNumberOfAttributes
        case invalidNumberOfAutoScalingGroups
        case invalidNumberOfFindingArns
        case invalidNumberOfResourceGroupArns
        case invalidNumberOfResourceGroupTags
        case invalidNumberOfRulesPackageArns
        case invalidNumberOfRuleNames
        case invalidNumberOfSeverities
        case invalidNumberOfTags
        case invalidNumberOfUserAttributes
        case invalidPaginationToken
        case invalidResourceArn
        case invalidResourceGroupArn
        case invalidResourceGroupTagKey
        case invalidResourceGroupTagValue
        case invalidRulesPackageArn
        case invalidRuleName
        case invalidSeverity
        case invalidSnsTopicArn
        case invalidTag
        case invalidTagKey
        case invalidTagValue
        case invalidUserAttribute
        case invalidUserAttributeKey
        case invalidUserAttributeValue
        case sdkUnknown(Swift.String)

        public static var allCases: [InvalidInputErrorCode] {
            return [
                .assessmentTargetNameAlreadyTaken,
                .assessmentTemplateNameAlreadyTaken,
                .invalidAgentId,
                .invalidAssessmentRunArn,
                .invalidAssessmentRunCompletionTimeRange,
                .invalidAssessmentRunDurationRange,
                .invalidAssessmentRunStartTimeRange,
                .invalidAssessmentRunState,
                .invalidAssessmentRunStateChangeTimeRange,
                .invalidAssessmentTargetArn,
                .invalidAssessmentTargetName,
                .invalidAssessmentTargetNamePattern,
                .invalidAssessmentTemplateArn,
                .invalidAssessmentTemplateDuration,
                .invalidAssessmentTemplateDurationRange,
                .invalidAssessmentTemplateName,
                .invalidAssessmentTemplateNamePattern,
                .invalidAttribute,
                .invalidAutoScalingGroup,
                .invalidEvent,
                .invalidFindingArn,
                .invalidIamRoleArn,
                .invalidLocale,
                .invalidMaxResults,
                .invalidNumberOfAgentIds,
                .invalidNumberOfAssessmentRunArns,
                .invalidNumberOfAssessmentRunStates,
                .invalidNumberOfAssessmentTargetArns,
                .invalidNumberOfAssessmentTemplateArns,
                .invalidNumberOfAttributes,
                .invalidNumberOfAutoScalingGroups,
                .invalidNumberOfFindingArns,
                .invalidNumberOfResourceGroupArns,
                .invalidNumberOfResourceGroupTags,
                .invalidNumberOfRulesPackageArns,
                .invalidNumberOfRuleNames,
                .invalidNumberOfSeverities,
                .invalidNumberOfTags,
                .invalidNumberOfUserAttributes,
                .invalidPaginationToken,
                .invalidResourceArn,
                .invalidResourceGroupArn,
                .invalidResourceGroupTagKey,
                .invalidResourceGroupTagValue,
                .invalidRulesPackageArn,
                .invalidRuleName,
                .invalidSeverity,
                .invalidSnsTopicArn,
                .invalidTag,
                .invalidTagKey,
                .invalidTagValue,
                .invalidUserAttribute,
                .invalidUserAttributeKey,
                .invalidUserAttributeValue,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .assessmentTargetNameAlreadyTaken: return "ASSESSMENT_TARGET_NAME_ALREADY_TAKEN"
            case .assessmentTemplateNameAlreadyTaken: return "ASSESSMENT_TEMPLATE_NAME_ALREADY_TAKEN"
            case .invalidAgentId: return "INVALID_AGENT_ID"
            case .invalidAssessmentRunArn: return "INVALID_ASSESSMENT_RUN_ARN"
            case .invalidAssessmentRunCompletionTimeRange: return "INVALID_ASSESSMENT_RUN_COMPLETION_TIME_RANGE"
            case .invalidAssessmentRunDurationRange: return "INVALID_ASSESSMENT_RUN_DURATION_RANGE"
            case .invalidAssessmentRunStartTimeRange: return "INVALID_ASSESSMENT_RUN_START_TIME_RANGE"
            case .invalidAssessmentRunState: return "INVALID_ASSESSMENT_RUN_STATE"
            case .invalidAssessmentRunStateChangeTimeRange: return "INVALID_ASSESSMENT_RUN_STATE_CHANGE_TIME_RANGE"
            case .invalidAssessmentTargetArn: return "INVALID_ASSESSMENT_TARGET_ARN"
            case .invalidAssessmentTargetName: return "INVALID_ASSESSMENT_TARGET_NAME"
            case .invalidAssessmentTargetNamePattern: return "INVALID_ASSESSMENT_TARGET_NAME_PATTERN"
            case .invalidAssessmentTemplateArn: return "INVALID_ASSESSMENT_TEMPLATE_ARN"
            case .invalidAssessmentTemplateDuration: return "INVALID_ASSESSMENT_TEMPLATE_DURATION"
            case .invalidAssessmentTemplateDurationRange: return "INVALID_ASSESSMENT_TEMPLATE_DURATION_RANGE"
            case .invalidAssessmentTemplateName: return "INVALID_ASSESSMENT_TEMPLATE_NAME"
            case .invalidAssessmentTemplateNamePattern: return "INVALID_ASSESSMENT_TEMPLATE_NAME_PATTERN"
            case .invalidAttribute: return "INVALID_ATTRIBUTE"
            case .invalidAutoScalingGroup: return "INVALID_AUTO_SCALING_GROUP"
            case .invalidEvent: return "INVALID_EVENT"
            case .invalidFindingArn: return "INVALID_FINDING_ARN"
            case .invalidIamRoleArn: return "INVALID_IAM_ROLE_ARN"
            case .invalidLocale: return "INVALID_LOCALE"
            case .invalidMaxResults: return "INVALID_MAX_RESULTS"
            case .invalidNumberOfAgentIds: return "INVALID_NUMBER_OF_AGENT_IDS"
            case .invalidNumberOfAssessmentRunArns: return "INVALID_NUMBER_OF_ASSESSMENT_RUN_ARNS"
            case .invalidNumberOfAssessmentRunStates: return "INVALID_NUMBER_OF_ASSESSMENT_RUN_STATES"
            case .invalidNumberOfAssessmentTargetArns: return "INVALID_NUMBER_OF_ASSESSMENT_TARGET_ARNS"
            case .invalidNumberOfAssessmentTemplateArns: return "INVALID_NUMBER_OF_ASSESSMENT_TEMPLATE_ARNS"
            case .invalidNumberOfAttributes: return "INVALID_NUMBER_OF_ATTRIBUTES"
            case .invalidNumberOfAutoScalingGroups: return "INVALID_NUMBER_OF_AUTO_SCALING_GROUPS"
            case .invalidNumberOfFindingArns: return "INVALID_NUMBER_OF_FINDING_ARNS"
            case .invalidNumberOfResourceGroupArns: return "INVALID_NUMBER_OF_RESOURCE_GROUP_ARNS"
            case .invalidNumberOfResourceGroupTags: return "INVALID_NUMBER_OF_RESOURCE_GROUP_TAGS"
            case .invalidNumberOfRulesPackageArns: return "INVALID_NUMBER_OF_RULES_PACKAGE_ARNS"
            case .invalidNumberOfRuleNames: return "INVALID_NUMBER_OF_RULE_NAMES"
            case .invalidNumberOfSeverities: return "INVALID_NUMBER_OF_SEVERITIES"
            case .invalidNumberOfTags: return "INVALID_NUMBER_OF_TAGS"
            case .invalidNumberOfUserAttributes: return "INVALID_NUMBER_OF_USER_ATTRIBUTES"
            case .invalidPaginationToken: return "INVALID_PAGINATION_TOKEN"
            case .invalidResourceArn: return "INVALID_RESOURCE_ARN"
            case .invalidResourceGroupArn: return "INVALID_RESOURCE_GROUP_ARN"
            case .invalidResourceGroupTagKey: return "INVALID_RESOURCE_GROUP_TAG_KEY"
            case .invalidResourceGroupTagValue: return "INVALID_RESOURCE_GROUP_TAG_VALUE"
            case .invalidRulesPackageArn: return "INVALID_RULES_PACKAGE_ARN"
            case .invalidRuleName: return "INVALID_RULE_NAME"
            case .invalidSeverity: return "INVALID_SEVERITY"
            case .invalidSnsTopicArn: return "INVALID_SNS_TOPIC_ARN"
            case .invalidTag: return "INVALID_TAG"
            case .invalidTagKey: return "INVALID_TAG_KEY"
            case .invalidTagValue: return "INVALID_TAG_VALUE"
            case .invalidUserAttribute: return "INVALID_USER_ATTRIBUTE"
            case .invalidUserAttributeKey: return "INVALID_USER_ATTRIBUTE_KEY"
            case .invalidUserAttributeValue: return "INVALID_USER_ATTRIBUTE_VALUE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InvalidInputErrorCode(rawValue: rawValue) ?? InvalidInputErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension InvalidInputException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidInputException(canRetry: \(Swift.String(describing: canRetry)), errorCode: \(Swift.String(describing: errorCode)), message: \(Swift.String(describing: message)))"}
}

extension InvalidInputException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidInputExceptionBody = try responseDecoder.decode(responseBody: data)
            self.canRetry = output.canRetry
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.canRetry = nil
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was rejected because an invalid or out-of-range value was supplied for an
///          input parameter.
public struct InvalidInputException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// You can immediately retry your request.
    /// This member is required.
    public var canRetry: Swift.Bool?
    /// Code that indicates the type of error that is generated.
    /// This member is required.
    public var errorCode: InspectorClientTypes.InvalidInputErrorCode?
    /// Details of the exception error.
    /// This member is required.
    public var message: Swift.String?

    public init (
        canRetry: Swift.Bool? = nil,
        errorCode: InspectorClientTypes.InvalidInputErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.canRetry = canRetry
        self.errorCode = errorCode
        self.message = message
    }
}

struct InvalidInputExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let errorCode: InspectorClientTypes.InvalidInputErrorCode?
    public let canRetry: Swift.Bool?
}

extension InvalidInputExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case canRetry
        case errorCode
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.InvalidInputErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let canRetryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .canRetry)
        canRetry = canRetryDecoded
    }
}

extension InspectorClientTypes {
    public enum LimitExceededErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case assessmentRunLimitExceeded
        case assessmentTargetLimitExceeded
        case assessmentTemplateLimitExceeded
        case eventSubscriptionLimitExceeded
        case resourceGroupLimitExceeded
        case sdkUnknown(Swift.String)

        public static var allCases: [LimitExceededErrorCode] {
            return [
                .assessmentRunLimitExceeded,
                .assessmentTargetLimitExceeded,
                .assessmentTemplateLimitExceeded,
                .eventSubscriptionLimitExceeded,
                .resourceGroupLimitExceeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .assessmentRunLimitExceeded: return "ASSESSMENT_RUN_LIMIT_EXCEEDED"
            case .assessmentTargetLimitExceeded: return "ASSESSMENT_TARGET_LIMIT_EXCEEDED"
            case .assessmentTemplateLimitExceeded: return "ASSESSMENT_TEMPLATE_LIMIT_EXCEEDED"
            case .eventSubscriptionLimitExceeded: return "EVENT_SUBSCRIPTION_LIMIT_EXCEEDED"
            case .resourceGroupLimitExceeded: return "RESOURCE_GROUP_LIMIT_EXCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LimitExceededErrorCode(rawValue: rawValue) ?? LimitExceededErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension LimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LimitExceededException(canRetry: \(Swift.String(describing: canRetry)), errorCode: \(Swift.String(describing: errorCode)), message: \(Swift.String(describing: message)))"}
}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.canRetry = output.canRetry
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.canRetry = nil
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was rejected because it attempted to create resources beyond the current
///          AWS account limits. The error code describes the limit exceeded.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// You can immediately retry your request.
    /// This member is required.
    public var canRetry: Swift.Bool?
    /// Code that indicates the type of error that is generated.
    /// This member is required.
    public var errorCode: InspectorClientTypes.LimitExceededErrorCode?
    /// Details of the exception error.
    /// This member is required.
    public var message: Swift.String?

    public init (
        canRetry: Swift.Bool? = nil,
        errorCode: InspectorClientTypes.LimitExceededErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.canRetry = canRetry
        self.errorCode = errorCode
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let errorCode: InspectorClientTypes.LimitExceededErrorCode?
    public let canRetry: Swift.Bool?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case canRetry
        case errorCode
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.LimitExceededErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let canRetryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .canRetry)
        canRetry = canRetryDecoded
    }
}

public struct ListAssessmentRunAgentsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssessmentRunAgentsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAssessmentRunAgentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssessmentRunAgentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAssessmentRunAgentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssessmentRunAgentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssessmentRunAgentsOutputError>
}

extension ListAssessmentRunAgentsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAssessmentRunAgentsInput(assessmentRunArn: \(Swift.String(describing: assessmentRunArn)), filter: \(Swift.String(describing: filter)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAssessmentRunAgentsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentRunArn
        case filter
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentRunArn = assessmentRunArn {
            try encodeContainer.encode(assessmentRunArn, forKey: .assessmentRunArn)
        }
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListAssessmentRunAgentsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssessmentRunAgentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAssessmentRunAgentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssessmentRunAgentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAssessmentRunAgentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssessmentRunAgentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssessmentRunAgentsOutputError>
}

public struct ListAssessmentRunAgentsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssessmentRunAgentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAssessmentRunAgentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssessmentRunAgentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAssessmentRunAgentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssessmentRunAgentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssessmentRunAgentsOutputError>
}

public struct ListAssessmentRunAgentsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssessmentRunAgentsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListAssessmentRunAgentsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssessmentRunAgentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAssessmentRunAgentsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssessmentRunAgentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssessmentRunAgentsOutputError>
}

public struct ListAssessmentRunAgentsInput: Swift.Equatable {
    /// The ARN that specifies the assessment run whose agents you want to list.
    /// This member is required.
    public var assessmentRunArn: Swift.String?
    /// You can use this parameter to specify a subset of data to be included in the action's
    ///          response.
    ///          For a record to match a filter, all specified filter attributes must match. When
    ///          multiple values are specified for a filter attribute, any of the values can
    ///          match.
    public var filter: InspectorClientTypes.AgentFilter?
    /// You can use this parameter to indicate the maximum number of items that you want in
    ///          the response. The default value is 10. The maximum value is 500.
    public var maxResults: Swift.Int?
    /// You can use this parameter when paginating results. Set the value of this parameter
    ///          to null on your first call to the ListAssessmentRunAgents
    ///          action. Subsequent calls to the action fill nextToken in
    ///          the request with the value of NextToken from the previous
    ///          response to continue listing data.
    public var nextToken: Swift.String?

    public init (
        assessmentRunArn: Swift.String? = nil,
        filter: InspectorClientTypes.AgentFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentRunArn = assessmentRunArn
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAssessmentRunAgentsInputBody: Swift.Equatable {
    public let assessmentRunArn: Swift.String?
    public let filter: InspectorClientTypes.AgentFilter?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListAssessmentRunAgentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentRunArn
        case filter
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentRunArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentRunArn)
        assessmentRunArn = assessmentRunArnDecoded
        let filterDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.AgentFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAssessmentRunAgentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAssessmentRunAgentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAssessmentRunAgentsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAssessmentRunAgentsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAssessmentRunAgentsOutputResponse(assessmentRunAgents: \(Swift.String(describing: assessmentRunAgents)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAssessmentRunAgentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAssessmentRunAgentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assessmentRunAgents = output.assessmentRunAgents
            self.nextToken = output.nextToken
        } else {
            self.assessmentRunAgents = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssessmentRunAgentsOutputResponse: Swift.Equatable {
    /// A list of ARNs that specifies the agents returned by the action.
    /// This member is required.
    public var assessmentRunAgents: [InspectorClientTypes.AssessmentRunAgent]?
    ///  When a response is generated, if there is more data to be listed, this parameter is
    ///          present in the response and contains the value to use for the nextToken parameter in a subsequent pagination request. If there is no more
    ///          data to be listed, this parameter is set to null.
    public var nextToken: Swift.String?

    public init (
        assessmentRunAgents: [InspectorClientTypes.AssessmentRunAgent]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentRunAgents = assessmentRunAgents
        self.nextToken = nextToken
    }
}

struct ListAssessmentRunAgentsOutputResponseBody: Swift.Equatable {
    public let assessmentRunAgents: [InspectorClientTypes.AssessmentRunAgent]?
    public let nextToken: Swift.String?
}

extension ListAssessmentRunAgentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentRunAgents
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentRunAgentsContainer = try containerValues.decodeIfPresent([InspectorClientTypes.AssessmentRunAgent?].self, forKey: .assessmentRunAgents)
        var assessmentRunAgentsDecoded0:[InspectorClientTypes.AssessmentRunAgent]? = nil
        if let assessmentRunAgentsContainer = assessmentRunAgentsContainer {
            assessmentRunAgentsDecoded0 = [InspectorClientTypes.AssessmentRunAgent]()
            for structure0 in assessmentRunAgentsContainer {
                if let structure0 = structure0 {
                    assessmentRunAgentsDecoded0?.append(structure0)
                }
            }
        }
        assessmentRunAgents = assessmentRunAgentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListAssessmentRunsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssessmentRunsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAssessmentRunsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssessmentRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAssessmentRunsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssessmentRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssessmentRunsOutputError>
}

extension ListAssessmentRunsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAssessmentRunsInput(assessmentTemplateArns: \(Swift.String(describing: assessmentTemplateArns)), filter: \(Swift.String(describing: filter)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAssessmentRunsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTemplateArns
        case filter
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentTemplateArns = assessmentTemplateArns {
            var assessmentTemplateArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assessmentTemplateArns)
            for listparentarnlist0 in assessmentTemplateArns {
                try assessmentTemplateArnsContainer.encode(listparentarnlist0)
            }
        }
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListAssessmentRunsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssessmentRunsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAssessmentRunsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssessmentRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAssessmentRunsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssessmentRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssessmentRunsOutputError>
}

public struct ListAssessmentRunsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssessmentRunsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAssessmentRunsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssessmentRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAssessmentRunsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssessmentRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssessmentRunsOutputError>
}

public struct ListAssessmentRunsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssessmentRunsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListAssessmentRunsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssessmentRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAssessmentRunsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssessmentRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssessmentRunsOutputError>
}

public struct ListAssessmentRunsInput: Swift.Equatable {
    /// The ARNs that specify the assessment templates whose assessment runs you want to
    ///          list.
    public var assessmentTemplateArns: [Swift.String]?
    /// You can use this parameter to specify a subset of data to be included in the action's
    ///          response.
    ///          For a record to match a filter, all specified filter attributes must match. When
    ///          multiple values are specified for a filter attribute, any of the values can
    ///          match.
    public var filter: InspectorClientTypes.AssessmentRunFilter?
    /// You can use this parameter to indicate the maximum number of items that you want in
    ///          the response. The default value is 10. The maximum value is 500.
    public var maxResults: Swift.Int?
    /// You can use this parameter when paginating results. Set the value of this parameter
    ///          to null on your first call to the ListAssessmentRuns
    ///          action. Subsequent calls to the action fill nextToken in
    ///          the request with the value of NextToken from the previous
    ///          response to continue listing data.
    public var nextToken: Swift.String?

    public init (
        assessmentTemplateArns: [Swift.String]? = nil,
        filter: InspectorClientTypes.AssessmentRunFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentTemplateArns = assessmentTemplateArns
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAssessmentRunsInputBody: Swift.Equatable {
    public let assessmentTemplateArns: [Swift.String]?
    public let filter: InspectorClientTypes.AssessmentRunFilter?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListAssessmentRunsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTemplateArns
        case filter
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentTemplateArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .assessmentTemplateArns)
        var assessmentTemplateArnsDecoded0:[Swift.String]? = nil
        if let assessmentTemplateArnsContainer = assessmentTemplateArnsContainer {
            assessmentTemplateArnsDecoded0 = [Swift.String]()
            for string0 in assessmentTemplateArnsContainer {
                if let string0 = string0 {
                    assessmentTemplateArnsDecoded0?.append(string0)
                }
            }
        }
        assessmentTemplateArns = assessmentTemplateArnsDecoded0
        let filterDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.AssessmentRunFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAssessmentRunsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAssessmentRunsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAssessmentRunsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAssessmentRunsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAssessmentRunsOutputResponse(assessmentRunArns: \(Swift.String(describing: assessmentRunArns)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAssessmentRunsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAssessmentRunsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assessmentRunArns = output.assessmentRunArns
            self.nextToken = output.nextToken
        } else {
            self.assessmentRunArns = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssessmentRunsOutputResponse: Swift.Equatable {
    /// A list of ARNs that specifies the assessment runs that are returned by the
    ///          action.
    /// This member is required.
    public var assessmentRunArns: [Swift.String]?
    ///  When a response is generated, if there is more data to be listed, this parameter is
    ///          present in the response and contains the value to use for the nextToken parameter in a subsequent pagination request. If there is no more
    ///          data to be listed, this parameter is set to null.
    public var nextToken: Swift.String?

    public init (
        assessmentRunArns: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentRunArns = assessmentRunArns
        self.nextToken = nextToken
    }
}

struct ListAssessmentRunsOutputResponseBody: Swift.Equatable {
    public let assessmentRunArns: [Swift.String]?
    public let nextToken: Swift.String?
}

extension ListAssessmentRunsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentRunArns
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentRunArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .assessmentRunArns)
        var assessmentRunArnsDecoded0:[Swift.String]? = nil
        if let assessmentRunArnsContainer = assessmentRunArnsContainer {
            assessmentRunArnsDecoded0 = [Swift.String]()
            for string0 in assessmentRunArnsContainer {
                if let string0 = string0 {
                    assessmentRunArnsDecoded0?.append(string0)
                }
            }
        }
        assessmentRunArns = assessmentRunArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListAssessmentTargetsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssessmentTargetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAssessmentTargetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssessmentTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAssessmentTargetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssessmentTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssessmentTargetsOutputError>
}

extension ListAssessmentTargetsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAssessmentTargetsInput(filter: \(Swift.String(describing: filter)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAssessmentTargetsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListAssessmentTargetsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssessmentTargetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAssessmentTargetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssessmentTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAssessmentTargetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssessmentTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssessmentTargetsOutputError>
}

public struct ListAssessmentTargetsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssessmentTargetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAssessmentTargetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssessmentTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAssessmentTargetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssessmentTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssessmentTargetsOutputError>
}

public struct ListAssessmentTargetsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssessmentTargetsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListAssessmentTargetsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssessmentTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAssessmentTargetsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssessmentTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssessmentTargetsOutputError>
}

public struct ListAssessmentTargetsInput: Swift.Equatable {
    /// You can use this parameter to specify a subset of data to be included in the action's
    ///          response.
    ///          For a record to match a filter, all specified filter attributes must match. When
    ///          multiple values are specified for a filter attribute, any of the values can
    ///          match.
    public var filter: InspectorClientTypes.AssessmentTargetFilter?
    /// You can use this parameter to indicate the maximum number of items you want in the
    ///          response. The default value is 10. The maximum value is 500.
    public var maxResults: Swift.Int?
    /// You can use this parameter when paginating results. Set the value of this parameter
    ///          to null on your first call to the ListAssessmentTargets
    ///          action. Subsequent calls to the action fill nextToken in
    ///          the request with the value of NextToken from the previous
    ///          response to continue listing data.
    public var nextToken: Swift.String?

    public init (
        filter: InspectorClientTypes.AssessmentTargetFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAssessmentTargetsInputBody: Swift.Equatable {
    public let filter: InspectorClientTypes.AssessmentTargetFilter?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListAssessmentTargetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.AssessmentTargetFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAssessmentTargetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAssessmentTargetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAssessmentTargetsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAssessmentTargetsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAssessmentTargetsOutputResponse(assessmentTargetArns: \(Swift.String(describing: assessmentTargetArns)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAssessmentTargetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAssessmentTargetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assessmentTargetArns = output.assessmentTargetArns
            self.nextToken = output.nextToken
        } else {
            self.assessmentTargetArns = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssessmentTargetsOutputResponse: Swift.Equatable {
    /// A list of ARNs that specifies the assessment targets that are returned by the
    ///          action.
    /// This member is required.
    public var assessmentTargetArns: [Swift.String]?
    ///  When a response is generated, if there is more data to be listed, this parameter is
    ///          present in the response and contains the value to use for the nextToken parameter in a subsequent pagination request. If there is no more
    ///          data to be listed, this parameter is set to null.
    public var nextToken: Swift.String?

    public init (
        assessmentTargetArns: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentTargetArns = assessmentTargetArns
        self.nextToken = nextToken
    }
}

struct ListAssessmentTargetsOutputResponseBody: Swift.Equatable {
    public let assessmentTargetArns: [Swift.String]?
    public let nextToken: Swift.String?
}

extension ListAssessmentTargetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTargetArns
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentTargetArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .assessmentTargetArns)
        var assessmentTargetArnsDecoded0:[Swift.String]? = nil
        if let assessmentTargetArnsContainer = assessmentTargetArnsContainer {
            assessmentTargetArnsDecoded0 = [Swift.String]()
            for string0 in assessmentTargetArnsContainer {
                if let string0 = string0 {
                    assessmentTargetArnsDecoded0?.append(string0)
                }
            }
        }
        assessmentTargetArns = assessmentTargetArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListAssessmentTemplatesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssessmentTemplatesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAssessmentTemplatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssessmentTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAssessmentTemplatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssessmentTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssessmentTemplatesOutputError>
}

extension ListAssessmentTemplatesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAssessmentTemplatesInput(assessmentTargetArns: \(Swift.String(describing: assessmentTargetArns)), filter: \(Swift.String(describing: filter)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAssessmentTemplatesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTargetArns
        case filter
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentTargetArns = assessmentTargetArns {
            var assessmentTargetArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assessmentTargetArns)
            for listparentarnlist0 in assessmentTargetArns {
                try assessmentTargetArnsContainer.encode(listparentarnlist0)
            }
        }
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListAssessmentTemplatesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssessmentTemplatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAssessmentTemplatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssessmentTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAssessmentTemplatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssessmentTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssessmentTemplatesOutputError>
}

public struct ListAssessmentTemplatesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssessmentTemplatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAssessmentTemplatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssessmentTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAssessmentTemplatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssessmentTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssessmentTemplatesOutputError>
}

public struct ListAssessmentTemplatesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssessmentTemplatesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListAssessmentTemplatesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssessmentTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAssessmentTemplatesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssessmentTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssessmentTemplatesOutputError>
}

public struct ListAssessmentTemplatesInput: Swift.Equatable {
    /// A list of ARNs that specifies the assessment targets whose assessment templates you
    ///          want to list.
    public var assessmentTargetArns: [Swift.String]?
    /// You can use this parameter to specify a subset of data to be included in the action's
    ///          response.
    ///          For a record to match a filter, all specified filter attributes must match. When
    ///          multiple values are specified for a filter attribute, any of the values can
    ///          match.
    public var filter: InspectorClientTypes.AssessmentTemplateFilter?
    /// You can use this parameter to indicate the maximum number of items you want in the
    ///          response. The default value is 10. The maximum value is 500.
    public var maxResults: Swift.Int?
    /// You can use this parameter when paginating results. Set the value of this parameter
    ///          to null on your first call to the ListAssessmentTemplates
    ///          action. Subsequent calls to the action fill nextToken in
    ///          the request with the value of NextToken from the previous
    ///          response to continue listing data.
    public var nextToken: Swift.String?

    public init (
        assessmentTargetArns: [Swift.String]? = nil,
        filter: InspectorClientTypes.AssessmentTemplateFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentTargetArns = assessmentTargetArns
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAssessmentTemplatesInputBody: Swift.Equatable {
    public let assessmentTargetArns: [Swift.String]?
    public let filter: InspectorClientTypes.AssessmentTemplateFilter?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListAssessmentTemplatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTargetArns
        case filter
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentTargetArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .assessmentTargetArns)
        var assessmentTargetArnsDecoded0:[Swift.String]? = nil
        if let assessmentTargetArnsContainer = assessmentTargetArnsContainer {
            assessmentTargetArnsDecoded0 = [Swift.String]()
            for string0 in assessmentTargetArnsContainer {
                if let string0 = string0 {
                    assessmentTargetArnsDecoded0?.append(string0)
                }
            }
        }
        assessmentTargetArns = assessmentTargetArnsDecoded0
        let filterDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.AssessmentTemplateFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAssessmentTemplatesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAssessmentTemplatesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAssessmentTemplatesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAssessmentTemplatesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAssessmentTemplatesOutputResponse(assessmentTemplateArns: \(Swift.String(describing: assessmentTemplateArns)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAssessmentTemplatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAssessmentTemplatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assessmentTemplateArns = output.assessmentTemplateArns
            self.nextToken = output.nextToken
        } else {
            self.assessmentTemplateArns = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssessmentTemplatesOutputResponse: Swift.Equatable {
    /// A list of ARNs that specifies the assessment templates returned by the
    ///          action.
    /// This member is required.
    public var assessmentTemplateArns: [Swift.String]?
    ///  When a response is generated, if there is more data to be listed, this parameter is
    ///          present in the response and contains the value to use for the nextToken parameter in a subsequent pagination request. If there is no more
    ///          data to be listed, this parameter is set to null.
    public var nextToken: Swift.String?

    public init (
        assessmentTemplateArns: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentTemplateArns = assessmentTemplateArns
        self.nextToken = nextToken
    }
}

struct ListAssessmentTemplatesOutputResponseBody: Swift.Equatable {
    public let assessmentTemplateArns: [Swift.String]?
    public let nextToken: Swift.String?
}

extension ListAssessmentTemplatesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTemplateArns
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentTemplateArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .assessmentTemplateArns)
        var assessmentTemplateArnsDecoded0:[Swift.String]? = nil
        if let assessmentTemplateArnsContainer = assessmentTemplateArnsContainer {
            assessmentTemplateArnsDecoded0 = [Swift.String]()
            for string0 in assessmentTemplateArnsContainer {
                if let string0 = string0 {
                    assessmentTemplateArnsDecoded0?.append(string0)
                }
            }
        }
        assessmentTemplateArns = assessmentTemplateArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListEventSubscriptionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEventSubscriptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListEventSubscriptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEventSubscriptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListEventSubscriptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListEventSubscriptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEventSubscriptionsOutputError>
}

extension ListEventSubscriptionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListEventSubscriptionsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListEventSubscriptionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct ListEventSubscriptionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEventSubscriptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListEventSubscriptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEventSubscriptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListEventSubscriptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListEventSubscriptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEventSubscriptionsOutputError>
}

public struct ListEventSubscriptionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEventSubscriptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListEventSubscriptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEventSubscriptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListEventSubscriptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListEventSubscriptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEventSubscriptionsOutputError>
}

public struct ListEventSubscriptionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEventSubscriptionsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListEventSubscriptionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEventSubscriptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListEventSubscriptionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListEventSubscriptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEventSubscriptionsOutputError>
}

public struct ListEventSubscriptionsInput: Swift.Equatable {
    /// You can use this parameter to indicate the maximum number of items you want in the
    ///          response. The default value is 10. The maximum value is 500.
    public var maxResults: Swift.Int?
    /// You can use this parameter when paginating results. Set the value of this parameter
    ///          to null on your first call to the ListEventSubscriptions
    ///          action. Subsequent calls to the action fill nextToken in
    ///          the request with the value of NextToken from the previous
    ///          response to continue listing data.
    public var nextToken: Swift.String?
    /// The ARN of the assessment template for which you want to list the existing event
    ///          subscriptions.
    public var resourceArn: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct ListEventSubscriptionsInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListEventSubscriptionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListEventSubscriptionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEventSubscriptionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEventSubscriptionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEventSubscriptionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListEventSubscriptionsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), subscriptions: \(Swift.String(describing: subscriptions)))"}
}

extension ListEventSubscriptionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListEventSubscriptionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.subscriptions = output.subscriptions
        } else {
            self.nextToken = nil
            self.subscriptions = nil
        }
    }
}

public struct ListEventSubscriptionsOutputResponse: Swift.Equatable {
    ///  When a response is generated, if there is more data to be listed, this parameter is
    ///          present in the response and contains the value to use for the nextToken parameter in a subsequent pagination request. If there is no more
    ///          data to be listed, this parameter is set to null.
    public var nextToken: Swift.String?
    /// Details of the returned event subscriptions.
    /// This member is required.
    public var subscriptions: [InspectorClientTypes.Subscription]?

    public init (
        nextToken: Swift.String? = nil,
        subscriptions: [InspectorClientTypes.Subscription]? = nil
    )
    {
        self.nextToken = nextToken
        self.subscriptions = subscriptions
    }
}

struct ListEventSubscriptionsOutputResponseBody: Swift.Equatable {
    public let subscriptions: [InspectorClientTypes.Subscription]?
    public let nextToken: Swift.String?
}

extension ListEventSubscriptionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case subscriptions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionsContainer = try containerValues.decodeIfPresent([InspectorClientTypes.Subscription?].self, forKey: .subscriptions)
        var subscriptionsDecoded0:[InspectorClientTypes.Subscription]? = nil
        if let subscriptionsContainer = subscriptionsContainer {
            subscriptionsDecoded0 = [InspectorClientTypes.Subscription]()
            for structure0 in subscriptionsContainer {
                if let structure0 = structure0 {
                    subscriptionsDecoded0?.append(structure0)
                }
            }
        }
        subscriptions = subscriptionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListExclusionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListExclusionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListExclusionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListExclusionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListExclusionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListExclusionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListExclusionsOutputError>
}

extension ListExclusionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListExclusionsInput(assessmentRunArn: \(Swift.String(describing: assessmentRunArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListExclusionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentRunArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentRunArn = assessmentRunArn {
            try encodeContainer.encode(assessmentRunArn, forKey: .assessmentRunArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListExclusionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListExclusionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListExclusionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListExclusionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListExclusionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListExclusionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListExclusionsOutputError>
}

public struct ListExclusionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListExclusionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListExclusionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListExclusionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListExclusionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListExclusionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListExclusionsOutputError>
}

public struct ListExclusionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListExclusionsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListExclusionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListExclusionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListExclusionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListExclusionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListExclusionsOutputError>
}

public struct ListExclusionsInput: Swift.Equatable {
    /// The ARN of the assessment run that generated the exclusions that you want to
    ///          list.
    /// This member is required.
    public var assessmentRunArn: Swift.String?
    /// You can use this parameter to indicate the maximum number of items you want in the
    ///          response. The default value is 100. The maximum value is 500.
    public var maxResults: Swift.Int?
    /// You can use this parameter when paginating results. Set the value of this parameter
    ///          to null on your first call to the ListExclusionsRequest action. Subsequent calls to the
    ///          action fill nextToken in the request with the value of nextToken from the previous response
    ///          to continue listing data.
    public var nextToken: Swift.String?

    public init (
        assessmentRunArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentRunArn = assessmentRunArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListExclusionsInputBody: Swift.Equatable {
    public let assessmentRunArn: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListExclusionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentRunArn
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentRunArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentRunArn)
        assessmentRunArn = assessmentRunArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListExclusionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListExclusionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListExclusionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListExclusionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListExclusionsOutputResponse(exclusionArns: \(Swift.String(describing: exclusionArns)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListExclusionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListExclusionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.exclusionArns = output.exclusionArns
            self.nextToken = output.nextToken
        } else {
            self.exclusionArns = nil
            self.nextToken = nil
        }
    }
}

public struct ListExclusionsOutputResponse: Swift.Equatable {
    /// A list of exclusions' ARNs returned by the action.
    /// This member is required.
    public var exclusionArns: [Swift.String]?
    /// When a response is generated, if there is more data to be listed, this parameters is
    ///          present in the response and contains the value to use for the nextToken parameter in a
    ///          subsequent pagination request. If there is no more data to be listed, this parameter is set
    ///          to null.
    public var nextToken: Swift.String?

    public init (
        exclusionArns: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.exclusionArns = exclusionArns
        self.nextToken = nextToken
    }
}

struct ListExclusionsOutputResponseBody: Swift.Equatable {
    public let exclusionArns: [Swift.String]?
    public let nextToken: Swift.String?
}

extension ListExclusionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exclusionArns
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exclusionArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .exclusionArns)
        var exclusionArnsDecoded0:[Swift.String]? = nil
        if let exclusionArnsContainer = exclusionArnsContainer {
            exclusionArnsDecoded0 = [Swift.String]()
            for string0 in exclusionArnsContainer {
                if let string0 = string0 {
                    exclusionArnsDecoded0?.append(string0)
                }
            }
        }
        exclusionArns = exclusionArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListFindingsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFindingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFindingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFindingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFindingsOutputError>
}

extension ListFindingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListFindingsInput(assessmentRunArns: \(Swift.String(describing: assessmentRunArns)), filter: \(Swift.String(describing: filter)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListFindingsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentRunArns
        case filter
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentRunArns = assessmentRunArns {
            var assessmentRunArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assessmentRunArns)
            for listparentarnlist0 in assessmentRunArns {
                try assessmentRunArnsContainer.encode(listparentarnlist0)
            }
        }
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListFindingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFindingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFindingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFindingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFindingsOutputError>
}

public struct ListFindingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFindingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFindingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFindingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFindingsOutputError>
}

public struct ListFindingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFindingsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListFindingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListFindingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFindingsOutputError>
}

public struct ListFindingsInput: Swift.Equatable {
    /// The ARNs of the assessment runs that generate the findings that you want to
    ///          list.
    public var assessmentRunArns: [Swift.String]?
    /// You can use this parameter to specify a subset of data to be included in the action's
    ///          response.
    ///          For a record to match a filter, all specified filter attributes must match. When
    ///          multiple values are specified for a filter attribute, any of the values can
    ///          match.
    public var filter: InspectorClientTypes.FindingFilter?
    /// You can use this parameter to indicate the maximum number of items you want in the
    ///          response. The default value is 10. The maximum value is 500.
    public var maxResults: Swift.Int?
    /// You can use this parameter when paginating results. Set the value of this parameter
    ///          to null on your first call to the ListFindings action.
    ///          Subsequent calls to the action fill nextToken in the
    ///          request with the value of NextToken from the previous
    ///          response to continue listing data.
    public var nextToken: Swift.String?

    public init (
        assessmentRunArns: [Swift.String]? = nil,
        filter: InspectorClientTypes.FindingFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentRunArns = assessmentRunArns
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFindingsInputBody: Swift.Equatable {
    public let assessmentRunArns: [Swift.String]?
    public let filter: InspectorClientTypes.FindingFilter?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListFindingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentRunArns
        case filter
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentRunArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .assessmentRunArns)
        var assessmentRunArnsDecoded0:[Swift.String]? = nil
        if let assessmentRunArnsContainer = assessmentRunArnsContainer {
            assessmentRunArnsDecoded0 = [Swift.String]()
            for string0 in assessmentRunArnsContainer {
                if let string0 = string0 {
                    assessmentRunArnsDecoded0?.append(string0)
                }
            }
        }
        assessmentRunArns = assessmentRunArnsDecoded0
        let filterDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.FindingFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListFindingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFindingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFindingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFindingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListFindingsOutputResponse(findingArns: \(Swift.String(describing: findingArns)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListFindingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListFindingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.findingArns = output.findingArns
            self.nextToken = output.nextToken
        } else {
            self.findingArns = nil
            self.nextToken = nil
        }
    }
}

public struct ListFindingsOutputResponse: Swift.Equatable {
    /// A list of ARNs that specifies the findings returned by the action.
    /// This member is required.
    public var findingArns: [Swift.String]?
    ///  When a response is generated, if there is more data to be listed, this parameter is
    ///          present in the response and contains the value to use for the nextToken parameter in a subsequent pagination request. If there is no more
    ///          data to be listed, this parameter is set to null.
    public var nextToken: Swift.String?

    public init (
        findingArns: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.findingArns = findingArns
        self.nextToken = nextToken
    }
}

struct ListFindingsOutputResponseBody: Swift.Equatable {
    public let findingArns: [Swift.String]?
    public let nextToken: Swift.String?
}

extension ListFindingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingArns
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .findingArns)
        var findingArnsDecoded0:[Swift.String]? = nil
        if let findingArnsContainer = findingArnsContainer {
            findingArnsDecoded0 = [Swift.String]()
            for string0 in findingArnsContainer {
                if let string0 = string0 {
                    findingArnsDecoded0?.append(string0)
                }
            }
        }
        findingArns = findingArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListRulesPackagesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRulesPackagesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRulesPackagesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRulesPackagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRulesPackagesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRulesPackagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRulesPackagesOutputError>
}

extension ListRulesPackagesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRulesPackagesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListRulesPackagesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListRulesPackagesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRulesPackagesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRulesPackagesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRulesPackagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRulesPackagesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRulesPackagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRulesPackagesOutputError>
}

public struct ListRulesPackagesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRulesPackagesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRulesPackagesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRulesPackagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRulesPackagesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRulesPackagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRulesPackagesOutputError>
}

public struct ListRulesPackagesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRulesPackagesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListRulesPackagesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRulesPackagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListRulesPackagesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListRulesPackagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRulesPackagesOutputError>
}

public struct ListRulesPackagesInput: Swift.Equatable {
    /// You can use this parameter to indicate the maximum number of items you want in the
    ///          response. The default value is 10. The maximum value is 500.
    public var maxResults: Swift.Int?
    /// You can use this parameter when paginating results. Set the value of this parameter
    ///          to null on your first call to the ListRulesPackages
    ///          action. Subsequent calls to the action fill nextToken in
    ///          the request with the value of NextToken from the previous
    ///          response to continue listing data.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRulesPackagesInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListRulesPackagesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListRulesPackagesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRulesPackagesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRulesPackagesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRulesPackagesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRulesPackagesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), rulesPackageArns: \(Swift.String(describing: rulesPackageArns)))"}
}

extension ListRulesPackagesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListRulesPackagesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.rulesPackageArns = output.rulesPackageArns
        } else {
            self.nextToken = nil
            self.rulesPackageArns = nil
        }
    }
}

public struct ListRulesPackagesOutputResponse: Swift.Equatable {
    ///  When a response is generated, if there is more data to be listed, this parameter is
    ///          present in the response and contains the value to use for the nextToken parameter in a subsequent pagination request. If there is no more
    ///          data to be listed, this parameter is set to null.
    public var nextToken: Swift.String?
    /// The list of ARNs that specifies the rules packages returned by the action.
    /// This member is required.
    public var rulesPackageArns: [Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        rulesPackageArns: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.rulesPackageArns = rulesPackageArns
    }
}

struct ListRulesPackagesOutputResponseBody: Swift.Equatable {
    public let rulesPackageArns: [Swift.String]?
    public let nextToken: Swift.String?
}

extension ListRulesPackagesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case rulesPackageArns
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rulesPackageArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .rulesPackageArns)
        var rulesPackageArnsDecoded0:[Swift.String]? = nil
        if let rulesPackageArnsContainer = rulesPackageArnsContainer {
            rulesPackageArnsDecoded0 = [Swift.String]()
            for string0 in rulesPackageArnsContainer {
                if let string0 = string0 {
                    rulesPackageArnsDecoded0?.append(string0)
                }
            }
        }
        rulesPackageArns = rulesPackageArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN that specifies the assessment template whose tags you want to list.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// A collection of key and value pairs.
    /// This member is required.
    public var tags: [InspectorClientTypes.Tag]?

    public init (
        tags: [InspectorClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [InspectorClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([InspectorClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[InspectorClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [InspectorClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension InspectorClientTypes {
    public enum Locale: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case enUs
        case sdkUnknown(Swift.String)

        public static var allCases: [Locale] {
            return [
                .enUs,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .enUs: return "EN_US"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Locale(rawValue: rawValue) ?? Locale.sdkUnknown(rawValue)
        }
    }
}

extension InspectorClientTypes.NetworkInterface: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipv6Addresses
        case networkInterfaceId
        case privateDnsName
        case privateIpAddress
        case privateIpAddresses
        case publicDnsName
        case publicIp
        case securityGroups
        case subnetId
        case vpcId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipv6Addresses = ipv6Addresses {
            var ipv6AddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipv6Addresses)
            for ipv6addresses0 in ipv6Addresses {
                try ipv6AddressesContainer.encode(ipv6addresses0)
            }
        }
        if let networkInterfaceId = networkInterfaceId {
            try encodeContainer.encode(networkInterfaceId, forKey: .networkInterfaceId)
        }
        if let privateDnsName = privateDnsName {
            try encodeContainer.encode(privateDnsName, forKey: .privateDnsName)
        }
        if let privateIpAddress = privateIpAddress {
            try encodeContainer.encode(privateIpAddress, forKey: .privateIpAddress)
        }
        if let privateIpAddresses = privateIpAddresses {
            var privateIpAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .privateIpAddresses)
            for privateipaddresses0 in privateIpAddresses {
                try privateIpAddressesContainer.encode(privateipaddresses0)
            }
        }
        if let publicDnsName = publicDnsName {
            try encodeContainer.encode(publicDnsName, forKey: .publicDnsName)
        }
        if let publicIp = publicIp {
            try encodeContainer.encode(publicIp, forKey: .publicIp)
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for securitygroups0 in securityGroups {
                try securityGroupsContainer.encode(securitygroups0)
            }
        }
        if let subnetId = subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkInterfaceId)
        networkInterfaceId = networkInterfaceIdDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let privateDnsNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateDnsName)
        privateDnsName = privateDnsNameDecoded
        let privateIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateIpAddress)
        privateIpAddress = privateIpAddressDecoded
        let privateIpAddressesContainer = try containerValues.decodeIfPresent([InspectorClientTypes.PrivateIp?].self, forKey: .privateIpAddresses)
        var privateIpAddressesDecoded0:[InspectorClientTypes.PrivateIp]? = nil
        if let privateIpAddressesContainer = privateIpAddressesContainer {
            privateIpAddressesDecoded0 = [InspectorClientTypes.PrivateIp]()
            for structure0 in privateIpAddressesContainer {
                if let structure0 = structure0 {
                    privateIpAddressesDecoded0?.append(structure0)
                }
            }
        }
        privateIpAddresses = privateIpAddressesDecoded0
        let publicDnsNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publicDnsName)
        publicDnsName = publicDnsNameDecoded
        let publicIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publicIp)
        publicIp = publicIpDecoded
        let ipv6AddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ipv6Addresses)
        var ipv6AddressesDecoded0:[Swift.String]? = nil
        if let ipv6AddressesContainer = ipv6AddressesContainer {
            ipv6AddressesDecoded0 = [Swift.String]()
            for string0 in ipv6AddressesContainer {
                if let string0 = string0 {
                    ipv6AddressesDecoded0?.append(string0)
                }
            }
        }
        ipv6Addresses = ipv6AddressesDecoded0
        let securityGroupsContainer = try containerValues.decodeIfPresent([InspectorClientTypes.SecurityGroup?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[InspectorClientTypes.SecurityGroup]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [InspectorClientTypes.SecurityGroup]()
            for structure0 in securityGroupsContainer {
                if let structure0 = structure0 {
                    securityGroupsDecoded0?.append(structure0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
    }
}

extension InspectorClientTypes.NetworkInterface: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NetworkInterface(ipv6Addresses: \(Swift.String(describing: ipv6Addresses)), networkInterfaceId: \(Swift.String(describing: networkInterfaceId)), privateDnsName: \(Swift.String(describing: privateDnsName)), privateIpAddress: \(Swift.String(describing: privateIpAddress)), privateIpAddresses: \(Swift.String(describing: privateIpAddresses)), publicDnsName: \(Swift.String(describing: publicDnsName)), publicIp: \(Swift.String(describing: publicIp)), securityGroups: \(Swift.String(describing: securityGroups)), subnetId: \(Swift.String(describing: subnetId)), vpcId: \(Swift.String(describing: vpcId)))"}
}

extension InspectorClientTypes {
    /// Contains information about the network interfaces interacting with an EC2 instance.
    ///          This data type is used as one of the elements of the AssetAttributes data
    ///          type.
    public struct NetworkInterface: Swift.Equatable {
        /// The IP addresses associated with the network interface.
        public var ipv6Addresses: [Swift.String]?
        /// The ID of the network interface.
        public var networkInterfaceId: Swift.String?
        /// The name of a private DNS associated with the network interface.
        public var privateDnsName: Swift.String?
        /// The private IP address associated with the network interface.
        public var privateIpAddress: Swift.String?
        /// A list of the private IP addresses associated with the network interface. Includes
        ///          the privateDnsName and privateIpAddress.
        public var privateIpAddresses: [InspectorClientTypes.PrivateIp]?
        /// The name of a public DNS associated with the network interface.
        public var publicDnsName: Swift.String?
        /// The public IP address from which the network interface is reachable.
        public var publicIp: Swift.String?
        /// A list of the security groups associated with the network interface. Includes the
        ///          groupId and groupName.
        public var securityGroups: [InspectorClientTypes.SecurityGroup]?
        /// The ID of a subnet associated with the network interface.
        public var subnetId: Swift.String?
        /// The ID of a VPC associated with the network interface.
        public var vpcId: Swift.String?

        public init (
            ipv6Addresses: [Swift.String]? = nil,
            networkInterfaceId: Swift.String? = nil,
            privateDnsName: Swift.String? = nil,
            privateIpAddress: Swift.String? = nil,
            privateIpAddresses: [InspectorClientTypes.PrivateIp]? = nil,
            publicDnsName: Swift.String? = nil,
            publicIp: Swift.String? = nil,
            securityGroups: [InspectorClientTypes.SecurityGroup]? = nil,
            subnetId: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.ipv6Addresses = ipv6Addresses
            self.networkInterfaceId = networkInterfaceId
            self.privateDnsName = privateDnsName
            self.privateIpAddress = privateIpAddress
            self.privateIpAddresses = privateIpAddresses
            self.publicDnsName = publicDnsName
            self.publicIp = publicIp
            self.securityGroups = securityGroups
            self.subnetId = subnetId
            self.vpcId = vpcId
        }
    }

}

extension InspectorClientTypes {
    public enum NoSuchEntityErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case assessmentRunDoesNotExist
        case assessmentTargetDoesNotExist
        case assessmentTemplateDoesNotExist
        case findingDoesNotExist
        case iamRoleDoesNotExist
        case resourceGroupDoesNotExist
        case rulesPackageDoesNotExist
        case snsTopicDoesNotExist
        case sdkUnknown(Swift.String)

        public static var allCases: [NoSuchEntityErrorCode] {
            return [
                .assessmentRunDoesNotExist,
                .assessmentTargetDoesNotExist,
                .assessmentTemplateDoesNotExist,
                .findingDoesNotExist,
                .iamRoleDoesNotExist,
                .resourceGroupDoesNotExist,
                .rulesPackageDoesNotExist,
                .snsTopicDoesNotExist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .assessmentRunDoesNotExist: return "ASSESSMENT_RUN_DOES_NOT_EXIST"
            case .assessmentTargetDoesNotExist: return "ASSESSMENT_TARGET_DOES_NOT_EXIST"
            case .assessmentTemplateDoesNotExist: return "ASSESSMENT_TEMPLATE_DOES_NOT_EXIST"
            case .findingDoesNotExist: return "FINDING_DOES_NOT_EXIST"
            case .iamRoleDoesNotExist: return "IAM_ROLE_DOES_NOT_EXIST"
            case .resourceGroupDoesNotExist: return "RESOURCE_GROUP_DOES_NOT_EXIST"
            case .rulesPackageDoesNotExist: return "RULES_PACKAGE_DOES_NOT_EXIST"
            case .snsTopicDoesNotExist: return "SNS_TOPIC_DOES_NOT_EXIST"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NoSuchEntityErrorCode(rawValue: rawValue) ?? NoSuchEntityErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension NoSuchEntityException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NoSuchEntityException(canRetry: \(Swift.String(describing: canRetry)), errorCode: \(Swift.String(describing: errorCode)), message: \(Swift.String(describing: message)))"}
}

extension NoSuchEntityException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NoSuchEntityExceptionBody = try responseDecoder.decode(responseBody: data)
            self.canRetry = output.canRetry
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.canRetry = nil
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was rejected because it referenced an entity that does not exist. The
///          error code describes the entity.
public struct NoSuchEntityException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// You can immediately retry your request.
    /// This member is required.
    public var canRetry: Swift.Bool?
    /// Code that indicates the type of error that is generated.
    /// This member is required.
    public var errorCode: InspectorClientTypes.NoSuchEntityErrorCode?
    /// Details of the exception error.
    /// This member is required.
    public var message: Swift.String?

    public init (
        canRetry: Swift.Bool? = nil,
        errorCode: InspectorClientTypes.NoSuchEntityErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.canRetry = canRetry
        self.errorCode = errorCode
        self.message = message
    }
}

struct NoSuchEntityExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let errorCode: InspectorClientTypes.NoSuchEntityErrorCode?
    public let canRetry: Swift.Bool?
}

extension NoSuchEntityExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case canRetry
        case errorCode
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.NoSuchEntityErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let canRetryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .canRetry)
        canRetry = canRetryDecoded
    }
}

public struct PreviewAgentsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PreviewAgentsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PreviewAgentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PreviewAgentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PreviewAgentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PreviewAgentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PreviewAgentsOutputError>
}

extension PreviewAgentsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PreviewAgentsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), previewAgentsArn: \(Swift.String(describing: previewAgentsArn)))"}
}

extension PreviewAgentsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case previewAgentsArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let previewAgentsArn = previewAgentsArn {
            try encodeContainer.encode(previewAgentsArn, forKey: .previewAgentsArn)
        }
    }
}

public struct PreviewAgentsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PreviewAgentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PreviewAgentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PreviewAgentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PreviewAgentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PreviewAgentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PreviewAgentsOutputError>
}

public struct PreviewAgentsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PreviewAgentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PreviewAgentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PreviewAgentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PreviewAgentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PreviewAgentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PreviewAgentsOutputError>
}

public struct PreviewAgentsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PreviewAgentsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: PreviewAgentsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PreviewAgentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PreviewAgentsInput
    public typealias MOutput = ClientRuntime.OperationOutput<PreviewAgentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PreviewAgentsOutputError>
}

public struct PreviewAgentsInput: Swift.Equatable {
    /// You can use this parameter to indicate the maximum number of items you want in the
    ///          response. The default value is 10. The maximum value is 500.
    public var maxResults: Swift.Int?
    /// You can use this parameter when paginating results. Set the value of this parameter
    ///          to null on your first call to the PreviewAgents action.
    ///          Subsequent calls to the action fill nextToken in the
    ///          request with the value of NextToken from the previous
    ///          response to continue listing data.
    public var nextToken: Swift.String?
    /// The ARN of the assessment target whose agents you want to preview.
    /// This member is required.
    public var previewAgentsArn: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        previewAgentsArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.previewAgentsArn = previewAgentsArn
    }
}

struct PreviewAgentsInputBody: Swift.Equatable {
    public let previewAgentsArn: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension PreviewAgentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case previewAgentsArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let previewAgentsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .previewAgentsArn)
        previewAgentsArn = previewAgentsArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension PreviewAgentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PreviewAgentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCrossAccountRoleException" : self = .invalidCrossAccountRoleException(try InvalidCrossAccountRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PreviewAgentsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidCrossAccountRoleException(InvalidCrossAccountRoleException)
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PreviewAgentsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PreviewAgentsOutputResponse(agentPreviews: \(Swift.String(describing: agentPreviews)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension PreviewAgentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PreviewAgentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.agentPreviews = output.agentPreviews
            self.nextToken = output.nextToken
        } else {
            self.agentPreviews = nil
            self.nextToken = nil
        }
    }
}

public struct PreviewAgentsOutputResponse: Swift.Equatable {
    /// The resulting list of agents.
    /// This member is required.
    public var agentPreviews: [InspectorClientTypes.AgentPreview]?
    ///  When a response is generated, if there is more data to be listed, this parameter is
    ///          present in the response and contains the value to use for the nextToken parameter in a subsequent pagination request. If there is no more
    ///          data to be listed, this parameter is set to null.
    public var nextToken: Swift.String?

    public init (
        agentPreviews: [InspectorClientTypes.AgentPreview]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.agentPreviews = agentPreviews
        self.nextToken = nextToken
    }
}

struct PreviewAgentsOutputResponseBody: Swift.Equatable {
    public let agentPreviews: [InspectorClientTypes.AgentPreview]?
    public let nextToken: Swift.String?
}

extension PreviewAgentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentPreviews
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentPreviewsContainer = try containerValues.decodeIfPresent([InspectorClientTypes.AgentPreview?].self, forKey: .agentPreviews)
        var agentPreviewsDecoded0:[InspectorClientTypes.AgentPreview]? = nil
        if let agentPreviewsContainer = agentPreviewsContainer {
            agentPreviewsDecoded0 = [InspectorClientTypes.AgentPreview]()
            for structure0 in agentPreviewsContainer {
                if let structure0 = structure0 {
                    agentPreviewsDecoded0?.append(structure0)
                }
            }
        }
        agentPreviews = agentPreviewsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension PreviewGenerationInProgressException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PreviewGenerationInProgressException(message: \(Swift.String(describing: message)))"}
}

extension PreviewGenerationInProgressException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PreviewGenerationInProgressExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request is rejected. The specified assessment template is currently generating an
///          exclusions preview.
public struct PreviewGenerationInProgressException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct PreviewGenerationInProgressExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension PreviewGenerationInProgressExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InspectorClientTypes {
    public enum PreviewStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case workInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [PreviewStatus] {
            return [
                .completed,
                .workInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .workInProgress: return "WORK_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PreviewStatus(rawValue: rawValue) ?? PreviewStatus.sdkUnknown(rawValue)
        }
    }
}

extension InspectorClientTypes.PrivateIp: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case privateDnsName
        case privateIpAddress
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let privateDnsName = privateDnsName {
            try encodeContainer.encode(privateDnsName, forKey: .privateDnsName)
        }
        if let privateIpAddress = privateIpAddress {
            try encodeContainer.encode(privateIpAddress, forKey: .privateIpAddress)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let privateDnsNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateDnsName)
        privateDnsName = privateDnsNameDecoded
        let privateIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateIpAddress)
        privateIpAddress = privateIpAddressDecoded
    }
}

extension InspectorClientTypes.PrivateIp: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PrivateIp(privateDnsName: \(Swift.String(describing: privateDnsName)), privateIpAddress: \(Swift.String(describing: privateIpAddress)))"}
}

extension InspectorClientTypes {
    /// Contains information about a private IP address associated with a network interface. This
    ///          data type is used as a response element in the DescribeFindings
    ///          action.
    public struct PrivateIp: Swift.Equatable {
        /// The DNS name of the private IP address.
        public var privateDnsName: Swift.String?
        /// The full IP address of the network inteface.
        public var privateIpAddress: Swift.String?

        public init (
            privateDnsName: Swift.String? = nil,
            privateIpAddress: Swift.String? = nil
        )
        {
            self.privateDnsName = privateDnsName
            self.privateIpAddress = privateIpAddress
        }
    }

}

public struct RegisterCrossAccountAccessRoleInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterCrossAccountAccessRoleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterCrossAccountAccessRoleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterCrossAccountAccessRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterCrossAccountAccessRoleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterCrossAccountAccessRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterCrossAccountAccessRoleOutputError>
}

extension RegisterCrossAccountAccessRoleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegisterCrossAccountAccessRoleInput(roleArn: \(Swift.String(describing: roleArn)))"}
}

extension RegisterCrossAccountAccessRoleInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

public struct RegisterCrossAccountAccessRoleInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterCrossAccountAccessRoleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterCrossAccountAccessRoleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterCrossAccountAccessRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterCrossAccountAccessRoleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterCrossAccountAccessRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterCrossAccountAccessRoleOutputError>
}

public struct RegisterCrossAccountAccessRoleInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterCrossAccountAccessRoleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterCrossAccountAccessRoleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterCrossAccountAccessRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterCrossAccountAccessRoleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterCrossAccountAccessRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterCrossAccountAccessRoleOutputError>
}

public struct RegisterCrossAccountAccessRoleInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterCrossAccountAccessRoleInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: RegisterCrossAccountAccessRoleInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterCrossAccountAccessRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RegisterCrossAccountAccessRoleInput
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterCrossAccountAccessRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterCrossAccountAccessRoleOutputError>
}

public struct RegisterCrossAccountAccessRoleInput: Swift.Equatable {
    /// The ARN of the IAM role that grants Amazon Inspector access to AWS Services needed to
    ///          perform security assessments.
    /// This member is required.
    public var roleArn: Swift.String?

    public init (
        roleArn: Swift.String? = nil
    )
    {
        self.roleArn = roleArn
    }
}

struct RegisterCrossAccountAccessRoleInputBody: Swift.Equatable {
    public let roleArn: Swift.String?
}

extension RegisterCrossAccountAccessRoleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension RegisterCrossAccountAccessRoleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterCrossAccountAccessRoleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCrossAccountRoleException" : self = .invalidCrossAccountRoleException(try InvalidCrossAccountRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceTemporarilyUnavailableException" : self = .serviceTemporarilyUnavailableException(try ServiceTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterCrossAccountAccessRoleOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidCrossAccountRoleException(InvalidCrossAccountRoleException)
    case invalidInputException(InvalidInputException)
    case serviceTemporarilyUnavailableException(ServiceTemporarilyUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterCrossAccountAccessRoleOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegisterCrossAccountAccessRoleOutputResponse()"}
}

extension RegisterCrossAccountAccessRoleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RegisterCrossAccountAccessRoleOutputResponse: Swift.Equatable {

    public init() {}
}

struct RegisterCrossAccountAccessRoleOutputResponseBody: Swift.Equatable {
}

extension RegisterCrossAccountAccessRoleOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct RemoveAttributesFromFindingsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveAttributesFromFindingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveAttributesFromFindingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveAttributesFromFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveAttributesFromFindingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveAttributesFromFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveAttributesFromFindingsOutputError>
}

extension RemoveAttributesFromFindingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveAttributesFromFindingsInput(attributeKeys: \(Swift.String(describing: attributeKeys)), findingArns: \(Swift.String(describing: findingArns)))"}
}

extension RemoveAttributesFromFindingsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeKeys
        case findingArns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeKeys = attributeKeys {
            var attributeKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributeKeys)
            for userattributekeylist0 in attributeKeys {
                try attributeKeysContainer.encode(userattributekeylist0)
            }
        }
        if let findingArns = findingArns {
            var findingArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingArns)
            for addremoveattributesfindingarnlist0 in findingArns {
                try findingArnsContainer.encode(addremoveattributesfindingarnlist0)
            }
        }
    }
}

public struct RemoveAttributesFromFindingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveAttributesFromFindingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveAttributesFromFindingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveAttributesFromFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveAttributesFromFindingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveAttributesFromFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveAttributesFromFindingsOutputError>
}

public struct RemoveAttributesFromFindingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveAttributesFromFindingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveAttributesFromFindingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveAttributesFromFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveAttributesFromFindingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveAttributesFromFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveAttributesFromFindingsOutputError>
}

public struct RemoveAttributesFromFindingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveAttributesFromFindingsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: RemoveAttributesFromFindingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveAttributesFromFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RemoveAttributesFromFindingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveAttributesFromFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveAttributesFromFindingsOutputError>
}

public struct RemoveAttributesFromFindingsInput: Swift.Equatable {
    /// The array of attribute keys that you want to remove from specified
    ///          findings.
    /// This member is required.
    public var attributeKeys: [Swift.String]?
    /// The ARNs that specify the findings that you want to remove attributes from.
    /// This member is required.
    public var findingArns: [Swift.String]?

    public init (
        attributeKeys: [Swift.String]? = nil,
        findingArns: [Swift.String]? = nil
    )
    {
        self.attributeKeys = attributeKeys
        self.findingArns = findingArns
    }
}

struct RemoveAttributesFromFindingsInputBody: Swift.Equatable {
    public let findingArns: [Swift.String]?
    public let attributeKeys: [Swift.String]?
}

extension RemoveAttributesFromFindingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeKeys
        case findingArns
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .findingArns)
        var findingArnsDecoded0:[Swift.String]? = nil
        if let findingArnsContainer = findingArnsContainer {
            findingArnsDecoded0 = [Swift.String]()
            for string0 in findingArnsContainer {
                if let string0 = string0 {
                    findingArnsDecoded0?.append(string0)
                }
            }
        }
        findingArns = findingArnsDecoded0
        let attributeKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .attributeKeys)
        var attributeKeysDecoded0:[Swift.String]? = nil
        if let attributeKeysContainer = attributeKeysContainer {
            attributeKeysDecoded0 = [Swift.String]()
            for string0 in attributeKeysContainer {
                if let string0 = string0 {
                    attributeKeysDecoded0?.append(string0)
                }
            }
        }
        attributeKeys = attributeKeysDecoded0
    }
}

extension RemoveAttributesFromFindingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveAttributesFromFindingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceTemporarilyUnavailableException" : self = .serviceTemporarilyUnavailableException(try ServiceTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveAttributesFromFindingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceTemporarilyUnavailableException(ServiceTemporarilyUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveAttributesFromFindingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveAttributesFromFindingsOutputResponse(failedItems: \(Swift.String(describing: failedItems)))"}
}

extension RemoveAttributesFromFindingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RemoveAttributesFromFindingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failedItems = output.failedItems
        } else {
            self.failedItems = nil
        }
    }
}

public struct RemoveAttributesFromFindingsOutputResponse: Swift.Equatable {
    /// Attributes details that cannot be described. An error code is provided for each
    ///          failed item.
    /// This member is required.
    public var failedItems: [Swift.String:InspectorClientTypes.FailedItemDetails]?

    public init (
        failedItems: [Swift.String:InspectorClientTypes.FailedItemDetails]? = nil
    )
    {
        self.failedItems = failedItems
    }
}

struct RemoveAttributesFromFindingsOutputResponseBody: Swift.Equatable {
    public let failedItems: [Swift.String:InspectorClientTypes.FailedItemDetails]?
}

extension RemoveAttributesFromFindingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedItems
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedItemsContainer = try containerValues.decodeIfPresent([Swift.String: InspectorClientTypes.FailedItemDetails?].self, forKey: .failedItems)
        var failedItemsDecoded0: [Swift.String:InspectorClientTypes.FailedItemDetails]? = nil
        if let failedItemsContainer = failedItemsContainer {
            failedItemsDecoded0 = [Swift.String:InspectorClientTypes.FailedItemDetails]()
            for (key0, faileditemdetails0) in failedItemsContainer {
                if let faileditemdetails0 = faileditemdetails0 {
                    failedItemsDecoded0?[key0] = faileditemdetails0
                }
            }
        }
        failedItems = failedItemsDecoded0
    }
}

extension InspectorClientTypes {
    public enum ReportFileFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case html
        case pdf
        case sdkUnknown(Swift.String)

        public static var allCases: [ReportFileFormat] {
            return [
                .html,
                .pdf,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .html: return "HTML"
            case .pdf: return "PDF"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReportFileFormat(rawValue: rawValue) ?? ReportFileFormat.sdkUnknown(rawValue)
        }
    }
}

extension InspectorClientTypes {
    public enum ReportStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case workInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ReportStatus] {
            return [
                .completed,
                .failed,
                .workInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .workInProgress: return "WORK_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReportStatus(rawValue: rawValue) ?? ReportStatus.sdkUnknown(rawValue)
        }
    }
}

extension InspectorClientTypes {
    public enum ReportType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case finding
        case full
        case sdkUnknown(Swift.String)

        public static var allCases: [ReportType] {
            return [
                .finding,
                .full,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .finding: return "FINDING"
            case .full: return "FULL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReportType(rawValue: rawValue) ?? ReportType.sdkUnknown(rawValue)
        }
    }
}

extension InspectorClientTypes.ResourceGroup: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for resourcegrouptags0 in tags {
                try tagsContainer.encode(resourcegrouptags0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([InspectorClientTypes.ResourceGroupTag?].self, forKey: .tags)
        var tagsDecoded0:[InspectorClientTypes.ResourceGroupTag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [InspectorClientTypes.ResourceGroupTag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension InspectorClientTypes.ResourceGroup: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceGroup(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), tags: \(Swift.String(describing: tags)))"}
}

extension InspectorClientTypes {
    /// Contains information about a resource group. The resource group defines a set of tags
    ///          that, when queried, identify the AWS resources that make up the assessment target. This
    ///          data type is used as the response element in the DescribeResourceGroups
    ///          action.
    public struct ResourceGroup: Swift.Equatable {
        /// The ARN of the resource group.
        /// This member is required.
        public var arn: Swift.String?
        /// The time at which resource group is created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The tags (key and value pairs) of the resource group. This data type property is used
        ///          in the CreateResourceGroup action.
        /// This member is required.
        public var tags: [InspectorClientTypes.ResourceGroupTag]?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            tags: [InspectorClientTypes.ResourceGroupTag]? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.tags = tags
        }
    }

}

extension InspectorClientTypes.ResourceGroupTag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension InspectorClientTypes.ResourceGroupTag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceGroupTag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension InspectorClientTypes {
    /// This data type is used as one of the elements of the ResourceGroup
    ///          data type.
    public struct ResourceGroupTag: Swift.Equatable {
        /// A tag key.
        /// This member is required.
        public var key: Swift.String?
        /// The value assigned to a tag key.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension InspectorClientTypes.RulesPackage: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case description
        case name
        case provider
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let provider = provider {
            try encodeContainer.encode(provider, forKey: .provider)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let providerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provider)
        provider = providerDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension InspectorClientTypes.RulesPackage: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RulesPackage(arn: \(Swift.String(describing: arn)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), provider: \(Swift.String(describing: provider)), version: \(Swift.String(describing: version)))"}
}

extension InspectorClientTypes {
    /// Contains information about an Amazon Inspector rules package. This data type is used
    ///          as the response element in the DescribeRulesPackages action.
    public struct RulesPackage: Swift.Equatable {
        /// The ARN of the rules package.
        /// This member is required.
        public var arn: Swift.String?
        /// The description of the rules package.
        public var description: Swift.String?
        /// The name of the rules package.
        /// This member is required.
        public var name: Swift.String?
        /// The provider of the rules package.
        /// This member is required.
        public var provider: Swift.String?
        /// The version ID of the rules package.
        /// This member is required.
        public var version: Swift.String?

        public init (
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            provider: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.name = name
            self.provider = provider
            self.version = version
        }
    }

}

extension InspectorClientTypes.Scope: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.ScopeType.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension InspectorClientTypes.Scope: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Scope(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension InspectorClientTypes {
    /// This data type contains key-value pairs that identify various Amazon
    ///          resources.
    public struct Scope: Swift.Equatable {
        /// The type of the scope.
        public var key: InspectorClientTypes.ScopeType?
        /// The resource identifier for the specified scope type.
        public var value: Swift.String?

        public init (
            key: InspectorClientTypes.ScopeType? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension InspectorClientTypes {
    public enum ScopeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case instanceId
        case rulesPackageArn
        case sdkUnknown(Swift.String)

        public static var allCases: [ScopeType] {
            return [
                .instanceId,
                .rulesPackageArn,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .instanceId: return "INSTANCE_ID"
            case .rulesPackageArn: return "RULES_PACKAGE_ARN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScopeType(rawValue: rawValue) ?? ScopeType.sdkUnknown(rawValue)
        }
    }
}

extension InspectorClientTypes.SecurityGroup: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId
        case groupName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let groupName = groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
    }
}

extension InspectorClientTypes.SecurityGroup: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SecurityGroup(groupId: \(Swift.String(describing: groupId)), groupName: \(Swift.String(describing: groupName)))"}
}

extension InspectorClientTypes {
    /// Contains information about a security group associated with a network interface. This
    ///          data type is used as one of the elements of the NetworkInterface data
    ///          type.
    public struct SecurityGroup: Swift.Equatable {
        /// The ID of the security group.
        public var groupId: Swift.String?
        /// The name of the security group.
        public var groupName: Swift.String?

        public init (
            groupId: Swift.String? = nil,
            groupName: Swift.String? = nil
        )
        {
            self.groupId = groupId
            self.groupName = groupName
        }
    }

}

extension ServiceTemporarilyUnavailableException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceTemporarilyUnavailableException(canRetry: \(Swift.String(describing: canRetry)), message: \(Swift.String(describing: message)))"}
}

extension ServiceTemporarilyUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceTemporarilyUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.canRetry = output.canRetry
            self.message = output.message
        } else {
            self.canRetry = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The serice is temporary unavailable.
public struct ServiceTemporarilyUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// You can wait and then retry your request.
    /// This member is required.
    public var canRetry: Swift.Bool?
    /// Details of the exception error.
    /// This member is required.
    public var message: Swift.String?

    public init (
        canRetry: Swift.Bool? = nil,
        message: Swift.String? = nil
    )
    {
        self.canRetry = canRetry
        self.message = message
    }
}

struct ServiceTemporarilyUnavailableExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let canRetry: Swift.Bool?
}

extension ServiceTemporarilyUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case canRetry
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let canRetryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .canRetry)
        canRetry = canRetryDecoded
    }
}

public struct SetTagsForResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetTagsForResourceOutputError>
}

extension SetTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SetTagsForResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension SetTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct SetTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetTagsForResourceOutputError>
}

public struct SetTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetTagsForResourceOutputError>
}

public struct SetTagsForResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetTagsForResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SetTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = SetTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<SetTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetTagsForResourceOutputError>
}

public struct SetTagsForResourceInput: Swift.Equatable {
    /// The ARN of the assessment template that you want to set tags to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A collection of key and value pairs that you want to set to the assessment
    ///          template.
    public var tags: [InspectorClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [InspectorClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct SetTagsForResourceInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
    public let tags: [InspectorClientTypes.Tag]?
}

extension SetTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([InspectorClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[InspectorClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [InspectorClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension SetTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SetTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceTemporarilyUnavailableException" : self = .serviceTemporarilyUnavailableException(try ServiceTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceTemporarilyUnavailableException(ServiceTemporarilyUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SetTagsForResourceOutputResponse()"}
}

extension SetTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct SetTagsForResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct SetTagsForResourceOutputResponseBody: Swift.Equatable {
}

extension SetTagsForResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension InspectorClientTypes {
    public enum Severity: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case high
        case informational
        case low
        case medium
        case undefined
        case sdkUnknown(Swift.String)

        public static var allCases: [Severity] {
            return [
                .high,
                .informational,
                .low,
                .medium,
                .undefined,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .high: return "High"
            case .informational: return "Informational"
            case .low: return "Low"
            case .medium: return "Medium"
            case .undefined: return "Undefined"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Severity(rawValue: rawValue) ?? Severity.sdkUnknown(rawValue)
        }
    }
}

public struct StartAssessmentRunInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartAssessmentRunInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartAssessmentRunInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartAssessmentRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartAssessmentRunInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartAssessmentRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartAssessmentRunOutputError>
}

extension StartAssessmentRunInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartAssessmentRunInput(assessmentRunName: \(Swift.String(describing: assessmentRunName)), assessmentTemplateArn: \(Swift.String(describing: assessmentTemplateArn)))"}
}

extension StartAssessmentRunInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentRunName
        case assessmentTemplateArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentRunName = assessmentRunName {
            try encodeContainer.encode(assessmentRunName, forKey: .assessmentRunName)
        }
        if let assessmentTemplateArn = assessmentTemplateArn {
            try encodeContainer.encode(assessmentTemplateArn, forKey: .assessmentTemplateArn)
        }
    }
}

public struct StartAssessmentRunInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartAssessmentRunInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartAssessmentRunInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartAssessmentRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartAssessmentRunInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartAssessmentRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartAssessmentRunOutputError>
}

public struct StartAssessmentRunInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartAssessmentRunInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartAssessmentRunInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartAssessmentRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartAssessmentRunInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartAssessmentRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartAssessmentRunOutputError>
}

public struct StartAssessmentRunInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartAssessmentRunInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: StartAssessmentRunInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartAssessmentRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartAssessmentRunInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartAssessmentRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartAssessmentRunOutputError>
}

public struct StartAssessmentRunInput: Swift.Equatable {
    /// You can specify the name for the assessment run. The name must be unique for the
    ///          assessment template whose ARN is used to start the assessment run.
    public var assessmentRunName: Swift.String?
    /// The ARN of the assessment template of the assessment run that you want to
    ///          start.
    /// This member is required.
    public var assessmentTemplateArn: Swift.String?

    public init (
        assessmentRunName: Swift.String? = nil,
        assessmentTemplateArn: Swift.String? = nil
    )
    {
        self.assessmentRunName = assessmentRunName
        self.assessmentTemplateArn = assessmentTemplateArn
    }
}

struct StartAssessmentRunInputBody: Swift.Equatable {
    public let assessmentTemplateArn: Swift.String?
    public let assessmentRunName: Swift.String?
}

extension StartAssessmentRunInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentRunName
        case assessmentTemplateArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentTemplateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentTemplateArn)
        assessmentTemplateArn = assessmentTemplateArnDecoded
        let assessmentRunNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentRunName)
        assessmentRunName = assessmentRunNameDecoded
    }
}

extension StartAssessmentRunOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartAssessmentRunOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AgentsAlreadyRunningAssessmentException" : self = .agentsAlreadyRunningAssessmentException(try AgentsAlreadyRunningAssessmentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCrossAccountRoleException" : self = .invalidCrossAccountRoleException(try InvalidCrossAccountRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceTemporarilyUnavailableException" : self = .serviceTemporarilyUnavailableException(try ServiceTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartAssessmentRunOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case agentsAlreadyRunningAssessmentException(AgentsAlreadyRunningAssessmentException)
    case internalException(InternalException)
    case invalidCrossAccountRoleException(InvalidCrossAccountRoleException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceTemporarilyUnavailableException(ServiceTemporarilyUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartAssessmentRunOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartAssessmentRunOutputResponse(assessmentRunArn: \(Swift.String(describing: assessmentRunArn)))"}
}

extension StartAssessmentRunOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartAssessmentRunOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assessmentRunArn = output.assessmentRunArn
        } else {
            self.assessmentRunArn = nil
        }
    }
}

public struct StartAssessmentRunOutputResponse: Swift.Equatable {
    /// The ARN of the assessment run that has been started.
    /// This member is required.
    public var assessmentRunArn: Swift.String?

    public init (
        assessmentRunArn: Swift.String? = nil
    )
    {
        self.assessmentRunArn = assessmentRunArn
    }
}

struct StartAssessmentRunOutputResponseBody: Swift.Equatable {
    public let assessmentRunArn: Swift.String?
}

extension StartAssessmentRunOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentRunArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentRunArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentRunArn)
        assessmentRunArn = assessmentRunArnDecoded
    }
}

extension InspectorClientTypes {
    public enum StopAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case skipEvaluation
        case startEvaluation
        case sdkUnknown(Swift.String)

        public static var allCases: [StopAction] {
            return [
                .skipEvaluation,
                .startEvaluation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .skipEvaluation: return "SKIP_EVALUATION"
            case .startEvaluation: return "START_EVALUATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StopAction(rawValue: rawValue) ?? StopAction.sdkUnknown(rawValue)
        }
    }
}

public struct StopAssessmentRunInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopAssessmentRunInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopAssessmentRunInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopAssessmentRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopAssessmentRunInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopAssessmentRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopAssessmentRunOutputError>
}

extension StopAssessmentRunInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopAssessmentRunInput(assessmentRunArn: \(Swift.String(describing: assessmentRunArn)), stopAction: \(Swift.String(describing: stopAction)))"}
}

extension StopAssessmentRunInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentRunArn
        case stopAction
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentRunArn = assessmentRunArn {
            try encodeContainer.encode(assessmentRunArn, forKey: .assessmentRunArn)
        }
        if let stopAction = stopAction {
            try encodeContainer.encode(stopAction.rawValue, forKey: .stopAction)
        }
    }
}

public struct StopAssessmentRunInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopAssessmentRunInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopAssessmentRunInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopAssessmentRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopAssessmentRunInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopAssessmentRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopAssessmentRunOutputError>
}

public struct StopAssessmentRunInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopAssessmentRunInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopAssessmentRunInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopAssessmentRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopAssessmentRunInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopAssessmentRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopAssessmentRunOutputError>
}

public struct StopAssessmentRunInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopAssessmentRunInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: StopAssessmentRunInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopAssessmentRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StopAssessmentRunInput
    public typealias MOutput = ClientRuntime.OperationOutput<StopAssessmentRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopAssessmentRunOutputError>
}

public struct StopAssessmentRunInput: Swift.Equatable {
    /// The ARN of the assessment run that you want to stop.
    /// This member is required.
    public var assessmentRunArn: Swift.String?
    /// An input option that can be set to either START_EVALUATION or SKIP_EVALUATION.
    ///          START_EVALUATION (the default value), stops the AWS agent from collecting data and begins
    ///          the results evaluation and the findings generation process. SKIP_EVALUATION cancels the
    ///          assessment run immediately, after which no findings are generated.
    public var stopAction: InspectorClientTypes.StopAction?

    public init (
        assessmentRunArn: Swift.String? = nil,
        stopAction: InspectorClientTypes.StopAction? = nil
    )
    {
        self.assessmentRunArn = assessmentRunArn
        self.stopAction = stopAction
    }
}

struct StopAssessmentRunInputBody: Swift.Equatable {
    public let assessmentRunArn: Swift.String?
    public let stopAction: InspectorClientTypes.StopAction?
}

extension StopAssessmentRunInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentRunArn
        case stopAction
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentRunArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentRunArn)
        assessmentRunArn = assessmentRunArnDecoded
        let stopActionDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.StopAction.self, forKey: .stopAction)
        stopAction = stopActionDecoded
    }
}

extension StopAssessmentRunOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopAssessmentRunOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceTemporarilyUnavailableException" : self = .serviceTemporarilyUnavailableException(try ServiceTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopAssessmentRunOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceTemporarilyUnavailableException(ServiceTemporarilyUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopAssessmentRunOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopAssessmentRunOutputResponse()"}
}

extension StopAssessmentRunOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StopAssessmentRunOutputResponse: Swift.Equatable {

    public init() {}
}

struct StopAssessmentRunOutputResponseBody: Swift.Equatable {
}

extension StopAssessmentRunOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct SubscribeToEventInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SubscribeToEventInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SubscribeToEventInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SubscribeToEventOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SubscribeToEventInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SubscribeToEventOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SubscribeToEventOutputError>
}

extension SubscribeToEventInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubscribeToEventInput(event: \(Swift.String(describing: event)), resourceArn: \(Swift.String(describing: resourceArn)), topicArn: \(Swift.String(describing: topicArn)))"}
}

extension SubscribeToEventInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case event
        case resourceArn
        case topicArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let event = event {
            try encodeContainer.encode(event.rawValue, forKey: .event)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let topicArn = topicArn {
            try encodeContainer.encode(topicArn, forKey: .topicArn)
        }
    }
}

public struct SubscribeToEventInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SubscribeToEventInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SubscribeToEventInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SubscribeToEventOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SubscribeToEventInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SubscribeToEventOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SubscribeToEventOutputError>
}

public struct SubscribeToEventInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SubscribeToEventInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SubscribeToEventInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SubscribeToEventOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SubscribeToEventInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SubscribeToEventOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SubscribeToEventOutputError>
}

public struct SubscribeToEventInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SubscribeToEventInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SubscribeToEventInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SubscribeToEventOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = SubscribeToEventInput
    public typealias MOutput = ClientRuntime.OperationOutput<SubscribeToEventOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SubscribeToEventOutputError>
}

public struct SubscribeToEventInput: Swift.Equatable {
    /// The event for which you want to receive SNS notifications.
    /// This member is required.
    public var event: InspectorClientTypes.InspectorEvent?
    /// The ARN of the assessment template that is used during the event for which you want
    ///          to receive SNS notifications.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The ARN of the SNS topic to which the SNS notifications are sent.
    /// This member is required.
    public var topicArn: Swift.String?

    public init (
        event: InspectorClientTypes.InspectorEvent? = nil,
        resourceArn: Swift.String? = nil,
        topicArn: Swift.String? = nil
    )
    {
        self.event = event
        self.resourceArn = resourceArn
        self.topicArn = topicArn
    }
}

struct SubscribeToEventInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
    public let event: InspectorClientTypes.InspectorEvent?
    public let topicArn: Swift.String?
}

extension SubscribeToEventInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case event
        case resourceArn
        case topicArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let eventDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.InspectorEvent.self, forKey: .event)
        event = eventDecoded
        let topicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topicArn)
        topicArn = topicArnDecoded
    }
}

extension SubscribeToEventOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SubscribeToEventOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceTemporarilyUnavailableException" : self = .serviceTemporarilyUnavailableException(try ServiceTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SubscribeToEventOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceTemporarilyUnavailableException(ServiceTemporarilyUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SubscribeToEventOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubscribeToEventOutputResponse()"}
}

extension SubscribeToEventOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct SubscribeToEventOutputResponse: Swift.Equatable {

    public init() {}
}

struct SubscribeToEventOutputResponseBody: Swift.Equatable {
}

extension SubscribeToEventOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension InspectorClientTypes.Subscription: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSubscriptions
        case resourceArn
        case topicArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventSubscriptions = eventSubscriptions {
            var eventSubscriptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventSubscriptions)
            for eventsubscriptionlist0 in eventSubscriptions {
                try eventSubscriptionsContainer.encode(eventsubscriptionlist0)
            }
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let topicArn = topicArn {
            try encodeContainer.encode(topicArn, forKey: .topicArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let topicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topicArn)
        topicArn = topicArnDecoded
        let eventSubscriptionsContainer = try containerValues.decodeIfPresent([InspectorClientTypes.EventSubscription?].self, forKey: .eventSubscriptions)
        var eventSubscriptionsDecoded0:[InspectorClientTypes.EventSubscription]? = nil
        if let eventSubscriptionsContainer = eventSubscriptionsContainer {
            eventSubscriptionsDecoded0 = [InspectorClientTypes.EventSubscription]()
            for structure0 in eventSubscriptionsContainer {
                if let structure0 = structure0 {
                    eventSubscriptionsDecoded0?.append(structure0)
                }
            }
        }
        eventSubscriptions = eventSubscriptionsDecoded0
    }
}

extension InspectorClientTypes.Subscription: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Subscription(eventSubscriptions: \(Swift.String(describing: eventSubscriptions)), resourceArn: \(Swift.String(describing: resourceArn)), topicArn: \(Swift.String(describing: topicArn)))"}
}

extension InspectorClientTypes {
    /// This data type is used as a response element in the ListEventSubscriptions action.
    public struct Subscription: Swift.Equatable {
        /// The list of existing event subscriptions.
        /// This member is required.
        public var eventSubscriptions: [InspectorClientTypes.EventSubscription]?
        /// The ARN of the assessment template that is used during the event for which the SNS
        ///          notification is sent.
        /// This member is required.
        public var resourceArn: Swift.String?
        /// The ARN of the Amazon Simple Notification Service (SNS) topic to which the SNS
        ///          notifications are sent.
        /// This member is required.
        public var topicArn: Swift.String?

        public init (
            eventSubscriptions: [InspectorClientTypes.EventSubscription]? = nil,
            resourceArn: Swift.String? = nil,
            topicArn: Swift.String? = nil
        )
        {
            self.eventSubscriptions = eventSubscriptions
            self.resourceArn = resourceArn
            self.topicArn = topicArn
        }
    }

}

extension InspectorClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension InspectorClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension InspectorClientTypes {
    /// A key and value pair. This data type is used as a request parameter in the SetTagsForResource action and a response element in the ListTagsForResource action.
    public struct Tag: Swift.Equatable {
        /// A tag key.
        /// This member is required.
        public var key: Swift.String?
        /// A value assigned to a tag key.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension InspectorClientTypes.TelemetryMetadata: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case count
        case dataSize
        case messageType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let count = count {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let dataSize = dataSize {
            try encodeContainer.encode(dataSize, forKey: .dataSize)
        }
        if let messageType = messageType {
            try encodeContainer.encode(messageType, forKey: .messageType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageType)
        messageType = messageTypeDecoded
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count)
        count = countDecoded
        let dataSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dataSize)
        dataSize = dataSizeDecoded
    }
}

extension InspectorClientTypes.TelemetryMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TelemetryMetadata(count: \(Swift.String(describing: count)), dataSize: \(Swift.String(describing: dataSize)), messageType: \(Swift.String(describing: messageType)))"}
}

extension InspectorClientTypes {
    /// The metadata about the Amazon Inspector application data metrics collected by the
    ///          agent. This data type is used as the response element in the GetTelemetryMetadata action.
    public struct TelemetryMetadata: Swift.Equatable {
        /// The count of messages that the agent sends to the Amazon Inspector service.
        /// This member is required.
        public var count: Swift.Int?
        /// The data size of messages that the agent sends to the Amazon Inspector
        ///          service.
        public var dataSize: Swift.Int?
        /// A specific type of behavioral data that is collected by the agent.
        /// This member is required.
        public var messageType: Swift.String?

        public init (
            count: Swift.Int? = nil,
            dataSize: Swift.Int? = nil,
            messageType: Swift.String? = nil
        )
        {
            self.count = count
            self.dataSize = dataSize
            self.messageType = messageType
        }
    }

}

extension InspectorClientTypes.TimestampRange: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case beginDate
        case endDate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let beginDate = beginDate {
            try encodeContainer.encode(beginDate.timeIntervalSince1970, forKey: .beginDate)
        }
        if let endDate = endDate {
            try encodeContainer.encode(endDate.timeIntervalSince1970, forKey: .endDate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let beginDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .beginDate)
        beginDate = beginDateDecoded
        let endDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endDate)
        endDate = endDateDecoded
    }
}

extension InspectorClientTypes.TimestampRange: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TimestampRange(beginDate: \(Swift.String(describing: beginDate)), endDate: \(Swift.String(describing: endDate)))"}
}

extension InspectorClientTypes {
    /// This data type is used in the AssessmentRunFilter data
    ///          type.
    public struct TimestampRange: Swift.Equatable {
        /// The minimum value of the timestamp range.
        public var beginDate: ClientRuntime.Date?
        /// The maximum value of the timestamp range.
        public var endDate: ClientRuntime.Date?

        public init (
            beginDate: ClientRuntime.Date? = nil,
            endDate: ClientRuntime.Date? = nil
        )
        {
            self.beginDate = beginDate
            self.endDate = endDate
        }
    }

}

public struct UnsubscribeFromEventInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UnsubscribeFromEventInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UnsubscribeFromEventInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UnsubscribeFromEventOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UnsubscribeFromEventInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UnsubscribeFromEventOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UnsubscribeFromEventOutputError>
}

extension UnsubscribeFromEventInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnsubscribeFromEventInput(event: \(Swift.String(describing: event)), resourceArn: \(Swift.String(describing: resourceArn)), topicArn: \(Swift.String(describing: topicArn)))"}
}

extension UnsubscribeFromEventInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case event
        case resourceArn
        case topicArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let event = event {
            try encodeContainer.encode(event.rawValue, forKey: .event)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let topicArn = topicArn {
            try encodeContainer.encode(topicArn, forKey: .topicArn)
        }
    }
}

public struct UnsubscribeFromEventInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UnsubscribeFromEventInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UnsubscribeFromEventInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UnsubscribeFromEventOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UnsubscribeFromEventInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UnsubscribeFromEventOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UnsubscribeFromEventOutputError>
}

public struct UnsubscribeFromEventInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UnsubscribeFromEventInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UnsubscribeFromEventInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UnsubscribeFromEventOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UnsubscribeFromEventInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UnsubscribeFromEventOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UnsubscribeFromEventOutputError>
}

public struct UnsubscribeFromEventInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UnsubscribeFromEventInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UnsubscribeFromEventInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UnsubscribeFromEventOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UnsubscribeFromEventInput
    public typealias MOutput = ClientRuntime.OperationOutput<UnsubscribeFromEventOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UnsubscribeFromEventOutputError>
}

public struct UnsubscribeFromEventInput: Swift.Equatable {
    /// The event for which you want to stop receiving SNS notifications.
    /// This member is required.
    public var event: InspectorClientTypes.InspectorEvent?
    /// The ARN of the assessment template that is used during the event for which you want
    ///          to stop receiving SNS notifications.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The ARN of the SNS topic to which SNS notifications are sent.
    /// This member is required.
    public var topicArn: Swift.String?

    public init (
        event: InspectorClientTypes.InspectorEvent? = nil,
        resourceArn: Swift.String? = nil,
        topicArn: Swift.String? = nil
    )
    {
        self.event = event
        self.resourceArn = resourceArn
        self.topicArn = topicArn
    }
}

struct UnsubscribeFromEventInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
    public let event: InspectorClientTypes.InspectorEvent?
    public let topicArn: Swift.String?
}

extension UnsubscribeFromEventInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case event
        case resourceArn
        case topicArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let eventDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.InspectorEvent.self, forKey: .event)
        event = eventDecoded
        let topicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topicArn)
        topicArn = topicArnDecoded
    }
}

extension UnsubscribeFromEventOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UnsubscribeFromEventOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceTemporarilyUnavailableException" : self = .serviceTemporarilyUnavailableException(try ServiceTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UnsubscribeFromEventOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceTemporarilyUnavailableException(ServiceTemporarilyUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UnsubscribeFromEventOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnsubscribeFromEventOutputResponse()"}
}

extension UnsubscribeFromEventOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UnsubscribeFromEventOutputResponse: Swift.Equatable {

    public init() {}
}

struct UnsubscribeFromEventOutputResponseBody: Swift.Equatable {
}

extension UnsubscribeFromEventOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UnsupportedFeatureException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnsupportedFeatureException(canRetry: \(Swift.String(describing: canRetry)), message: \(Swift.String(describing: message)))"}
}

extension UnsupportedFeatureException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnsupportedFeatureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.canRetry = output.canRetry
            self.message = output.message
        } else {
            self.canRetry = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Used by the GetAssessmentReport API. The request was rejected
///          because you tried to generate a report for an assessment run that existed before reporting
///          was supported in Amazon Inspector. You can only generate reports for assessment runs that
///          took place or will take place after generating reports in Amazon Inspector became
///          available.
public struct UnsupportedFeatureException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var canRetry: Swift.Bool?
    /// This member is required.
    public var message: Swift.String?

    public init (
        canRetry: Swift.Bool? = nil,
        message: Swift.String? = nil
    )
    {
        self.canRetry = canRetry
        self.message = message
    }
}

struct UnsupportedFeatureExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let canRetry: Swift.Bool?
}

extension UnsupportedFeatureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case canRetry
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let canRetryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .canRetry)
        canRetry = canRetryDecoded
    }
}

public struct UpdateAssessmentTargetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAssessmentTargetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAssessmentTargetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAssessmentTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAssessmentTargetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAssessmentTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAssessmentTargetOutputError>
}

extension UpdateAssessmentTargetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAssessmentTargetInput(assessmentTargetArn: \(Swift.String(describing: assessmentTargetArn)), assessmentTargetName: \(Swift.String(describing: assessmentTargetName)), resourceGroupArn: \(Swift.String(describing: resourceGroupArn)))"}
}

extension UpdateAssessmentTargetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTargetArn
        case assessmentTargetName
        case resourceGroupArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentTargetArn = assessmentTargetArn {
            try encodeContainer.encode(assessmentTargetArn, forKey: .assessmentTargetArn)
        }
        if let assessmentTargetName = assessmentTargetName {
            try encodeContainer.encode(assessmentTargetName, forKey: .assessmentTargetName)
        }
        if let resourceGroupArn = resourceGroupArn {
            try encodeContainer.encode(resourceGroupArn, forKey: .resourceGroupArn)
        }
    }
}

public struct UpdateAssessmentTargetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAssessmentTargetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAssessmentTargetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAssessmentTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAssessmentTargetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAssessmentTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAssessmentTargetOutputError>
}

public struct UpdateAssessmentTargetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAssessmentTargetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAssessmentTargetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAssessmentTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAssessmentTargetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAssessmentTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAssessmentTargetOutputError>
}

public struct UpdateAssessmentTargetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAssessmentTargetInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateAssessmentTargetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAssessmentTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateAssessmentTargetInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAssessmentTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAssessmentTargetOutputError>
}

public struct UpdateAssessmentTargetInput: Swift.Equatable {
    /// The ARN of the assessment target that you want to update.
    /// This member is required.
    public var assessmentTargetArn: Swift.String?
    /// The name of the assessment target that you want to update.
    /// This member is required.
    public var assessmentTargetName: Swift.String?
    /// The ARN of the resource group that is used to specify the new resource group to
    ///          associate with the assessment target.
    public var resourceGroupArn: Swift.String?

    public init (
        assessmentTargetArn: Swift.String? = nil,
        assessmentTargetName: Swift.String? = nil,
        resourceGroupArn: Swift.String? = nil
    )
    {
        self.assessmentTargetArn = assessmentTargetArn
        self.assessmentTargetName = assessmentTargetName
        self.resourceGroupArn = resourceGroupArn
    }
}

struct UpdateAssessmentTargetInputBody: Swift.Equatable {
    public let assessmentTargetArn: Swift.String?
    public let assessmentTargetName: Swift.String?
    public let resourceGroupArn: Swift.String?
}

extension UpdateAssessmentTargetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTargetArn
        case assessmentTargetName
        case resourceGroupArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentTargetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentTargetArn)
        assessmentTargetArn = assessmentTargetArnDecoded
        let assessmentTargetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentTargetName)
        assessmentTargetName = assessmentTargetNameDecoded
        let resourceGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupArn)
        resourceGroupArn = resourceGroupArnDecoded
    }
}

extension UpdateAssessmentTargetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAssessmentTargetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceTemporarilyUnavailableException" : self = .serviceTemporarilyUnavailableException(try ServiceTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAssessmentTargetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceTemporarilyUnavailableException(ServiceTemporarilyUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAssessmentTargetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAssessmentTargetOutputResponse()"}
}

extension UpdateAssessmentTargetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateAssessmentTargetOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateAssessmentTargetOutputResponseBody: Swift.Equatable {
}

extension UpdateAssessmentTargetOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}
