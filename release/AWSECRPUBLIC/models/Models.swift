// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension EcrPublicClientTypes.AuthorizationData: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizationToken
        case expiresAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizationToken = authorizationToken {
            try encodeContainer.encode(authorizationToken, forKey: .authorizationToken)
        }
        if let expiresAt = expiresAt {
            try encodeContainer.encode(expiresAt.timeIntervalSince1970, forKey: .expiresAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizationTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizationToken)
        authorizationToken = authorizationTokenDecoded
        let expiresAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .expiresAt)
        expiresAt = expiresAtDecoded
    }
}

extension EcrPublicClientTypes.AuthorizationData: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AuthorizationData(authorizationToken: \(Swift.String(describing: authorizationToken)), expiresAt: \(Swift.String(describing: expiresAt)))"}
}

extension EcrPublicClientTypes {
    /// An authorization token data object that corresponds to a public registry.
    public struct AuthorizationData: Swift.Equatable {
        /// A base64-encoded string that contains authorization data for a public Amazon ECR registry.
        ///          When the string is decoded, it is presented in the format user:password for
        ///          public registry authentication using docker login.
        public var authorizationToken: Swift.String?
        /// The Unix time in seconds and milliseconds when the authorization token expires.
        ///          Authorization tokens are valid for 12 hours.
        public var expiresAt: ClientRuntime.Date?

        public init (
            authorizationToken: Swift.String? = nil,
            expiresAt: ClientRuntime.Date? = nil
        )
        {
            self.authorizationToken = authorizationToken
            self.expiresAt = expiresAt
        }
    }

}

public struct BatchCheckLayerAvailabilityInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchCheckLayerAvailabilityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchCheckLayerAvailabilityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchCheckLayerAvailabilityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchCheckLayerAvailabilityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchCheckLayerAvailabilityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchCheckLayerAvailabilityOutputError>
}

extension BatchCheckLayerAvailabilityInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchCheckLayerAvailabilityInput(layerDigests: \(Swift.String(describing: layerDigests)), registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)))"}
}

extension BatchCheckLayerAvailabilityInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerDigests
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let layerDigests = layerDigests {
            var layerDigestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .layerDigests)
            for batchedoperationlayerdigestlist0 in layerDigests {
                try layerDigestsContainer.encode(batchedoperationlayerdigestlist0)
            }
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct BatchCheckLayerAvailabilityInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchCheckLayerAvailabilityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchCheckLayerAvailabilityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchCheckLayerAvailabilityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchCheckLayerAvailabilityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchCheckLayerAvailabilityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchCheckLayerAvailabilityOutputError>
}

public struct BatchCheckLayerAvailabilityInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchCheckLayerAvailabilityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchCheckLayerAvailabilityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchCheckLayerAvailabilityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchCheckLayerAvailabilityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchCheckLayerAvailabilityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchCheckLayerAvailabilityOutputError>
}

public struct BatchCheckLayerAvailabilityInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchCheckLayerAvailabilityInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: BatchCheckLayerAvailabilityInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchCheckLayerAvailabilityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BatchCheckLayerAvailabilityInput
    public typealias MOutput = ClientRuntime.OperationOutput<BatchCheckLayerAvailabilityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchCheckLayerAvailabilityOutputError>
}

public struct BatchCheckLayerAvailabilityInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchCheckLayerAvailabilityInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: BatchCheckLayerAvailabilityInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchCheckLayerAvailabilityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BatchCheckLayerAvailabilityInput
    public typealias MOutput = ClientRuntime.OperationOutput<BatchCheckLayerAvailabilityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchCheckLayerAvailabilityOutputError>
}

public struct BatchCheckLayerAvailabilityInput: Swift.Equatable {
    /// The digests of the image layers to check.
    /// This member is required.
    public var layerDigests: [Swift.String]?
    /// The AWS account ID associated with the public registry that contains the image layers to
    ///          check. If you do not specify a registry, the default public registry is assumed.
    public var registryId: Swift.String?
    /// The name of the repository that is associated with the image layers to check.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init (
        layerDigests: [Swift.String]? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.layerDigests = layerDigests
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct BatchCheckLayerAvailabilityInputBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryName: Swift.String?
    public let layerDigests: [Swift.String]?
}

extension BatchCheckLayerAvailabilityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerDigests
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let layerDigestsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .layerDigests)
        var layerDigestsDecoded0:[Swift.String]? = nil
        if let layerDigestsContainer = layerDigestsContainer {
            layerDigestsDecoded0 = [Swift.String]()
            for string0 in layerDigestsContainer {
                if let string0 = string0 {
                    layerDigestsDecoded0?.append(string0)
                }
            }
        }
        layerDigests = layerDigestsDecoded0
    }
}

extension BatchCheckLayerAvailabilityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchCheckLayerAvailabilityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RegistryNotFoundException" : self = .registryNotFoundException(try RegistryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchCheckLayerAvailabilityOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case registryNotFoundException(RegistryNotFoundException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchCheckLayerAvailabilityOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchCheckLayerAvailabilityOutputResponse(failures: \(Swift.String(describing: failures)), layers: \(Swift.String(describing: layers)))"}
}

extension BatchCheckLayerAvailabilityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchCheckLayerAvailabilityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failures = output.failures
            self.layers = output.layers
        } else {
            self.failures = nil
            self.layers = nil
        }
    }
}

public struct BatchCheckLayerAvailabilityOutputResponse: Swift.Equatable {
    /// Any failures associated with the call.
    public var failures: [EcrPublicClientTypes.LayerFailure]?
    /// A list of image layer objects corresponding to the image layer references in the
    ///          request.
    public var layers: [EcrPublicClientTypes.Layer]?

    public init (
        failures: [EcrPublicClientTypes.LayerFailure]? = nil,
        layers: [EcrPublicClientTypes.Layer]? = nil
    )
    {
        self.failures = failures
        self.layers = layers
    }
}

struct BatchCheckLayerAvailabilityOutputResponseBody: Swift.Equatable {
    public let layers: [EcrPublicClientTypes.Layer]?
    public let failures: [EcrPublicClientTypes.LayerFailure]?
}

extension BatchCheckLayerAvailabilityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failures
        case layers
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layersContainer = try containerValues.decodeIfPresent([EcrPublicClientTypes.Layer?].self, forKey: .layers)
        var layersDecoded0:[EcrPublicClientTypes.Layer]? = nil
        if let layersContainer = layersContainer {
            layersDecoded0 = [EcrPublicClientTypes.Layer]()
            for structure0 in layersContainer {
                if let structure0 = structure0 {
                    layersDecoded0?.append(structure0)
                }
            }
        }
        layers = layersDecoded0
        let failuresContainer = try containerValues.decodeIfPresent([EcrPublicClientTypes.LayerFailure?].self, forKey: .failures)
        var failuresDecoded0:[EcrPublicClientTypes.LayerFailure]? = nil
        if let failuresContainer = failuresContainer {
            failuresDecoded0 = [EcrPublicClientTypes.LayerFailure]()
            for structure0 in failuresContainer {
                if let structure0 = structure0 {
                    failuresDecoded0?.append(structure0)
                }
            }
        }
        failures = failuresDecoded0
    }
}

public struct BatchDeleteImageInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDeleteImageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchDeleteImageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDeleteImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchDeleteImageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDeleteImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDeleteImageOutputError>
}

extension BatchDeleteImageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchDeleteImageInput(imageIds: \(Swift.String(describing: imageIds)), registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)))"}
}

extension BatchDeleteImageInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageIds
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageIds = imageIds {
            var imageIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .imageIds)
            for imageidentifierlist0 in imageIds {
                try imageIdsContainer.encode(imageidentifierlist0)
            }
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct BatchDeleteImageInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDeleteImageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchDeleteImageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDeleteImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchDeleteImageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDeleteImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDeleteImageOutputError>
}

public struct BatchDeleteImageInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDeleteImageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchDeleteImageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDeleteImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchDeleteImageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDeleteImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDeleteImageOutputError>
}

public struct BatchDeleteImageInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDeleteImageInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: BatchDeleteImageInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDeleteImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BatchDeleteImageInput
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDeleteImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDeleteImageOutputError>
}

public struct BatchDeleteImageInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDeleteImageInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: BatchDeleteImageInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDeleteImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BatchDeleteImageInput
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDeleteImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDeleteImageOutputError>
}

public struct BatchDeleteImageInput: Swift.Equatable {
    /// A list of image ID references that correspond to images to delete. The format of the
    ///             imageIds reference is imageTag=tag or
    ///             imageDigest=digest.
    /// This member is required.
    public var imageIds: [EcrPublicClientTypes.ImageIdentifier]?
    /// The AWS account ID associated with the registry that contains the image to delete.
    ///          If you do not specify a registry, the default public registry is assumed.
    public var registryId: Swift.String?
    /// The repository in a public registry that contains the image to delete.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init (
        imageIds: [EcrPublicClientTypes.ImageIdentifier]? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.imageIds = imageIds
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct BatchDeleteImageInputBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryName: Swift.String?
    public let imageIds: [EcrPublicClientTypes.ImageIdentifier]?
}

extension BatchDeleteImageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageIds
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageIdsContainer = try containerValues.decodeIfPresent([EcrPublicClientTypes.ImageIdentifier?].self, forKey: .imageIds)
        var imageIdsDecoded0:[EcrPublicClientTypes.ImageIdentifier]? = nil
        if let imageIdsContainer = imageIdsContainer {
            imageIdsDecoded0 = [EcrPublicClientTypes.ImageIdentifier]()
            for structure0 in imageIdsContainer {
                if let structure0 = structure0 {
                    imageIdsDecoded0?.append(structure0)
                }
            }
        }
        imageIds = imageIdsDecoded0
    }
}

extension BatchDeleteImageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDeleteImageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchDeleteImageOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDeleteImageOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchDeleteImageOutputResponse(failures: \(Swift.String(describing: failures)), imageIds: \(Swift.String(describing: imageIds)))"}
}

extension BatchDeleteImageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchDeleteImageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failures = output.failures
            self.imageIds = output.imageIds
        } else {
            self.failures = nil
            self.imageIds = nil
        }
    }
}

public struct BatchDeleteImageOutputResponse: Swift.Equatable {
    /// Any failures associated with the call.
    public var failures: [EcrPublicClientTypes.ImageFailure]?
    /// The image IDs of the deleted images.
    public var imageIds: [EcrPublicClientTypes.ImageIdentifier]?

    public init (
        failures: [EcrPublicClientTypes.ImageFailure]? = nil,
        imageIds: [EcrPublicClientTypes.ImageIdentifier]? = nil
    )
    {
        self.failures = failures
        self.imageIds = imageIds
    }
}

struct BatchDeleteImageOutputResponseBody: Swift.Equatable {
    public let imageIds: [EcrPublicClientTypes.ImageIdentifier]?
    public let failures: [EcrPublicClientTypes.ImageFailure]?
}

extension BatchDeleteImageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failures
        case imageIds
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageIdsContainer = try containerValues.decodeIfPresent([EcrPublicClientTypes.ImageIdentifier?].self, forKey: .imageIds)
        var imageIdsDecoded0:[EcrPublicClientTypes.ImageIdentifier]? = nil
        if let imageIdsContainer = imageIdsContainer {
            imageIdsDecoded0 = [EcrPublicClientTypes.ImageIdentifier]()
            for structure0 in imageIdsContainer {
                if let structure0 = structure0 {
                    imageIdsDecoded0?.append(structure0)
                }
            }
        }
        imageIds = imageIdsDecoded0
        let failuresContainer = try containerValues.decodeIfPresent([EcrPublicClientTypes.ImageFailure?].self, forKey: .failures)
        var failuresDecoded0:[EcrPublicClientTypes.ImageFailure]? = nil
        if let failuresContainer = failuresContainer {
            failuresDecoded0 = [EcrPublicClientTypes.ImageFailure]()
            for structure0 in failuresContainer {
                if let structure0 = structure0 {
                    failuresDecoded0?.append(structure0)
                }
            }
        }
        failures = failuresDecoded0
    }
}

public struct CompleteLayerUploadInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CompleteLayerUploadInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CompleteLayerUploadInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CompleteLayerUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CompleteLayerUploadInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CompleteLayerUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CompleteLayerUploadOutputError>
}

extension CompleteLayerUploadInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CompleteLayerUploadInput(layerDigests: \(Swift.String(describing: layerDigests)), registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)), uploadId: \(Swift.String(describing: uploadId)))"}
}

extension CompleteLayerUploadInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerDigests
        case registryId
        case repositoryName
        case uploadId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let layerDigests = layerDigests {
            var layerDigestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .layerDigests)
            for layerdigestlist0 in layerDigests {
                try layerDigestsContainer.encode(layerdigestlist0)
            }
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let uploadId = uploadId {
            try encodeContainer.encode(uploadId, forKey: .uploadId)
        }
    }
}

public struct CompleteLayerUploadInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CompleteLayerUploadInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CompleteLayerUploadInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CompleteLayerUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CompleteLayerUploadInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CompleteLayerUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CompleteLayerUploadOutputError>
}

public struct CompleteLayerUploadInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CompleteLayerUploadInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CompleteLayerUploadInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CompleteLayerUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CompleteLayerUploadInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CompleteLayerUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CompleteLayerUploadOutputError>
}

public struct CompleteLayerUploadInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CompleteLayerUploadInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CompleteLayerUploadInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CompleteLayerUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CompleteLayerUploadInput
    public typealias MOutput = ClientRuntime.OperationOutput<CompleteLayerUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CompleteLayerUploadOutputError>
}

public struct CompleteLayerUploadInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CompleteLayerUploadInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CompleteLayerUploadInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CompleteLayerUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CompleteLayerUploadInput
    public typealias MOutput = ClientRuntime.OperationOutput<CompleteLayerUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CompleteLayerUploadOutputError>
}

public struct CompleteLayerUploadInput: Swift.Equatable {
    /// The sha256 digest of the image layer.
    /// This member is required.
    public var layerDigests: [Swift.String]?
    /// The AWS account ID associated with the registry to which to upload layers.
    ///          If you do not specify a registry, the default public registry is assumed.
    public var registryId: Swift.String?
    /// The name of the repository in a public registry to associate with the image
    ///          layer.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The upload ID from a previous InitiateLayerUpload operation to
    ///          associate with the image layer.
    /// This member is required.
    public var uploadId: Swift.String?

    public init (
        layerDigests: [Swift.String]? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        uploadId: Swift.String? = nil
    )
    {
        self.layerDigests = layerDigests
        self.registryId = registryId
        self.repositoryName = repositoryName
        self.uploadId = uploadId
    }
}

struct CompleteLayerUploadInputBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryName: Swift.String?
    public let uploadId: Swift.String?
    public let layerDigests: [Swift.String]?
}

extension CompleteLayerUploadInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerDigests
        case registryId
        case repositoryName
        case uploadId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let uploadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
        let layerDigestsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .layerDigests)
        var layerDigestsDecoded0:[Swift.String]? = nil
        if let layerDigestsContainer = layerDigestsContainer {
            layerDigestsDecoded0 = [Swift.String]()
            for string0 in layerDigestsContainer {
                if let string0 = string0 {
                    layerDigestsDecoded0?.append(string0)
                }
            }
        }
        layerDigests = layerDigestsDecoded0
    }
}

extension CompleteLayerUploadOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CompleteLayerUploadOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EmptyUploadException" : self = .emptyUploadException(try EmptyUploadException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLayerException" : self = .invalidLayerException(try InvalidLayerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LayerAlreadyExistsException" : self = .layerAlreadyExistsException(try LayerAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LayerPartTooSmallException" : self = .layerPartTooSmallException(try LayerPartTooSmallException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RegistryNotFoundException" : self = .registryNotFoundException(try RegistryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedCommandException" : self = .unsupportedCommandException(try UnsupportedCommandException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UploadNotFoundException" : self = .uploadNotFoundException(try UploadNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CompleteLayerUploadOutputError: Swift.Error, Swift.Equatable {
    case emptyUploadException(EmptyUploadException)
    case invalidLayerException(InvalidLayerException)
    case invalidParameterException(InvalidParameterException)
    case layerAlreadyExistsException(LayerAlreadyExistsException)
    case layerPartTooSmallException(LayerPartTooSmallException)
    case registryNotFoundException(RegistryNotFoundException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unsupportedCommandException(UnsupportedCommandException)
    case uploadNotFoundException(UploadNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CompleteLayerUploadOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CompleteLayerUploadOutputResponse(layerDigest: \(Swift.String(describing: layerDigest)), registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)), uploadId: \(Swift.String(describing: uploadId)))"}
}

extension CompleteLayerUploadOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CompleteLayerUploadOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.layerDigest = output.layerDigest
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
            self.uploadId = output.uploadId
        } else {
            self.layerDigest = nil
            self.registryId = nil
            self.repositoryName = nil
            self.uploadId = nil
        }
    }
}

public struct CompleteLayerUploadOutputResponse: Swift.Equatable {
    /// The sha256 digest of the image layer.
    public var layerDigest: Swift.String?
    /// The public registry ID associated with the request.
    public var registryId: Swift.String?
    /// The repository name associated with the request.
    public var repositoryName: Swift.String?
    /// The upload ID associated with the layer.
    public var uploadId: Swift.String?

    public init (
        layerDigest: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        uploadId: Swift.String? = nil
    )
    {
        self.layerDigest = layerDigest
        self.registryId = registryId
        self.repositoryName = repositoryName
        self.uploadId = uploadId
    }
}

struct CompleteLayerUploadOutputResponseBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryName: Swift.String?
    public let uploadId: Swift.String?
    public let layerDigest: Swift.String?
}

extension CompleteLayerUploadOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerDigest
        case registryId
        case repositoryName
        case uploadId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let uploadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
        let layerDigestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerDigest)
        layerDigest = layerDigestDecoded
    }
}

public struct CreateRepositoryInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRepositoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRepositoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRepositoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRepositoryOutputError>
}

extension CreateRepositoryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateRepositoryInput(catalogData: \(Swift.String(describing: catalogData)), repositoryName: \(Swift.String(describing: repositoryName)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateRepositoryInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogData
        case repositoryName
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogData = catalogData {
            try encodeContainer.encode(catalogData, forKey: .catalogData)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateRepositoryInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRepositoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRepositoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRepositoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRepositoryOutputError>
}

public struct CreateRepositoryInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRepositoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRepositoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRepositoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRepositoryOutputError>
}

public struct CreateRepositoryInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRepositoryInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateRepositoryInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateRepositoryInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRepositoryOutputError>
}

public struct CreateRepositoryInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRepositoryInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateRepositoryInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateRepositoryInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRepositoryOutputError>
}

public struct CreateRepositoryInput: Swift.Equatable {
    /// The details about the repository that are publicly visible in the
    ///          Amazon ECR Public Gallery.
    public var catalogData: EcrPublicClientTypes.RepositoryCatalogDataInput?
    /// The name to use for the repository. This appears publicly in the Amazon ECR Public Gallery.
    ///          The repository name may be specified on its own (such as nginx-web-app) or it
    ///          can be prepended with a namespace to group the repository into a category (such as
    ///             project-a/nginx-web-app).
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The metadata that you apply to the repository to help you categorize and organize them.
    ///          Each tag consists of a key and an optional value, both of which you define.
    ///          Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
    public var tags: [EcrPublicClientTypes.Tag]?

    public init (
        catalogData: EcrPublicClientTypes.RepositoryCatalogDataInput? = nil,
        repositoryName: Swift.String? = nil,
        tags: [EcrPublicClientTypes.Tag]? = nil
    )
    {
        self.catalogData = catalogData
        self.repositoryName = repositoryName
        self.tags = tags
    }
}

struct CreateRepositoryInputBody: Swift.Equatable {
    public let repositoryName: Swift.String?
    public let catalogData: EcrPublicClientTypes.RepositoryCatalogDataInput?
    public let tags: [EcrPublicClientTypes.Tag]?
}

extension CreateRepositoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogData
        case repositoryName
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let catalogDataDecoded = try containerValues.decodeIfPresent(EcrPublicClientTypes.RepositoryCatalogDataInput.self, forKey: .catalogData)
        catalogData = catalogDataDecoded
        let tagsContainer = try containerValues.decodeIfPresent([EcrPublicClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[EcrPublicClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [EcrPublicClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRepositoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRepositoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagParameterException" : self = .invalidTagParameterException(try InvalidTagParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryAlreadyExistsException" : self = .repositoryAlreadyExistsException(try RepositoryAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRepositoryOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case invalidTagParameterException(InvalidTagParameterException)
    case limitExceededException(LimitExceededException)
    case repositoryAlreadyExistsException(RepositoryAlreadyExistsException)
    case serverException(ServerException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRepositoryOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateRepositoryOutputResponse(catalogData: \(Swift.String(describing: catalogData)), repository: \(Swift.String(describing: repository)))"}
}

extension CreateRepositoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateRepositoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.catalogData = output.catalogData
            self.repository = output.repository
        } else {
            self.catalogData = nil
            self.repository = nil
        }
    }
}

public struct CreateRepositoryOutputResponse: Swift.Equatable {
    /// The catalog data for a repository. This data is publicly visible in the
    ///          Amazon ECR Public Gallery.
    public var catalogData: EcrPublicClientTypes.RepositoryCatalogData?
    /// The repository that was created.
    public var repository: EcrPublicClientTypes.Repository?

    public init (
        catalogData: EcrPublicClientTypes.RepositoryCatalogData? = nil,
        repository: EcrPublicClientTypes.Repository? = nil
    )
    {
        self.catalogData = catalogData
        self.repository = repository
    }
}

struct CreateRepositoryOutputResponseBody: Swift.Equatable {
    public let repository: EcrPublicClientTypes.Repository?
    public let catalogData: EcrPublicClientTypes.RepositoryCatalogData?
}

extension CreateRepositoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogData
        case repository
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryDecoded = try containerValues.decodeIfPresent(EcrPublicClientTypes.Repository.self, forKey: .repository)
        repository = repositoryDecoded
        let catalogDataDecoded = try containerValues.decodeIfPresent(EcrPublicClientTypes.RepositoryCatalogData.self, forKey: .catalogData)
        catalogData = catalogDataDecoded
    }
}

public struct DeleteRepositoryInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRepositoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRepositoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRepositoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRepositoryOutputError>
}

extension DeleteRepositoryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteRepositoryInput(force: \(Swift.String(describing: force)), registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)))"}
}

extension DeleteRepositoryInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case force
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if force != false {
            try encodeContainer.encode(force, forKey: .force)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct DeleteRepositoryInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRepositoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRepositoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRepositoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRepositoryOutputError>
}

public struct DeleteRepositoryInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRepositoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRepositoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRepositoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRepositoryOutputError>
}

public struct DeleteRepositoryInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRepositoryInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteRepositoryInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteRepositoryInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRepositoryOutputError>
}

public struct DeleteRepositoryInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRepositoryInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteRepositoryInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteRepositoryInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRepositoryOutputError>
}

public struct DeleteRepositoryInput: Swift.Equatable {
    ///  If a repository contains images, forces the deletion.
    public var force: Swift.Bool
    /// The AWS account ID associated with the public registry that contains the repository to
    ///          delete. If you do not specify a registry, the default public registry is assumed.
    public var registryId: Swift.String?
    /// The name of the repository to delete.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init (
        force: Swift.Bool = false,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.force = force
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct DeleteRepositoryInputBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryName: Swift.String?
    public let force: Swift.Bool
}

extension DeleteRepositoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case force
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let forceDecoded = try containerValues.decode(Swift.Bool.self, forKey: .force)
        force = forceDecoded
    }
}

extension DeleteRepositoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRepositoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotEmptyException" : self = .repositoryNotEmptyException(try RepositoryNotEmptyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRepositoryOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case repositoryNotEmptyException(RepositoryNotEmptyException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRepositoryOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteRepositoryOutputResponse(repository: \(Swift.String(describing: repository)))"}
}

extension DeleteRepositoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteRepositoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.repository = output.repository
        } else {
            self.repository = nil
        }
    }
}

public struct DeleteRepositoryOutputResponse: Swift.Equatable {
    /// The repository that was deleted.
    public var repository: EcrPublicClientTypes.Repository?

    public init (
        repository: EcrPublicClientTypes.Repository? = nil
    )
    {
        self.repository = repository
    }
}

struct DeleteRepositoryOutputResponseBody: Swift.Equatable {
    public let repository: EcrPublicClientTypes.Repository?
}

extension DeleteRepositoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repository
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryDecoded = try containerValues.decodeIfPresent(EcrPublicClientTypes.Repository.self, forKey: .repository)
        repository = repositoryDecoded
    }
}

public struct DeleteRepositoryPolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRepositoryPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRepositoryPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRepositoryPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRepositoryPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRepositoryPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRepositoryPolicyOutputError>
}

extension DeleteRepositoryPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteRepositoryPolicyInput(registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)))"}
}

extension DeleteRepositoryPolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct DeleteRepositoryPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRepositoryPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRepositoryPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRepositoryPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRepositoryPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRepositoryPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRepositoryPolicyOutputError>
}

public struct DeleteRepositoryPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRepositoryPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRepositoryPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRepositoryPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRepositoryPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRepositoryPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRepositoryPolicyOutputError>
}

public struct DeleteRepositoryPolicyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRepositoryPolicyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteRepositoryPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRepositoryPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteRepositoryPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRepositoryPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRepositoryPolicyOutputError>
}

public struct DeleteRepositoryPolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRepositoryPolicyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteRepositoryPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRepositoryPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteRepositoryPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRepositoryPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRepositoryPolicyOutputError>
}

public struct DeleteRepositoryPolicyInput: Swift.Equatable {
    /// The AWS account ID associated with the public registry that contains the repository
    ///          policy to delete. If you do not specify a registry, the default public registry is assumed.
    public var registryId: Swift.String?
    /// The name of the repository that is associated with the repository policy to
    ///          delete.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init (
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct DeleteRepositoryPolicyInputBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryName: Swift.String?
}

extension DeleteRepositoryPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
    }
}

extension DeleteRepositoryPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRepositoryPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryPolicyNotFoundException" : self = .repositoryPolicyNotFoundException(try RepositoryPolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRepositoryPolicyOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case repositoryPolicyNotFoundException(RepositoryPolicyNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRepositoryPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteRepositoryPolicyOutputResponse(policyText: \(Swift.String(describing: policyText)), registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)))"}
}

extension DeleteRepositoryPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteRepositoryPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policyText = output.policyText
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
        } else {
            self.policyText = nil
            self.registryId = nil
            self.repositoryName = nil
        }
    }
}

public struct DeleteRepositoryPolicyOutputResponse: Swift.Equatable {
    /// The JSON repository policy that was deleted from the repository.
    public var policyText: Swift.String?
    /// The registry ID associated with the request.
    public var registryId: Swift.String?
    /// The repository name associated with the request.
    public var repositoryName: Swift.String?

    public init (
        policyText: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.policyText = policyText
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct DeleteRepositoryPolicyOutputResponseBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryName: Swift.String?
    public let policyText: Swift.String?
}

extension DeleteRepositoryPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyText
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let policyTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyText)
        policyText = policyTextDecoded
    }
}

public struct DescribeImageTagsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeImageTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeImageTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeImageTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeImageTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeImageTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeImageTagsOutputError>
}

extension DescribeImageTagsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeImageTagsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)))"}
}

extension DescribeImageTagsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct DescribeImageTagsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeImageTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeImageTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeImageTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeImageTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeImageTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeImageTagsOutputError>
}

public struct DescribeImageTagsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeImageTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeImageTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeImageTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeImageTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeImageTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeImageTagsOutputError>
}

public struct DescribeImageTagsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeImageTagsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeImageTagsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeImageTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeImageTagsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeImageTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeImageTagsOutputError>
}

public struct DescribeImageTagsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeImageTagsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeImageTagsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeImageTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeImageTagsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeImageTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeImageTagsOutputError>
}

public struct DescribeImageTagsInput: Swift.Equatable {
    /// The maximum number of repository results returned by DescribeImageTags in
    ///          paginated output. When this parameter is used, DescribeImageTags only returns
    ///             maxResults results in a single page along with a nextToken
    ///          response element. The remaining results of the initial request can be seen by sending
    ///          another DescribeImageTags request with the returned nextToken
    ///          value. This value can be between 1 and 1000. If this parameter
    ///          is not used, then DescribeImageTags returns up to 100
    ///          results and a nextToken value, if applicable. This option cannot be used when
    ///          you specify images with imageIds.
    public var maxResults: Swift.Int?
    /// The nextToken value returned from a previous paginated
    ///             DescribeImageTags request where maxResults was used and the
    ///          results exceeded the value of that parameter. Pagination continues from the end of the
    ///          previous results that returned the nextToken value. This value is
    ///             null when there are no more results to return. This option cannot be used
    ///          when you specify images with imageIds.
    public var nextToken: Swift.String?
    /// The AWS account ID associated with the public registry that contains the repository in
    ///          which to describe images. If you do not specify a registry, the default public registry is assumed.
    public var registryId: Swift.String?
    /// The name of the repository that contains the image tag details to describe.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct DescribeImageTagsInputBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryName: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension DescribeImageTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeImageTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeImageTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeImageTagsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeImageTagsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeImageTagsOutputResponse(imageTagDetails: \(Swift.String(describing: imageTagDetails)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeImageTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeImageTagsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.imageTagDetails = output.imageTagDetails
            self.nextToken = output.nextToken
        } else {
            self.imageTagDetails = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeImageTagsOutputResponse: Swift.Equatable {
    /// The image tag details for the images in the requested repository.
    public var imageTagDetails: [EcrPublicClientTypes.ImageTagDetail]?
    /// The nextToken value to include in a future DescribeImageTags
    ///          request. When the results of a DescribeImageTags request exceed
    ///             maxResults, this value can be used to retrieve the next page of results.
    ///          This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init (
        imageTagDetails: [EcrPublicClientTypes.ImageTagDetail]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.imageTagDetails = imageTagDetails
        self.nextToken = nextToken
    }
}

struct DescribeImageTagsOutputResponseBody: Swift.Equatable {
    public let imageTagDetails: [EcrPublicClientTypes.ImageTagDetail]?
    public let nextToken: Swift.String?
}

extension DescribeImageTagsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageTagDetails
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageTagDetailsContainer = try containerValues.decodeIfPresent([EcrPublicClientTypes.ImageTagDetail?].self, forKey: .imageTagDetails)
        var imageTagDetailsDecoded0:[EcrPublicClientTypes.ImageTagDetail]? = nil
        if let imageTagDetailsContainer = imageTagDetailsContainer {
            imageTagDetailsDecoded0 = [EcrPublicClientTypes.ImageTagDetail]()
            for structure0 in imageTagDetailsContainer {
                if let structure0 = structure0 {
                    imageTagDetailsDecoded0?.append(structure0)
                }
            }
        }
        imageTagDetails = imageTagDetailsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeImagesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeImagesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeImagesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeImagesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeImagesOutputError>
}

extension DescribeImagesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeImagesInput(imageIds: \(Swift.String(describing: imageIds)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)))"}
}

extension DescribeImagesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageIds
        case maxResults
        case nextToken
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageIds = imageIds {
            var imageIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .imageIds)
            for imageidentifierlist0 in imageIds {
                try imageIdsContainer.encode(imageidentifierlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct DescribeImagesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeImagesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeImagesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeImagesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeImagesOutputError>
}

public struct DescribeImagesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeImagesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeImagesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeImagesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeImagesOutputError>
}

public struct DescribeImagesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeImagesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeImagesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeImagesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeImagesOutputError>
}

public struct DescribeImagesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeImagesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeImagesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeImagesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeImagesOutputError>
}

public struct DescribeImagesInput: Swift.Equatable {
    /// The list of image IDs for the requested repository.
    public var imageIds: [EcrPublicClientTypes.ImageIdentifier]?
    /// The maximum number of repository results returned by DescribeImages in
    ///          paginated output. When this parameter is used, DescribeImages only returns
    ///             maxResults results in a single page along with a nextToken
    ///          response element. The remaining results of the initial request can be seen by sending
    ///          another DescribeImages request with the returned nextToken value.
    ///          This value can be between 1 and 1000. If this parameter is not
    ///          used, then DescribeImages returns up to 100 results and a
    ///             nextToken value, if applicable. This option cannot be used when you specify
    ///          images with imageIds.
    public var maxResults: Swift.Int?
    /// The nextToken value returned from a previous paginated
    ///             DescribeImages request where maxResults was used and the
    ///          results exceeded the value of that parameter. Pagination continues from the end of the
    ///          previous results that returned the nextToken value. This value is
    ///             null when there are no more results to return. This option cannot be used
    ///          when you specify images with imageIds.
    public var nextToken: Swift.String?
    /// The AWS account ID associated with the public registry that contains the repository in
    ///          which to describe images. If you do not specify a registry, the default public registry is assumed.
    public var registryId: Swift.String?
    /// The repository that contains the images to describe.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init (
        imageIds: [EcrPublicClientTypes.ImageIdentifier]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.imageIds = imageIds
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct DescribeImagesInputBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryName: Swift.String?
    public let imageIds: [EcrPublicClientTypes.ImageIdentifier]?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension DescribeImagesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageIds
        case maxResults
        case nextToken
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageIdsContainer = try containerValues.decodeIfPresent([EcrPublicClientTypes.ImageIdentifier?].self, forKey: .imageIds)
        var imageIdsDecoded0:[EcrPublicClientTypes.ImageIdentifier]? = nil
        if let imageIdsContainer = imageIdsContainer {
            imageIdsDecoded0 = [EcrPublicClientTypes.ImageIdentifier]()
            for structure0 in imageIdsContainer {
                if let structure0 = structure0 {
                    imageIdsDecoded0?.append(structure0)
                }
            }
        }
        imageIds = imageIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeImagesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeImagesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ImageNotFoundException" : self = .imageNotFoundException(try ImageNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeImagesOutputError: Swift.Error, Swift.Equatable {
    case imageNotFoundException(ImageNotFoundException)
    case invalidParameterException(InvalidParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeImagesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeImagesOutputResponse(imageDetails: \(Swift.String(describing: imageDetails)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeImagesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeImagesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.imageDetails = output.imageDetails
            self.nextToken = output.nextToken
        } else {
            self.imageDetails = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeImagesOutputResponse: Swift.Equatable {
    /// A list of ImageDetail objects that contain data about the
    ///          image.
    public var imageDetails: [EcrPublicClientTypes.ImageDetail]?
    /// The nextToken value to include in a future DescribeImages
    ///          request. When the results of a DescribeImages request exceed
    ///             maxResults, this value can be used to retrieve the next page of results.
    ///          This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init (
        imageDetails: [EcrPublicClientTypes.ImageDetail]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.imageDetails = imageDetails
        self.nextToken = nextToken
    }
}

struct DescribeImagesOutputResponseBody: Swift.Equatable {
    public let imageDetails: [EcrPublicClientTypes.ImageDetail]?
    public let nextToken: Swift.String?
}

extension DescribeImagesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageDetails
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageDetailsContainer = try containerValues.decodeIfPresent([EcrPublicClientTypes.ImageDetail?].self, forKey: .imageDetails)
        var imageDetailsDecoded0:[EcrPublicClientTypes.ImageDetail]? = nil
        if let imageDetailsContainer = imageDetailsContainer {
            imageDetailsDecoded0 = [EcrPublicClientTypes.ImageDetail]()
            for structure0 in imageDetailsContainer {
                if let structure0 = structure0 {
                    imageDetailsDecoded0?.append(structure0)
                }
            }
        }
        imageDetails = imageDetailsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeRegistriesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRegistriesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRegistriesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRegistriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRegistriesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRegistriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRegistriesOutputError>
}

extension DescribeRegistriesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeRegistriesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeRegistriesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeRegistriesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRegistriesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRegistriesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRegistriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRegistriesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRegistriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRegistriesOutputError>
}

public struct DescribeRegistriesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRegistriesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRegistriesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRegistriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRegistriesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRegistriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRegistriesOutputError>
}

public struct DescribeRegistriesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRegistriesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeRegistriesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRegistriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeRegistriesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRegistriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRegistriesOutputError>
}

public struct DescribeRegistriesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRegistriesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeRegistriesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRegistriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeRegistriesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRegistriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRegistriesOutputError>
}

public struct DescribeRegistriesInput: Swift.Equatable {
    /// The maximum number of repository results returned by DescribeRegistries in
    ///          paginated output. When this parameter is used, DescribeRegistries only returns
    ///             maxResults results in a single page along with a nextToken
    ///          response element. The remaining results of the initial request can be seen by sending
    ///          another DescribeRegistries request with the returned nextToken
    ///          value. This value can be between 1 and 1000. If this parameter
    ///          is not used, then DescribeRegistries returns up to 100
    ///          results and a nextToken value, if applicable.
    public var maxResults: Swift.Int?
    /// The nextToken value returned from a previous paginated
    ///             DescribeRegistries request where maxResults was used and the
    ///          results exceeded the value of that parameter. Pagination continues from the end of the
    ///          previous results that returned the nextToken value. This value is
    ///             null when there are no more results to return.
    ///
    ///             This token should be treated as an opaque identifier that is only used to retrieve the next items in a list and not for other programmatic purposes.
    ///
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeRegistriesInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension DescribeRegistriesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeRegistriesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRegistriesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedCommandException" : self = .unsupportedCommandException(try UnsupportedCommandException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRegistriesOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case serverException(ServerException)
    case unsupportedCommandException(UnsupportedCommandException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRegistriesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeRegistriesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), registries: \(Swift.String(describing: registries)))"}
}

extension DescribeRegistriesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeRegistriesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.registries = output.registries
        } else {
            self.nextToken = nil
            self.registries = nil
        }
    }
}

public struct DescribeRegistriesOutputResponse: Swift.Equatable {
    /// The nextToken value to include in a future
    ///             DescribeRepositories request. When the results of a
    ///             DescribeRepositories request exceed maxResults, this value can
    ///          be used to retrieve the next page of results. This value is null when there
    ///          are no more results to return.
    public var nextToken: Swift.String?
    /// An object containing the details for a public registry.
    /// This member is required.
    public var registries: [EcrPublicClientTypes.Registry]?

    public init (
        nextToken: Swift.String? = nil,
        registries: [EcrPublicClientTypes.Registry]? = nil
    )
    {
        self.nextToken = nextToken
        self.registries = registries
    }
}

struct DescribeRegistriesOutputResponseBody: Swift.Equatable {
    public let registries: [EcrPublicClientTypes.Registry]?
    public let nextToken: Swift.String?
}

extension DescribeRegistriesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case registries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registriesContainer = try containerValues.decodeIfPresent([EcrPublicClientTypes.Registry?].self, forKey: .registries)
        var registriesDecoded0:[EcrPublicClientTypes.Registry]? = nil
        if let registriesContainer = registriesContainer {
            registriesDecoded0 = [EcrPublicClientTypes.Registry]()
            for structure0 in registriesContainer {
                if let structure0 = structure0 {
                    registriesDecoded0?.append(structure0)
                }
            }
        }
        registries = registriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeRepositoriesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRepositoriesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRepositoriesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRepositoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRepositoriesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRepositoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRepositoriesOutputError>
}

extension DescribeRepositoriesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeRepositoriesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), registryId: \(Swift.String(describing: registryId)), repositoryNames: \(Swift.String(describing: repositoryNames)))"}
}

extension DescribeRepositoriesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case registryId
        case repositoryNames
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryNames = repositoryNames {
            var repositoryNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .repositoryNames)
            for repositorynamelist0 in repositoryNames {
                try repositoryNamesContainer.encode(repositorynamelist0)
            }
        }
    }
}

public struct DescribeRepositoriesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRepositoriesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRepositoriesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRepositoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRepositoriesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRepositoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRepositoriesOutputError>
}

public struct DescribeRepositoriesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRepositoriesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRepositoriesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRepositoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRepositoriesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRepositoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRepositoriesOutputError>
}

public struct DescribeRepositoriesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRepositoriesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeRepositoriesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRepositoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeRepositoriesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRepositoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRepositoriesOutputError>
}

public struct DescribeRepositoriesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRepositoriesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeRepositoriesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRepositoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeRepositoriesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRepositoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRepositoriesOutputError>
}

public struct DescribeRepositoriesInput: Swift.Equatable {
    /// The maximum number of repository results returned by DescribeRepositories
    ///          in paginated output. When this parameter is used, DescribeRepositories only
    ///          returns maxResults results in a single page along with a
    ///             nextToken response element. The remaining results of the initial request
    ///          can be seen by sending another DescribeRepositories request with the returned
    ///             nextToken value. This value can be between 1 and
    ///          1000. If this parameter is not used, then DescribeRepositories
    ///          returns up to 100 results and a nextToken value, if
    ///          applicable. This option cannot be used when you specify repositories with
    ///             repositoryNames.
    public var maxResults: Swift.Int?
    /// The nextToken value returned from a previous paginated
    ///             DescribeRepositories request where maxResults was used and the
    ///          results exceeded the value of that parameter. Pagination continues from the end of the
    ///          previous results that returned the nextToken value. This value is
    ///             null when there are no more results to return. This option cannot be used
    ///          when you specify repositories with repositoryNames.
    ///
    ///             This token should be treated as an opaque identifier that is only used to retrieve the next items in a list and not for other programmatic purposes.
    ///
    public var nextToken: Swift.String?
    /// The AWS account ID associated with the registry that contains the repositories to be
    ///          described. If you do not specify a registry, the default public registry is assumed.
    public var registryId: Swift.String?
    /// A list of repositories to describe. If this parameter is omitted, then all repositories
    ///          in a registry are described.
    public var repositoryNames: [Swift.String]?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryNames: [Swift.String]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.registryId = registryId
        self.repositoryNames = repositoryNames
    }
}

struct DescribeRepositoriesInputBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryNames: [Swift.String]?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension DescribeRepositoriesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case registryId
        case repositoryNames
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .repositoryNames)
        var repositoryNamesDecoded0:[Swift.String]? = nil
        if let repositoryNamesContainer = repositoryNamesContainer {
            repositoryNamesDecoded0 = [Swift.String]()
            for string0 in repositoryNamesContainer {
                if let string0 = string0 {
                    repositoryNamesDecoded0?.append(string0)
                }
            }
        }
        repositoryNames = repositoryNamesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeRepositoriesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRepositoriesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRepositoriesOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRepositoriesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeRepositoriesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), repositories: \(Swift.String(describing: repositories)))"}
}

extension DescribeRepositoriesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeRepositoriesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.repositories = output.repositories
        } else {
            self.nextToken = nil
            self.repositories = nil
        }
    }
}

public struct DescribeRepositoriesOutputResponse: Swift.Equatable {
    /// The nextToken value to include in a future
    ///             DescribeRepositories request. When the results of a
    ///             DescribeRepositories request exceed maxResults, this value can
    ///          be used to retrieve the next page of results. This value is null when there
    ///          are no more results to return.
    public var nextToken: Swift.String?
    /// A list of repository objects corresponding to valid repositories.
    public var repositories: [EcrPublicClientTypes.Repository]?

    public init (
        nextToken: Swift.String? = nil,
        repositories: [EcrPublicClientTypes.Repository]? = nil
    )
    {
        self.nextToken = nextToken
        self.repositories = repositories
    }
}

struct DescribeRepositoriesOutputResponseBody: Swift.Equatable {
    public let repositories: [EcrPublicClientTypes.Repository]?
    public let nextToken: Swift.String?
}

extension DescribeRepositoriesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case repositories
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoriesContainer = try containerValues.decodeIfPresent([EcrPublicClientTypes.Repository?].self, forKey: .repositories)
        var repositoriesDecoded0:[EcrPublicClientTypes.Repository]? = nil
        if let repositoriesContainer = repositoriesContainer {
            repositoriesDecoded0 = [EcrPublicClientTypes.Repository]()
            for structure0 in repositoriesContainer {
                if let structure0 = structure0 {
                    repositoriesDecoded0?.append(structure0)
                }
            }
        }
        repositories = repositoriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension EmptyUploadException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EmptyUploadException(message: \(Swift.String(describing: message)))"}
}

extension EmptyUploadException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: EmptyUploadExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified layer upload does not contain any layer parts.
public struct EmptyUploadException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct EmptyUploadExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension EmptyUploadExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GetAuthorizationTokenInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAuthorizationTokenInput()"}
}

extension GetAuthorizationTokenInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetAuthorizationTokenInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAuthorizationTokenInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAuthorizationTokenInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAuthorizationTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAuthorizationTokenInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAuthorizationTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAuthorizationTokenOutputError>
}

public struct GetAuthorizationTokenInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAuthorizationTokenInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAuthorizationTokenInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAuthorizationTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAuthorizationTokenInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAuthorizationTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAuthorizationTokenOutputError>
}

public struct GetAuthorizationTokenInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAuthorizationTokenInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetAuthorizationTokenInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAuthorizationTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetAuthorizationTokenInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetAuthorizationTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAuthorizationTokenOutputError>
}

public struct GetAuthorizationTokenInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAuthorizationTokenInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetAuthorizationTokenInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAuthorizationTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetAuthorizationTokenInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetAuthorizationTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAuthorizationTokenOutputError>
}

public struct GetAuthorizationTokenInput: Swift.Equatable {

    public init() {}
}

struct GetAuthorizationTokenInputBody: Swift.Equatable {
}

extension GetAuthorizationTokenInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAuthorizationTokenOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAuthorizationTokenOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAuthorizationTokenOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAuthorizationTokenOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAuthorizationTokenOutputResponse(authorizationData: \(Swift.String(describing: authorizationData)))"}
}

extension GetAuthorizationTokenOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAuthorizationTokenOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.authorizationData = output.authorizationData
        } else {
            self.authorizationData = nil
        }
    }
}

public struct GetAuthorizationTokenOutputResponse: Swift.Equatable {
    /// An authorization token data object that corresponds to a public registry.
    public var authorizationData: EcrPublicClientTypes.AuthorizationData?

    public init (
        authorizationData: EcrPublicClientTypes.AuthorizationData? = nil
    )
    {
        self.authorizationData = authorizationData
    }
}

struct GetAuthorizationTokenOutputResponseBody: Swift.Equatable {
    public let authorizationData: EcrPublicClientTypes.AuthorizationData?
}

extension GetAuthorizationTokenOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizationData
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizationDataDecoded = try containerValues.decodeIfPresent(EcrPublicClientTypes.AuthorizationData.self, forKey: .authorizationData)
        authorizationData = authorizationDataDecoded
    }
}

extension GetRegistryCatalogDataInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRegistryCatalogDataInput()"}
}

extension GetRegistryCatalogDataInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetRegistryCatalogDataInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRegistryCatalogDataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRegistryCatalogDataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRegistryCatalogDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRegistryCatalogDataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRegistryCatalogDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRegistryCatalogDataOutputError>
}

public struct GetRegistryCatalogDataInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRegistryCatalogDataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRegistryCatalogDataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRegistryCatalogDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRegistryCatalogDataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRegistryCatalogDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRegistryCatalogDataOutputError>
}

public struct GetRegistryCatalogDataInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRegistryCatalogDataInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetRegistryCatalogDataInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRegistryCatalogDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetRegistryCatalogDataInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetRegistryCatalogDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRegistryCatalogDataOutputError>
}

public struct GetRegistryCatalogDataInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRegistryCatalogDataInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetRegistryCatalogDataInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRegistryCatalogDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetRegistryCatalogDataInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetRegistryCatalogDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRegistryCatalogDataOutputError>
}

public struct GetRegistryCatalogDataInput: Swift.Equatable {

    public init() {}
}

struct GetRegistryCatalogDataInputBody: Swift.Equatable {
}

extension GetRegistryCatalogDataInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetRegistryCatalogDataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRegistryCatalogDataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedCommandException" : self = .unsupportedCommandException(try UnsupportedCommandException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRegistryCatalogDataOutputError: Swift.Error, Swift.Equatable {
    case serverException(ServerException)
    case unsupportedCommandException(UnsupportedCommandException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRegistryCatalogDataOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRegistryCatalogDataOutputResponse(registryCatalogData: \(Swift.String(describing: registryCatalogData)))"}
}

extension GetRegistryCatalogDataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetRegistryCatalogDataOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.registryCatalogData = output.registryCatalogData
        } else {
            self.registryCatalogData = nil
        }
    }
}

public struct GetRegistryCatalogDataOutputResponse: Swift.Equatable {
    /// The catalog metadata for the public registry.
    /// This member is required.
    public var registryCatalogData: EcrPublicClientTypes.RegistryCatalogData?

    public init (
        registryCatalogData: EcrPublicClientTypes.RegistryCatalogData? = nil
    )
    {
        self.registryCatalogData = registryCatalogData
    }
}

struct GetRegistryCatalogDataOutputResponseBody: Swift.Equatable {
    public let registryCatalogData: EcrPublicClientTypes.RegistryCatalogData?
}

extension GetRegistryCatalogDataOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registryCatalogData
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryCatalogDataDecoded = try containerValues.decodeIfPresent(EcrPublicClientTypes.RegistryCatalogData.self, forKey: .registryCatalogData)
        registryCatalogData = registryCatalogDataDecoded
    }
}

public struct GetRepositoryCatalogDataInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRepositoryCatalogDataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRepositoryCatalogDataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRepositoryCatalogDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRepositoryCatalogDataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRepositoryCatalogDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRepositoryCatalogDataOutputError>
}

extension GetRepositoryCatalogDataInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRepositoryCatalogDataInput(registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)))"}
}

extension GetRepositoryCatalogDataInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct GetRepositoryCatalogDataInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRepositoryCatalogDataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRepositoryCatalogDataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRepositoryCatalogDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRepositoryCatalogDataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRepositoryCatalogDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRepositoryCatalogDataOutputError>
}

public struct GetRepositoryCatalogDataInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRepositoryCatalogDataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRepositoryCatalogDataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRepositoryCatalogDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRepositoryCatalogDataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRepositoryCatalogDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRepositoryCatalogDataOutputError>
}

public struct GetRepositoryCatalogDataInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRepositoryCatalogDataInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetRepositoryCatalogDataInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRepositoryCatalogDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetRepositoryCatalogDataInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetRepositoryCatalogDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRepositoryCatalogDataOutputError>
}

public struct GetRepositoryCatalogDataInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRepositoryCatalogDataInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetRepositoryCatalogDataInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRepositoryCatalogDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetRepositoryCatalogDataInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetRepositoryCatalogDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRepositoryCatalogDataOutputError>
}

public struct GetRepositoryCatalogDataInput: Swift.Equatable {
    /// The AWS account ID associated with the registry that contains the repositories to be
    ///          described. If you do not specify a registry, the default public registry is assumed.
    public var registryId: Swift.String?
    /// The name of the repository to retrieve the catalog metadata for.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init (
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct GetRepositoryCatalogDataInputBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryName: Swift.String?
}

extension GetRepositoryCatalogDataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
    }
}

extension GetRepositoryCatalogDataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRepositoryCatalogDataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRepositoryCatalogDataOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRepositoryCatalogDataOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRepositoryCatalogDataOutputResponse(catalogData: \(Swift.String(describing: catalogData)))"}
}

extension GetRepositoryCatalogDataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetRepositoryCatalogDataOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.catalogData = output.catalogData
        } else {
            self.catalogData = nil
        }
    }
}

public struct GetRepositoryCatalogDataOutputResponse: Swift.Equatable {
    /// The catalog metadata for the repository.
    public var catalogData: EcrPublicClientTypes.RepositoryCatalogData?

    public init (
        catalogData: EcrPublicClientTypes.RepositoryCatalogData? = nil
    )
    {
        self.catalogData = catalogData
    }
}

struct GetRepositoryCatalogDataOutputResponseBody: Swift.Equatable {
    public let catalogData: EcrPublicClientTypes.RepositoryCatalogData?
}

extension GetRepositoryCatalogDataOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogData
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogDataDecoded = try containerValues.decodeIfPresent(EcrPublicClientTypes.RepositoryCatalogData.self, forKey: .catalogData)
        catalogData = catalogDataDecoded
    }
}

public struct GetRepositoryPolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRepositoryPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRepositoryPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRepositoryPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRepositoryPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRepositoryPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRepositoryPolicyOutputError>
}

extension GetRepositoryPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRepositoryPolicyInput(registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)))"}
}

extension GetRepositoryPolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct GetRepositoryPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRepositoryPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRepositoryPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRepositoryPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRepositoryPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRepositoryPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRepositoryPolicyOutputError>
}

public struct GetRepositoryPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRepositoryPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRepositoryPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRepositoryPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRepositoryPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRepositoryPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRepositoryPolicyOutputError>
}

public struct GetRepositoryPolicyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRepositoryPolicyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetRepositoryPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRepositoryPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetRepositoryPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetRepositoryPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRepositoryPolicyOutputError>
}

public struct GetRepositoryPolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRepositoryPolicyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetRepositoryPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRepositoryPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetRepositoryPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetRepositoryPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRepositoryPolicyOutputError>
}

public struct GetRepositoryPolicyInput: Swift.Equatable {
    /// The AWS account ID associated with the public registry that contains the repository.
    ///          If you do not specify a registry, the default public registry is assumed.
    public var registryId: Swift.String?
    /// The name of the repository with the policy to retrieve.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init (
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct GetRepositoryPolicyInputBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryName: Swift.String?
}

extension GetRepositoryPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
    }
}

extension GetRepositoryPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRepositoryPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryPolicyNotFoundException" : self = .repositoryPolicyNotFoundException(try RepositoryPolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRepositoryPolicyOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case repositoryPolicyNotFoundException(RepositoryPolicyNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRepositoryPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRepositoryPolicyOutputResponse(policyText: \(Swift.String(describing: policyText)), registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)))"}
}

extension GetRepositoryPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetRepositoryPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policyText = output.policyText
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
        } else {
            self.policyText = nil
            self.registryId = nil
            self.repositoryName = nil
        }
    }
}

public struct GetRepositoryPolicyOutputResponse: Swift.Equatable {
    /// The repository policy text associated with the repository. The policy text will be in
    ///          JSON format.
    public var policyText: Swift.String?
    /// The registry ID associated with the request.
    public var registryId: Swift.String?
    /// The repository name associated with the request.
    public var repositoryName: Swift.String?

    public init (
        policyText: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.policyText = policyText
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct GetRepositoryPolicyOutputResponseBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryName: Swift.String?
    public let policyText: Swift.String?
}

extension GetRepositoryPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyText
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let policyTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyText)
        policyText = policyTextDecoded
    }
}

extension EcrPublicClientTypes.Image: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageId
        case imageManifest
        case imageManifestMediaType
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageId = imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
        if let imageManifest = imageManifest {
            try encodeContainer.encode(imageManifest, forKey: .imageManifest)
        }
        if let imageManifestMediaType = imageManifestMediaType {
            try encodeContainer.encode(imageManifestMediaType, forKey: .imageManifestMediaType)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageIdDecoded = try containerValues.decodeIfPresent(EcrPublicClientTypes.ImageIdentifier.self, forKey: .imageId)
        imageId = imageIdDecoded
        let imageManifestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageManifest)
        imageManifest = imageManifestDecoded
        let imageManifestMediaTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageManifestMediaType)
        imageManifestMediaType = imageManifestMediaTypeDecoded
    }
}

extension EcrPublicClientTypes.Image: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Image(imageId: \(Swift.String(describing: imageId)), imageManifest: \(Swift.String(describing: imageManifest)), imageManifestMediaType: \(Swift.String(describing: imageManifestMediaType)), registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)))"}
}

extension EcrPublicClientTypes {
    /// An object representing an Amazon ECR image.
    public struct Image: Swift.Equatable {
        /// An object containing the image tag and image digest associated with an image.
        public var imageId: EcrPublicClientTypes.ImageIdentifier?
        /// The image manifest associated with the image.
        public var imageManifest: Swift.String?
        /// The manifest media type of the image.
        public var imageManifestMediaType: Swift.String?
        /// The AWS account ID associated with the registry containing the image.
        public var registryId: Swift.String?
        /// The name of the repository associated with the image.
        public var repositoryName: Swift.String?

        public init (
            imageId: EcrPublicClientTypes.ImageIdentifier? = nil,
            imageManifest: Swift.String? = nil,
            imageManifestMediaType: Swift.String? = nil,
            registryId: Swift.String? = nil,
            repositoryName: Swift.String? = nil
        )
        {
            self.imageId = imageId
            self.imageManifest = imageManifest
            self.imageManifestMediaType = imageManifestMediaType
            self.registryId = registryId
            self.repositoryName = repositoryName
        }
    }

}

extension ImageAlreadyExistsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImageAlreadyExistsException(message: \(Swift.String(describing: message)))"}
}

extension ImageAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ImageAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified image has already been pushed, and there were no changes to the manifest
///          or image tag after the last push.
public struct ImageAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ImageAlreadyExistsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ImageAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EcrPublicClientTypes.ImageDetail: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case artifactMediaType
        case imageDigest
        case imageManifestMediaType
        case imagePushedAt
        case imageSizeInBytes
        case imageTags
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let artifactMediaType = artifactMediaType {
            try encodeContainer.encode(artifactMediaType, forKey: .artifactMediaType)
        }
        if let imageDigest = imageDigest {
            try encodeContainer.encode(imageDigest, forKey: .imageDigest)
        }
        if let imageManifestMediaType = imageManifestMediaType {
            try encodeContainer.encode(imageManifestMediaType, forKey: .imageManifestMediaType)
        }
        if let imagePushedAt = imagePushedAt {
            try encodeContainer.encode(imagePushedAt.timeIntervalSince1970, forKey: .imagePushedAt)
        }
        if let imageSizeInBytes = imageSizeInBytes {
            try encodeContainer.encode(imageSizeInBytes, forKey: .imageSizeInBytes)
        }
        if let imageTags = imageTags {
            var imageTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .imageTags)
            for imagetaglist0 in imageTags {
                try imageTagsContainer.encode(imagetaglist0)
            }
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageDigestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageDigest)
        imageDigest = imageDigestDecoded
        let imageTagsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .imageTags)
        var imageTagsDecoded0:[Swift.String]? = nil
        if let imageTagsContainer = imageTagsContainer {
            imageTagsDecoded0 = [Swift.String]()
            for string0 in imageTagsContainer {
                if let string0 = string0 {
                    imageTagsDecoded0?.append(string0)
                }
            }
        }
        imageTags = imageTagsDecoded0
        let imageSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .imageSizeInBytes)
        imageSizeInBytes = imageSizeInBytesDecoded
        let imagePushedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .imagePushedAt)
        imagePushedAt = imagePushedAtDecoded
        let imageManifestMediaTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageManifestMediaType)
        imageManifestMediaType = imageManifestMediaTypeDecoded
        let artifactMediaTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .artifactMediaType)
        artifactMediaType = artifactMediaTypeDecoded
    }
}

extension EcrPublicClientTypes.ImageDetail: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImageDetail(artifactMediaType: \(Swift.String(describing: artifactMediaType)), imageDigest: \(Swift.String(describing: imageDigest)), imageManifestMediaType: \(Swift.String(describing: imageManifestMediaType)), imagePushedAt: \(Swift.String(describing: imagePushedAt)), imageSizeInBytes: \(Swift.String(describing: imageSizeInBytes)), imageTags: \(Swift.String(describing: imageTags)), registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)))"}
}

extension EcrPublicClientTypes {
    /// An object that describes an image returned by a DescribeImages
    ///          operation.
    public struct ImageDetail: Swift.Equatable {
        /// The artifact media type of the image.
        public var artifactMediaType: Swift.String?
        /// The sha256 digest of the image manifest.
        public var imageDigest: Swift.String?
        /// The media type of the image manifest.
        public var imageManifestMediaType: Swift.String?
        /// The date and time, expressed in standard JavaScript date format, at which the current
        ///          image was pushed to the repository.
        public var imagePushedAt: ClientRuntime.Date?
        /// The size, in bytes, of the image in the repository.
        ///          If the image is a manifest list, this will be the max size of all manifests in the
        ///          list.
        ///
        ///             Beginning with Docker version 1.9, the Docker client compresses image layers before
        ///             pushing them to a V2 Docker registry. The output of the docker images
        ///             command shows the uncompressed image size, so it may return a larger image size than the
        ///             image sizes returned by DescribeImages.
        ///
        public var imageSizeInBytes: Swift.Int?
        /// The list of tags associated with this image.
        public var imageTags: [Swift.String]?
        /// The AWS account ID associated with the public registry to which this image
        ///          belongs.
        public var registryId: Swift.String?
        /// The name of the repository to which this image belongs.
        public var repositoryName: Swift.String?

        public init (
            artifactMediaType: Swift.String? = nil,
            imageDigest: Swift.String? = nil,
            imageManifestMediaType: Swift.String? = nil,
            imagePushedAt: ClientRuntime.Date? = nil,
            imageSizeInBytes: Swift.Int? = nil,
            imageTags: [Swift.String]? = nil,
            registryId: Swift.String? = nil,
            repositoryName: Swift.String? = nil
        )
        {
            self.artifactMediaType = artifactMediaType
            self.imageDigest = imageDigest
            self.imageManifestMediaType = imageManifestMediaType
            self.imagePushedAt = imagePushedAt
            self.imageSizeInBytes = imageSizeInBytes
            self.imageTags = imageTags
            self.registryId = registryId
            self.repositoryName = repositoryName
        }
    }

}

extension ImageDigestDoesNotMatchException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImageDigestDoesNotMatchException(message: \(Swift.String(describing: message)))"}
}

extension ImageDigestDoesNotMatchException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ImageDigestDoesNotMatchExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified image digest does not match the digest that Amazon ECR calculated for the
///          image.
public struct ImageDigestDoesNotMatchException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ImageDigestDoesNotMatchExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ImageDigestDoesNotMatchExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EcrPublicClientTypes.ImageFailure: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureCode
        case failureReason
        case imageId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureCode = failureCode {
            try encodeContainer.encode(failureCode.rawValue, forKey: .failureCode)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let imageId = imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageIdDecoded = try containerValues.decodeIfPresent(EcrPublicClientTypes.ImageIdentifier.self, forKey: .imageId)
        imageId = imageIdDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(EcrPublicClientTypes.ImageFailureCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension EcrPublicClientTypes.ImageFailure: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImageFailure(failureCode: \(Swift.String(describing: failureCode)), failureReason: \(Swift.String(describing: failureReason)), imageId: \(Swift.String(describing: imageId)))"}
}

extension EcrPublicClientTypes {
    /// An object representing an Amazon ECR image failure.
    public struct ImageFailure: Swift.Equatable {
        /// The code associated with the failure.
        public var failureCode: EcrPublicClientTypes.ImageFailureCode?
        /// The reason for the failure.
        public var failureReason: Swift.String?
        /// The image ID associated with the failure.
        public var imageId: EcrPublicClientTypes.ImageIdentifier?

        public init (
            failureCode: EcrPublicClientTypes.ImageFailureCode? = nil,
            failureReason: Swift.String? = nil,
            imageId: EcrPublicClientTypes.ImageIdentifier? = nil
        )
        {
            self.failureCode = failureCode
            self.failureReason = failureReason
            self.imageId = imageId
        }
    }

}

extension EcrPublicClientTypes {
    public enum ImageFailureCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case imagenotfound
        case imagereferencedbymanifestlist
        case imagetagdoesnotmatchdigest
        case invalidimagedigest
        case invalidimagetag
        case kmserror
        case missingdigestandtag
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageFailureCode] {
            return [
                .imagenotfound,
                .imagereferencedbymanifestlist,
                .imagetagdoesnotmatchdigest,
                .invalidimagedigest,
                .invalidimagetag,
                .kmserror,
                .missingdigestandtag,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .imagenotfound: return "ImageNotFound"
            case .imagereferencedbymanifestlist: return "ImageReferencedByManifestList"
            case .imagetagdoesnotmatchdigest: return "ImageTagDoesNotMatchDigest"
            case .invalidimagedigest: return "InvalidImageDigest"
            case .invalidimagetag: return "InvalidImageTag"
            case .kmserror: return "KmsError"
            case .missingdigestandtag: return "MissingDigestAndTag"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImageFailureCode(rawValue: rawValue) ?? ImageFailureCode.sdkUnknown(rawValue)
        }
    }
}

extension EcrPublicClientTypes.ImageIdentifier: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageDigest
        case imageTag
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageDigest = imageDigest {
            try encodeContainer.encode(imageDigest, forKey: .imageDigest)
        }
        if let imageTag = imageTag {
            try encodeContainer.encode(imageTag, forKey: .imageTag)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageDigestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageDigest)
        imageDigest = imageDigestDecoded
        let imageTagDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageTag)
        imageTag = imageTagDecoded
    }
}

extension EcrPublicClientTypes.ImageIdentifier: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImageIdentifier(imageDigest: \(Swift.String(describing: imageDigest)), imageTag: \(Swift.String(describing: imageTag)))"}
}

extension EcrPublicClientTypes {
    /// An object with identifying information for an Amazon ECR image.
    public struct ImageIdentifier: Swift.Equatable {
        /// The sha256 digest of the image manifest.
        public var imageDigest: Swift.String?
        /// The tag used for the image.
        public var imageTag: Swift.String?

        public init (
            imageDigest: Swift.String? = nil,
            imageTag: Swift.String? = nil
        )
        {
            self.imageDigest = imageDigest
            self.imageTag = imageTag
        }
    }

}

extension ImageNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImageNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ImageNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ImageNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The image requested does not exist in the specified repository.
public struct ImageNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ImageNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ImageNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ImageTagAlreadyExistsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImageTagAlreadyExistsException(message: \(Swift.String(describing: message)))"}
}

extension ImageTagAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ImageTagAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified image is tagged with a tag that already exists. The repository is
///          configured for tag immutability.
public struct ImageTagAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ImageTagAlreadyExistsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ImageTagAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EcrPublicClientTypes.ImageTagDetail: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case imageDetail
        case imageTag
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let imageDetail = imageDetail {
            try encodeContainer.encode(imageDetail, forKey: .imageDetail)
        }
        if let imageTag = imageTag {
            try encodeContainer.encode(imageTag, forKey: .imageTag)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageTagDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageTag)
        imageTag = imageTagDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let imageDetailDecoded = try containerValues.decodeIfPresent(EcrPublicClientTypes.ReferencedImageDetail.self, forKey: .imageDetail)
        imageDetail = imageDetailDecoded
    }
}

extension EcrPublicClientTypes.ImageTagDetail: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImageTagDetail(createdAt: \(Swift.String(describing: createdAt)), imageDetail: \(Swift.String(describing: imageDetail)), imageTag: \(Swift.String(describing: imageTag)))"}
}

extension EcrPublicClientTypes {
    /// An object representing the image tag details for an image.
    public struct ImageTagDetail: Swift.Equatable {
        /// The time stamp indicating when the image tag was created.
        public var createdAt: ClientRuntime.Date?
        /// An object that describes the details of an image.
        public var imageDetail: EcrPublicClientTypes.ReferencedImageDetail?
        /// The tag associated with the image.
        public var imageTag: Swift.String?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            imageDetail: EcrPublicClientTypes.ReferencedImageDetail? = nil,
            imageTag: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.imageDetail = imageDetail
            self.imageTag = imageTag
        }
    }

}

public struct InitiateLayerUploadInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InitiateLayerUploadInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<InitiateLayerUploadInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<InitiateLayerUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<InitiateLayerUploadInput>
    public typealias MOutput = ClientRuntime.OperationOutput<InitiateLayerUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<InitiateLayerUploadOutputError>
}

extension InitiateLayerUploadInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InitiateLayerUploadInput(registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)))"}
}

extension InitiateLayerUploadInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct InitiateLayerUploadInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InitiateLayerUploadInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<InitiateLayerUploadInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<InitiateLayerUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<InitiateLayerUploadInput>
    public typealias MOutput = ClientRuntime.OperationOutput<InitiateLayerUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<InitiateLayerUploadOutputError>
}

public struct InitiateLayerUploadInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InitiateLayerUploadInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<InitiateLayerUploadInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<InitiateLayerUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<InitiateLayerUploadInput>
    public typealias MOutput = ClientRuntime.OperationOutput<InitiateLayerUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<InitiateLayerUploadOutputError>
}

public struct InitiateLayerUploadInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InitiateLayerUploadInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: InitiateLayerUploadInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<InitiateLayerUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = InitiateLayerUploadInput
    public typealias MOutput = ClientRuntime.OperationOutput<InitiateLayerUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<InitiateLayerUploadOutputError>
}

public struct InitiateLayerUploadInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InitiateLayerUploadInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: InitiateLayerUploadInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<InitiateLayerUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = InitiateLayerUploadInput
    public typealias MOutput = ClientRuntime.OperationOutput<InitiateLayerUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<InitiateLayerUploadOutputError>
}

public struct InitiateLayerUploadInput: Swift.Equatable {
    /// The AWS account ID associated with the registry to which you intend to upload layers.
    ///          If you do not specify a registry, the default public registry is assumed.
    public var registryId: Swift.String?
    /// The name of the repository to which you intend to upload layers.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init (
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct InitiateLayerUploadInputBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryName: Swift.String?
}

extension InitiateLayerUploadInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
    }
}

extension InitiateLayerUploadOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension InitiateLayerUploadOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RegistryNotFoundException" : self = .registryNotFoundException(try RegistryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedCommandException" : self = .unsupportedCommandException(try UnsupportedCommandException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum InitiateLayerUploadOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case registryNotFoundException(RegistryNotFoundException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unsupportedCommandException(UnsupportedCommandException)
    case unknown(UnknownAWSHttpServiceError)
}

extension InitiateLayerUploadOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InitiateLayerUploadOutputResponse(partSize: \(Swift.String(describing: partSize)), uploadId: \(Swift.String(describing: uploadId)))"}
}

extension InitiateLayerUploadOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InitiateLayerUploadOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.partSize = output.partSize
            self.uploadId = output.uploadId
        } else {
            self.partSize = nil
            self.uploadId = nil
        }
    }
}

public struct InitiateLayerUploadOutputResponse: Swift.Equatable {
    /// The size, in bytes, that Amazon ECR expects future layer part uploads to be.
    public var partSize: Swift.Int?
    /// The upload ID for the layer upload. This parameter is passed to further UploadLayerPart and CompleteLayerUpload operations.
    public var uploadId: Swift.String?

    public init (
        partSize: Swift.Int? = nil,
        uploadId: Swift.String? = nil
    )
    {
        self.partSize = partSize
        self.uploadId = uploadId
    }
}

struct InitiateLayerUploadOutputResponseBody: Swift.Equatable {
    public let uploadId: Swift.String?
    public let partSize: Swift.Int?
}

extension InitiateLayerUploadOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case partSize
        case uploadId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uploadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
        let partSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .partSize)
        partSize = partSizeDecoded
    }
}

extension InvalidLayerException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidLayerException(message: \(Swift.String(describing: message)))"}
}

extension InvalidLayerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidLayerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The layer digest calculation performed by Amazon ECR upon receipt of the image layer does not
///          match the digest specified.
public struct InvalidLayerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidLayerExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidLayerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidLayerPartException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidLayerPartException(lastValidByteReceived: \(Swift.String(describing: lastValidByteReceived)), message: \(Swift.String(describing: message)), registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)), uploadId: \(Swift.String(describing: uploadId)))"}
}

extension InvalidLayerPartException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidLayerPartExceptionBody = try responseDecoder.decode(responseBody: data)
            self.lastValidByteReceived = output.lastValidByteReceived
            self.message = output.message
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
            self.uploadId = output.uploadId
        } else {
            self.lastValidByteReceived = nil
            self.message = nil
            self.registryId = nil
            self.repositoryName = nil
            self.uploadId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The layer part size is not valid, or the first byte specified is not consecutive to the
///          last byte of a previous layer part upload.
public struct InvalidLayerPartException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The position of the last byte of the layer part.
    public var lastValidByteReceived: Swift.Int?
    public var message: Swift.String?
    /// The AWS account ID associated with the layer part.
    public var registryId: Swift.String?
    /// The name of the repository.
    public var repositoryName: Swift.String?
    /// The upload ID associated with the layer part.
    public var uploadId: Swift.String?

    public init (
        lastValidByteReceived: Swift.Int? = nil,
        message: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        uploadId: Swift.String? = nil
    )
    {
        self.lastValidByteReceived = lastValidByteReceived
        self.message = message
        self.registryId = registryId
        self.repositoryName = repositoryName
        self.uploadId = uploadId
    }
}

struct InvalidLayerPartExceptionBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryName: Swift.String?
    public let uploadId: Swift.String?
    public let lastValidByteReceived: Swift.Int?
    public let message: Swift.String?
}

extension InvalidLayerPartExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastValidByteReceived
        case message
        case registryId
        case repositoryName
        case uploadId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let uploadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
        let lastValidByteReceivedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastValidByteReceived)
        lastValidByteReceived = lastValidByteReceivedDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidParameterException(message: \(Swift.String(describing: message)))"}
}

extension InvalidParameterException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified parameter is invalid. Review the available parameters for the API
///          request.
public struct InvalidParameterException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTagParameterException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidTagParameterException(message: \(Swift.String(describing: message)))"}
}

extension InvalidTagParameterException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidTagParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An invalid parameter has been specified. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
public struct InvalidTagParameterException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTagParameterExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidTagParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EcrPublicClientTypes.Layer: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerAvailability
        case layerDigest
        case layerSize
        case mediaType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let layerAvailability = layerAvailability {
            try encodeContainer.encode(layerAvailability.rawValue, forKey: .layerAvailability)
        }
        if let layerDigest = layerDigest {
            try encodeContainer.encode(layerDigest, forKey: .layerDigest)
        }
        if let layerSize = layerSize {
            try encodeContainer.encode(layerSize, forKey: .layerSize)
        }
        if let mediaType = mediaType {
            try encodeContainer.encode(mediaType, forKey: .mediaType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layerDigestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerDigest)
        layerDigest = layerDigestDecoded
        let layerAvailabilityDecoded = try containerValues.decodeIfPresent(EcrPublicClientTypes.LayerAvailability.self, forKey: .layerAvailability)
        layerAvailability = layerAvailabilityDecoded
        let layerSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .layerSize)
        layerSize = layerSizeDecoded
        let mediaTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaType)
        mediaType = mediaTypeDecoded
    }
}

extension EcrPublicClientTypes.Layer: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Layer(layerAvailability: \(Swift.String(describing: layerAvailability)), layerDigest: \(Swift.String(describing: layerDigest)), layerSize: \(Swift.String(describing: layerSize)), mediaType: \(Swift.String(describing: mediaType)))"}
}

extension EcrPublicClientTypes {
    /// An object representing an Amazon ECR image layer.
    public struct Layer: Swift.Equatable {
        /// The availability status of the image layer.
        public var layerAvailability: EcrPublicClientTypes.LayerAvailability?
        /// The sha256 digest of the image layer.
        public var layerDigest: Swift.String?
        /// The size, in bytes, of the image layer.
        public var layerSize: Swift.Int?
        /// The media type of the layer, such as
        ///             application/vnd.docker.image.rootfs.diff.tar.gzip or
        ///             application/vnd.oci.image.layer.v1.tar+gzip.
        public var mediaType: Swift.String?

        public init (
            layerAvailability: EcrPublicClientTypes.LayerAvailability? = nil,
            layerDigest: Swift.String? = nil,
            layerSize: Swift.Int? = nil,
            mediaType: Swift.String? = nil
        )
        {
            self.layerAvailability = layerAvailability
            self.layerDigest = layerDigest
            self.layerSize = layerSize
            self.mediaType = mediaType
        }
    }

}

extension LayerAlreadyExistsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LayerAlreadyExistsException(message: \(Swift.String(describing: message)))"}
}

extension LayerAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LayerAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The image layer already exists in the associated repository.
public struct LayerAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LayerAlreadyExistsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension LayerAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EcrPublicClientTypes {
    public enum LayerAvailability: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case unavailable
        case sdkUnknown(Swift.String)

        public static var allCases: [LayerAvailability] {
            return [
                .available,
                .unavailable,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .unavailable: return "UNAVAILABLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LayerAvailability(rawValue: rawValue) ?? LayerAvailability.sdkUnknown(rawValue)
        }
    }
}

extension EcrPublicClientTypes.LayerFailure: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureCode
        case failureReason
        case layerDigest
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureCode = failureCode {
            try encodeContainer.encode(failureCode.rawValue, forKey: .failureCode)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let layerDigest = layerDigest {
            try encodeContainer.encode(layerDigest, forKey: .layerDigest)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layerDigestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerDigest)
        layerDigest = layerDigestDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(EcrPublicClientTypes.LayerFailureCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension EcrPublicClientTypes.LayerFailure: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LayerFailure(failureCode: \(Swift.String(describing: failureCode)), failureReason: \(Swift.String(describing: failureReason)), layerDigest: \(Swift.String(describing: layerDigest)))"}
}

extension EcrPublicClientTypes {
    /// An object representing an Amazon ECR image layer failure.
    public struct LayerFailure: Swift.Equatable {
        /// The failure code associated with the failure.
        public var failureCode: EcrPublicClientTypes.LayerFailureCode?
        /// The reason for the failure.
        public var failureReason: Swift.String?
        /// The layer digest associated with the failure.
        public var layerDigest: Swift.String?

        public init (
            failureCode: EcrPublicClientTypes.LayerFailureCode? = nil,
            failureReason: Swift.String? = nil,
            layerDigest: Swift.String? = nil
        )
        {
            self.failureCode = failureCode
            self.failureReason = failureReason
            self.layerDigest = layerDigest
        }
    }

}

extension EcrPublicClientTypes {
    public enum LayerFailureCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case invalidlayerdigest
        case missinglayerdigest
        case sdkUnknown(Swift.String)

        public static var allCases: [LayerFailureCode] {
            return [
                .invalidlayerdigest,
                .missinglayerdigest,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .invalidlayerdigest: return "InvalidLayerDigest"
            case .missinglayerdigest: return "MissingLayerDigest"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LayerFailureCode(rawValue: rawValue) ?? LayerFailureCode.sdkUnknown(rawValue)
        }
    }
}

extension LayerPartTooSmallException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LayerPartTooSmallException(message: \(Swift.String(describing: message)))"}
}

extension LayerPartTooSmallException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LayerPartTooSmallExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Layer parts must be at least 5 MiB in size.
public struct LayerPartTooSmallException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LayerPartTooSmallExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension LayerPartTooSmallExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LayersNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LayersNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension LayersNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LayersNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified layers could not be found, or the specified layer is not valid for this
///          repository.
public struct LayersNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LayersNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension LayersNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The operation did not succeed because it would have exceeded a service limit for your
///          account. For more information, see <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/service-quotas.html">Amazon ECR Service Quotas in the
///          Amazon Elastic Container Registry User Guide.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that identifies the resource for which to list the tags. Currently, the
    ///          supported resource is an Amazon ECR Public repository.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags for the resource.
    public var tags: [EcrPublicClientTypes.Tag]?

    public init (
        tags: [EcrPublicClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [EcrPublicClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([EcrPublicClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[EcrPublicClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [EcrPublicClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct PutImageInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutImageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutImageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutImageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutImageOutputError>
}

extension PutImageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutImageInput(imageDigest: \(Swift.String(describing: imageDigest)), imageManifest: \(Swift.String(describing: imageManifest)), imageManifestMediaType: \(Swift.String(describing: imageManifestMediaType)), imageTag: \(Swift.String(describing: imageTag)), registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)))"}
}

extension PutImageInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageDigest
        case imageManifest
        case imageManifestMediaType
        case imageTag
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageDigest = imageDigest {
            try encodeContainer.encode(imageDigest, forKey: .imageDigest)
        }
        if let imageManifest = imageManifest {
            try encodeContainer.encode(imageManifest, forKey: .imageManifest)
        }
        if let imageManifestMediaType = imageManifestMediaType {
            try encodeContainer.encode(imageManifestMediaType, forKey: .imageManifestMediaType)
        }
        if let imageTag = imageTag {
            try encodeContainer.encode(imageTag, forKey: .imageTag)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct PutImageInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutImageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutImageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutImageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutImageOutputError>
}

public struct PutImageInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutImageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutImageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutImageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutImageOutputError>
}

public struct PutImageInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutImageInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: PutImageInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutImageInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutImageOutputError>
}

public struct PutImageInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutImageInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: PutImageInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutImageInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutImageOutputError>
}

public struct PutImageInput: Swift.Equatable {
    /// The image digest of the image manifest corresponding to the image.
    public var imageDigest: Swift.String?
    /// The image manifest corresponding to the image to be uploaded.
    /// This member is required.
    public var imageManifest: Swift.String?
    /// The media type of the image manifest. If you push an image manifest that does not
    ///          contain the mediaType field, you must specify the
    ///             imageManifestMediaType in the request.
    public var imageManifestMediaType: Swift.String?
    /// The tag to associate with the image. This parameter is required for images that use the
    ///          Docker Image Manifest V2 Schema 2 or Open Container Initiative (OCI) formats.
    public var imageTag: Swift.String?
    /// The AWS account ID associated with the public registry that contains the repository in
    ///          which to put the image. If you do not specify a registry, the default public registry is assumed.
    public var registryId: Swift.String?
    /// The name of the repository in which to put the image.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init (
        imageDigest: Swift.String? = nil,
        imageManifest: Swift.String? = nil,
        imageManifestMediaType: Swift.String? = nil,
        imageTag: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.imageDigest = imageDigest
        self.imageManifest = imageManifest
        self.imageManifestMediaType = imageManifestMediaType
        self.imageTag = imageTag
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct PutImageInputBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryName: Swift.String?
    public let imageManifest: Swift.String?
    public let imageManifestMediaType: Swift.String?
    public let imageTag: Swift.String?
    public let imageDigest: Swift.String?
}

extension PutImageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageDigest
        case imageManifest
        case imageManifestMediaType
        case imageTag
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageManifestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageManifest)
        imageManifest = imageManifestDecoded
        let imageManifestMediaTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageManifestMediaType)
        imageManifestMediaType = imageManifestMediaTypeDecoded
        let imageTagDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageTag)
        imageTag = imageTagDecoded
        let imageDigestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageDigest)
        imageDigest = imageDigestDecoded
    }
}

extension PutImageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutImageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ImageAlreadyExistsException" : self = .imageAlreadyExistsException(try ImageAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ImageDigestDoesNotMatchException" : self = .imageDigestDoesNotMatchException(try ImageDigestDoesNotMatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ImageTagAlreadyExistsException" : self = .imageTagAlreadyExistsException(try ImageTagAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LayersNotFoundException" : self = .layersNotFoundException(try LayersNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReferencedImagesNotFoundException" : self = .referencedImagesNotFoundException(try ReferencedImagesNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RegistryNotFoundException" : self = .registryNotFoundException(try RegistryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedCommandException" : self = .unsupportedCommandException(try UnsupportedCommandException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutImageOutputError: Swift.Error, Swift.Equatable {
    case imageAlreadyExistsException(ImageAlreadyExistsException)
    case imageDigestDoesNotMatchException(ImageDigestDoesNotMatchException)
    case imageTagAlreadyExistsException(ImageTagAlreadyExistsException)
    case invalidParameterException(InvalidParameterException)
    case layersNotFoundException(LayersNotFoundException)
    case limitExceededException(LimitExceededException)
    case referencedImagesNotFoundException(ReferencedImagesNotFoundException)
    case registryNotFoundException(RegistryNotFoundException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unsupportedCommandException(UnsupportedCommandException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutImageOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutImageOutputResponse(image: \(Swift.String(describing: image)))"}
}

extension PutImageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutImageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.image = output.image
        } else {
            self.image = nil
        }
    }
}

public struct PutImageOutputResponse: Swift.Equatable {
    /// Details of the image uploaded.
    public var image: EcrPublicClientTypes.Image?

    public init (
        image: EcrPublicClientTypes.Image? = nil
    )
    {
        self.image = image
    }
}

struct PutImageOutputResponseBody: Swift.Equatable {
    public let image: EcrPublicClientTypes.Image?
}

extension PutImageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case image
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageDecoded = try containerValues.decodeIfPresent(EcrPublicClientTypes.Image.self, forKey: .image)
        image = imageDecoded
    }
}

public struct PutRegistryCatalogDataInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutRegistryCatalogDataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutRegistryCatalogDataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutRegistryCatalogDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutRegistryCatalogDataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutRegistryCatalogDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutRegistryCatalogDataOutputError>
}

extension PutRegistryCatalogDataInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutRegistryCatalogDataInput(displayName: \(Swift.String(describing: displayName)))"}
}

extension PutRegistryCatalogDataInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
    }
}

public struct PutRegistryCatalogDataInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutRegistryCatalogDataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutRegistryCatalogDataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutRegistryCatalogDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutRegistryCatalogDataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutRegistryCatalogDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutRegistryCatalogDataOutputError>
}

public struct PutRegistryCatalogDataInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutRegistryCatalogDataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutRegistryCatalogDataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutRegistryCatalogDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutRegistryCatalogDataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutRegistryCatalogDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutRegistryCatalogDataOutputError>
}

public struct PutRegistryCatalogDataInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutRegistryCatalogDataInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: PutRegistryCatalogDataInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutRegistryCatalogDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutRegistryCatalogDataInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutRegistryCatalogDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutRegistryCatalogDataOutputError>
}

public struct PutRegistryCatalogDataInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutRegistryCatalogDataInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: PutRegistryCatalogDataInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutRegistryCatalogDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutRegistryCatalogDataInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutRegistryCatalogDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutRegistryCatalogDataOutputError>
}

public struct PutRegistryCatalogDataInput: Swift.Equatable {
    /// The display name for a public registry. The display name is shown as the repository
    ///          author in the Amazon ECR Public Gallery.
    ///
    ///             The registry display name is only publicly visible in the Amazon ECR Public Gallery for
    ///             verified accounts.
    ///
    public var displayName: Swift.String?

    public init (
        displayName: Swift.String? = nil
    )
    {
        self.displayName = displayName
    }
}

struct PutRegistryCatalogDataInputBody: Swift.Equatable {
    public let displayName: Swift.String?
}

extension PutRegistryCatalogDataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
    }
}

extension PutRegistryCatalogDataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutRegistryCatalogDataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedCommandException" : self = .unsupportedCommandException(try UnsupportedCommandException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutRegistryCatalogDataOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case serverException(ServerException)
    case unsupportedCommandException(UnsupportedCommandException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutRegistryCatalogDataOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutRegistryCatalogDataOutputResponse(registryCatalogData: \(Swift.String(describing: registryCatalogData)))"}
}

extension PutRegistryCatalogDataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutRegistryCatalogDataOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.registryCatalogData = output.registryCatalogData
        } else {
            self.registryCatalogData = nil
        }
    }
}

public struct PutRegistryCatalogDataOutputResponse: Swift.Equatable {
    /// The catalog data for the public registry.
    /// This member is required.
    public var registryCatalogData: EcrPublicClientTypes.RegistryCatalogData?

    public init (
        registryCatalogData: EcrPublicClientTypes.RegistryCatalogData? = nil
    )
    {
        self.registryCatalogData = registryCatalogData
    }
}

struct PutRegistryCatalogDataOutputResponseBody: Swift.Equatable {
    public let registryCatalogData: EcrPublicClientTypes.RegistryCatalogData?
}

extension PutRegistryCatalogDataOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registryCatalogData
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryCatalogDataDecoded = try containerValues.decodeIfPresent(EcrPublicClientTypes.RegistryCatalogData.self, forKey: .registryCatalogData)
        registryCatalogData = registryCatalogDataDecoded
    }
}

public struct PutRepositoryCatalogDataInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutRepositoryCatalogDataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutRepositoryCatalogDataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutRepositoryCatalogDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutRepositoryCatalogDataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutRepositoryCatalogDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutRepositoryCatalogDataOutputError>
}

extension PutRepositoryCatalogDataInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutRepositoryCatalogDataInput(catalogData: \(Swift.String(describing: catalogData)), registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)))"}
}

extension PutRepositoryCatalogDataInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogData
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogData = catalogData {
            try encodeContainer.encode(catalogData, forKey: .catalogData)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct PutRepositoryCatalogDataInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutRepositoryCatalogDataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutRepositoryCatalogDataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutRepositoryCatalogDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutRepositoryCatalogDataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutRepositoryCatalogDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutRepositoryCatalogDataOutputError>
}

public struct PutRepositoryCatalogDataInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutRepositoryCatalogDataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutRepositoryCatalogDataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutRepositoryCatalogDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutRepositoryCatalogDataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutRepositoryCatalogDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutRepositoryCatalogDataOutputError>
}

public struct PutRepositoryCatalogDataInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutRepositoryCatalogDataInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: PutRepositoryCatalogDataInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutRepositoryCatalogDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutRepositoryCatalogDataInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutRepositoryCatalogDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutRepositoryCatalogDataOutputError>
}

public struct PutRepositoryCatalogDataInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutRepositoryCatalogDataInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: PutRepositoryCatalogDataInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutRepositoryCatalogDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutRepositoryCatalogDataInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutRepositoryCatalogDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutRepositoryCatalogDataOutputError>
}

public struct PutRepositoryCatalogDataInput: Swift.Equatable {
    /// An object containing the catalog data for a repository. This data is publicly visible in
    ///          the Amazon ECR Public Gallery.
    /// This member is required.
    public var catalogData: EcrPublicClientTypes.RepositoryCatalogDataInput?
    /// The AWS account ID associated with the public registry the repository is in.
    ///          If you do not specify a registry, the default public registry is assumed.
    public var registryId: Swift.String?
    /// The name of the repository to create or update the catalog data for.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init (
        catalogData: EcrPublicClientTypes.RepositoryCatalogDataInput? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.catalogData = catalogData
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct PutRepositoryCatalogDataInputBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryName: Swift.String?
    public let catalogData: EcrPublicClientTypes.RepositoryCatalogDataInput?
}

extension PutRepositoryCatalogDataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogData
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let catalogDataDecoded = try containerValues.decodeIfPresent(EcrPublicClientTypes.RepositoryCatalogDataInput.self, forKey: .catalogData)
        catalogData = catalogDataDecoded
    }
}

extension PutRepositoryCatalogDataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutRepositoryCatalogDataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutRepositoryCatalogDataOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutRepositoryCatalogDataOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutRepositoryCatalogDataOutputResponse(catalogData: \(Swift.String(describing: catalogData)))"}
}

extension PutRepositoryCatalogDataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutRepositoryCatalogDataOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.catalogData = output.catalogData
        } else {
            self.catalogData = nil
        }
    }
}

public struct PutRepositoryCatalogDataOutputResponse: Swift.Equatable {
    /// The catalog data for the repository.
    public var catalogData: EcrPublicClientTypes.RepositoryCatalogData?

    public init (
        catalogData: EcrPublicClientTypes.RepositoryCatalogData? = nil
    )
    {
        self.catalogData = catalogData
    }
}

struct PutRepositoryCatalogDataOutputResponseBody: Swift.Equatable {
    public let catalogData: EcrPublicClientTypes.RepositoryCatalogData?
}

extension PutRepositoryCatalogDataOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogData
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogDataDecoded = try containerValues.decodeIfPresent(EcrPublicClientTypes.RepositoryCatalogData.self, forKey: .catalogData)
        catalogData = catalogDataDecoded
    }
}

extension EcrPublicClientTypes.ReferencedImageDetail: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case artifactMediaType
        case imageDigest
        case imageManifestMediaType
        case imagePushedAt
        case imageSizeInBytes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let artifactMediaType = artifactMediaType {
            try encodeContainer.encode(artifactMediaType, forKey: .artifactMediaType)
        }
        if let imageDigest = imageDigest {
            try encodeContainer.encode(imageDigest, forKey: .imageDigest)
        }
        if let imageManifestMediaType = imageManifestMediaType {
            try encodeContainer.encode(imageManifestMediaType, forKey: .imageManifestMediaType)
        }
        if let imagePushedAt = imagePushedAt {
            try encodeContainer.encode(imagePushedAt.timeIntervalSince1970, forKey: .imagePushedAt)
        }
        if let imageSizeInBytes = imageSizeInBytes {
            try encodeContainer.encode(imageSizeInBytes, forKey: .imageSizeInBytes)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageDigestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageDigest)
        imageDigest = imageDigestDecoded
        let imageSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .imageSizeInBytes)
        imageSizeInBytes = imageSizeInBytesDecoded
        let imagePushedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .imagePushedAt)
        imagePushedAt = imagePushedAtDecoded
        let imageManifestMediaTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageManifestMediaType)
        imageManifestMediaType = imageManifestMediaTypeDecoded
        let artifactMediaTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .artifactMediaType)
        artifactMediaType = artifactMediaTypeDecoded
    }
}

extension EcrPublicClientTypes.ReferencedImageDetail: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReferencedImageDetail(artifactMediaType: \(Swift.String(describing: artifactMediaType)), imageDigest: \(Swift.String(describing: imageDigest)), imageManifestMediaType: \(Swift.String(describing: imageManifestMediaType)), imagePushedAt: \(Swift.String(describing: imagePushedAt)), imageSizeInBytes: \(Swift.String(describing: imageSizeInBytes)))"}
}

extension EcrPublicClientTypes {
    /// An object that describes the image tag details returned by a DescribeImageTags action.
    public struct ReferencedImageDetail: Swift.Equatable {
        /// The artifact media type of the image.
        public var artifactMediaType: Swift.String?
        /// The sha256 digest of the image manifest.
        public var imageDigest: Swift.String?
        /// The media type of the image manifest.
        public var imageManifestMediaType: Swift.String?
        /// The date and time, expressed in standard JavaScript date format, at which the current
        ///          image tag was pushed to the repository.
        public var imagePushedAt: ClientRuntime.Date?
        /// The size, in bytes, of the image in the repository.
        ///          If the image is a manifest list, this will be the max size of all manifests in the
        ///          list.
        ///
        ///             Beginning with Docker version 1.9, the Docker client compresses image layers before
        ///             pushing them to a V2 Docker registry. The output of the docker images
        ///             command shows the uncompressed image size, so it may return a larger image size than the
        ///             image sizes returned by DescribeImages.
        ///
        public var imageSizeInBytes: Swift.Int?

        public init (
            artifactMediaType: Swift.String? = nil,
            imageDigest: Swift.String? = nil,
            imageManifestMediaType: Swift.String? = nil,
            imagePushedAt: ClientRuntime.Date? = nil,
            imageSizeInBytes: Swift.Int? = nil
        )
        {
            self.artifactMediaType = artifactMediaType
            self.imageDigest = imageDigest
            self.imageManifestMediaType = imageManifestMediaType
            self.imagePushedAt = imagePushedAt
            self.imageSizeInBytes = imageSizeInBytes
        }
    }

}

extension ReferencedImagesNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReferencedImagesNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ReferencedImagesNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ReferencedImagesNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The manifest list is referencing an image that does not exist.
public struct ReferencedImagesNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ReferencedImagesNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ReferencedImagesNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EcrPublicClientTypes.Registry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliases
        case registryArn
        case registryId
        case registryUri
        case verified
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aliases = aliases {
            var aliasesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .aliases)
            for registryaliaslist0 in aliases {
                try aliasesContainer.encode(registryaliaslist0)
            }
        }
        if let registryArn = registryArn {
            try encodeContainer.encode(registryArn, forKey: .registryArn)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let registryUri = registryUri {
            try encodeContainer.encode(registryUri, forKey: .registryUri)
        }
        if let verified = verified {
            try encodeContainer.encode(verified, forKey: .verified)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let registryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryArn)
        registryArn = registryArnDecoded
        let registryUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryUri)
        registryUri = registryUriDecoded
        let verifiedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .verified)
        verified = verifiedDecoded
        let aliasesContainer = try containerValues.decodeIfPresent([EcrPublicClientTypes.RegistryAlias?].self, forKey: .aliases)
        var aliasesDecoded0:[EcrPublicClientTypes.RegistryAlias]? = nil
        if let aliasesContainer = aliasesContainer {
            aliasesDecoded0 = [EcrPublicClientTypes.RegistryAlias]()
            for structure0 in aliasesContainer {
                if let structure0 = structure0 {
                    aliasesDecoded0?.append(structure0)
                }
            }
        }
        aliases = aliasesDecoded0
    }
}

extension EcrPublicClientTypes.Registry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Registry(aliases: \(Swift.String(describing: aliases)), registryArn: \(Swift.String(describing: registryArn)), registryId: \(Swift.String(describing: registryId)), registryUri: \(Swift.String(describing: registryUri)), verified: \(Swift.String(describing: verified)))"}
}

extension EcrPublicClientTypes {
    /// The details of a public registry.
    public struct Registry: Swift.Equatable {
        /// An array of objects representing the aliases for a public registry.
        /// This member is required.
        public var aliases: [EcrPublicClientTypes.RegistryAlias]?
        /// The Amazon Resource Name (ARN) of the public registry.
        /// This member is required.
        public var registryArn: Swift.String?
        /// The AWS account ID associated with the registry. If you do not specify a registry, the default public registry is assumed.
        /// This member is required.
        public var registryId: Swift.String?
        /// The URI of a public registry. The URI contains a universal prefix and the registry
        ///          alias.
        /// This member is required.
        public var registryUri: Swift.String?
        /// Whether the account is verified. This indicates whether the account is an AWS
        ///          Marketplace vendor. If an account is verified, each public repository will received a
        ///          verified account badge on the Amazon ECR Public Gallery.
        /// This member is required.
        public var verified: Swift.Bool?

        public init (
            aliases: [EcrPublicClientTypes.RegistryAlias]? = nil,
            registryArn: Swift.String? = nil,
            registryId: Swift.String? = nil,
            registryUri: Swift.String? = nil,
            verified: Swift.Bool? = nil
        )
        {
            self.aliases = aliases
            self.registryArn = registryArn
            self.registryId = registryId
            self.registryUri = registryUri
            self.verified = verified
        }
    }

}

extension EcrPublicClientTypes.RegistryAlias: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultRegistryAlias
        case name
        case primaryRegistryAlias
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if defaultRegistryAlias != false {
            try encodeContainer.encode(defaultRegistryAlias, forKey: .defaultRegistryAlias)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if primaryRegistryAlias != false {
            try encodeContainer.encode(primaryRegistryAlias, forKey: .primaryRegistryAlias)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(EcrPublicClientTypes.RegistryAliasStatus.self, forKey: .status)
        status = statusDecoded
        let primaryRegistryAliasDecoded = try containerValues.decode(Swift.Bool.self, forKey: .primaryRegistryAlias)
        primaryRegistryAlias = primaryRegistryAliasDecoded
        let defaultRegistryAliasDecoded = try containerValues.decode(Swift.Bool.self, forKey: .defaultRegistryAlias)
        defaultRegistryAlias = defaultRegistryAliasDecoded
    }
}

extension EcrPublicClientTypes.RegistryAlias: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegistryAlias(defaultRegistryAlias: \(Swift.String(describing: defaultRegistryAlias)), name: \(Swift.String(describing: name)), primaryRegistryAlias: \(Swift.String(describing: primaryRegistryAlias)), status: \(Swift.String(describing: status)))"}
}

extension EcrPublicClientTypes {
    /// An object representing the aliases for a public registry. A public registry is given an
    ///          alias upon creation but a custom alias can be set using the Amazon ECR console. For more
    ///          information, see <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/Registries.html">Registries in the
    ///             Amazon Elastic Container Registry User Guide.
    public struct RegistryAlias: Swift.Equatable {
        /// Whether or not the registry alias is the default alias for the registry. When the first
        ///          public repository is created, your public registry is assigned a default registry
        ///          alias.
        /// This member is required.
        public var defaultRegistryAlias: Swift.Bool
        /// The name of the registry alias.
        /// This member is required.
        public var name: Swift.String?
        /// Whether or not the registry alias is the primary alias for the registry. If true, the
        ///          alias is the primary registry alias and is displayed in both the repository URL and the
        ///          image URI used in the docker pull commands on the Amazon ECR Public Gallery.
        ///
        ///             A registry alias that is not the primary registry alias can be used in the repository
        ///             URI in a docker pull command.
        ///
        /// This member is required.
        public var primaryRegistryAlias: Swift.Bool
        /// The status of the registry alias.
        /// This member is required.
        public var status: EcrPublicClientTypes.RegistryAliasStatus?

        public init (
            defaultRegistryAlias: Swift.Bool = false,
            name: Swift.String? = nil,
            primaryRegistryAlias: Swift.Bool = false,
            status: EcrPublicClientTypes.RegistryAliasStatus? = nil
        )
        {
            self.defaultRegistryAlias = defaultRegistryAlias
            self.name = name
            self.primaryRegistryAlias = primaryRegistryAlias
            self.status = status
        }
    }

}

extension EcrPublicClientTypes {
    public enum RegistryAliasStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case pending
        case rejected
        case sdkUnknown(Swift.String)

        public static var allCases: [RegistryAliasStatus] {
            return [
                .active,
                .pending,
                .rejected,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .pending: return "PENDING"
            case .rejected: return "REJECTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RegistryAliasStatus(rawValue: rawValue) ?? RegistryAliasStatus.sdkUnknown(rawValue)
        }
    }
}

extension EcrPublicClientTypes.RegistryCatalogData: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
    }
}

extension EcrPublicClientTypes.RegistryCatalogData: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegistryCatalogData(displayName: \(Swift.String(describing: displayName)))"}
}

extension EcrPublicClientTypes {
    /// The metadata for a public registry.
    public struct RegistryCatalogData: Swift.Equatable {
        /// The display name for a public registry. This appears on the Amazon ECR Public Gallery.
        ///
        ///             Only accounts that have the verified account badge can have a registry display
        ///             name.
        ///
        public var displayName: Swift.String?

        public init (
            displayName: Swift.String? = nil
        )
        {
            self.displayName = displayName
        }
    }

}

extension RegistryNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegistryNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension RegistryNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RegistryNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The registry does not exist.
public struct RegistryNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RegistryNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension RegistryNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EcrPublicClientTypes.Repository: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case registryId
        case repositoryArn
        case repositoryName
        case repositoryUri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryArn = repositoryArn {
            try encodeContainer.encode(repositoryArn, forKey: .repositoryArn)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let repositoryUri = repositoryUri {
            try encodeContainer.encode(repositoryUri, forKey: .repositoryUri)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryArn)
        repositoryArn = repositoryArnDecoded
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let repositoryUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryUri)
        repositoryUri = repositoryUriDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension EcrPublicClientTypes.Repository: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Repository(createdAt: \(Swift.String(describing: createdAt)), registryId: \(Swift.String(describing: registryId)), repositoryArn: \(Swift.String(describing: repositoryArn)), repositoryName: \(Swift.String(describing: repositoryName)), repositoryUri: \(Swift.String(describing: repositoryUri)))"}
}

extension EcrPublicClientTypes {
    /// An object representing a repository.
    public struct Repository: Swift.Equatable {
        /// The date and time, in JavaScript date format, when the repository was created.
        public var createdAt: ClientRuntime.Date?
        /// The AWS account ID associated with the public registry that contains the
        ///          repository.
        public var registryId: Swift.String?
        /// The Amazon Resource Name (ARN) that identifies the repository. The ARN contains the arn:aws:ecr namespace, followed by the region of the repository, AWS account ID of the repository owner, repository namespace, and repository name. For example, arn:aws:ecr:region:012345678910:repository/test.
        public var repositoryArn: Swift.String?
        /// The name of the repository.
        public var repositoryName: Swift.String?
        /// The URI for the repository. You can use this URI for container image push
        ///          and pull operations.
        public var repositoryUri: Swift.String?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            registryId: Swift.String? = nil,
            repositoryArn: Swift.String? = nil,
            repositoryName: Swift.String? = nil,
            repositoryUri: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.registryId = registryId
            self.repositoryArn = repositoryArn
            self.repositoryName = repositoryName
            self.repositoryUri = repositoryUri
        }
    }

}

extension RepositoryAlreadyExistsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RepositoryAlreadyExistsException(message: \(Swift.String(describing: message)))"}
}

extension RepositoryAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RepositoryAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified repository already exists in the specified registry.
public struct RepositoryAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RepositoryAlreadyExistsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension RepositoryAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EcrPublicClientTypes.RepositoryCatalogData: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aboutText
        case architectures
        case description
        case logoUrl
        case marketplaceCertified
        case operatingSystems
        case usageText
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aboutText = aboutText {
            try encodeContainer.encode(aboutText, forKey: .aboutText)
        }
        if let architectures = architectures {
            var architecturesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .architectures)
            for architecturelist0 in architectures {
                try architecturesContainer.encode(architecturelist0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let logoUrl = logoUrl {
            try encodeContainer.encode(logoUrl, forKey: .logoUrl)
        }
        if let marketplaceCertified = marketplaceCertified {
            try encodeContainer.encode(marketplaceCertified, forKey: .marketplaceCertified)
        }
        if let operatingSystems = operatingSystems {
            var operatingSystemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .operatingSystems)
            for operatingsystemlist0 in operatingSystems {
                try operatingSystemsContainer.encode(operatingsystemlist0)
            }
        }
        if let usageText = usageText {
            try encodeContainer.encode(usageText, forKey: .usageText)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let architecturesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .architectures)
        var architecturesDecoded0:[Swift.String]? = nil
        if let architecturesContainer = architecturesContainer {
            architecturesDecoded0 = [Swift.String]()
            for string0 in architecturesContainer {
                if let string0 = string0 {
                    architecturesDecoded0?.append(string0)
                }
            }
        }
        architectures = architecturesDecoded0
        let operatingSystemsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .operatingSystems)
        var operatingSystemsDecoded0:[Swift.String]? = nil
        if let operatingSystemsContainer = operatingSystemsContainer {
            operatingSystemsDecoded0 = [Swift.String]()
            for string0 in operatingSystemsContainer {
                if let string0 = string0 {
                    operatingSystemsDecoded0?.append(string0)
                }
            }
        }
        operatingSystems = operatingSystemsDecoded0
        let logoUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logoUrl)
        logoUrl = logoUrlDecoded
        let aboutTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aboutText)
        aboutText = aboutTextDecoded
        let usageTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .usageText)
        usageText = usageTextDecoded
        let marketplaceCertifiedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .marketplaceCertified)
        marketplaceCertified = marketplaceCertifiedDecoded
    }
}

extension EcrPublicClientTypes.RepositoryCatalogData: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RepositoryCatalogData(aboutText: \(Swift.String(describing: aboutText)), architectures: \(Swift.String(describing: architectures)), description: \(Swift.String(describing: description)), logoUrl: \(Swift.String(describing: logoUrl)), marketplaceCertified: \(Swift.String(describing: marketplaceCertified)), operatingSystems: \(Swift.String(describing: operatingSystems)), usageText: \(Swift.String(describing: usageText)))"}
}

extension EcrPublicClientTypes {
    /// The catalog data for a repository. This data is publicly visible in the
    ///          Amazon ECR Public Gallery.
    public struct RepositoryCatalogData: Swift.Equatable {
        /// The longform description of the contents of the repository. This text appears in the
        ///          repository details on the Amazon ECR Public Gallery.
        public var aboutText: Swift.String?
        /// The architecture tags that are associated with the repository.
        ///
        ///             Only supported operating system tags appear publicly in the Amazon ECR Public Gallery. For
        ///             more information, see RepositoryCatalogDataInput.
        ///
        public var architectures: [Swift.String]?
        /// The short description of the repository.
        public var description: Swift.String?
        /// The URL containing the logo associated with the repository.
        public var logoUrl: Swift.String?
        /// Whether or not the repository is certified by AWS Marketplace.
        public var marketplaceCertified: Swift.Bool?
        /// The operating system tags that are associated with the repository.
        ///
        ///             Only supported operating system tags appear publicly in the Amazon ECR Public Gallery. For
        ///             more information, see RepositoryCatalogDataInput.
        ///
        public var operatingSystems: [Swift.String]?
        /// The longform usage details of the contents of the repository. The usage text provides
        ///          context for users of the repository.
        public var usageText: Swift.String?

        public init (
            aboutText: Swift.String? = nil,
            architectures: [Swift.String]? = nil,
            description: Swift.String? = nil,
            logoUrl: Swift.String? = nil,
            marketplaceCertified: Swift.Bool? = nil,
            operatingSystems: [Swift.String]? = nil,
            usageText: Swift.String? = nil
        )
        {
            self.aboutText = aboutText
            self.architectures = architectures
            self.description = description
            self.logoUrl = logoUrl
            self.marketplaceCertified = marketplaceCertified
            self.operatingSystems = operatingSystems
            self.usageText = usageText
        }
    }

}

extension EcrPublicClientTypes.RepositoryCatalogDataInput: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aboutText
        case architectures
        case description
        case logoImageBlob
        case operatingSystems
        case usageText
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aboutText = aboutText {
            try encodeContainer.encode(aboutText, forKey: .aboutText)
        }
        if let architectures = architectures {
            var architecturesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .architectures)
            for architecturelist0 in architectures {
                try architecturesContainer.encode(architecturelist0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let logoImageBlob = logoImageBlob {
            try encodeContainer.encode(logoImageBlob.base64EncodedString(), forKey: .logoImageBlob)
        }
        if let operatingSystems = operatingSystems {
            var operatingSystemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .operatingSystems)
            for operatingsystemlist0 in operatingSystems {
                try operatingSystemsContainer.encode(operatingsystemlist0)
            }
        }
        if let usageText = usageText {
            try encodeContainer.encode(usageText, forKey: .usageText)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let architecturesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .architectures)
        var architecturesDecoded0:[Swift.String]? = nil
        if let architecturesContainer = architecturesContainer {
            architecturesDecoded0 = [Swift.String]()
            for string0 in architecturesContainer {
                if let string0 = string0 {
                    architecturesDecoded0?.append(string0)
                }
            }
        }
        architectures = architecturesDecoded0
        let operatingSystemsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .operatingSystems)
        var operatingSystemsDecoded0:[Swift.String]? = nil
        if let operatingSystemsContainer = operatingSystemsContainer {
            operatingSystemsDecoded0 = [Swift.String]()
            for string0 in operatingSystemsContainer {
                if let string0 = string0 {
                    operatingSystemsDecoded0?.append(string0)
                }
            }
        }
        operatingSystems = operatingSystemsDecoded0
        let logoImageBlobDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .logoImageBlob)
        logoImageBlob = logoImageBlobDecoded
        let aboutTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aboutText)
        aboutText = aboutTextDecoded
        let usageTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .usageText)
        usageText = usageTextDecoded
    }
}

extension EcrPublicClientTypes.RepositoryCatalogDataInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RepositoryCatalogDataInput(aboutText: \(Swift.String(describing: aboutText)), architectures: \(Swift.String(describing: architectures)), description: \(Swift.String(describing: description)), logoImageBlob: \(Swift.String(describing: logoImageBlob)), operatingSystems: \(Swift.String(describing: operatingSystems)), usageText: \(Swift.String(describing: usageText)))"}
}

extension EcrPublicClientTypes {
    /// An object containing the catalog data for a repository. This data is publicly visible in
    ///          the Amazon ECR Public Gallery.
    public struct RepositoryCatalogDataInput: Swift.Equatable {
        /// A detailed description of the contents of the repository. It is publicly visible in the
        ///          Amazon ECR Public Gallery. The text must be in markdown format.
        public var aboutText: Swift.String?
        /// The system architecture that the images in the repository are compatible with. On the
        ///          Amazon ECR Public Gallery, the following supported architectures will appear as badges on the
        ///          repository and are used as search filters.
        ///
        ///
        ///
        ///                   Linux
        ///
        ///
        ///
        ///
        ///                   Windows
        ///
        ///
        ///
        ///
        ///             If an unsupported tag is added to your repository catalog data, it will be associated
        ///             with the repository and can be retrieved using the API but will not be discoverable in
        ///             the Amazon ECR Public Gallery.
        ///
        public var architectures: [Swift.String]?
        /// A short description of the contents of the repository. This text appears in both the
        ///          image details and also when searching for repositories on the Amazon ECR Public Gallery.
        public var description: Swift.String?
        /// The base64-encoded repository logo payload.
        ///
        ///             The repository logo is only publicly visible in the Amazon ECR Public Gallery for verified
        ///             accounts.
        ///
        public var logoImageBlob: ClientRuntime.Data?
        /// The operating systems that the images in the repository are compatible with. On the
        ///          Amazon ECR Public Gallery, the following supported operating systems will appear as badges on
        ///          the repository and are used as search filters.
        ///
        ///
        ///
        ///                   ARM
        ///
        ///
        ///
        ///
        ///                   ARM 64
        ///
        ///
        ///
        ///
        ///                   x86
        ///
        ///
        ///
        ///
        ///                   x86-64
        ///
        ///
        ///
        ///
        ///             If an unsupported tag is added to your repository catalog data, it will be associated
        ///             with the repository and can be retrieved using the API but will not be discoverable in
        ///             the Amazon ECR Public Gallery.
        ///
        public var operatingSystems: [Swift.String]?
        /// Detailed information on how to use the contents of the repository. It is publicly
        ///          visible in the Amazon ECR Public Gallery. The usage text provides context, support information,
        ///          and additional usage details for users of the repository. The text must be in markdown
        ///          format.
        public var usageText: Swift.String?

        public init (
            aboutText: Swift.String? = nil,
            architectures: [Swift.String]? = nil,
            description: Swift.String? = nil,
            logoImageBlob: ClientRuntime.Data? = nil,
            operatingSystems: [Swift.String]? = nil,
            usageText: Swift.String? = nil
        )
        {
            self.aboutText = aboutText
            self.architectures = architectures
            self.description = description
            self.logoImageBlob = logoImageBlob
            self.operatingSystems = operatingSystems
            self.usageText = usageText
        }
    }

}

extension RepositoryNotEmptyException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RepositoryNotEmptyException(message: \(Swift.String(describing: message)))"}
}

extension RepositoryNotEmptyException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RepositoryNotEmptyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified repository contains images. To delete a repository that contains images,
///          you must force the deletion with the force parameter.
public struct RepositoryNotEmptyException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RepositoryNotEmptyExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension RepositoryNotEmptyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RepositoryNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RepositoryNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension RepositoryNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RepositoryNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified repository could not be found. Check the spelling of the specified
///          repository and ensure that you are performing operations on the correct registry.
public struct RepositoryNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RepositoryNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension RepositoryNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RepositoryPolicyNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RepositoryPolicyNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension RepositoryPolicyNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RepositoryPolicyNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified repository and registry combination does not have an associated repository
///          policy.
public struct RepositoryPolicyNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RepositoryPolicyNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension RepositoryPolicyNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServerException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServerException(message: \(Swift.String(describing: message)))"}
}

extension ServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// These errors are usually caused by a server-side issue.
public struct ServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServerExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct SetRepositoryPolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetRepositoryPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetRepositoryPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetRepositoryPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetRepositoryPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetRepositoryPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetRepositoryPolicyOutputError>
}

extension SetRepositoryPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SetRepositoryPolicyInput(force: \(Swift.String(describing: force)), policyText: \(Swift.String(describing: policyText)), registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)))"}
}

extension SetRepositoryPolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case force
        case policyText
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if force != false {
            try encodeContainer.encode(force, forKey: .force)
        }
        if let policyText = policyText {
            try encodeContainer.encode(policyText, forKey: .policyText)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct SetRepositoryPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetRepositoryPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetRepositoryPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetRepositoryPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetRepositoryPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetRepositoryPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetRepositoryPolicyOutputError>
}

public struct SetRepositoryPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetRepositoryPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetRepositoryPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetRepositoryPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetRepositoryPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetRepositoryPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetRepositoryPolicyOutputError>
}

public struct SetRepositoryPolicyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetRepositoryPolicyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: SetRepositoryPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetRepositoryPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = SetRepositoryPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<SetRepositoryPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetRepositoryPolicyOutputError>
}

public struct SetRepositoryPolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetRepositoryPolicyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: SetRepositoryPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetRepositoryPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = SetRepositoryPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<SetRepositoryPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetRepositoryPolicyOutputError>
}

public struct SetRepositoryPolicyInput: Swift.Equatable {
    /// If the policy you are attempting to set on a repository policy would prevent you from
    ///          setting another policy in the future, you must force the SetRepositoryPolicy operation. This is intended to prevent accidental
    ///          repository lock outs.
    public var force: Swift.Bool
    /// The JSON repository policy text to apply to the repository. For more information, see
    ///             <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/repository-policy-examples.html">Amazon ECR Repository
    ///             Policies in the Amazon Elastic Container Registry User Guide.
    /// This member is required.
    public var policyText: Swift.String?
    /// The AWS account ID associated with the registry that contains the repository.
    ///          If you do not specify a registry, the default public registry is assumed.
    public var registryId: Swift.String?
    /// The name of the repository to receive the policy.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init (
        force: Swift.Bool = false,
        policyText: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.force = force
        self.policyText = policyText
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct SetRepositoryPolicyInputBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryName: Swift.String?
    public let policyText: Swift.String?
    public let force: Swift.Bool
}

extension SetRepositoryPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case force
        case policyText
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let policyTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyText)
        policyText = policyTextDecoded
        let forceDecoded = try containerValues.decode(Swift.Bool.self, forKey: .force)
        force = forceDecoded
    }
}

extension SetRepositoryPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SetRepositoryPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetRepositoryPolicyOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetRepositoryPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SetRepositoryPolicyOutputResponse(policyText: \(Swift.String(describing: policyText)), registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)))"}
}

extension SetRepositoryPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SetRepositoryPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policyText = output.policyText
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
        } else {
            self.policyText = nil
            self.registryId = nil
            self.repositoryName = nil
        }
    }
}

public struct SetRepositoryPolicyOutputResponse: Swift.Equatable {
    /// The JSON repository policy text applied to the repository.
    public var policyText: Swift.String?
    /// The registry ID associated with the request.
    public var registryId: Swift.String?
    /// The repository name associated with the request.
    public var repositoryName: Swift.String?

    public init (
        policyText: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.policyText = policyText
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct SetRepositoryPolicyOutputResponseBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryName: Swift.String?
    public let policyText: Swift.String?
}

extension SetRepositoryPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyText
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let policyTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyText)
        policyText = policyTextDecoded
    }
}

extension EcrPublicClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension EcrPublicClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension EcrPublicClientTypes {
    /// The metadata that you apply to a resource to help you categorize and organize them. Each
    ///          tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
    public struct Tag: Swift.Equatable {
        /// One part of a key-value pair that make up a tag. A key is a general label
        ///          that acts like a category for more specific tag values.
        public var key: Swift.String?
        /// The optional part of a key-value pair that make up a tag. A value acts as a
        ///          descriptor within a tag category (key).
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource to which to add tags. Currently, the
    ///          supported resource is an Amazon ECR Public repository.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to add to the resource. A tag is an array of key-value pairs.
    ///          Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
    /// This member is required.
    public var tags: [EcrPublicClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [EcrPublicClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
    public let tags: [EcrPublicClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([EcrPublicClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[EcrPublicClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [EcrPublicClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagParameterException" : self = .invalidTagParameterException(try InvalidTagParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case invalidTagParameterException(InvalidTagParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension TooManyTagsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyTagsException(message: \(Swift.String(describing: message)))"}
}

extension TooManyTagsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The list of tags on the repository is over the limit. The maximum number of tags that
///          can be applied to a repository is 50.
public struct TooManyTagsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnsupportedCommandException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnsupportedCommandException(message: \(Swift.String(describing: message)))"}
}

extension UnsupportedCommandException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnsupportedCommandExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The action is not supported in this Region.
public struct UnsupportedCommandException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedCommandExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension UnsupportedCommandExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UntagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tagKeys
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource from which to delete tags. Currently, the supported
    ///          resource is an Amazon ECR Public repository.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of the tags to be removed.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
    public let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tagKeys
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagParameterException" : self = .invalidTagParameterException(try InvalidTagParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case invalidTagParameterException(InvalidTagParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UploadLayerPartInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UploadLayerPartInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UploadLayerPartInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UploadLayerPartOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UploadLayerPartInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UploadLayerPartOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UploadLayerPartOutputError>
}

extension UploadLayerPartInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UploadLayerPartInput(layerPartBlob: \(Swift.String(describing: layerPartBlob)), partFirstByte: \(Swift.String(describing: partFirstByte)), partLastByte: \(Swift.String(describing: partLastByte)), registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)), uploadId: \(Swift.String(describing: uploadId)))"}
}

extension UploadLayerPartInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerPartBlob
        case partFirstByte
        case partLastByte
        case registryId
        case repositoryName
        case uploadId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let layerPartBlob = layerPartBlob {
            try encodeContainer.encode(layerPartBlob.base64EncodedString(), forKey: .layerPartBlob)
        }
        if let partFirstByte = partFirstByte {
            try encodeContainer.encode(partFirstByte, forKey: .partFirstByte)
        }
        if let partLastByte = partLastByte {
            try encodeContainer.encode(partLastByte, forKey: .partLastByte)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let uploadId = uploadId {
            try encodeContainer.encode(uploadId, forKey: .uploadId)
        }
    }
}

public struct UploadLayerPartInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UploadLayerPartInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UploadLayerPartInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UploadLayerPartOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UploadLayerPartInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UploadLayerPartOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UploadLayerPartOutputError>
}

public struct UploadLayerPartInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UploadLayerPartInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UploadLayerPartInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UploadLayerPartOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UploadLayerPartInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UploadLayerPartOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UploadLayerPartOutputError>
}

public struct UploadLayerPartInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UploadLayerPartInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UploadLayerPartInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UploadLayerPartOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UploadLayerPartInput
    public typealias MOutput = ClientRuntime.OperationOutput<UploadLayerPartOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UploadLayerPartOutputError>
}

public struct UploadLayerPartInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UploadLayerPartInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UploadLayerPartInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UploadLayerPartOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UploadLayerPartInput
    public typealias MOutput = ClientRuntime.OperationOutput<UploadLayerPartOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UploadLayerPartOutputError>
}

public struct UploadLayerPartInput: Swift.Equatable {
    /// The base64-encoded layer part payload.
    /// This member is required.
    public var layerPartBlob: ClientRuntime.Data?
    /// The position of the first byte of the layer part witin the overall image layer.
    /// This member is required.
    public var partFirstByte: Swift.Int?
    /// The position of the last byte of the layer part within the overall image layer.
    /// This member is required.
    public var partLastByte: Swift.Int?
    /// The AWS account ID associated with the registry to which you are uploading layer parts.
    ///          If you do not specify a registry, the default public registry is assumed.
    public var registryId: Swift.String?
    /// The name of the repository to which you are uploading layer parts.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The upload ID from a previous InitiateLayerUpload operation to
    ///          associate with the layer part upload.
    /// This member is required.
    public var uploadId: Swift.String?

    public init (
        layerPartBlob: ClientRuntime.Data? = nil,
        partFirstByte: Swift.Int? = nil,
        partLastByte: Swift.Int? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        uploadId: Swift.String? = nil
    )
    {
        self.layerPartBlob = layerPartBlob
        self.partFirstByte = partFirstByte
        self.partLastByte = partLastByte
        self.registryId = registryId
        self.repositoryName = repositoryName
        self.uploadId = uploadId
    }
}

struct UploadLayerPartInputBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryName: Swift.String?
    public let uploadId: Swift.String?
    public let partFirstByte: Swift.Int?
    public let partLastByte: Swift.Int?
    public let layerPartBlob: ClientRuntime.Data?
}

extension UploadLayerPartInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerPartBlob
        case partFirstByte
        case partLastByte
        case registryId
        case repositoryName
        case uploadId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let uploadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
        let partFirstByteDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .partFirstByte)
        partFirstByte = partFirstByteDecoded
        let partLastByteDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .partLastByte)
        partLastByte = partLastByteDecoded
        let layerPartBlobDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .layerPartBlob)
        layerPartBlob = layerPartBlobDecoded
    }
}

extension UploadLayerPartOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UploadLayerPartOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidLayerPartException" : self = .invalidLayerPartException(try InvalidLayerPartException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RegistryNotFoundException" : self = .registryNotFoundException(try RegistryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedCommandException" : self = .unsupportedCommandException(try UnsupportedCommandException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UploadNotFoundException" : self = .uploadNotFoundException(try UploadNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UploadLayerPartOutputError: Swift.Error, Swift.Equatable {
    case invalidLayerPartException(InvalidLayerPartException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case registryNotFoundException(RegistryNotFoundException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unsupportedCommandException(UnsupportedCommandException)
    case uploadNotFoundException(UploadNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UploadLayerPartOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UploadLayerPartOutputResponse(lastByteReceived: \(Swift.String(describing: lastByteReceived)), registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)), uploadId: \(Swift.String(describing: uploadId)))"}
}

extension UploadLayerPartOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UploadLayerPartOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.lastByteReceived = output.lastByteReceived
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
            self.uploadId = output.uploadId
        } else {
            self.lastByteReceived = nil
            self.registryId = nil
            self.repositoryName = nil
            self.uploadId = nil
        }
    }
}

public struct UploadLayerPartOutputResponse: Swift.Equatable {
    /// The integer value of the last byte received in the request.
    public var lastByteReceived: Swift.Int?
    /// The registry ID associated with the request.
    public var registryId: Swift.String?
    /// The repository name associated with the request.
    public var repositoryName: Swift.String?
    /// The upload ID associated with the request.
    public var uploadId: Swift.String?

    public init (
        lastByteReceived: Swift.Int? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        uploadId: Swift.String? = nil
    )
    {
        self.lastByteReceived = lastByteReceived
        self.registryId = registryId
        self.repositoryName = repositoryName
        self.uploadId = uploadId
    }
}

struct UploadLayerPartOutputResponseBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryName: Swift.String?
    public let uploadId: Swift.String?
    public let lastByteReceived: Swift.Int?
}

extension UploadLayerPartOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastByteReceived
        case registryId
        case repositoryName
        case uploadId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let uploadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
        let lastByteReceivedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastByteReceived)
        lastByteReceived = lastByteReceivedDecoded
    }
}

extension UploadNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UploadNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension UploadNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UploadNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The upload could not be found, or the specified upload ID is not valid for this
///          repository.
public struct UploadNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UploadNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension UploadNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
