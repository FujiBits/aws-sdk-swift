// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

#if swift(>=5.5) && canImport(_Concurrency)
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, macCatalyst 15.0, *)
public extension IotEventsDataClient {
    /// Acknowledges one or more alarms. The alarms change to the ACKNOWLEDGED state
    ///       after you acknowledge them.
    func batchAcknowledgeAlarm(input: BatchAcknowledgeAlarmInput) async throws -> BatchAcknowledgeAlarmOutputResponse
    {
        typealias batchAcknowledgeAlarmContinuation = CheckedContinuation<BatchAcknowledgeAlarmOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: batchAcknowledgeAlarmContinuation) in
            batchAcknowledgeAlarm(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Disables one or more alarms. The alarms change to the DISABLED state after
    ///       you disable them.
    func batchDisableAlarm(input: BatchDisableAlarmInput) async throws -> BatchDisableAlarmOutputResponse
    {
        typealias batchDisableAlarmContinuation = CheckedContinuation<BatchDisableAlarmOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: batchDisableAlarmContinuation) in
            batchDisableAlarm(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Enables one or more alarms. The alarms change to the NORMAL state after you
    ///       enable them.
    func batchEnableAlarm(input: BatchEnableAlarmInput) async throws -> BatchEnableAlarmOutputResponse
    {
        typealias batchEnableAlarmContinuation = CheckedContinuation<BatchEnableAlarmOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: batchEnableAlarmContinuation) in
            batchEnableAlarm(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Sends a set of messages to the AWS IoT Events system. Each message payload is transformed into
    ///       the input you specify ("inputName") and ingested into any detectors that monitor
    ///       that input. If multiple messages are sent, the order in which the messages are processed isn't
    ///       guaranteed. To guarantee ordering, you must send messages one at a time and wait for a
    ///       successful response.
    func batchPutMessage(input: BatchPutMessageInput) async throws -> BatchPutMessageOutputResponse
    {
        typealias batchPutMessageContinuation = CheckedContinuation<BatchPutMessageOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: batchPutMessageContinuation) in
            batchPutMessage(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Resets one or more alarms. The alarms return to the NORMAL state after you
    ///       reset them.
    func batchResetAlarm(input: BatchResetAlarmInput) async throws -> BatchResetAlarmOutputResponse
    {
        typealias batchResetAlarmContinuation = CheckedContinuation<BatchResetAlarmOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: batchResetAlarmContinuation) in
            batchResetAlarm(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Changes one or more alarms to the snooze mode. The alarms change to the
    ///         SNOOZE_DISABLED state after you set them to the snooze mode.
    func batchSnoozeAlarm(input: BatchSnoozeAlarmInput) async throws -> BatchSnoozeAlarmOutputResponse
    {
        typealias batchSnoozeAlarmContinuation = CheckedContinuation<BatchSnoozeAlarmOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: batchSnoozeAlarmContinuation) in
            batchSnoozeAlarm(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates the state, variable values, and timer settings of one or more detectors
    ///       (instances) of a specified detector model.
    func batchUpdateDetector(input: BatchUpdateDetectorInput) async throws -> BatchUpdateDetectorOutputResponse
    {
        typealias batchUpdateDetectorContinuation = CheckedContinuation<BatchUpdateDetectorOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: batchUpdateDetectorContinuation) in
            batchUpdateDetector(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves information about an alarm.
    func describeAlarm(input: DescribeAlarmInput) async throws -> DescribeAlarmOutputResponse
    {
        typealias describeAlarmContinuation = CheckedContinuation<DescribeAlarmOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeAlarmContinuation) in
            describeAlarm(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns information about the specified detector (instance).
    func describeDetector(input: DescribeDetectorInput) async throws -> DescribeDetectorOutputResponse
    {
        typealias describeDetectorContinuation = CheckedContinuation<DescribeDetectorOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeDetectorContinuation) in
            describeDetector(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Lists one or more alarms. The operation returns only the metadata associated with each
    ///       alarm.
    func listAlarms(input: ListAlarmsInput) async throws -> ListAlarmsOutputResponse
    {
        typealias listAlarmsContinuation = CheckedContinuation<ListAlarmsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listAlarmsContinuation) in
            listAlarms(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Lists detectors (the instances of a detector model).
    func listDetectors(input: ListDetectorsInput) async throws -> ListDetectorsOutputResponse
    {
        typealias listDetectorsContinuation = CheckedContinuation<ListDetectorsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listDetectorsContinuation) in
            listDetectors(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

}
#endif
