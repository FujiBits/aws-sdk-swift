// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

#if swift(>=5.5)
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, macCatalyst 15.0, *)
public extension ApplicationInsightsClient {
    /// <p>Adds an application that is created from a resource group.</p>
    func createApplication(input: CreateApplicationInput) async throws -> CreateApplicationOutputResponse
    {
        typealias createApplicationContinuation = CheckedContinuation<CreateApplicationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createApplicationContinuation) in
            createApplication(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates a custom component by grouping similar standalone instances to monitor.</p>
    func createComponent(input: CreateComponentInput) async throws -> CreateComponentOutputResponse
    {
        typealias createComponentContinuation = CheckedContinuation<CreateComponentOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createComponentContinuation) in
            createComponent(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Adds an log pattern to a <code>LogPatternSet</code>.</p>
    func createLogPattern(input: CreateLogPatternInput) async throws -> CreateLogPatternOutputResponse
    {
        typealias createLogPatternContinuation = CheckedContinuation<CreateLogPatternOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createLogPatternContinuation) in
            createLogPattern(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Removes the specified application from monitoring. Does not delete the application.</p>
    func deleteApplication(input: DeleteApplicationInput) async throws -> DeleteApplicationOutputResponse
    {
        typealias deleteApplicationContinuation = CheckedContinuation<DeleteApplicationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteApplicationContinuation) in
            deleteApplication(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Ungroups a custom component. When you ungroup custom components, all applicable
    ///          monitors that are set up for the component are removed and the instances revert to their standalone status.</p>
    func deleteComponent(input: DeleteComponentInput) async throws -> DeleteComponentOutputResponse
    {
        typealias deleteComponentContinuation = CheckedContinuation<DeleteComponentOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteComponentContinuation) in
            deleteComponent(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Removes the specified log pattern from a <code>LogPatternSet</code>.</p>
    func deleteLogPattern(input: DeleteLogPatternInput) async throws -> DeleteLogPatternOutputResponse
    {
        typealias deleteLogPatternContinuation = CheckedContinuation<DeleteLogPatternOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteLogPatternContinuation) in
            deleteLogPattern(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Describes the application.</p>
    func describeApplication(input: DescribeApplicationInput) async throws -> DescribeApplicationOutputResponse
    {
        typealias describeApplicationContinuation = CheckedContinuation<DescribeApplicationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeApplicationContinuation) in
            describeApplication(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Describes a component and lists the resources that are grouped together in a component.</p>
    func describeComponent(input: DescribeComponentInput) async throws -> DescribeComponentOutputResponse
    {
        typealias describeComponentContinuation = CheckedContinuation<DescribeComponentOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeComponentContinuation) in
            describeComponent(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Describes the monitoring configuration of the component.</p>
    func describeComponentConfiguration(input: DescribeComponentConfigurationInput) async throws -> DescribeComponentConfigurationOutputResponse
    {
        typealias describeComponentConfigurationContinuation = CheckedContinuation<DescribeComponentConfigurationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeComponentConfigurationContinuation) in
            describeComponentConfiguration(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Describes the recommended monitoring configuration of the component.</p>
    func describeComponentConfigurationRecommendation(input: DescribeComponentConfigurationRecommendationInput) async throws -> DescribeComponentConfigurationRecommendationOutputResponse
    {
        typealias describeComponentConfigurationRecommendationContinuation = CheckedContinuation<DescribeComponentConfigurationRecommendationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeComponentConfigurationRecommendationContinuation) in
            describeComponentConfigurationRecommendation(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Describe a specific log pattern from a <code>LogPatternSet</code>.</p>
    func describeLogPattern(input: DescribeLogPatternInput) async throws -> DescribeLogPatternOutputResponse
    {
        typealias describeLogPatternContinuation = CheckedContinuation<DescribeLogPatternOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeLogPatternContinuation) in
            describeLogPattern(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Describes an anomaly or error with the application.</p>
    func describeObservation(input: DescribeObservationInput) async throws -> DescribeObservationOutputResponse
    {
        typealias describeObservationContinuation = CheckedContinuation<DescribeObservationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeObservationContinuation) in
            describeObservation(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Describes an application problem.</p>
    func describeProblem(input: DescribeProblemInput) async throws -> DescribeProblemOutputResponse
    {
        typealias describeProblemContinuation = CheckedContinuation<DescribeProblemOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeProblemContinuation) in
            describeProblem(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Describes the anomalies or errors associated with the problem.</p>
    func describeProblemObservations(input: DescribeProblemObservationsInput) async throws -> DescribeProblemObservationsOutputResponse
    {
        typealias describeProblemObservationsContinuation = CheckedContinuation<DescribeProblemObservationsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeProblemObservationsContinuation) in
            describeProblemObservations(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Lists the IDs of the applications that you are monitoring. </p>
    func listApplications(input: ListApplicationsInput) async throws -> ListApplicationsOutputResponse
    {
        typealias listApplicationsContinuation = CheckedContinuation<ListApplicationsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listApplicationsContinuation) in
            listApplications(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Lists the auto-grouped, standalone, and custom components of the application.</p>
    func listComponents(input: ListComponentsInput) async throws -> ListComponentsOutputResponse
    {
        typealias listComponentsContinuation = CheckedContinuation<ListComponentsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listComponentsContinuation) in
            listComponents(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>
    ///          Lists the INFO, WARN, and ERROR events for periodic configuration updates performed by Application Insights. Examples of events represented are:
    ///       </p>
    ///          <ul>
    ///             <li>
    ///                <p>INFO: creating a new alarm or updating an alarm threshold.</p>
    ///             </li>
    ///             <li>
    ///                <p>WARN: alarm not created due to insufficient data points used to predict thresholds.</p>
    ///             </li>
    ///             <li>
    ///                <p>ERROR: alarm not created due to permission errors or exceeding quotas. </p>
    ///             </li>
    ///          </ul>
    func listConfigurationHistory(input: ListConfigurationHistoryInput) async throws -> ListConfigurationHistoryOutputResponse
    {
        typealias listConfigurationHistoryContinuation = CheckedContinuation<ListConfigurationHistoryOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listConfigurationHistoryContinuation) in
            listConfigurationHistory(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Lists the log pattern sets in the specific application.</p>
    func listLogPatternSets(input: ListLogPatternSetsInput) async throws -> ListLogPatternSetsOutputResponse
    {
        typealias listLogPatternSetsContinuation = CheckedContinuation<ListLogPatternSetsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listLogPatternSetsContinuation) in
            listLogPatternSets(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Lists the log patterns in the specific log <code>LogPatternSet</code>.</p>
    func listLogPatterns(input: ListLogPatternsInput) async throws -> ListLogPatternsOutputResponse
    {
        typealias listLogPatternsContinuation = CheckedContinuation<ListLogPatternsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listLogPatternsContinuation) in
            listLogPatterns(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Lists the problems with your application.</p>
    func listProblems(input: ListProblemsInput) async throws -> ListProblemsOutputResponse
    {
        typealias listProblemsContinuation = CheckedContinuation<ListProblemsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listProblemsContinuation) in
            listProblems(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Retrieve a list of the tags (keys and values) that are associated with a specified
    ///          application. A <i>tag</i> is a label that you optionally define and associate
    ///          with an application. Each tag consists of a required <i>tag key</i> and an
    ///          optional associated <i>tag value</i>. A tag key is a general label that
    ///          acts as a category for more specific tag values. A tag value acts as a descriptor within
    ///          a tag key.</p>
    func listTagsForResource(input: ListTagsForResourceInput) async throws -> ListTagsForResourceOutputResponse
    {
        typealias listTagsForResourceContinuation = CheckedContinuation<ListTagsForResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listTagsForResourceContinuation) in
            listTagsForResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Add one or more tags (keys and values) to a specified application. A
    ///          <i>tag</i> is a label that you optionally define and associate with an
    ///          application. Tags can help you categorize and manage application in different ways, such as
    ///          by purpose, owner, environment, or other criteria. </p>
    ///          <p>Each tag consists of a required <i>tag key</i> and an
    ///          associated <i>tag value</i>, both of which you define. A tag key is a
    ///          general label that acts as a category for more specific tag values. A tag value acts as
    ///          a descriptor within a tag key.</p>
    func tagResource(input: TagResourceInput) async throws -> TagResourceOutputResponse
    {
        typealias tagResourceContinuation = CheckedContinuation<TagResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: tagResourceContinuation) in
            tagResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Remove one or more tags (keys and values) from a specified application.</p>
    func untagResource(input: UntagResourceInput) async throws -> UntagResourceOutputResponse
    {
        typealias untagResourceContinuation = CheckedContinuation<UntagResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: untagResourceContinuation) in
            untagResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Updates the application.</p>
    func updateApplication(input: UpdateApplicationInput) async throws -> UpdateApplicationOutputResponse
    {
        typealias updateApplicationContinuation = CheckedContinuation<UpdateApplicationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateApplicationContinuation) in
            updateApplication(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Updates the custom component name and/or the list of resources that make up the
    ///          component.</p>
    func updateComponent(input: UpdateComponentInput) async throws -> UpdateComponentOutputResponse
    {
        typealias updateComponentContinuation = CheckedContinuation<UpdateComponentOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateComponentContinuation) in
            updateComponent(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Updates the monitoring configurations for the component. The configuration input parameter
    ///          is an escaped JSON of the configuration and should match the schema of what is returned
    ///          by <code>DescribeComponentConfigurationRecommendation</code>. </p>
    func updateComponentConfiguration(input: UpdateComponentConfigurationInput) async throws -> UpdateComponentConfigurationOutputResponse
    {
        typealias updateComponentConfigurationContinuation = CheckedContinuation<UpdateComponentConfigurationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateComponentConfigurationContinuation) in
            updateComponentConfiguration(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Adds a log pattern to a <code>LogPatternSet</code>.</p>
    func updateLogPattern(input: UpdateLogPatternInput) async throws -> UpdateLogPatternOutputResponse
    {
        typealias updateLogPatternContinuation = CheckedContinuation<UpdateLogPatternOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateLogPatternContinuation) in
            updateLogPattern(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

}
#endif
