// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension GroundStationClientTypes {
    public enum AngleUnits: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case degreeAngle
        case radian
        case sdkUnknown(Swift.String)

        public static var allCases: [AngleUnits] {
            return [
                .degreeAngle,
                .radian,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .degreeAngle: return "DEGREE_ANGLE"
            case .radian: return "RADIAN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AngleUnits(rawValue: rawValue) ?? AngleUnits.sdkUnknown(rawValue)
        }
    }
}

extension GroundStationClientTypes.AntennaDemodDecodeDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case outputNode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let outputNode = outputNode {
            try encodeContainer.encode(outputNode, forKey: .outputNode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputNodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputNode)
        outputNode = outputNodeDecoded
    }
}

extension GroundStationClientTypes.AntennaDemodDecodeDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AntennaDemodDecodeDetails(outputNode: \(Swift.String(describing: outputNode)))"}
}

extension GroundStationClientTypes {
    /// <p>Details about an antenna demod decode <code>Config</code> used in a contact.</p>
    public struct AntennaDemodDecodeDetails: Swift.Equatable {
        /// <p>Name of an antenna demod decode output node used in a contact.</p>
        public let outputNode: Swift.String?

        public init (
            outputNode: Swift.String? = nil
        )
        {
            self.outputNode = outputNode
        }
    }

}

extension GroundStationClientTypes.AntennaDownlinkConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case spectrumConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let spectrumConfig = spectrumConfig {
            try encodeContainer.encode(spectrumConfig, forKey: .spectrumConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let spectrumConfigDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.SpectrumConfig.self, forKey: .spectrumConfig)
        spectrumConfig = spectrumConfigDecoded
    }
}

extension GroundStationClientTypes.AntennaDownlinkConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AntennaDownlinkConfig(spectrumConfig: \(Swift.String(describing: spectrumConfig)))"}
}

extension GroundStationClientTypes {
    /// <p>Information about how AWS Ground Station should configure an
    ///          antenna for downlink during a contact.</p>
    public struct AntennaDownlinkConfig: Swift.Equatable {
        /// <p>Object that describes a spectral <code>Config</code>.</p>
        public let spectrumConfig: GroundStationClientTypes.SpectrumConfig?

        public init (
            spectrumConfig: GroundStationClientTypes.SpectrumConfig? = nil
        )
        {
            self.spectrumConfig = spectrumConfig
        }
    }

}

extension GroundStationClientTypes.AntennaDownlinkDemodDecodeConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case decodeConfig
        case demodulationConfig
        case spectrumConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let decodeConfig = decodeConfig {
            try encodeContainer.encode(decodeConfig, forKey: .decodeConfig)
        }
        if let demodulationConfig = demodulationConfig {
            try encodeContainer.encode(demodulationConfig, forKey: .demodulationConfig)
        }
        if let spectrumConfig = spectrumConfig {
            try encodeContainer.encode(spectrumConfig, forKey: .spectrumConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let spectrumConfigDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.SpectrumConfig.self, forKey: .spectrumConfig)
        spectrumConfig = spectrumConfigDecoded
        let demodulationConfigDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.DemodulationConfig.self, forKey: .demodulationConfig)
        demodulationConfig = demodulationConfigDecoded
        let decodeConfigDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.DecodeConfig.self, forKey: .decodeConfig)
        decodeConfig = decodeConfigDecoded
    }
}

extension GroundStationClientTypes.AntennaDownlinkDemodDecodeConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AntennaDownlinkDemodDecodeConfig(decodeConfig: \(Swift.String(describing: decodeConfig)), demodulationConfig: \(Swift.String(describing: demodulationConfig)), spectrumConfig: \(Swift.String(describing: spectrumConfig)))"}
}

extension GroundStationClientTypes {
    /// <p>Information about how AWS Ground Station should conÔ¨Ågure an antenna for downlink demod decode during a contact.</p>
    public struct AntennaDownlinkDemodDecodeConfig: Swift.Equatable {
        /// <p>Information about the decode <code>Config</code>.</p>
        public let decodeConfig: GroundStationClientTypes.DecodeConfig?
        /// <p>Information about the demodulation <code>Config</code>.</p>
        public let demodulationConfig: GroundStationClientTypes.DemodulationConfig?
        /// <p>Information about the spectral <code>Config</code>.</p>
        public let spectrumConfig: GroundStationClientTypes.SpectrumConfig?

        public init (
            decodeConfig: GroundStationClientTypes.DecodeConfig? = nil,
            demodulationConfig: GroundStationClientTypes.DemodulationConfig? = nil,
            spectrumConfig: GroundStationClientTypes.SpectrumConfig? = nil
        )
        {
            self.decodeConfig = decodeConfig
            self.demodulationConfig = demodulationConfig
            self.spectrumConfig = spectrumConfig
        }
    }

}

extension GroundStationClientTypes.AntennaUplinkConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case spectrumConfig
        case targetEirp
        case transmitDisabled
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let spectrumConfig = spectrumConfig {
            try encodeContainer.encode(spectrumConfig, forKey: .spectrumConfig)
        }
        if let targetEirp = targetEirp {
            try encodeContainer.encode(targetEirp, forKey: .targetEirp)
        }
        if let transmitDisabled = transmitDisabled {
            try encodeContainer.encode(transmitDisabled, forKey: .transmitDisabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transmitDisabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .transmitDisabled)
        transmitDisabled = transmitDisabledDecoded
        let spectrumConfigDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.UplinkSpectrumConfig.self, forKey: .spectrumConfig)
        spectrumConfig = spectrumConfigDecoded
        let targetEirpDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.Eirp.self, forKey: .targetEirp)
        targetEirp = targetEirpDecoded
    }
}

extension GroundStationClientTypes.AntennaUplinkConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AntennaUplinkConfig(spectrumConfig: \(Swift.String(describing: spectrumConfig)), targetEirp: \(Swift.String(describing: targetEirp)), transmitDisabled: \(Swift.String(describing: transmitDisabled)))"}
}

extension GroundStationClientTypes {
    /// <p>Information about the uplink <code>Config</code> of an antenna.</p>
    public struct AntennaUplinkConfig: Swift.Equatable {
        /// <p>Information about the uplink spectral <code>Config</code>.</p>
        public let spectrumConfig: GroundStationClientTypes.UplinkSpectrumConfig?
        /// <p>EIRP of the target.</p>
        public let targetEirp: GroundStationClientTypes.Eirp?
        /// <p>Whether or not uplink transmit is disabled.</p>
        public let transmitDisabled: Swift.Bool?

        public init (
            spectrumConfig: GroundStationClientTypes.UplinkSpectrumConfig? = nil,
            targetEirp: GroundStationClientTypes.Eirp? = nil,
            transmitDisabled: Swift.Bool? = nil
        )
        {
            self.spectrumConfig = spectrumConfig
            self.targetEirp = targetEirp
            self.transmitDisabled = transmitDisabled
        }
    }

}

extension GroundStationClientTypes {
    public enum BandwidthUnits: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ghz
        case khz
        case mhz
        case sdkUnknown(Swift.String)

        public static var allCases: [BandwidthUnits] {
            return [
                .ghz,
                .khz,
                .mhz,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ghz: return "GHz"
            case .khz: return "kHz"
            case .mhz: return "MHz"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BandwidthUnits(rawValue: rawValue) ?? BandwidthUnits.sdkUnknown(rawValue)
        }
    }
}

extension CancelContactInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelContactInput(contactId: \(Swift.String(describing: contactId)))"}
}

extension CancelContactInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct CancelContactInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelContactInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelContactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelContactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelContactOutputError>
}

public struct CancelContactInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelContactInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelContactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelContactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelContactOutputError>
}

/// <p/>
public struct CancelContactInput: Swift.Equatable {
    /// <p>UUID of a contact.</p>
    public let contactId: Swift.String?

    public init (
        contactId: Swift.String? = nil
    )
    {
        self.contactId = contactId
    }
}

struct CancelContactInputBody: Swift.Equatable {
}

extension CancelContactInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CancelContactOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelContactOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelContactOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelContactOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelContactOutputResponse(contactId: \(Swift.String(describing: contactId)))"}
}

extension CancelContactOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CancelContactOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contactId = output.contactId
        } else {
            self.contactId = nil
        }
    }
}

/// <p/>
public struct CancelContactOutputResponse: Swift.Equatable {
    /// <p>UUID of a contact.</p>
    public let contactId: Swift.String?

    public init (
        contactId: Swift.String? = nil
    )
    {
        self.contactId = contactId
    }
}

struct CancelContactOutputResponseBody: Swift.Equatable {
    public let contactId: Swift.String?
}

extension CancelContactOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
    }
}

extension GroundStationClientTypes {
    public enum ConfigCapabilityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case antennaDownlink
        case antennaDownlinkDemodDecode
        case antennaUplink
        case dataflowEndpoint
        case s3Recording
        case tracking
        case uplinkEcho
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfigCapabilityType] {
            return [
                .antennaDownlink,
                .antennaDownlinkDemodDecode,
                .antennaUplink,
                .dataflowEndpoint,
                .s3Recording,
                .tracking,
                .uplinkEcho,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .antennaDownlink: return "antenna-downlink"
            case .antennaDownlinkDemodDecode: return "antenna-downlink-demod-decode"
            case .antennaUplink: return "antenna-uplink"
            case .dataflowEndpoint: return "dataflow-endpoint"
            case .s3Recording: return "s3-recording"
            case .tracking: return "tracking"
            case .uplinkEcho: return "uplink-echo"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConfigCapabilityType(rawValue: rawValue) ?? ConfigCapabilityType.sdkUnknown(rawValue)
        }
    }
}

extension GroundStationClientTypes.ConfigDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case antennademoddecodedetails = "antennaDemodDecodeDetails"
        case endpointdetails = "endpointDetails"
        case s3recordingdetails = "s3RecordingDetails"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .antennademoddecodedetails(antennademoddecodedetails):
                try container.encode(antennademoddecodedetails, forKey: .antennademoddecodedetails)
            case let .endpointdetails(endpointdetails):
                try container.encode(endpointdetails, forKey: .endpointdetails)
            case let .s3recordingdetails(s3recordingdetails):
                try container.encode(s3recordingdetails, forKey: .s3recordingdetails)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let endpointdetailsDecoded = try values.decodeIfPresent(GroundStationClientTypes.EndpointDetails.self, forKey: .endpointdetails)
        if let endpointdetails = endpointdetailsDecoded {
            self = .endpointdetails(endpointdetails)
            return
        }
        let antennademoddecodedetailsDecoded = try values.decodeIfPresent(GroundStationClientTypes.AntennaDemodDecodeDetails.self, forKey: .antennademoddecodedetails)
        if let antennademoddecodedetails = antennademoddecodedetailsDecoded {
            self = .antennademoddecodedetails(antennademoddecodedetails)
            return
        }
        let s3recordingdetailsDecoded = try values.decodeIfPresent(GroundStationClientTypes.S3RecordingDetails.self, forKey: .s3recordingdetails)
        if let s3recordingdetails = s3recordingdetailsDecoded {
            self = .s3recordingdetails(s3recordingdetails)
            return
        }
        self = .sdkUnknown("")
    }
}

extension GroundStationClientTypes {
    /// <p>Details for certain <code>Config</code> object types in a contact.</p>
    public enum ConfigDetails: Swift.Equatable {
        /// <p>Information about the endpoint details.</p>
        case endpointdetails(GroundStationClientTypes.EndpointDetails)
        /// <p>Details for antenna demod decode <code>Config</code> in a contact.</p>
        case antennademoddecodedetails(GroundStationClientTypes.AntennaDemodDecodeDetails)
        /// <p>Details for an S3 recording <code>Config</code> in a contact.</p>
        case s3recordingdetails(GroundStationClientTypes.S3RecordingDetails)
        case sdkUnknown(Swift.String)
    }

}

extension GroundStationClientTypes.ConfigListItem: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configArn
        case configId
        case configType
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configArn = configArn {
            try encodeContainer.encode(configArn, forKey: .configArn)
        }
        if let configId = configId {
            try encodeContainer.encode(configId, forKey: .configId)
        }
        if let configType = configType {
            try encodeContainer.encode(configType.rawValue, forKey: .configType)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configId)
        configId = configIdDecoded
        let configTypeDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.ConfigCapabilityType.self, forKey: .configType)
        configType = configTypeDecoded
        let configArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configArn)
        configArn = configArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GroundStationClientTypes.ConfigListItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConfigListItem(configArn: \(Swift.String(describing: configArn)), configId: \(Swift.String(describing: configId)), configType: \(Swift.String(describing: configType)), name: \(Swift.String(describing: name)))"}
}

extension GroundStationClientTypes {
    /// <p>An item in a list of <code>Config</code> objects.</p>
    public struct ConfigListItem: Swift.Equatable {
        /// <p>ARN of a <code>Config</code>.</p>
        public let configArn: Swift.String?
        /// <p>UUID of a <code>Config</code>.</p>
        public let configId: Swift.String?
        /// <p>Type of a <code>Config</code>.</p>
        public let configType: GroundStationClientTypes.ConfigCapabilityType?
        /// <p>Name of a <code>Config</code>.</p>
        public let name: Swift.String?

        public init (
            configArn: Swift.String? = nil,
            configId: Swift.String? = nil,
            configType: GroundStationClientTypes.ConfigCapabilityType? = nil,
            name: Swift.String? = nil
        )
        {
            self.configArn = configArn
            self.configId = configId
            self.configType = configType
            self.name = name
        }
    }

}

extension GroundStationClientTypes.ConfigTypeData: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case antennadownlinkconfig = "antennaDownlinkConfig"
        case antennadownlinkdemoddecodeconfig = "antennaDownlinkDemodDecodeConfig"
        case antennauplinkconfig = "antennaUplinkConfig"
        case dataflowendpointconfig = "dataflowEndpointConfig"
        case s3recordingconfig = "s3RecordingConfig"
        case sdkUnknown
        case trackingconfig = "trackingConfig"
        case uplinkechoconfig = "uplinkEchoConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .antennadownlinkconfig(antennadownlinkconfig):
                try container.encode(antennadownlinkconfig, forKey: .antennadownlinkconfig)
            case let .antennadownlinkdemoddecodeconfig(antennadownlinkdemoddecodeconfig):
                try container.encode(antennadownlinkdemoddecodeconfig, forKey: .antennadownlinkdemoddecodeconfig)
            case let .antennauplinkconfig(antennauplinkconfig):
                try container.encode(antennauplinkconfig, forKey: .antennauplinkconfig)
            case let .dataflowendpointconfig(dataflowendpointconfig):
                try container.encode(dataflowendpointconfig, forKey: .dataflowendpointconfig)
            case let .s3recordingconfig(s3recordingconfig):
                try container.encode(s3recordingconfig, forKey: .s3recordingconfig)
            case let .trackingconfig(trackingconfig):
                try container.encode(trackingconfig, forKey: .trackingconfig)
            case let .uplinkechoconfig(uplinkechoconfig):
                try container.encode(uplinkechoconfig, forKey: .uplinkechoconfig)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let antennadownlinkconfigDecoded = try values.decodeIfPresent(GroundStationClientTypes.AntennaDownlinkConfig.self, forKey: .antennadownlinkconfig)
        if let antennadownlinkconfig = antennadownlinkconfigDecoded {
            self = .antennadownlinkconfig(antennadownlinkconfig)
            return
        }
        let trackingconfigDecoded = try values.decodeIfPresent(GroundStationClientTypes.TrackingConfig.self, forKey: .trackingconfig)
        if let trackingconfig = trackingconfigDecoded {
            self = .trackingconfig(trackingconfig)
            return
        }
        let dataflowendpointconfigDecoded = try values.decodeIfPresent(GroundStationClientTypes.DataflowEndpointConfig.self, forKey: .dataflowendpointconfig)
        if let dataflowendpointconfig = dataflowendpointconfigDecoded {
            self = .dataflowendpointconfig(dataflowendpointconfig)
            return
        }
        let antennadownlinkdemoddecodeconfigDecoded = try values.decodeIfPresent(GroundStationClientTypes.AntennaDownlinkDemodDecodeConfig.self, forKey: .antennadownlinkdemoddecodeconfig)
        if let antennadownlinkdemoddecodeconfig = antennadownlinkdemoddecodeconfigDecoded {
            self = .antennadownlinkdemoddecodeconfig(antennadownlinkdemoddecodeconfig)
            return
        }
        let antennauplinkconfigDecoded = try values.decodeIfPresent(GroundStationClientTypes.AntennaUplinkConfig.self, forKey: .antennauplinkconfig)
        if let antennauplinkconfig = antennauplinkconfigDecoded {
            self = .antennauplinkconfig(antennauplinkconfig)
            return
        }
        let uplinkechoconfigDecoded = try values.decodeIfPresent(GroundStationClientTypes.UplinkEchoConfig.self, forKey: .uplinkechoconfig)
        if let uplinkechoconfig = uplinkechoconfigDecoded {
            self = .uplinkechoconfig(uplinkechoconfig)
            return
        }
        let s3recordingconfigDecoded = try values.decodeIfPresent(GroundStationClientTypes.S3RecordingConfig.self, forKey: .s3recordingconfig)
        if let s3recordingconfig = s3recordingconfigDecoded {
            self = .s3recordingconfig(s3recordingconfig)
            return
        }
        self = .sdkUnknown("")
    }
}

extension GroundStationClientTypes {
    /// <p>Object containing the parameters of a <code>Config</code>.</p>
    ///          <p>See the subtype definitions for what each type of <code>Config</code> contains.</p>
    public enum ConfigTypeData: Swift.Equatable {
        /// <p>Information about how AWS Ground Station should configure an antenna for downlink during a contact.</p>
        case antennadownlinkconfig(GroundStationClientTypes.AntennaDownlinkConfig)
        /// <p>Object that determines whether tracking should be used during a contact executed with this <code>Config</code> in the mission profile. </p>
        case trackingconfig(GroundStationClientTypes.TrackingConfig)
        /// <p>Information about the dataflow endpoint <code>Config</code>.</p>
        case dataflowendpointconfig(GroundStationClientTypes.DataflowEndpointConfig)
        /// <p>Information about how AWS Ground Station should conÔ¨Ågure an antenna for downlink demod decode during a contact.</p>
        case antennadownlinkdemoddecodeconfig(GroundStationClientTypes.AntennaDownlinkDemodDecodeConfig)
        /// <p>Information about how AWS Ground Station should conÔ¨Ågure an antenna for uplink during a contact.</p>
        case antennauplinkconfig(GroundStationClientTypes.AntennaUplinkConfig)
        /// <p>Information about an uplink echo <code>Config</code>.</p>
        ///          <p>Parameters from the <code>AntennaUplinkConfig</code>, corresponding to the specified <code>AntennaUplinkConfigArn</code>, are used when this <code>UplinkEchoConfig</code> is used in a contact.</p>
        case uplinkechoconfig(GroundStationClientTypes.UplinkEchoConfig)
        /// <p>Information about an S3 recording <code>Config</code>.</p>
        case s3recordingconfig(GroundStationClientTypes.S3RecordingConfig)
        case sdkUnknown(Swift.String)
    }

}

extension GroundStationClientTypes.ContactData: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId
        case contactStatus
        case endTime
        case errorMessage
        case groundStation
        case maximumElevation
        case missionProfileArn
        case postPassEndTime
        case prePassStartTime
        case region
        case satelliteArn
        case startTime
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let contactStatus = contactStatus {
            try encodeContainer.encode(contactStatus.rawValue, forKey: .contactStatus)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let groundStation = groundStation {
            try encodeContainer.encode(groundStation, forKey: .groundStation)
        }
        if let maximumElevation = maximumElevation {
            try encodeContainer.encode(maximumElevation, forKey: .maximumElevation)
        }
        if let missionProfileArn = missionProfileArn {
            try encodeContainer.encode(missionProfileArn, forKey: .missionProfileArn)
        }
        if let postPassEndTime = postPassEndTime {
            try encodeContainer.encode(postPassEndTime.timeIntervalSince1970, forKey: .postPassEndTime)
        }
        if let prePassStartTime = prePassStartTime {
            try encodeContainer.encode(prePassStartTime.timeIntervalSince1970, forKey: .prePassStartTime)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let satelliteArn = satelliteArn {
            try encodeContainer.encode(satelliteArn, forKey: .satelliteArn)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let missionProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .missionProfileArn)
        missionProfileArn = missionProfileArnDecoded
        let satelliteArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .satelliteArn)
        satelliteArn = satelliteArnDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let prePassStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .prePassStartTime)
        prePassStartTime = prePassStartTimeDecoded
        let postPassEndTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .postPassEndTime)
        postPassEndTime = postPassEndTimeDecoded
        let groundStationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groundStation)
        groundStation = groundStationDecoded
        let contactStatusDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.ContactStatus.self, forKey: .contactStatus)
        contactStatus = contactStatusDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let maximumElevationDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.Elevation.self, forKey: .maximumElevation)
        maximumElevation = maximumElevationDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GroundStationClientTypes.ContactData: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ContactData(contactId: \(Swift.String(describing: contactId)), contactStatus: \(Swift.String(describing: contactStatus)), endTime: \(Swift.String(describing: endTime)), errorMessage: \(Swift.String(describing: errorMessage)), groundStation: \(Swift.String(describing: groundStation)), maximumElevation: \(Swift.String(describing: maximumElevation)), missionProfileArn: \(Swift.String(describing: missionProfileArn)), postPassEndTime: \(Swift.String(describing: postPassEndTime)), prePassStartTime: \(Swift.String(describing: prePassStartTime)), region: \(Swift.String(describing: region)), satelliteArn: \(Swift.String(describing: satelliteArn)), startTime: \(Swift.String(describing: startTime)), tags: \(Swift.String(describing: tags)))"}
}

extension GroundStationClientTypes {
    /// <p>Data describing a contact.</p>
    public struct ContactData: Swift.Equatable {
        /// <p>UUID of a contact.</p>
        public let contactId: Swift.String?
        /// <p>Status of a contact.</p>
        public let contactStatus: GroundStationClientTypes.ContactStatus?
        /// <p>End time of a contact.</p>
        public let endTime: ClientRuntime.Date?
        /// <p>Error message of a contact.</p>
        public let errorMessage: Swift.String?
        /// <p>Name of a ground station.</p>
        public let groundStation: Swift.String?
        /// <p>Maximum elevation angle of a contact.</p>
        public let maximumElevation: GroundStationClientTypes.Elevation?
        /// <p>ARN of a mission profile.</p>
        public let missionProfileArn: Swift.String?
        /// <p>Amount of time after a contact ends that you‚Äôd like to receive a CloudWatch event indicating the pass has finished.</p>
        public let postPassEndTime: ClientRuntime.Date?
        /// <p>Amount of time prior to contact start you‚Äôd like to receive a CloudWatch event indicating an upcoming pass.</p>
        public let prePassStartTime: ClientRuntime.Date?
        /// <p>Region of a contact.</p>
        public let region: Swift.String?
        /// <p>ARN of a satellite.</p>
        public let satelliteArn: Swift.String?
        /// <p>Start time of a contact.</p>
        public let startTime: ClientRuntime.Date?
        /// <p>Tags assigned to a contact.</p>
        public let tags: [Swift.String:Swift.String]?

        public init (
            contactId: Swift.String? = nil,
            contactStatus: GroundStationClientTypes.ContactStatus? = nil,
            endTime: ClientRuntime.Date? = nil,
            errorMessage: Swift.String? = nil,
            groundStation: Swift.String? = nil,
            maximumElevation: GroundStationClientTypes.Elevation? = nil,
            missionProfileArn: Swift.String? = nil,
            postPassEndTime: ClientRuntime.Date? = nil,
            prePassStartTime: ClientRuntime.Date? = nil,
            region: Swift.String? = nil,
            satelliteArn: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.contactId = contactId
            self.contactStatus = contactStatus
            self.endTime = endTime
            self.errorMessage = errorMessage
            self.groundStation = groundStation
            self.maximumElevation = maximumElevation
            self.missionProfileArn = missionProfileArn
            self.postPassEndTime = postPassEndTime
            self.prePassStartTime = prePassStartTime
            self.region = region
            self.satelliteArn = satelliteArn
            self.startTime = startTime
            self.tags = tags
        }
    }

}

extension GroundStationClientTypes {
    public enum ContactStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case awsCancelled
        case awsFailed
        case cancelled
        case cancelling
        case completed
        case failed
        case failedToSchedule
        case pass
        case postpass
        case prepass
        case scheduled
        case scheduling
        case sdkUnknown(Swift.String)

        public static var allCases: [ContactStatus] {
            return [
                .available,
                .awsCancelled,
                .awsFailed,
                .cancelled,
                .cancelling,
                .completed,
                .failed,
                .failedToSchedule,
                .pass,
                .postpass,
                .prepass,
                .scheduled,
                .scheduling,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .awsCancelled: return "AWS_CANCELLED"
            case .awsFailed: return "AWS_FAILED"
            case .cancelled: return "CANCELLED"
            case .cancelling: return "CANCELLING"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .failedToSchedule: return "FAILED_TO_SCHEDULE"
            case .pass: return "PASS"
            case .postpass: return "POSTPASS"
            case .prepass: return "PREPASS"
            case .scheduled: return "SCHEDULED"
            case .scheduling: return "SCHEDULING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContactStatus(rawValue: rawValue) ?? ContactStatus.sdkUnknown(rawValue)
        }
    }
}

public struct CreateConfigInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConfigOutputError>
}

extension CreateConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateConfigInput(configData: \(Swift.String(describing: configData)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateConfigInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configData
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configData = configData {
            try encodeContainer.encode(configData, forKey: .configData)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConfigOutputError>
}

public struct CreateConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConfigOutputError>
}

/// <p/>
public struct CreateConfigInput: Swift.Equatable {
    /// <p>Parameters of a <code>Config</code>.</p>
    public let configData: GroundStationClientTypes.ConfigTypeData?
    /// <p>Name of a <code>Config</code>.</p>
    public let name: Swift.String?
    /// <p>Tags assigned to a <code>Config</code>.</p>
    public let tags: [Swift.String:Swift.String]?

    public init (
        configData: GroundStationClientTypes.ConfigTypeData? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.configData = configData
        self.name = name
        self.tags = tags
    }
}

struct CreateConfigInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let configData: GroundStationClientTypes.ConfigTypeData?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configData
        case name
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let configDataDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.ConfigTypeData.self, forKey: .configData)
        configData = configDataDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateConfigOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateConfigOutputResponse(configArn: \(Swift.String(describing: configArn)), configId: \(Swift.String(describing: configId)), configType: \(Swift.String(describing: configType)))"}
}

extension CreateConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.configArn = output.configArn
            self.configId = output.configId
            self.configType = output.configType
        } else {
            self.configArn = nil
            self.configId = nil
            self.configType = nil
        }
    }
}

/// <p/>
public struct CreateConfigOutputResponse: Swift.Equatable {
    /// <p>ARN of a <code>Config</code>.</p>
    public let configArn: Swift.String?
    /// <p>UUID of a <code>Config</code>.</p>
    public let configId: Swift.String?
    /// <p>Type of a <code>Config</code>.</p>
    public let configType: GroundStationClientTypes.ConfigCapabilityType?

    public init (
        configArn: Swift.String? = nil,
        configId: Swift.String? = nil,
        configType: GroundStationClientTypes.ConfigCapabilityType? = nil
    )
    {
        self.configArn = configArn
        self.configId = configId
        self.configType = configType
    }
}

struct CreateConfigOutputResponseBody: Swift.Equatable {
    public let configId: Swift.String?
    public let configType: GroundStationClientTypes.ConfigCapabilityType?
    public let configArn: Swift.String?
}

extension CreateConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configArn
        case configId
        case configType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configId)
        configId = configIdDecoded
        let configTypeDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.ConfigCapabilityType.self, forKey: .configType)
        configType = configTypeDecoded
        let configArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configArn)
        configArn = configArnDecoded
    }
}

public struct CreateDataflowEndpointGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDataflowEndpointGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDataflowEndpointGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDataflowEndpointGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDataflowEndpointGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDataflowEndpointGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDataflowEndpointGroupOutputError>
}

extension CreateDataflowEndpointGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDataflowEndpointGroupInput(endpointDetails: \(Swift.String(describing: endpointDetails)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateDataflowEndpointGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointDetails
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointDetails = endpointDetails {
            var endpointDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpointDetails)
            for endpointdetailslist0 in endpointDetails {
                try endpointDetailsContainer.encode(endpointdetailslist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateDataflowEndpointGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDataflowEndpointGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDataflowEndpointGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDataflowEndpointGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDataflowEndpointGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDataflowEndpointGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDataflowEndpointGroupOutputError>
}

public struct CreateDataflowEndpointGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDataflowEndpointGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDataflowEndpointGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDataflowEndpointGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDataflowEndpointGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDataflowEndpointGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDataflowEndpointGroupOutputError>
}

/// <p/>
public struct CreateDataflowEndpointGroupInput: Swift.Equatable {
    /// <p>Endpoint details of each endpoint in the dataflow endpoint group.</p>
    public let endpointDetails: [GroundStationClientTypes.EndpointDetails]?
    /// <p>Tags of a dataflow endpoint group.</p>
    public let tags: [Swift.String:Swift.String]?

    public init (
        endpointDetails: [GroundStationClientTypes.EndpointDetails]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.endpointDetails = endpointDetails
        self.tags = tags
    }
}

struct CreateDataflowEndpointGroupInputBody: Swift.Equatable {
    public let endpointDetails: [GroundStationClientTypes.EndpointDetails]?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateDataflowEndpointGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointDetails
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDetailsContainer = try containerValues.decodeIfPresent([GroundStationClientTypes.EndpointDetails?].self, forKey: .endpointDetails)
        var endpointDetailsDecoded0:[GroundStationClientTypes.EndpointDetails]? = nil
        if let endpointDetailsContainer = endpointDetailsContainer {
            endpointDetailsDecoded0 = [GroundStationClientTypes.EndpointDetails]()
            for structure0 in endpointDetailsContainer {
                if let structure0 = structure0 {
                    endpointDetailsDecoded0?.append(structure0)
                }
            }
        }
        endpointDetails = endpointDetailsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDataflowEndpointGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDataflowEndpointGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDataflowEndpointGroupOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDataflowEndpointGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDataflowEndpointGroupOutputResponse(dataflowEndpointGroupId: \(Swift.String(describing: dataflowEndpointGroupId)))"}
}

extension CreateDataflowEndpointGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDataflowEndpointGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataflowEndpointGroupId = output.dataflowEndpointGroupId
        } else {
            self.dataflowEndpointGroupId = nil
        }
    }
}

/// <p/>
public struct CreateDataflowEndpointGroupOutputResponse: Swift.Equatable {
    /// <p>UUID of a dataflow endpoint group.</p>
    public let dataflowEndpointGroupId: Swift.String?

    public init (
        dataflowEndpointGroupId: Swift.String? = nil
    )
    {
        self.dataflowEndpointGroupId = dataflowEndpointGroupId
    }
}

struct CreateDataflowEndpointGroupOutputResponseBody: Swift.Equatable {
    public let dataflowEndpointGroupId: Swift.String?
}

extension CreateDataflowEndpointGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataflowEndpointGroupId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataflowEndpointGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataflowEndpointGroupId)
        dataflowEndpointGroupId = dataflowEndpointGroupIdDecoded
    }
}

public struct CreateMissionProfileInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMissionProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateMissionProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateMissionProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateMissionProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMissionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateMissionProfileOutputError>
}

extension CreateMissionProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMissionProfileInput(contactPostPassDurationSeconds: \(Swift.String(describing: contactPostPassDurationSeconds)), contactPrePassDurationSeconds: \(Swift.String(describing: contactPrePassDurationSeconds)), dataflowEdges: \(Swift.String(describing: dataflowEdges)), minimumViableContactDurationSeconds: \(Swift.String(describing: minimumViableContactDurationSeconds)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)), trackingConfigArn: \(Swift.String(describing: trackingConfigArn)))"}
}

extension CreateMissionProfileInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactPostPassDurationSeconds
        case contactPrePassDurationSeconds
        case dataflowEdges
        case minimumViableContactDurationSeconds
        case name
        case tags
        case trackingConfigArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactPostPassDurationSeconds = contactPostPassDurationSeconds {
            try encodeContainer.encode(contactPostPassDurationSeconds, forKey: .contactPostPassDurationSeconds)
        }
        if let contactPrePassDurationSeconds = contactPrePassDurationSeconds {
            try encodeContainer.encode(contactPrePassDurationSeconds, forKey: .contactPrePassDurationSeconds)
        }
        if let dataflowEdges = dataflowEdges {
            var dataflowEdgesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataflowEdges)
            for dataflowedgelist0 in dataflowEdges {
                var dataflowedgelist0Container = dataflowEdgesContainer.nestedUnkeyedContainer()
                for dataflowedge1 in dataflowedgelist0 {
                    try dataflowedgelist0Container.encode(dataflowedge1)
                }
            }
        }
        if let minimumViableContactDurationSeconds = minimumViableContactDurationSeconds {
            try encodeContainer.encode(minimumViableContactDurationSeconds, forKey: .minimumViableContactDurationSeconds)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let trackingConfigArn = trackingConfigArn {
            try encodeContainer.encode(trackingConfigArn, forKey: .trackingConfigArn)
        }
    }
}

public struct CreateMissionProfileInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMissionProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateMissionProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateMissionProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateMissionProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMissionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateMissionProfileOutputError>
}

public struct CreateMissionProfileInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMissionProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateMissionProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateMissionProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateMissionProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMissionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateMissionProfileOutputError>
}

/// <p/>
public struct CreateMissionProfileInput: Swift.Equatable {
    /// <p>Amount of time after a contact ends that you‚Äôd like to receive a CloudWatch event indicating the pass has finished.</p>
    public let contactPostPassDurationSeconds: Swift.Int?
    /// <p>Amount of time prior to contact start you‚Äôd like to receive a CloudWatch event indicating an upcoming pass.</p>
    public let contactPrePassDurationSeconds: Swift.Int?
    /// <p>A list of lists of ARNs. Each list of ARNs is an edge, with a <i>from</i>
    ///             <code>Config</code> and a <i>to</i>
    ///             <code>Config</code>.</p>
    public let dataflowEdges: [[Swift.String]]?
    /// <p>Smallest amount of time in seconds that you‚Äôd like to see for an available contact. AWS Ground Station will not present you with contacts shorter than this duration.</p>
    public let minimumViableContactDurationSeconds: Swift.Int?
    /// <p>Name of a mission profile.</p>
    public let name: Swift.String?
    /// <p>Tags assigned to a mission profile.</p>
    public let tags: [Swift.String:Swift.String]?
    /// <p>ARN of a tracking <code>Config</code>.</p>
    public let trackingConfigArn: Swift.String?

    public init (
        contactPostPassDurationSeconds: Swift.Int? = nil,
        contactPrePassDurationSeconds: Swift.Int? = nil,
        dataflowEdges: [[Swift.String]]? = nil,
        minimumViableContactDurationSeconds: Swift.Int? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        trackingConfigArn: Swift.String? = nil
    )
    {
        self.contactPostPassDurationSeconds = contactPostPassDurationSeconds
        self.contactPrePassDurationSeconds = contactPrePassDurationSeconds
        self.dataflowEdges = dataflowEdges
        self.minimumViableContactDurationSeconds = minimumViableContactDurationSeconds
        self.name = name
        self.tags = tags
        self.trackingConfigArn = trackingConfigArn
    }
}

struct CreateMissionProfileInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let contactPrePassDurationSeconds: Swift.Int?
    public let contactPostPassDurationSeconds: Swift.Int?
    public let minimumViableContactDurationSeconds: Swift.Int?
    public let dataflowEdges: [[Swift.String]]?
    public let trackingConfigArn: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateMissionProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactPostPassDurationSeconds
        case contactPrePassDurationSeconds
        case dataflowEdges
        case minimumViableContactDurationSeconds
        case name
        case tags
        case trackingConfigArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let contactPrePassDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .contactPrePassDurationSeconds)
        contactPrePassDurationSeconds = contactPrePassDurationSecondsDecoded
        let contactPostPassDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .contactPostPassDurationSeconds)
        contactPostPassDurationSeconds = contactPostPassDurationSecondsDecoded
        let minimumViableContactDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minimumViableContactDurationSeconds)
        minimumViableContactDurationSeconds = minimumViableContactDurationSecondsDecoded
        let dataflowEdgesContainer = try containerValues.decodeIfPresent([[Swift.String?]?].self, forKey: .dataflowEdges)
        var dataflowEdgesDecoded0:[[Swift.String]]? = nil
        if let dataflowEdgesContainer = dataflowEdgesContainer {
            dataflowEdgesDecoded0 = [[Swift.String]]()
            for list0 in dataflowEdgesContainer {
                var list0Decoded0: [Swift.String]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [Swift.String]()
                    for string1 in list0 {
                        if let string1 = string1 {
                            list0Decoded0?.append(string1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    dataflowEdgesDecoded0?.append(list0Decoded0)
                }
            }
        }
        dataflowEdges = dataflowEdgesDecoded0
        let trackingConfigArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trackingConfigArn)
        trackingConfigArn = trackingConfigArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateMissionProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateMissionProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateMissionProfileOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateMissionProfileOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMissionProfileOutputResponse(missionProfileId: \(Swift.String(describing: missionProfileId)))"}
}

extension CreateMissionProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateMissionProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.missionProfileId = output.missionProfileId
        } else {
            self.missionProfileId = nil
        }
    }
}

/// <p/>
public struct CreateMissionProfileOutputResponse: Swift.Equatable {
    /// <p>UUID of a mission profile.</p>
    public let missionProfileId: Swift.String?

    public init (
        missionProfileId: Swift.String? = nil
    )
    {
        self.missionProfileId = missionProfileId
    }
}

struct CreateMissionProfileOutputResponseBody: Swift.Equatable {
    public let missionProfileId: Swift.String?
}

extension CreateMissionProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case missionProfileId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let missionProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .missionProfileId)
        missionProfileId = missionProfileIdDecoded
    }
}

extension GroundStationClientTypes {
    public enum Criticality: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case preferred
        case removed
        case `required`
        case sdkUnknown(Swift.String)

        public static var allCases: [Criticality] {
            return [
                .preferred,
                .removed,
                .required,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .preferred: return "PREFERRED"
            case .removed: return "REMOVED"
            case .required: return "REQUIRED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Criticality(rawValue: rawValue) ?? Criticality.sdkUnknown(rawValue)
        }
    }
}

extension GroundStationClientTypes.DataflowDetail: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination
        case errorMessage
        case source
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.Source.self, forKey: .source)
        source = sourceDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.Destination.self, forKey: .destination)
        destination = destinationDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension GroundStationClientTypes.DataflowDetail: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataflowDetail(destination: \(Swift.String(describing: destination)), errorMessage: \(Swift.String(describing: errorMessage)), source: \(Swift.String(describing: source)))"}
}

extension GroundStationClientTypes {
    /// <p>Information about a dataflow edge used in a contact.</p>
    public struct DataflowDetail: Swift.Equatable {
        /// <p>Dataflow details for the destination side.</p>
        public let destination: GroundStationClientTypes.Destination?
        /// <p>Error message for a dataflow.</p>
        public let errorMessage: Swift.String?
        /// <p>Dataflow details for the source side.</p>
        public let source: GroundStationClientTypes.Source?

        public init (
            destination: GroundStationClientTypes.Destination? = nil,
            errorMessage: Swift.String? = nil,
            source: GroundStationClientTypes.Source? = nil
        )
        {
            self.destination = destination
            self.errorMessage = errorMessage
            self.source = source
        }
    }

}

extension GroundStationClientTypes.DataflowEndpoint: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address
        case mtu
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if let mtu = mtu {
            try encodeContainer.encode(mtu, forKey: .mtu)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let addressDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.SocketAddress.self, forKey: .address)
        address = addressDecoded
        let statusDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.EndpointStatus.self, forKey: .status)
        status = statusDecoded
        let mtuDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .mtu)
        mtu = mtuDecoded
    }
}

extension GroundStationClientTypes.DataflowEndpoint: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataflowEndpoint(address: \(Swift.String(describing: address)), mtu: \(Swift.String(describing: mtu)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)))"}
}

extension GroundStationClientTypes {
    /// <p>Information about a dataflow endpoint.</p>
    public struct DataflowEndpoint: Swift.Equatable {
        /// <p>Socket address of a dataflow endpoint.</p>
        public let address: GroundStationClientTypes.SocketAddress?
        /// <p>Maximum transmission unit (MTU) size in bytes of a dataflow endpoint.</p>
        public let mtu: Swift.Int?
        /// <p>Name of a dataflow endpoint.</p>
        public let name: Swift.String?
        /// <p>Status of a dataflow endpoint.</p>
        public let status: GroundStationClientTypes.EndpointStatus?

        public init (
            address: GroundStationClientTypes.SocketAddress? = nil,
            mtu: Swift.Int? = nil,
            name: Swift.String? = nil,
            status: GroundStationClientTypes.EndpointStatus? = nil
        )
        {
            self.address = address
            self.mtu = mtu
            self.name = name
            self.status = status
        }
    }

}

extension GroundStationClientTypes.DataflowEndpointConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataflowEndpointName
        case dataflowEndpointRegion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataflowEndpointName = dataflowEndpointName {
            try encodeContainer.encode(dataflowEndpointName, forKey: .dataflowEndpointName)
        }
        if let dataflowEndpointRegion = dataflowEndpointRegion {
            try encodeContainer.encode(dataflowEndpointRegion, forKey: .dataflowEndpointRegion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataflowEndpointNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataflowEndpointName)
        dataflowEndpointName = dataflowEndpointNameDecoded
        let dataflowEndpointRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataflowEndpointRegion)
        dataflowEndpointRegion = dataflowEndpointRegionDecoded
    }
}

extension GroundStationClientTypes.DataflowEndpointConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataflowEndpointConfig(dataflowEndpointName: \(Swift.String(describing: dataflowEndpointName)), dataflowEndpointRegion: \(Swift.String(describing: dataflowEndpointRegion)))"}
}

extension GroundStationClientTypes {
    /// <p>Information about the dataflow endpoint <code>Config</code>.</p>
    public struct DataflowEndpointConfig: Swift.Equatable {
        /// <p>Name of a dataflow endpoint.</p>
        public let dataflowEndpointName: Swift.String?
        /// <p>Region of a dataflow endpoint.</p>
        public let dataflowEndpointRegion: Swift.String?

        public init (
            dataflowEndpointName: Swift.String? = nil,
            dataflowEndpointRegion: Swift.String? = nil
        )
        {
            self.dataflowEndpointName = dataflowEndpointName
            self.dataflowEndpointRegion = dataflowEndpointRegion
        }
    }

}

extension GroundStationClientTypes.DataflowEndpointListItem: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataflowEndpointGroupArn
        case dataflowEndpointGroupId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataflowEndpointGroupArn = dataflowEndpointGroupArn {
            try encodeContainer.encode(dataflowEndpointGroupArn, forKey: .dataflowEndpointGroupArn)
        }
        if let dataflowEndpointGroupId = dataflowEndpointGroupId {
            try encodeContainer.encode(dataflowEndpointGroupId, forKey: .dataflowEndpointGroupId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataflowEndpointGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataflowEndpointGroupId)
        dataflowEndpointGroupId = dataflowEndpointGroupIdDecoded
        let dataflowEndpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataflowEndpointGroupArn)
        dataflowEndpointGroupArn = dataflowEndpointGroupArnDecoded
    }
}

extension GroundStationClientTypes.DataflowEndpointListItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataflowEndpointListItem(dataflowEndpointGroupArn: \(Swift.String(describing: dataflowEndpointGroupArn)), dataflowEndpointGroupId: \(Swift.String(describing: dataflowEndpointGroupId)))"}
}

extension GroundStationClientTypes {
    /// <p>Item in a list of <code>DataflowEndpoint</code> groups.</p>
    public struct DataflowEndpointListItem: Swift.Equatable {
        /// <p>ARN of a dataflow endpoint group.</p>
        public let dataflowEndpointGroupArn: Swift.String?
        /// <p>UUID of a dataflow endpoint group.</p>
        public let dataflowEndpointGroupId: Swift.String?

        public init (
            dataflowEndpointGroupArn: Swift.String? = nil,
            dataflowEndpointGroupId: Swift.String? = nil
        )
        {
            self.dataflowEndpointGroupArn = dataflowEndpointGroupArn
            self.dataflowEndpointGroupId = dataflowEndpointGroupId
        }
    }

}

extension GroundStationClientTypes.DecodeConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unvalidatedJSON
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let unvalidatedJSON = unvalidatedJSON {
            try encodeContainer.encode(unvalidatedJSON, forKey: .unvalidatedJSON)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unvalidatedJSONDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unvalidatedJSON)
        unvalidatedJSON = unvalidatedJSONDecoded
    }
}

extension GroundStationClientTypes.DecodeConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DecodeConfig(unvalidatedJSON: \(Swift.String(describing: unvalidatedJSON)))"}
}

extension GroundStationClientTypes {
    /// <p>Information about the decode <code>Config</code>.</p>
    public struct DecodeConfig: Swift.Equatable {
        /// <p>Unvalidated JSON of a decode <code>Config</code>.</p>
        public let unvalidatedJSON: Swift.String?

        public init (
            unvalidatedJSON: Swift.String? = nil
        )
        {
            self.unvalidatedJSON = unvalidatedJSON
        }
    }

}

extension DeleteConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteConfigInput(configId: \(Swift.String(describing: configId)), configType: \(Swift.String(describing: configType)))"}
}

extension DeleteConfigInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteConfigOutputError>
}

public struct DeleteConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteConfigOutputError>
}

/// <p/>
public struct DeleteConfigInput: Swift.Equatable {
    /// <p>UUID of a <code>Config</code>.</p>
    public let configId: Swift.String?
    /// <p>Type of a <code>Config</code>.</p>
    public let configType: GroundStationClientTypes.ConfigCapabilityType?

    public init (
        configId: Swift.String? = nil,
        configType: GroundStationClientTypes.ConfigCapabilityType? = nil
    )
    {
        self.configId = configId
        self.configType = configType
    }
}

struct DeleteConfigInputBody: Swift.Equatable {
}

extension DeleteConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteConfigOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteConfigOutputResponse(configArn: \(Swift.String(describing: configArn)), configId: \(Swift.String(describing: configId)), configType: \(Swift.String(describing: configType)))"}
}

extension DeleteConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.configArn = output.configArn
            self.configId = output.configId
            self.configType = output.configType
        } else {
            self.configArn = nil
            self.configId = nil
            self.configType = nil
        }
    }
}

/// <p/>
public struct DeleteConfigOutputResponse: Swift.Equatable {
    /// <p>ARN of a <code>Config</code>.</p>
    public let configArn: Swift.String?
    /// <p>UUID of a <code>Config</code>.</p>
    public let configId: Swift.String?
    /// <p>Type of a <code>Config</code>.</p>
    public let configType: GroundStationClientTypes.ConfigCapabilityType?

    public init (
        configArn: Swift.String? = nil,
        configId: Swift.String? = nil,
        configType: GroundStationClientTypes.ConfigCapabilityType? = nil
    )
    {
        self.configArn = configArn
        self.configId = configId
        self.configType = configType
    }
}

struct DeleteConfigOutputResponseBody: Swift.Equatable {
    public let configId: Swift.String?
    public let configType: GroundStationClientTypes.ConfigCapabilityType?
    public let configArn: Swift.String?
}

extension DeleteConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configArn
        case configId
        case configType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configId)
        configId = configIdDecoded
        let configTypeDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.ConfigCapabilityType.self, forKey: .configType)
        configType = configTypeDecoded
        let configArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configArn)
        configArn = configArnDecoded
    }
}

extension DeleteDataflowEndpointGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDataflowEndpointGroupInput(dataflowEndpointGroupId: \(Swift.String(describing: dataflowEndpointGroupId)))"}
}

extension DeleteDataflowEndpointGroupInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteDataflowEndpointGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDataflowEndpointGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDataflowEndpointGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDataflowEndpointGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDataflowEndpointGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDataflowEndpointGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDataflowEndpointGroupOutputError>
}

public struct DeleteDataflowEndpointGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDataflowEndpointGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDataflowEndpointGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDataflowEndpointGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDataflowEndpointGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDataflowEndpointGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDataflowEndpointGroupOutputError>
}

/// <p/>
public struct DeleteDataflowEndpointGroupInput: Swift.Equatable {
    /// <p>UUID of a dataflow endpoint group.</p>
    public let dataflowEndpointGroupId: Swift.String?

    public init (
        dataflowEndpointGroupId: Swift.String? = nil
    )
    {
        self.dataflowEndpointGroupId = dataflowEndpointGroupId
    }
}

struct DeleteDataflowEndpointGroupInputBody: Swift.Equatable {
}

extension DeleteDataflowEndpointGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDataflowEndpointGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDataflowEndpointGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDataflowEndpointGroupOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDataflowEndpointGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDataflowEndpointGroupOutputResponse(dataflowEndpointGroupId: \(Swift.String(describing: dataflowEndpointGroupId)))"}
}

extension DeleteDataflowEndpointGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteDataflowEndpointGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataflowEndpointGroupId = output.dataflowEndpointGroupId
        } else {
            self.dataflowEndpointGroupId = nil
        }
    }
}

/// <p/>
public struct DeleteDataflowEndpointGroupOutputResponse: Swift.Equatable {
    /// <p>UUID of a dataflow endpoint group.</p>
    public let dataflowEndpointGroupId: Swift.String?

    public init (
        dataflowEndpointGroupId: Swift.String? = nil
    )
    {
        self.dataflowEndpointGroupId = dataflowEndpointGroupId
    }
}

struct DeleteDataflowEndpointGroupOutputResponseBody: Swift.Equatable {
    public let dataflowEndpointGroupId: Swift.String?
}

extension DeleteDataflowEndpointGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataflowEndpointGroupId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataflowEndpointGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataflowEndpointGroupId)
        dataflowEndpointGroupId = dataflowEndpointGroupIdDecoded
    }
}

extension DeleteMissionProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteMissionProfileInput(missionProfileId: \(Swift.String(describing: missionProfileId)))"}
}

extension DeleteMissionProfileInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteMissionProfileInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteMissionProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteMissionProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteMissionProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteMissionProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteMissionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteMissionProfileOutputError>
}

public struct DeleteMissionProfileInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteMissionProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteMissionProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteMissionProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteMissionProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteMissionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteMissionProfileOutputError>
}

/// <p/>
public struct DeleteMissionProfileInput: Swift.Equatable {
    /// <p>UUID of a mission profile.</p>
    public let missionProfileId: Swift.String?

    public init (
        missionProfileId: Swift.String? = nil
    )
    {
        self.missionProfileId = missionProfileId
    }
}

struct DeleteMissionProfileInputBody: Swift.Equatable {
}

extension DeleteMissionProfileInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteMissionProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteMissionProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteMissionProfileOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteMissionProfileOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteMissionProfileOutputResponse(missionProfileId: \(Swift.String(describing: missionProfileId)))"}
}

extension DeleteMissionProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteMissionProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.missionProfileId = output.missionProfileId
        } else {
            self.missionProfileId = nil
        }
    }
}

/// <p/>
public struct DeleteMissionProfileOutputResponse: Swift.Equatable {
    /// <p>UUID of a mission profile.</p>
    public let missionProfileId: Swift.String?

    public init (
        missionProfileId: Swift.String? = nil
    )
    {
        self.missionProfileId = missionProfileId
    }
}

struct DeleteMissionProfileOutputResponseBody: Swift.Equatable {
    public let missionProfileId: Swift.String?
}

extension DeleteMissionProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case missionProfileId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let missionProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .missionProfileId)
        missionProfileId = missionProfileIdDecoded
    }
}

extension GroundStationClientTypes.DemodulationConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unvalidatedJSON
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let unvalidatedJSON = unvalidatedJSON {
            try encodeContainer.encode(unvalidatedJSON, forKey: .unvalidatedJSON)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unvalidatedJSONDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unvalidatedJSON)
        unvalidatedJSON = unvalidatedJSONDecoded
    }
}

extension GroundStationClientTypes.DemodulationConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DemodulationConfig(unvalidatedJSON: \(Swift.String(describing: unvalidatedJSON)))"}
}

extension GroundStationClientTypes {
    /// <p>Information about the demodulation <code>Config</code>.</p>
    public struct DemodulationConfig: Swift.Equatable {
        /// <p>Unvalidated JSON of a demodulation <code>Config</code>.</p>
        public let unvalidatedJSON: Swift.String?

        public init (
            unvalidatedJSON: Swift.String? = nil
        )
        {
            self.unvalidatedJSON = unvalidatedJSON
        }
    }

}

extension DependencyException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DependencyException(message: \(Swift.String(describing: message)), parameterName: \(Swift.String(describing: parameterName)))"}
}

extension DependencyException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DependencyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.parameterName = output.parameterName
        } else {
            self.message = nil
            self.parameterName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Dependency encountered an error.</p>
public struct DependencyException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?
    /// <p/>
    public var parameterName: Swift.String?

    public init (
        message: Swift.String? = nil,
        parameterName: Swift.String? = nil
    )
    {
        self.message = message
        self.parameterName = parameterName
    }
}

struct DependencyExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let parameterName: Swift.String?
}

extension DependencyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case parameterName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let parameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterName)
        parameterName = parameterNameDecoded
    }
}

extension DescribeContactInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeContactInput(contactId: \(Swift.String(describing: contactId)))"}
}

extension DescribeContactInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeContactInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeContactInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeContactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeContactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeContactOutputError>
}

public struct DescribeContactInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeContactInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeContactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeContactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeContactOutputError>
}

/// <p/>
public struct DescribeContactInput: Swift.Equatable {
    /// <p>UUID of a contact.</p>
    public let contactId: Swift.String?

    public init (
        contactId: Swift.String? = nil
    )
    {
        self.contactId = contactId
    }
}

struct DescribeContactInputBody: Swift.Equatable {
}

extension DescribeContactInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeContactOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeContactOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeContactOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeContactOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeContactOutputResponse(contactId: \(Swift.String(describing: contactId)), contactStatus: \(Swift.String(describing: contactStatus)), dataflowList: \(Swift.String(describing: dataflowList)), endTime: \(Swift.String(describing: endTime)), errorMessage: \(Swift.String(describing: errorMessage)), groundStation: \(Swift.String(describing: groundStation)), maximumElevation: \(Swift.String(describing: maximumElevation)), missionProfileArn: \(Swift.String(describing: missionProfileArn)), postPassEndTime: \(Swift.String(describing: postPassEndTime)), prePassStartTime: \(Swift.String(describing: prePassStartTime)), region: \(Swift.String(describing: region)), satelliteArn: \(Swift.String(describing: satelliteArn)), startTime: \(Swift.String(describing: startTime)), tags: \(Swift.String(describing: tags)))"}
}

extension DescribeContactOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeContactOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contactId = output.contactId
            self.contactStatus = output.contactStatus
            self.dataflowList = output.dataflowList
            self.endTime = output.endTime
            self.errorMessage = output.errorMessage
            self.groundStation = output.groundStation
            self.maximumElevation = output.maximumElevation
            self.missionProfileArn = output.missionProfileArn
            self.postPassEndTime = output.postPassEndTime
            self.prePassStartTime = output.prePassStartTime
            self.region = output.region
            self.satelliteArn = output.satelliteArn
            self.startTime = output.startTime
            self.tags = output.tags
        } else {
            self.contactId = nil
            self.contactStatus = nil
            self.dataflowList = nil
            self.endTime = nil
            self.errorMessage = nil
            self.groundStation = nil
            self.maximumElevation = nil
            self.missionProfileArn = nil
            self.postPassEndTime = nil
            self.prePassStartTime = nil
            self.region = nil
            self.satelliteArn = nil
            self.startTime = nil
            self.tags = nil
        }
    }
}

/// <p/>
public struct DescribeContactOutputResponse: Swift.Equatable {
    /// <p>UUID of a contact.</p>
    public let contactId: Swift.String?
    /// <p>Status of a contact.</p>
    public let contactStatus: GroundStationClientTypes.ContactStatus?
    /// <p>List describing source and destination details for each dataflow edge.</p>
    public let dataflowList: [GroundStationClientTypes.DataflowDetail]?
    /// <p>End time of a contact.</p>
    public let endTime: ClientRuntime.Date?
    /// <p>Error message for a contact.</p>
    public let errorMessage: Swift.String?
    /// <p>Ground station for a contact.</p>
    public let groundStation: Swift.String?
    /// <p>Maximum elevation angle of a contact.</p>
    public let maximumElevation: GroundStationClientTypes.Elevation?
    /// <p>ARN of a mission profile.</p>
    public let missionProfileArn: Swift.String?
    /// <p>Amount of time after a contact ends that you‚Äôd like to receive a CloudWatch event indicating the pass has finished.</p>
    public let postPassEndTime: ClientRuntime.Date?
    /// <p>Amount of time prior to contact start you‚Äôd like to receive a CloudWatch event indicating an upcoming pass.</p>
    public let prePassStartTime: ClientRuntime.Date?
    /// <p>Region of a contact.</p>
    public let region: Swift.String?
    /// <p>ARN of a satellite.</p>
    public let satelliteArn: Swift.String?
    /// <p>Start time of a contact.</p>
    public let startTime: ClientRuntime.Date?
    /// <p>Tags assigned to a contact.</p>
    public let tags: [Swift.String:Swift.String]?

    public init (
        contactId: Swift.String? = nil,
        contactStatus: GroundStationClientTypes.ContactStatus? = nil,
        dataflowList: [GroundStationClientTypes.DataflowDetail]? = nil,
        endTime: ClientRuntime.Date? = nil,
        errorMessage: Swift.String? = nil,
        groundStation: Swift.String? = nil,
        maximumElevation: GroundStationClientTypes.Elevation? = nil,
        missionProfileArn: Swift.String? = nil,
        postPassEndTime: ClientRuntime.Date? = nil,
        prePassStartTime: ClientRuntime.Date? = nil,
        region: Swift.String? = nil,
        satelliteArn: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.contactId = contactId
        self.contactStatus = contactStatus
        self.dataflowList = dataflowList
        self.endTime = endTime
        self.errorMessage = errorMessage
        self.groundStation = groundStation
        self.maximumElevation = maximumElevation
        self.missionProfileArn = missionProfileArn
        self.postPassEndTime = postPassEndTime
        self.prePassStartTime = prePassStartTime
        self.region = region
        self.satelliteArn = satelliteArn
        self.startTime = startTime
        self.tags = tags
    }
}

struct DescribeContactOutputResponseBody: Swift.Equatable {
    public let contactId: Swift.String?
    public let missionProfileArn: Swift.String?
    public let satelliteArn: Swift.String?
    public let startTime: ClientRuntime.Date?
    public let endTime: ClientRuntime.Date?
    public let prePassStartTime: ClientRuntime.Date?
    public let postPassEndTime: ClientRuntime.Date?
    public let groundStation: Swift.String?
    public let contactStatus: GroundStationClientTypes.ContactStatus?
    public let errorMessage: Swift.String?
    public let maximumElevation: GroundStationClientTypes.Elevation?
    public let tags: [Swift.String:Swift.String]?
    public let region: Swift.String?
    public let dataflowList: [GroundStationClientTypes.DataflowDetail]?
}

extension DescribeContactOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId
        case contactStatus
        case dataflowList
        case endTime
        case errorMessage
        case groundStation
        case maximumElevation
        case missionProfileArn
        case postPassEndTime
        case prePassStartTime
        case region
        case satelliteArn
        case startTime
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let missionProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .missionProfileArn)
        missionProfileArn = missionProfileArnDecoded
        let satelliteArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .satelliteArn)
        satelliteArn = satelliteArnDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let prePassStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .prePassStartTime)
        prePassStartTime = prePassStartTimeDecoded
        let postPassEndTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .postPassEndTime)
        postPassEndTime = postPassEndTimeDecoded
        let groundStationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groundStation)
        groundStation = groundStationDecoded
        let contactStatusDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.ContactStatus.self, forKey: .contactStatus)
        contactStatus = contactStatusDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let maximumElevationDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.Elevation.self, forKey: .maximumElevation)
        maximumElevation = maximumElevationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let dataflowListContainer = try containerValues.decodeIfPresent([GroundStationClientTypes.DataflowDetail?].self, forKey: .dataflowList)
        var dataflowListDecoded0:[GroundStationClientTypes.DataflowDetail]? = nil
        if let dataflowListContainer = dataflowListContainer {
            dataflowListDecoded0 = [GroundStationClientTypes.DataflowDetail]()
            for structure0 in dataflowListContainer {
                if let structure0 = structure0 {
                    dataflowListDecoded0?.append(structure0)
                }
            }
        }
        dataflowList = dataflowListDecoded0
    }
}

extension GroundStationClientTypes.Destination: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configDetails
        case configId
        case configType
        case dataflowDestinationRegion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configDetails = configDetails {
            try encodeContainer.encode(configDetails, forKey: .configDetails)
        }
        if let configId = configId {
            try encodeContainer.encode(configId, forKey: .configId)
        }
        if let configType = configType {
            try encodeContainer.encode(configType.rawValue, forKey: .configType)
        }
        if let dataflowDestinationRegion = dataflowDestinationRegion {
            try encodeContainer.encode(dataflowDestinationRegion, forKey: .dataflowDestinationRegion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configTypeDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.ConfigCapabilityType.self, forKey: .configType)
        configType = configTypeDecoded
        let configIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configId)
        configId = configIdDecoded
        let configDetailsDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.ConfigDetails.self, forKey: .configDetails)
        configDetails = configDetailsDecoded
        let dataflowDestinationRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataflowDestinationRegion)
        dataflowDestinationRegion = dataflowDestinationRegionDecoded
    }
}

extension GroundStationClientTypes.Destination: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Destination(configDetails: \(Swift.String(describing: configDetails)), configId: \(Swift.String(describing: configId)), configType: \(Swift.String(describing: configType)), dataflowDestinationRegion: \(Swift.String(describing: dataflowDestinationRegion)))"}
}

extension GroundStationClientTypes {
    /// <p>Dataflow details for the destination side.</p>
    public struct Destination: Swift.Equatable {
        /// <p>Additional details for a <code>Config</code>, if type is dataflow endpoint or antenna demod decode.</p>
        public let configDetails: GroundStationClientTypes.ConfigDetails?
        /// <p>UUID of a <code>Config</code>.</p>
        public let configId: Swift.String?
        /// <p>Type of a <code>Config</code>.</p>
        public let configType: GroundStationClientTypes.ConfigCapabilityType?
        /// <p>Region of a dataflow destination.</p>
        public let dataflowDestinationRegion: Swift.String?

        public init (
            configDetails: GroundStationClientTypes.ConfigDetails? = nil,
            configId: Swift.String? = nil,
            configType: GroundStationClientTypes.ConfigCapabilityType? = nil,
            dataflowDestinationRegion: Swift.String? = nil
        )
        {
            self.configDetails = configDetails
            self.configId = configId
            self.configType = configType
            self.dataflowDestinationRegion = dataflowDestinationRegion
        }
    }

}

extension GroundStationClientTypes.Eirp: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case units
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let units = units {
            try encodeContainer.encode(units.rawValue, forKey: .units)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .value)
        value = valueDecoded
        let unitsDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.EirpUnits.self, forKey: .units)
        units = unitsDecoded
    }
}

extension GroundStationClientTypes.Eirp: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Eirp(units: \(Swift.String(describing: units)), value: \(Swift.String(describing: value)))"}
}

extension GroundStationClientTypes {
    /// <p>Object that represents EIRP.</p>
    public struct Eirp: Swift.Equatable {
        /// <p>Units of an EIRP.</p>
        public let units: GroundStationClientTypes.EirpUnits?
        /// <p>Value of an EIRP. Valid values are between 20.0 to 50.0 dBW.</p>
        public let value: Swift.Double?

        public init (
            units: GroundStationClientTypes.EirpUnits? = nil,
            value: Swift.Double? = nil
        )
        {
            self.units = units
            self.value = value
        }
    }

}

extension GroundStationClientTypes {
    public enum EirpUnits: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dbw
        case sdkUnknown(Swift.String)

        public static var allCases: [EirpUnits] {
            return [
                .dbw,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dbw: return "dBW"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EirpUnits(rawValue: rawValue) ?? EirpUnits.sdkUnknown(rawValue)
        }
    }
}

extension GroundStationClientTypes.Elevation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unit
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let unit = unit {
            try encodeContainer.encode(unit.rawValue, forKey: .unit)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .value)
        value = valueDecoded
        let unitDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.AngleUnits.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension GroundStationClientTypes.Elevation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Elevation(unit: \(Swift.String(describing: unit)), value: \(Swift.String(describing: value)))"}
}

extension GroundStationClientTypes {
    /// <p>Elevation angle of the satellite in the sky during a contact.</p>
    public struct Elevation: Swift.Equatable {
        /// <p>Elevation angle units.</p>
        public let unit: GroundStationClientTypes.AngleUnits?
        /// <p>Elevation angle value.</p>
        public let value: Swift.Double?

        public init (
            unit: GroundStationClientTypes.AngleUnits? = nil,
            value: Swift.Double? = nil
        )
        {
            self.unit = unit
            self.value = value
        }
    }

}

extension GroundStationClientTypes.EndpointDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoint
        case securityDetails
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpoint = endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
        if let securityDetails = securityDetails {
            try encodeContainer.encode(securityDetails, forKey: .securityDetails)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityDetailsDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.SecurityDetails.self, forKey: .securityDetails)
        securityDetails = securityDetailsDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.DataflowEndpoint.self, forKey: .endpoint)
        endpoint = endpointDecoded
    }
}

extension GroundStationClientTypes.EndpointDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EndpointDetails(endpoint: \(Swift.String(describing: endpoint)), securityDetails: \(Swift.String(describing: securityDetails)))"}
}

extension GroundStationClientTypes {
    /// <p>Information about the endpoint details.</p>
    public struct EndpointDetails: Swift.Equatable {
        /// <p>A dataflow endpoint.</p>
        public let endpoint: GroundStationClientTypes.DataflowEndpoint?
        /// <p>Endpoint security details.</p>
        public let securityDetails: GroundStationClientTypes.SecurityDetails?

        public init (
            endpoint: GroundStationClientTypes.DataflowEndpoint? = nil,
            securityDetails: GroundStationClientTypes.SecurityDetails? = nil
        )
        {
            self.endpoint = endpoint
            self.securityDetails = securityDetails
        }
    }

}

extension GroundStationClientTypes {
    public enum EndpointStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case created
        case creating
        case deleted
        case deleting
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [EndpointStatus] {
            return [
                .created,
                .creating,
                .deleted,
                .deleting,
                .failed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .created: return "created"
            case .creating: return "creating"
            case .deleted: return "deleted"
            case .deleting: return "deleting"
            case .failed: return "failed"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EndpointStatus(rawValue: rawValue) ?? EndpointStatus.sdkUnknown(rawValue)
        }
    }
}

extension GroundStationClientTypes.Frequency: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case units
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let units = units {
            try encodeContainer.encode(units.rawValue, forKey: .units)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .value)
        value = valueDecoded
        let unitsDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.FrequencyUnits.self, forKey: .units)
        units = unitsDecoded
    }
}

extension GroundStationClientTypes.Frequency: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Frequency(units: \(Swift.String(describing: units)), value: \(Swift.String(describing: value)))"}
}

extension GroundStationClientTypes {
    /// <p>Object that describes the frequency.</p>
    public struct Frequency: Swift.Equatable {
        /// <p>Frequency units.</p>
        public let units: GroundStationClientTypes.FrequencyUnits?
        /// <p>Frequency value. Valid values are between 2200 to 2300 MHz and 7750 to 8400 MHz for downlink and 2025 to 2120 MHz for uplink.</p>
        public let value: Swift.Double?

        public init (
            units: GroundStationClientTypes.FrequencyUnits? = nil,
            value: Swift.Double? = nil
        )
        {
            self.units = units
            self.value = value
        }
    }

}

extension GroundStationClientTypes.FrequencyBandwidth: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case units
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let units = units {
            try encodeContainer.encode(units.rawValue, forKey: .units)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .value)
        value = valueDecoded
        let unitsDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.BandwidthUnits.self, forKey: .units)
        units = unitsDecoded
    }
}

extension GroundStationClientTypes.FrequencyBandwidth: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FrequencyBandwidth(units: \(Swift.String(describing: units)), value: \(Swift.String(describing: value)))"}
}

extension GroundStationClientTypes {
    /// <p>Object that describes the frequency bandwidth. </p>
    public struct FrequencyBandwidth: Swift.Equatable {
        /// <p>Frequency bandwidth units.</p>
        public let units: GroundStationClientTypes.BandwidthUnits?
        /// <p>Frequency bandwidth value. AWS Ground Station currently has the following bandwidth limitations:</p>
        ///             <ul>
        ///             <li>
        ///                <p>For <code>AntennaDownlinkDemodDecodeconfig</code>, valid values are between 125 kHz to 650 MHz.</p>
        ///             </li>
        ///             <li>
        ///                <p>For <code>AntennaDownlinkconfig</code>, valid values are between 10 kHz to 54 MHz.</p>
        ///             </li>
        ///             <li>
        ///                <p>For <code>AntennaUplinkConfig</code>, valid values are between 10 kHz to 54 MHz.</p>
        ///             </li>
        ///          </ul>
        public let value: Swift.Double?

        public init (
            units: GroundStationClientTypes.BandwidthUnits? = nil,
            value: Swift.Double? = nil
        )
        {
            self.units = units
            self.value = value
        }
    }

}

extension GroundStationClientTypes {
    public enum FrequencyUnits: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ghz
        case khz
        case mhz
        case sdkUnknown(Swift.String)

        public static var allCases: [FrequencyUnits] {
            return [
                .ghz,
                .khz,
                .mhz,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ghz: return "GHz"
            case .khz: return "kHz"
            case .mhz: return "MHz"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FrequencyUnits(rawValue: rawValue) ?? FrequencyUnits.sdkUnknown(rawValue)
        }
    }
}

extension GetConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetConfigInput(configId: \(Swift.String(describing: configId)), configType: \(Swift.String(describing: configType)))"}
}

extension GetConfigInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetConfigOutputError>
}

public struct GetConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetConfigOutputError>
}

/// <p/>
public struct GetConfigInput: Swift.Equatable {
    /// <p>UUID of a <code>Config</code>.</p>
    public let configId: Swift.String?
    /// <p>Type of a <code>Config</code>.</p>
    public let configType: GroundStationClientTypes.ConfigCapabilityType?

    public init (
        configId: Swift.String? = nil,
        configType: GroundStationClientTypes.ConfigCapabilityType? = nil
    )
    {
        self.configId = configId
        self.configType = configType
    }
}

struct GetConfigInputBody: Swift.Equatable {
}

extension GetConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetConfigOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetConfigOutputResponse(configArn: \(Swift.String(describing: configArn)), configData: \(Swift.String(describing: configData)), configId: \(Swift.String(describing: configId)), configType: \(Swift.String(describing: configType)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)))"}
}

extension GetConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.configArn = output.configArn
            self.configData = output.configData
            self.configId = output.configId
            self.configType = output.configType
            self.name = output.name
            self.tags = output.tags
        } else {
            self.configArn = nil
            self.configData = nil
            self.configId = nil
            self.configType = nil
            self.name = nil
            self.tags = nil
        }
    }
}

/// <p/>
public struct GetConfigOutputResponse: Swift.Equatable {
    /// <p>ARN of a <code>Config</code>
    ///          </p>
    public let configArn: Swift.String?
    /// <p>Data elements in a <code>Config</code>.</p>
    public let configData: GroundStationClientTypes.ConfigTypeData?
    /// <p>UUID of a <code>Config</code>.</p>
    public let configId: Swift.String?
    /// <p>Type of a <code>Config</code>.</p>
    public let configType: GroundStationClientTypes.ConfigCapabilityType?
    /// <p>Name of a <code>Config</code>.</p>
    public let name: Swift.String?
    /// <p>Tags assigned to a <code>Config</code>.</p>
    public let tags: [Swift.String:Swift.String]?

    public init (
        configArn: Swift.String? = nil,
        configData: GroundStationClientTypes.ConfigTypeData? = nil,
        configId: Swift.String? = nil,
        configType: GroundStationClientTypes.ConfigCapabilityType? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.configArn = configArn
        self.configData = configData
        self.configId = configId
        self.configType = configType
        self.name = name
        self.tags = tags
    }
}

struct GetConfigOutputResponseBody: Swift.Equatable {
    public let configId: Swift.String?
    public let configArn: Swift.String?
    public let name: Swift.String?
    public let configType: GroundStationClientTypes.ConfigCapabilityType?
    public let configData: GroundStationClientTypes.ConfigTypeData?
    public let tags: [Swift.String:Swift.String]?
}

extension GetConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configArn
        case configData
        case configId
        case configType
        case name
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configId)
        configId = configIdDecoded
        let configArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configArn)
        configArn = configArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let configTypeDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.ConfigCapabilityType.self, forKey: .configType)
        configType = configTypeDecoded
        let configDataDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.ConfigTypeData.self, forKey: .configData)
        configData = configDataDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetDataflowEndpointGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDataflowEndpointGroupInput(dataflowEndpointGroupId: \(Swift.String(describing: dataflowEndpointGroupId)))"}
}

extension GetDataflowEndpointGroupInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetDataflowEndpointGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDataflowEndpointGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDataflowEndpointGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDataflowEndpointGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDataflowEndpointGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDataflowEndpointGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDataflowEndpointGroupOutputError>
}

public struct GetDataflowEndpointGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDataflowEndpointGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDataflowEndpointGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDataflowEndpointGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDataflowEndpointGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDataflowEndpointGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDataflowEndpointGroupOutputError>
}

/// <p/>
public struct GetDataflowEndpointGroupInput: Swift.Equatable {
    /// <p>UUID of a dataflow endpoint group.</p>
    public let dataflowEndpointGroupId: Swift.String?

    public init (
        dataflowEndpointGroupId: Swift.String? = nil
    )
    {
        self.dataflowEndpointGroupId = dataflowEndpointGroupId
    }
}

struct GetDataflowEndpointGroupInputBody: Swift.Equatable {
}

extension GetDataflowEndpointGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDataflowEndpointGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDataflowEndpointGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDataflowEndpointGroupOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDataflowEndpointGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDataflowEndpointGroupOutputResponse(dataflowEndpointGroupArn: \(Swift.String(describing: dataflowEndpointGroupArn)), dataflowEndpointGroupId: \(Swift.String(describing: dataflowEndpointGroupId)), endpointsDetails: \(Swift.String(describing: endpointsDetails)), tags: \(Swift.String(describing: tags)))"}
}

extension GetDataflowEndpointGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDataflowEndpointGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataflowEndpointGroupArn = output.dataflowEndpointGroupArn
            self.dataflowEndpointGroupId = output.dataflowEndpointGroupId
            self.endpointsDetails = output.endpointsDetails
            self.tags = output.tags
        } else {
            self.dataflowEndpointGroupArn = nil
            self.dataflowEndpointGroupId = nil
            self.endpointsDetails = nil
            self.tags = nil
        }
    }
}

/// <p/>
public struct GetDataflowEndpointGroupOutputResponse: Swift.Equatable {
    /// <p>ARN of a dataflow endpoint group.</p>
    public let dataflowEndpointGroupArn: Swift.String?
    /// <p>UUID of a dataflow endpoint group.</p>
    public let dataflowEndpointGroupId: Swift.String?
    /// <p>Details of a dataflow endpoint.</p>
    public let endpointsDetails: [GroundStationClientTypes.EndpointDetails]?
    /// <p>Tags assigned to a dataflow endpoint group.</p>
    public let tags: [Swift.String:Swift.String]?

    public init (
        dataflowEndpointGroupArn: Swift.String? = nil,
        dataflowEndpointGroupId: Swift.String? = nil,
        endpointsDetails: [GroundStationClientTypes.EndpointDetails]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.dataflowEndpointGroupArn = dataflowEndpointGroupArn
        self.dataflowEndpointGroupId = dataflowEndpointGroupId
        self.endpointsDetails = endpointsDetails
        self.tags = tags
    }
}

struct GetDataflowEndpointGroupOutputResponseBody: Swift.Equatable {
    public let dataflowEndpointGroupId: Swift.String?
    public let dataflowEndpointGroupArn: Swift.String?
    public let endpointsDetails: [GroundStationClientTypes.EndpointDetails]?
    public let tags: [Swift.String:Swift.String]?
}

extension GetDataflowEndpointGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataflowEndpointGroupArn
        case dataflowEndpointGroupId
        case endpointsDetails
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataflowEndpointGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataflowEndpointGroupId)
        dataflowEndpointGroupId = dataflowEndpointGroupIdDecoded
        let dataflowEndpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataflowEndpointGroupArn)
        dataflowEndpointGroupArn = dataflowEndpointGroupArnDecoded
        let endpointsDetailsContainer = try containerValues.decodeIfPresent([GroundStationClientTypes.EndpointDetails?].self, forKey: .endpointsDetails)
        var endpointsDetailsDecoded0:[GroundStationClientTypes.EndpointDetails]? = nil
        if let endpointsDetailsContainer = endpointsDetailsContainer {
            endpointsDetailsDecoded0 = [GroundStationClientTypes.EndpointDetails]()
            for structure0 in endpointsDetailsContainer {
                if let structure0 = structure0 {
                    endpointsDetailsDecoded0?.append(structure0)
                }
            }
        }
        endpointsDetails = endpointsDetailsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct GetMinuteUsageInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMinuteUsageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetMinuteUsageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMinuteUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetMinuteUsageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetMinuteUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMinuteUsageOutputError>
}

extension GetMinuteUsageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMinuteUsageInput(month: \(Swift.String(describing: month)), year: \(Swift.String(describing: year)))"}
}

extension GetMinuteUsageInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case month
        case year
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let month = month {
            try encodeContainer.encode(month, forKey: .month)
        }
        if let year = year {
            try encodeContainer.encode(year, forKey: .year)
        }
    }
}

public struct GetMinuteUsageInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMinuteUsageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetMinuteUsageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMinuteUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetMinuteUsageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetMinuteUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMinuteUsageOutputError>
}

public struct GetMinuteUsageInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMinuteUsageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetMinuteUsageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMinuteUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetMinuteUsageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetMinuteUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMinuteUsageOutputError>
}

/// <p/>
public struct GetMinuteUsageInput: Swift.Equatable {
    /// <p>The month being requested, with a value of 1-12.</p>
    public let month: Swift.Int?
    /// <p>The year being requested, in the format of YYYY.</p>
    public let year: Swift.Int?

    public init (
        month: Swift.Int? = nil,
        year: Swift.Int? = nil
    )
    {
        self.month = month
        self.year = year
    }
}

struct GetMinuteUsageInputBody: Swift.Equatable {
    public let month: Swift.Int?
    public let year: Swift.Int?
}

extension GetMinuteUsageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case month
        case year
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .month)
        month = monthDecoded
        let yearDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .year)
        year = yearDecoded
    }
}

extension GetMinuteUsageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMinuteUsageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMinuteUsageOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMinuteUsageOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMinuteUsageOutputResponse(estimatedMinutesRemaining: \(Swift.String(describing: estimatedMinutesRemaining)), isReservedMinutesCustomer: \(Swift.String(describing: isReservedMinutesCustomer)), totalReservedMinuteAllocation: \(Swift.String(describing: totalReservedMinuteAllocation)), totalScheduledMinutes: \(Swift.String(describing: totalScheduledMinutes)), upcomingMinutesScheduled: \(Swift.String(describing: upcomingMinutesScheduled)))"}
}

extension GetMinuteUsageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetMinuteUsageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.estimatedMinutesRemaining = output.estimatedMinutesRemaining
            self.isReservedMinutesCustomer = output.isReservedMinutesCustomer
            self.totalReservedMinuteAllocation = output.totalReservedMinuteAllocation
            self.totalScheduledMinutes = output.totalScheduledMinutes
            self.upcomingMinutesScheduled = output.upcomingMinutesScheduled
        } else {
            self.estimatedMinutesRemaining = nil
            self.isReservedMinutesCustomer = nil
            self.totalReservedMinuteAllocation = nil
            self.totalScheduledMinutes = nil
            self.upcomingMinutesScheduled = nil
        }
    }
}

/// <p/>
public struct GetMinuteUsageOutputResponse: Swift.Equatable {
    /// <p>Estimated number of minutes remaining for an account, specific to the month being requested.</p>
    public let estimatedMinutesRemaining: Swift.Int?
    /// <p>Returns whether or not an account has signed up for the reserved minutes pricing plan, specific to the month being requested.</p>
    public let isReservedMinutesCustomer: Swift.Bool?
    /// <p>Total number of reserved minutes allocated, specific to the month being requested.</p>
    public let totalReservedMinuteAllocation: Swift.Int?
    /// <p>Total scheduled minutes for an account, specific to the month being requested.</p>
    public let totalScheduledMinutes: Swift.Int?
    /// <p>Upcoming minutes scheduled for an account, specific to the month being requested.</p>
    public let upcomingMinutesScheduled: Swift.Int?

    public init (
        estimatedMinutesRemaining: Swift.Int? = nil,
        isReservedMinutesCustomer: Swift.Bool? = nil,
        totalReservedMinuteAllocation: Swift.Int? = nil,
        totalScheduledMinutes: Swift.Int? = nil,
        upcomingMinutesScheduled: Swift.Int? = nil
    )
    {
        self.estimatedMinutesRemaining = estimatedMinutesRemaining
        self.isReservedMinutesCustomer = isReservedMinutesCustomer
        self.totalReservedMinuteAllocation = totalReservedMinuteAllocation
        self.totalScheduledMinutes = totalScheduledMinutes
        self.upcomingMinutesScheduled = upcomingMinutesScheduled
    }
}

struct GetMinuteUsageOutputResponseBody: Swift.Equatable {
    public let isReservedMinutesCustomer: Swift.Bool?
    public let totalReservedMinuteAllocation: Swift.Int?
    public let upcomingMinutesScheduled: Swift.Int?
    public let totalScheduledMinutes: Swift.Int?
    public let estimatedMinutesRemaining: Swift.Int?
}

extension GetMinuteUsageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case estimatedMinutesRemaining
        case isReservedMinutesCustomer
        case totalReservedMinuteAllocation
        case totalScheduledMinutes
        case upcomingMinutesScheduled
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isReservedMinutesCustomerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isReservedMinutesCustomer)
        isReservedMinutesCustomer = isReservedMinutesCustomerDecoded
        let totalReservedMinuteAllocationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalReservedMinuteAllocation)
        totalReservedMinuteAllocation = totalReservedMinuteAllocationDecoded
        let upcomingMinutesScheduledDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .upcomingMinutesScheduled)
        upcomingMinutesScheduled = upcomingMinutesScheduledDecoded
        let totalScheduledMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalScheduledMinutes)
        totalScheduledMinutes = totalScheduledMinutesDecoded
        let estimatedMinutesRemainingDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .estimatedMinutesRemaining)
        estimatedMinutesRemaining = estimatedMinutesRemainingDecoded
    }
}

extension GetMissionProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMissionProfileInput(missionProfileId: \(Swift.String(describing: missionProfileId)))"}
}

extension GetMissionProfileInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetMissionProfileInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMissionProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetMissionProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMissionProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetMissionProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetMissionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMissionProfileOutputError>
}

public struct GetMissionProfileInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMissionProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetMissionProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMissionProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetMissionProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetMissionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMissionProfileOutputError>
}

/// <p/>
public struct GetMissionProfileInput: Swift.Equatable {
    /// <p>UUID of a mission profile.</p>
    public let missionProfileId: Swift.String?

    public init (
        missionProfileId: Swift.String? = nil
    )
    {
        self.missionProfileId = missionProfileId
    }
}

struct GetMissionProfileInputBody: Swift.Equatable {
}

extension GetMissionProfileInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetMissionProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMissionProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMissionProfileOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMissionProfileOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMissionProfileOutputResponse(contactPostPassDurationSeconds: \(Swift.String(describing: contactPostPassDurationSeconds)), contactPrePassDurationSeconds: \(Swift.String(describing: contactPrePassDurationSeconds)), dataflowEdges: \(Swift.String(describing: dataflowEdges)), minimumViableContactDurationSeconds: \(Swift.String(describing: minimumViableContactDurationSeconds)), missionProfileArn: \(Swift.String(describing: missionProfileArn)), missionProfileId: \(Swift.String(describing: missionProfileId)), name: \(Swift.String(describing: name)), region: \(Swift.String(describing: region)), tags: \(Swift.String(describing: tags)), trackingConfigArn: \(Swift.String(describing: trackingConfigArn)))"}
}

extension GetMissionProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetMissionProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contactPostPassDurationSeconds = output.contactPostPassDurationSeconds
            self.contactPrePassDurationSeconds = output.contactPrePassDurationSeconds
            self.dataflowEdges = output.dataflowEdges
            self.minimumViableContactDurationSeconds = output.minimumViableContactDurationSeconds
            self.missionProfileArn = output.missionProfileArn
            self.missionProfileId = output.missionProfileId
            self.name = output.name
            self.region = output.region
            self.tags = output.tags
            self.trackingConfigArn = output.trackingConfigArn
        } else {
            self.contactPostPassDurationSeconds = nil
            self.contactPrePassDurationSeconds = nil
            self.dataflowEdges = nil
            self.minimumViableContactDurationSeconds = nil
            self.missionProfileArn = nil
            self.missionProfileId = nil
            self.name = nil
            self.region = nil
            self.tags = nil
            self.trackingConfigArn = nil
        }
    }
}

/// <p/>
public struct GetMissionProfileOutputResponse: Swift.Equatable {
    /// <p>Amount of time after a contact ends that you‚Äôd like to receive a CloudWatch event indicating the pass has finished.</p>
    public let contactPostPassDurationSeconds: Swift.Int?
    /// <p>Amount of time prior to contact start you‚Äôd like to receive a CloudWatch event indicating an upcoming pass.</p>
    public let contactPrePassDurationSeconds: Swift.Int?
    /// <p>A list of lists of ARNs. Each list of ARNs is an edge, with a <i>from</i>
    ///             <code>Config</code> and a <i>to</i>
    ///             <code>Config</code>.</p>
    public let dataflowEdges: [[Swift.String]]?
    /// <p>Smallest amount of time in seconds that you‚Äôd like to see for an available contact. AWS Ground Station will not present you with contacts shorter than this duration.</p>
    public let minimumViableContactDurationSeconds: Swift.Int?
    /// <p>ARN of a mission profile.</p>
    public let missionProfileArn: Swift.String?
    /// <p>UUID of a mission profile.</p>
    public let missionProfileId: Swift.String?
    /// <p>Name of a mission profile.</p>
    public let name: Swift.String?
    /// <p>Region of a mission profile.</p>
    public let region: Swift.String?
    /// <p>Tags assigned to a mission profile.</p>
    public let tags: [Swift.String:Swift.String]?
    /// <p>ARN of a tracking <code>Config</code>.</p>
    public let trackingConfigArn: Swift.String?

    public init (
        contactPostPassDurationSeconds: Swift.Int? = nil,
        contactPrePassDurationSeconds: Swift.Int? = nil,
        dataflowEdges: [[Swift.String]]? = nil,
        minimumViableContactDurationSeconds: Swift.Int? = nil,
        missionProfileArn: Swift.String? = nil,
        missionProfileId: Swift.String? = nil,
        name: Swift.String? = nil,
        region: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        trackingConfigArn: Swift.String? = nil
    )
    {
        self.contactPostPassDurationSeconds = contactPostPassDurationSeconds
        self.contactPrePassDurationSeconds = contactPrePassDurationSeconds
        self.dataflowEdges = dataflowEdges
        self.minimumViableContactDurationSeconds = minimumViableContactDurationSeconds
        self.missionProfileArn = missionProfileArn
        self.missionProfileId = missionProfileId
        self.name = name
        self.region = region
        self.tags = tags
        self.trackingConfigArn = trackingConfigArn
    }
}

struct GetMissionProfileOutputResponseBody: Swift.Equatable {
    public let missionProfileId: Swift.String?
    public let missionProfileArn: Swift.String?
    public let name: Swift.String?
    public let region: Swift.String?
    public let contactPrePassDurationSeconds: Swift.Int?
    public let contactPostPassDurationSeconds: Swift.Int?
    public let minimumViableContactDurationSeconds: Swift.Int?
    public let dataflowEdges: [[Swift.String]]?
    public let trackingConfigArn: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension GetMissionProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactPostPassDurationSeconds
        case contactPrePassDurationSeconds
        case dataflowEdges
        case minimumViableContactDurationSeconds
        case missionProfileArn
        case missionProfileId
        case name
        case region
        case tags
        case trackingConfigArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let missionProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .missionProfileId)
        missionProfileId = missionProfileIdDecoded
        let missionProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .missionProfileArn)
        missionProfileArn = missionProfileArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let contactPrePassDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .contactPrePassDurationSeconds)
        contactPrePassDurationSeconds = contactPrePassDurationSecondsDecoded
        let contactPostPassDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .contactPostPassDurationSeconds)
        contactPostPassDurationSeconds = contactPostPassDurationSecondsDecoded
        let minimumViableContactDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minimumViableContactDurationSeconds)
        minimumViableContactDurationSeconds = minimumViableContactDurationSecondsDecoded
        let dataflowEdgesContainer = try containerValues.decodeIfPresent([[Swift.String?]?].self, forKey: .dataflowEdges)
        var dataflowEdgesDecoded0:[[Swift.String]]? = nil
        if let dataflowEdgesContainer = dataflowEdgesContainer {
            dataflowEdgesDecoded0 = [[Swift.String]]()
            for list0 in dataflowEdgesContainer {
                var list0Decoded0: [Swift.String]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [Swift.String]()
                    for string1 in list0 {
                        if let string1 = string1 {
                            list0Decoded0?.append(string1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    dataflowEdgesDecoded0?.append(list0Decoded0)
                }
            }
        }
        dataflowEdges = dataflowEdgesDecoded0
        let trackingConfigArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trackingConfigArn)
        trackingConfigArn = trackingConfigArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetSatelliteInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSatelliteInput(satelliteId: \(Swift.String(describing: satelliteId)))"}
}

extension GetSatelliteInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetSatelliteInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSatelliteInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSatelliteInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSatelliteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSatelliteInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSatelliteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSatelliteOutputError>
}

public struct GetSatelliteInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSatelliteInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSatelliteInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSatelliteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSatelliteInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSatelliteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSatelliteOutputError>
}

/// <p/>
public struct GetSatelliteInput: Swift.Equatable {
    /// <p>UUID of a satellite.</p>
    public let satelliteId: Swift.String?

    public init (
        satelliteId: Swift.String? = nil
    )
    {
        self.satelliteId = satelliteId
    }
}

struct GetSatelliteInputBody: Swift.Equatable {
}

extension GetSatelliteInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSatelliteOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSatelliteOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSatelliteOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSatelliteOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSatelliteOutputResponse(groundStations: \(Swift.String(describing: groundStations)), noradSatelliteID: \(Swift.String(describing: noradSatelliteID)), satelliteArn: \(Swift.String(describing: satelliteArn)), satelliteId: \(Swift.String(describing: satelliteId)))"}
}

extension GetSatelliteOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetSatelliteOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.groundStations = output.groundStations
            self.noradSatelliteID = output.noradSatelliteID
            self.satelliteArn = output.satelliteArn
            self.satelliteId = output.satelliteId
        } else {
            self.groundStations = nil
            self.noradSatelliteID = 0
            self.satelliteArn = nil
            self.satelliteId = nil
        }
    }
}

/// <p/>
public struct GetSatelliteOutputResponse: Swift.Equatable {
    /// <p>A list of ground stations to which the satellite is on-boarded.</p>
    public let groundStations: [Swift.String]?
    /// <p>NORAD satellite ID number.</p>
    public let noradSatelliteID: Swift.Int
    /// <p>ARN of a satellite.</p>
    public let satelliteArn: Swift.String?
    /// <p>UUID of a satellite.</p>
    public let satelliteId: Swift.String?

    public init (
        groundStations: [Swift.String]? = nil,
        noradSatelliteID: Swift.Int = 0,
        satelliteArn: Swift.String? = nil,
        satelliteId: Swift.String? = nil
    )
    {
        self.groundStations = groundStations
        self.noradSatelliteID = noradSatelliteID
        self.satelliteArn = satelliteArn
        self.satelliteId = satelliteId
    }
}

struct GetSatelliteOutputResponseBody: Swift.Equatable {
    public let satelliteId: Swift.String?
    public let satelliteArn: Swift.String?
    public let noradSatelliteID: Swift.Int
    public let groundStations: [Swift.String]?
}

extension GetSatelliteOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groundStations
        case noradSatelliteID
        case satelliteArn
        case satelliteId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let satelliteIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .satelliteId)
        satelliteId = satelliteIdDecoded
        let satelliteArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .satelliteArn)
        satelliteArn = satelliteArnDecoded
        let noradSatelliteIDDecoded = try containerValues.decode(Swift.Int.self, forKey: .noradSatelliteID)
        noradSatelliteID = noradSatelliteIDDecoded
        let groundStationsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .groundStations)
        var groundStationsDecoded0:[Swift.String]? = nil
        if let groundStationsContainer = groundStationsContainer {
            groundStationsDecoded0 = [Swift.String]()
            for string0 in groundStationsContainer {
                if let string0 = string0 {
                    groundStationsDecoded0?.append(string0)
                }
            }
        }
        groundStations = groundStationsDecoded0
    }
}

extension GroundStationClientTypes.GroundStationData: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groundStationId
        case groundStationName
        case region
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groundStationId = groundStationId {
            try encodeContainer.encode(groundStationId, forKey: .groundStationId)
        }
        if let groundStationName = groundStationName {
            try encodeContainer.encode(groundStationName, forKey: .groundStationName)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groundStationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groundStationId)
        groundStationId = groundStationIdDecoded
        let groundStationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groundStationName)
        groundStationName = groundStationNameDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
    }
}

extension GroundStationClientTypes.GroundStationData: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GroundStationData(groundStationId: \(Swift.String(describing: groundStationId)), groundStationName: \(Swift.String(describing: groundStationName)), region: \(Swift.String(describing: region)))"}
}

extension GroundStationClientTypes {
    /// <p>Information about the ground station data.</p>
    public struct GroundStationData: Swift.Equatable {
        /// <p>UUID of a ground station.</p>
        public let groundStationId: Swift.String?
        /// <p>Name of a ground station.</p>
        public let groundStationName: Swift.String?
        /// <p>Ground station Region.</p>
        public let region: Swift.String?

        public init (
            groundStationId: Swift.String? = nil,
            groundStationName: Swift.String? = nil,
            region: Swift.String? = nil
        )
        {
            self.groundStationId = groundStationId
            self.groundStationName = groundStationName
            self.region = region
        }
    }

}

extension InvalidParameterException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidParameterException(message: \(Swift.String(describing: message)), parameterName: \(Swift.String(describing: parameterName)))"}
}

extension InvalidParameterException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.parameterName = output.parameterName
        } else {
            self.message = nil
            self.parameterName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One or more parameters are not valid.</p>
public struct InvalidParameterException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// <p/>
    public var parameterName: Swift.String?

    public init (
        message: Swift.String? = nil,
        parameterName: Swift.String? = nil
    )
    {
        self.message = message
        self.parameterName = parameterName
    }
}

struct InvalidParameterExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let parameterName: Swift.String?
}

extension InvalidParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case parameterName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let parameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterName)
        parameterName = parameterNameDecoded
    }
}

extension ListConfigsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListConfigsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListConfigsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListConfigsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListConfigsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListConfigsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListConfigsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListConfigsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListConfigsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListConfigsOutputError>
}

public struct ListConfigsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListConfigsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListConfigsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListConfigsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListConfigsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListConfigsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListConfigsOutputError>
}

/// <p/>
public struct ListConfigsInput: Swift.Equatable {
    /// <p>Maximum number of <code>Configs</code> returned.</p>
    public let maxResults: Swift.Int?
    /// <p>Next token returned in the request of a previous <code>ListConfigs</code> call. Used to get the next page of results.</p>
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListConfigsInputBody: Swift.Equatable {
}

extension ListConfigsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListConfigsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListConfigsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListConfigsOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListConfigsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListConfigsOutputResponse(configList: \(Swift.String(describing: configList)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListConfigsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListConfigsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.configList = output.configList
            self.nextToken = output.nextToken
        } else {
            self.configList = nil
            self.nextToken = nil
        }
    }
}

/// <p/>
public struct ListConfigsOutputResponse: Swift.Equatable {
    /// <p>List of <code>Config</code> items.</p>
    public let configList: [GroundStationClientTypes.ConfigListItem]?
    /// <p>Next token returned in the response of a previous <code>ListConfigs</code> call. Used to get the next page of results.</p>
    public let nextToken: Swift.String?

    public init (
        configList: [GroundStationClientTypes.ConfigListItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.configList = configList
        self.nextToken = nextToken
    }
}

struct ListConfigsOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let configList: [GroundStationClientTypes.ConfigListItem]?
}

extension ListConfigsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configList
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let configListContainer = try containerValues.decodeIfPresent([GroundStationClientTypes.ConfigListItem?].self, forKey: .configList)
        var configListDecoded0:[GroundStationClientTypes.ConfigListItem]? = nil
        if let configListContainer = configListContainer {
            configListDecoded0 = [GroundStationClientTypes.ConfigListItem]()
            for structure0 in configListContainer {
                if let structure0 = structure0 {
                    configListDecoded0?.append(structure0)
                }
            }
        }
        configList = configListDecoded0
    }
}

public struct ListContactsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListContactsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListContactsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListContactsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListContactsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListContactsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListContactsOutputError>
}

extension ListContactsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListContactsInput(endTime: \(Swift.String(describing: endTime)), groundStation: \(Swift.String(describing: groundStation)), maxResults: \(Swift.String(describing: maxResults)), missionProfileArn: \(Swift.String(describing: missionProfileArn)), nextToken: \(Swift.String(describing: nextToken)), satelliteArn: \(Swift.String(describing: satelliteArn)), startTime: \(Swift.String(describing: startTime)), statusList: \(Swift.String(describing: statusList)))"}
}

extension ListContactsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case groundStation
        case maxResults
        case missionProfileArn
        case nextToken
        case satelliteArn
        case startTime
        case statusList
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let groundStation = groundStation {
            try encodeContainer.encode(groundStation, forKey: .groundStation)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let missionProfileArn = missionProfileArn {
            try encodeContainer.encode(missionProfileArn, forKey: .missionProfileArn)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let satelliteArn = satelliteArn {
            try encodeContainer.encode(satelliteArn, forKey: .satelliteArn)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let statusList = statusList {
            var statusListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statusList)
            for statuslist0 in statusList {
                try statusListContainer.encode(statuslist0.rawValue)
            }
        }
    }
}

public struct ListContactsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListContactsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListContactsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListContactsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListContactsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListContactsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListContactsOutputError>
}

public struct ListContactsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListContactsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListContactsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListContactsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListContactsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListContactsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListContactsOutputError>
}

/// <p/>
public struct ListContactsInput: Swift.Equatable {
    /// <p>End time of a contact.</p>
    public let endTime: ClientRuntime.Date?
    /// <p>Name of a ground station.</p>
    public let groundStation: Swift.String?
    /// <p>Maximum number of contacts returned.</p>
    public let maxResults: Swift.Int?
    /// <p>ARN of a mission profile.</p>
    public let missionProfileArn: Swift.String?
    /// <p>Next token returned in the request of a previous <code>ListContacts</code> call. Used to get the next page of results.</p>
    public let nextToken: Swift.String?
    /// <p>ARN of a satellite.</p>
    public let satelliteArn: Swift.String?
    /// <p>Start time of a contact.</p>
    public let startTime: ClientRuntime.Date?
    /// <p>Status of a contact reservation.</p>
    public let statusList: [GroundStationClientTypes.ContactStatus]?

    public init (
        endTime: ClientRuntime.Date? = nil,
        groundStation: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        missionProfileArn: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        satelliteArn: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        statusList: [GroundStationClientTypes.ContactStatus]? = nil
    )
    {
        self.endTime = endTime
        self.groundStation = groundStation
        self.maxResults = maxResults
        self.missionProfileArn = missionProfileArn
        self.nextToken = nextToken
        self.satelliteArn = satelliteArn
        self.startTime = startTime
        self.statusList = statusList
    }
}

struct ListContactsInputBody: Swift.Equatable {
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
    public let statusList: [GroundStationClientTypes.ContactStatus]?
    public let startTime: ClientRuntime.Date?
    public let endTime: ClientRuntime.Date?
    public let groundStation: Swift.String?
    public let satelliteArn: Swift.String?
    public let missionProfileArn: Swift.String?
}

extension ListContactsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case groundStation
        case maxResults
        case missionProfileArn
        case nextToken
        case satelliteArn
        case startTime
        case statusList
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let statusListContainer = try containerValues.decodeIfPresent([GroundStationClientTypes.ContactStatus?].self, forKey: .statusList)
        var statusListDecoded0:[GroundStationClientTypes.ContactStatus]? = nil
        if let statusListContainer = statusListContainer {
            statusListDecoded0 = [GroundStationClientTypes.ContactStatus]()
            for string0 in statusListContainer {
                if let string0 = string0 {
                    statusListDecoded0?.append(string0)
                }
            }
        }
        statusList = statusListDecoded0
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let groundStationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groundStation)
        groundStation = groundStationDecoded
        let satelliteArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .satelliteArn)
        satelliteArn = satelliteArnDecoded
        let missionProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .missionProfileArn)
        missionProfileArn = missionProfileArnDecoded
    }
}

extension ListContactsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListContactsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListContactsOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListContactsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListContactsOutputResponse(contactList: \(Swift.String(describing: contactList)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListContactsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListContactsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contactList = output.contactList
            self.nextToken = output.nextToken
        } else {
            self.contactList = nil
            self.nextToken = nil
        }
    }
}

/// <p/>
public struct ListContactsOutputResponse: Swift.Equatable {
    /// <p>List of contacts.</p>
    public let contactList: [GroundStationClientTypes.ContactData]?
    /// <p>Next token returned in the response of a previous <code>ListContacts</code> call. Used to get the next page of results.</p>
    public let nextToken: Swift.String?

    public init (
        contactList: [GroundStationClientTypes.ContactData]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.contactList = contactList
        self.nextToken = nextToken
    }
}

struct ListContactsOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let contactList: [GroundStationClientTypes.ContactData]?
}

extension ListContactsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactList
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let contactListContainer = try containerValues.decodeIfPresent([GroundStationClientTypes.ContactData?].self, forKey: .contactList)
        var contactListDecoded0:[GroundStationClientTypes.ContactData]? = nil
        if let contactListContainer = contactListContainer {
            contactListDecoded0 = [GroundStationClientTypes.ContactData]()
            for structure0 in contactListContainer {
                if let structure0 = structure0 {
                    contactListDecoded0?.append(structure0)
                }
            }
        }
        contactList = contactListDecoded0
    }
}

extension ListDataflowEndpointGroupsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDataflowEndpointGroupsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDataflowEndpointGroupsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListDataflowEndpointGroupsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDataflowEndpointGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDataflowEndpointGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDataflowEndpointGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDataflowEndpointGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDataflowEndpointGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDataflowEndpointGroupsOutputError>
}

public struct ListDataflowEndpointGroupsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDataflowEndpointGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDataflowEndpointGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDataflowEndpointGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDataflowEndpointGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDataflowEndpointGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDataflowEndpointGroupsOutputError>
}

/// <p/>
public struct ListDataflowEndpointGroupsInput: Swift.Equatable {
    /// <p>Maximum number of dataflow endpoint groups returned.</p>
    public let maxResults: Swift.Int?
    /// <p>Next token returned in the request of a previous <code>ListDataflowEndpointGroups</code> call. Used to get the next page of results.</p>
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDataflowEndpointGroupsInputBody: Swift.Equatable {
}

extension ListDataflowEndpointGroupsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDataflowEndpointGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDataflowEndpointGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDataflowEndpointGroupsOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDataflowEndpointGroupsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDataflowEndpointGroupsOutputResponse(dataflowEndpointGroupList: \(Swift.String(describing: dataflowEndpointGroupList)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDataflowEndpointGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDataflowEndpointGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataflowEndpointGroupList = output.dataflowEndpointGroupList
            self.nextToken = output.nextToken
        } else {
            self.dataflowEndpointGroupList = nil
            self.nextToken = nil
        }
    }
}

/// <p/>
public struct ListDataflowEndpointGroupsOutputResponse: Swift.Equatable {
    /// <p>A list of dataflow endpoint groups.</p>
    public let dataflowEndpointGroupList: [GroundStationClientTypes.DataflowEndpointListItem]?
    /// <p>Next token returned in the response of a previous <code>ListDataflowEndpointGroups</code> call. Used to get the next page of results.</p>
    public let nextToken: Swift.String?

    public init (
        dataflowEndpointGroupList: [GroundStationClientTypes.DataflowEndpointListItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dataflowEndpointGroupList = dataflowEndpointGroupList
        self.nextToken = nextToken
    }
}

struct ListDataflowEndpointGroupsOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let dataflowEndpointGroupList: [GroundStationClientTypes.DataflowEndpointListItem]?
}

extension ListDataflowEndpointGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataflowEndpointGroupList
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let dataflowEndpointGroupListContainer = try containerValues.decodeIfPresent([GroundStationClientTypes.DataflowEndpointListItem?].self, forKey: .dataflowEndpointGroupList)
        var dataflowEndpointGroupListDecoded0:[GroundStationClientTypes.DataflowEndpointListItem]? = nil
        if let dataflowEndpointGroupListContainer = dataflowEndpointGroupListContainer {
            dataflowEndpointGroupListDecoded0 = [GroundStationClientTypes.DataflowEndpointListItem]()
            for structure0 in dataflowEndpointGroupListContainer {
                if let structure0 = structure0 {
                    dataflowEndpointGroupListDecoded0?.append(structure0)
                }
            }
        }
        dataflowEndpointGroupList = dataflowEndpointGroupListDecoded0
    }
}

extension ListGroundStationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListGroundStationsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), satelliteId: \(Swift.String(describing: satelliteId)))"}
}

extension ListGroundStationsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListGroundStationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListGroundStationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListGroundStationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListGroundStationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListGroundStationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListGroundStationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListGroundStationsOutputError>
}

public struct ListGroundStationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListGroundStationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListGroundStationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListGroundStationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let satelliteId = input.operationInput.satelliteId {
            let satelliteIdQueryItem = ClientRuntime.URLQueryItem(name: "satelliteId".urlPercentEncoding(), value: Swift.String(satelliteId).urlPercentEncoding())
            input.builder.withQueryItem(satelliteIdQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListGroundStationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListGroundStationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListGroundStationsOutputError>
}

/// <p/>
public struct ListGroundStationsInput: Swift.Equatable {
    /// <p>Maximum number of ground stations returned.</p>
    public let maxResults: Swift.Int?
    /// <p>Next token that can be supplied in the next call to get the next page of ground stations.</p>
    public let nextToken: Swift.String?
    /// <p>Satellite ID to retrieve on-boarded ground stations.</p>
    public let satelliteId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        satelliteId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.satelliteId = satelliteId
    }
}

struct ListGroundStationsInputBody: Swift.Equatable {
}

extension ListGroundStationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListGroundStationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListGroundStationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListGroundStationsOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGroundStationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListGroundStationsOutputResponse(groundStationList: \(Swift.String(describing: groundStationList)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListGroundStationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListGroundStationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.groundStationList = output.groundStationList
            self.nextToken = output.nextToken
        } else {
            self.groundStationList = nil
            self.nextToken = nil
        }
    }
}

/// <p/>
public struct ListGroundStationsOutputResponse: Swift.Equatable {
    /// <p>List of ground stations.</p>
    public let groundStationList: [GroundStationClientTypes.GroundStationData]?
    /// <p>Next token that can be supplied in the next call to get the next page of ground stations.</p>
    public let nextToken: Swift.String?

    public init (
        groundStationList: [GroundStationClientTypes.GroundStationData]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.groundStationList = groundStationList
        self.nextToken = nextToken
    }
}

struct ListGroundStationsOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let groundStationList: [GroundStationClientTypes.GroundStationData]?
}

extension ListGroundStationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groundStationList
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let groundStationListContainer = try containerValues.decodeIfPresent([GroundStationClientTypes.GroundStationData?].self, forKey: .groundStationList)
        var groundStationListDecoded0:[GroundStationClientTypes.GroundStationData]? = nil
        if let groundStationListContainer = groundStationListContainer {
            groundStationListDecoded0 = [GroundStationClientTypes.GroundStationData]()
            for structure0 in groundStationListContainer {
                if let structure0 = structure0 {
                    groundStationListDecoded0?.append(structure0)
                }
            }
        }
        groundStationList = groundStationListDecoded0
    }
}

extension ListMissionProfilesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListMissionProfilesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListMissionProfilesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListMissionProfilesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMissionProfilesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListMissionProfilesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMissionProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListMissionProfilesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListMissionProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMissionProfilesOutputError>
}

public struct ListMissionProfilesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMissionProfilesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListMissionProfilesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMissionProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListMissionProfilesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListMissionProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMissionProfilesOutputError>
}

/// <p/>
public struct ListMissionProfilesInput: Swift.Equatable {
    /// <p>Maximum number of mission profiles returned.</p>
    public let maxResults: Swift.Int?
    /// <p>Next token returned in the request of a previous <code>ListMissionProfiles</code> call. Used to get the next page of results.</p>
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListMissionProfilesInputBody: Swift.Equatable {
}

extension ListMissionProfilesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListMissionProfilesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMissionProfilesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListMissionProfilesOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMissionProfilesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListMissionProfilesOutputResponse(missionProfileList: \(Swift.String(describing: missionProfileList)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListMissionProfilesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListMissionProfilesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.missionProfileList = output.missionProfileList
            self.nextToken = output.nextToken
        } else {
            self.missionProfileList = nil
            self.nextToken = nil
        }
    }
}

/// <p/>
public struct ListMissionProfilesOutputResponse: Swift.Equatable {
    /// <p>List of mission profiles.</p>
    public let missionProfileList: [GroundStationClientTypes.MissionProfileListItem]?
    /// <p>Next token returned in the response of a previous <code>ListMissionProfiles</code> call. Used to get the next page of results.</p>
    public let nextToken: Swift.String?

    public init (
        missionProfileList: [GroundStationClientTypes.MissionProfileListItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.missionProfileList = missionProfileList
        self.nextToken = nextToken
    }
}

struct ListMissionProfilesOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let missionProfileList: [GroundStationClientTypes.MissionProfileListItem]?
}

extension ListMissionProfilesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case missionProfileList
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let missionProfileListContainer = try containerValues.decodeIfPresent([GroundStationClientTypes.MissionProfileListItem?].self, forKey: .missionProfileList)
        var missionProfileListDecoded0:[GroundStationClientTypes.MissionProfileListItem]? = nil
        if let missionProfileListContainer = missionProfileListContainer {
            missionProfileListDecoded0 = [GroundStationClientTypes.MissionProfileListItem]()
            for structure0 in missionProfileListContainer {
                if let structure0 = structure0 {
                    missionProfileListDecoded0?.append(structure0)
                }
            }
        }
        missionProfileList = missionProfileListDecoded0
    }
}

extension ListSatellitesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSatellitesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListSatellitesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListSatellitesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSatellitesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSatellitesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSatellitesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSatellitesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSatellitesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSatellitesOutputError>
}

public struct ListSatellitesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSatellitesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSatellitesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSatellitesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSatellitesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSatellitesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSatellitesOutputError>
}

/// <p/>
public struct ListSatellitesInput: Swift.Equatable {
    /// <p>Maximum number of satellites returned.</p>
    public let maxResults: Swift.Int?
    /// <p>Next token that can be supplied in the next call to get the next page of satellites.</p>
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSatellitesInputBody: Swift.Equatable {
}

extension ListSatellitesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListSatellitesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSatellitesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSatellitesOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSatellitesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSatellitesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), satellites: \(Swift.String(describing: satellites)))"}
}

extension ListSatellitesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListSatellitesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.satellites = output.satellites
        } else {
            self.nextToken = nil
            self.satellites = nil
        }
    }
}

/// <p/>
public struct ListSatellitesOutputResponse: Swift.Equatable {
    /// <p>Next token that can be supplied in the next call to get the next page of satellites.</p>
    public let nextToken: Swift.String?
    /// <p>List of satellites.</p>
    public let satellites: [GroundStationClientTypes.SatelliteListItem]?

    public init (
        nextToken: Swift.String? = nil,
        satellites: [GroundStationClientTypes.SatelliteListItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.satellites = satellites
    }
}

struct ListSatellitesOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let satellites: [GroundStationClientTypes.SatelliteListItem]?
}

extension ListSatellitesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case satellites
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let satellitesContainer = try containerValues.decodeIfPresent([GroundStationClientTypes.SatelliteListItem?].self, forKey: .satellites)
        var satellitesDecoded0:[GroundStationClientTypes.SatelliteListItem]? = nil
        if let satellitesContainer = satellitesContainer {
            satellitesDecoded0 = [GroundStationClientTypes.SatelliteListItem]()
            for structure0 in satellitesContainer {
                if let structure0 = structure0 {
                    satellitesDecoded0?.append(structure0)
                }
            }
        }
        satellites = satellitesDecoded0
    }
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

/// <p/>
public struct ListTagsForResourceInput: Swift.Equatable {
    /// <p>ARN of a resource.</p>
    public let resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

/// <p/>
public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// <p>Tags assigned to a resource.</p>
    public let tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GroundStationClientTypes.MissionProfileListItem: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case missionProfileArn
        case missionProfileId
        case name
        case region
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let missionProfileArn = missionProfileArn {
            try encodeContainer.encode(missionProfileArn, forKey: .missionProfileArn)
        }
        if let missionProfileId = missionProfileId {
            try encodeContainer.encode(missionProfileId, forKey: .missionProfileId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let missionProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .missionProfileId)
        missionProfileId = missionProfileIdDecoded
        let missionProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .missionProfileArn)
        missionProfileArn = missionProfileArnDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GroundStationClientTypes.MissionProfileListItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MissionProfileListItem(missionProfileArn: \(Swift.String(describing: missionProfileArn)), missionProfileId: \(Swift.String(describing: missionProfileId)), name: \(Swift.String(describing: name)), region: \(Swift.String(describing: region)))"}
}

extension GroundStationClientTypes {
    /// <p>Item in a list of mission profiles.</p>
    public struct MissionProfileListItem: Swift.Equatable {
        /// <p>ARN of a mission profile.</p>
        public let missionProfileArn: Swift.String?
        /// <p>UUID of a mission profile.</p>
        public let missionProfileId: Swift.String?
        /// <p>Name of a mission profile.</p>
        public let name: Swift.String?
        /// <p>Region of a mission profile.</p>
        public let region: Swift.String?

        public init (
            missionProfileArn: Swift.String? = nil,
            missionProfileId: Swift.String? = nil,
            name: Swift.String? = nil,
            region: Swift.String? = nil
        )
        {
            self.missionProfileArn = missionProfileArn
            self.missionProfileId = missionProfileId
            self.name = name
            self.region = region
        }
    }

}

extension GroundStationClientTypes {
    public enum Polarization: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case leftHand
        case `none`
        case rightHand
        case sdkUnknown(Swift.String)

        public static var allCases: [Polarization] {
            return [
                .leftHand,
                .none,
                .rightHand,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .leftHand: return "LEFT_HAND"
            case .none: return "NONE"
            case .rightHand: return "RIGHT_HAND"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Polarization(rawValue: rawValue) ?? Polarization.sdkUnknown(rawValue)
        }
    }
}

public struct ReserveContactInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ReserveContactInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ReserveContactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ReserveContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ReserveContactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ReserveContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ReserveContactOutputError>
}

extension ReserveContactInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReserveContactInput(endTime: \(Swift.String(describing: endTime)), groundStation: \(Swift.String(describing: groundStation)), missionProfileArn: \(Swift.String(describing: missionProfileArn)), satelliteArn: \(Swift.String(describing: satelliteArn)), startTime: \(Swift.String(describing: startTime)), tags: \(Swift.String(describing: tags)))"}
}

extension ReserveContactInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case groundStation
        case missionProfileArn
        case satelliteArn
        case startTime
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let groundStation = groundStation {
            try encodeContainer.encode(groundStation, forKey: .groundStation)
        }
        if let missionProfileArn = missionProfileArn {
            try encodeContainer.encode(missionProfileArn, forKey: .missionProfileArn)
        }
        if let satelliteArn = satelliteArn {
            try encodeContainer.encode(satelliteArn, forKey: .satelliteArn)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct ReserveContactInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ReserveContactInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ReserveContactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ReserveContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ReserveContactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ReserveContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ReserveContactOutputError>
}

public struct ReserveContactInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ReserveContactInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ReserveContactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ReserveContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ReserveContactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ReserveContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ReserveContactOutputError>
}

/// <p/>
public struct ReserveContactInput: Swift.Equatable {
    /// <p>End time of a contact.</p>
    public let endTime: ClientRuntime.Date?
    /// <p>Name of a ground station.</p>
    public let groundStation: Swift.String?
    /// <p>ARN of a mission profile.</p>
    public let missionProfileArn: Swift.String?
    /// <p>ARN of a satellite</p>
    public let satelliteArn: Swift.String?
    /// <p>Start time of a contact.</p>
    public let startTime: ClientRuntime.Date?
    /// <p>Tags assigned to a contact.</p>
    public let tags: [Swift.String:Swift.String]?

    public init (
        endTime: ClientRuntime.Date? = nil,
        groundStation: Swift.String? = nil,
        missionProfileArn: Swift.String? = nil,
        satelliteArn: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.endTime = endTime
        self.groundStation = groundStation
        self.missionProfileArn = missionProfileArn
        self.satelliteArn = satelliteArn
        self.startTime = startTime
        self.tags = tags
    }
}

struct ReserveContactInputBody: Swift.Equatable {
    public let missionProfileArn: Swift.String?
    public let satelliteArn: Swift.String?
    public let startTime: ClientRuntime.Date?
    public let endTime: ClientRuntime.Date?
    public let groundStation: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension ReserveContactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case groundStation
        case missionProfileArn
        case satelliteArn
        case startTime
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let missionProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .missionProfileArn)
        missionProfileArn = missionProfileArnDecoded
        let satelliteArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .satelliteArn)
        satelliteArn = satelliteArnDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let groundStationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groundStation)
        groundStation = groundStationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ReserveContactOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ReserveContactOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ReserveContactOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ReserveContactOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReserveContactOutputResponse(contactId: \(Swift.String(describing: contactId)))"}
}

extension ReserveContactOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ReserveContactOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contactId = output.contactId
        } else {
            self.contactId = nil
        }
    }
}

/// <p/>
public struct ReserveContactOutputResponse: Swift.Equatable {
    /// <p>UUID of a contact.</p>
    public let contactId: Swift.String?

    public init (
        contactId: Swift.String? = nil
    )
    {
        self.contactId = contactId
    }
}

struct ReserveContactOutputResponseBody: Swift.Equatable {
    public let contactId: Swift.String?
}

extension ReserveContactOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
    }
}

extension ResourceLimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceLimitExceededException(message: \(Swift.String(describing: message)), parameterName: \(Swift.String(describing: parameterName)))"}
}

extension ResourceLimitExceededException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.parameterName = output.parameterName
        } else {
            self.message = nil
            self.parameterName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Account limits for this resource have been exceeded.</p>
public struct ResourceLimitExceededException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// <p/>
    public var parameterName: Swift.String?

    public init (
        message: Swift.String? = nil,
        parameterName: Swift.String? = nil
    )
    {
        self.message = message
        self.parameterName = parameterName
    }
}

struct ResourceLimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let parameterName: Swift.String?
}

extension ResourceLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case parameterName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let parameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterName)
        parameterName = parameterNameDecoded
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Resource was not found.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GroundStationClientTypes.S3RecordingConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketArn
        case prefix
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketArn = bucketArn {
            try encodeContainer.encode(bucketArn, forKey: .bucketArn)
        }
        if let prefix = prefix {
            try encodeContainer.encode(prefix, forKey: .prefix)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketArn)
        bucketArn = bucketArnDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        prefix = prefixDecoded
    }
}

extension GroundStationClientTypes.S3RecordingConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "S3RecordingConfig(bucketArn: \(Swift.String(describing: bucketArn)), prefix: \(Swift.String(describing: prefix)), roleArn: \(Swift.String(describing: roleArn)))"}
}

extension GroundStationClientTypes {
    /// <p>Information about an S3 recording <code>Config</code>.</p>
    public struct S3RecordingConfig: Swift.Equatable {
        /// <p>ARN of the bucket to record to.</p>
        public let bucketArn: Swift.String?
        /// <p>S3 Key prefix to prefice data files.</p>
        public let prefix: Swift.String?
        /// <p>ARN of the role Ground Station assumes to write data to the bucket.</p>
        public let roleArn: Swift.String?

        public init (
            bucketArn: Swift.String? = nil,
            prefix: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.bucketArn = bucketArn
            self.prefix = prefix
            self.roleArn = roleArn
        }
    }

}

extension GroundStationClientTypes.S3RecordingDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketArn
        case keyTemplate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketArn = bucketArn {
            try encodeContainer.encode(bucketArn, forKey: .bucketArn)
        }
        if let keyTemplate = keyTemplate {
            try encodeContainer.encode(keyTemplate, forKey: .keyTemplate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketArn)
        bucketArn = bucketArnDecoded
        let keyTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyTemplate)
        keyTemplate = keyTemplateDecoded
    }
}

extension GroundStationClientTypes.S3RecordingDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "S3RecordingDetails(bucketArn: \(Swift.String(describing: bucketArn)), keyTemplate: \(Swift.String(describing: keyTemplate)))"}
}

extension GroundStationClientTypes {
    /// <p>Details about an S3 recording <code>Config</code> used in a contact.</p>
    public struct S3RecordingDetails: Swift.Equatable {
        /// <p>ARN of the bucket used.</p>
        public let bucketArn: Swift.String?
        /// <p>Template of the S3 key used.</p>
        public let keyTemplate: Swift.String?

        public init (
            bucketArn: Swift.String? = nil,
            keyTemplate: Swift.String? = nil
        )
        {
            self.bucketArn = bucketArn
            self.keyTemplate = keyTemplate
        }
    }

}

extension GroundStationClientTypes.SatelliteListItem: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groundStations
        case noradSatelliteID
        case satelliteArn
        case satelliteId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groundStations = groundStations {
            var groundStationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groundStations)
            for groundstationidlist0 in groundStations {
                try groundStationsContainer.encode(groundstationidlist0)
            }
        }
        if noradSatelliteID != 0 {
            try encodeContainer.encode(noradSatelliteID, forKey: .noradSatelliteID)
        }
        if let satelliteArn = satelliteArn {
            try encodeContainer.encode(satelliteArn, forKey: .satelliteArn)
        }
        if let satelliteId = satelliteId {
            try encodeContainer.encode(satelliteId, forKey: .satelliteId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let satelliteIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .satelliteId)
        satelliteId = satelliteIdDecoded
        let satelliteArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .satelliteArn)
        satelliteArn = satelliteArnDecoded
        let noradSatelliteIDDecoded = try containerValues.decode(Swift.Int.self, forKey: .noradSatelliteID)
        noradSatelliteID = noradSatelliteIDDecoded
        let groundStationsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .groundStations)
        var groundStationsDecoded0:[Swift.String]? = nil
        if let groundStationsContainer = groundStationsContainer {
            groundStationsDecoded0 = [Swift.String]()
            for string0 in groundStationsContainer {
                if let string0 = string0 {
                    groundStationsDecoded0?.append(string0)
                }
            }
        }
        groundStations = groundStationsDecoded0
    }
}

extension GroundStationClientTypes.SatelliteListItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SatelliteListItem(groundStations: \(Swift.String(describing: groundStations)), noradSatelliteID: \(Swift.String(describing: noradSatelliteID)), satelliteArn: \(Swift.String(describing: satelliteArn)), satelliteId: \(Swift.String(describing: satelliteId)))"}
}

extension GroundStationClientTypes {
    /// <p>Item in a list of satellites.</p>
    public struct SatelliteListItem: Swift.Equatable {
        /// <p>A list of ground stations to which the satellite is on-boarded.</p>
        public let groundStations: [Swift.String]?
        /// <p>NORAD satellite ID number.</p>
        public let noradSatelliteID: Swift.Int
        /// <p>ARN of a satellite.</p>
        public let satelliteArn: Swift.String?
        /// <p>UUID of a satellite.</p>
        public let satelliteId: Swift.String?

        public init (
            groundStations: [Swift.String]? = nil,
            noradSatelliteID: Swift.Int = 0,
            satelliteArn: Swift.String? = nil,
            satelliteId: Swift.String? = nil
        )
        {
            self.groundStations = groundStations
            self.noradSatelliteID = noradSatelliteID
            self.satelliteArn = satelliteArn
            self.satelliteId = satelliteId
        }
    }

}

extension GroundStationClientTypes.SecurityDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleArn
        case securityGroupIds
        case subnetIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupidlist0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupidlist0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetlist0 in subnetIds {
                try subnetIdsContainer.encode(subnetlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension GroundStationClientTypes.SecurityDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SecurityDetails(roleArn: \(Swift.String(describing: roleArn)), securityGroupIds: \(Swift.String(describing: securityGroupIds)), subnetIds: \(Swift.String(describing: subnetIds)))"}
}

extension GroundStationClientTypes {
    /// <p>Information about endpoints.</p>
    public struct SecurityDetails: Swift.Equatable {
        /// <p>ARN to a role needed for connecting streams to your instances. </p>
        public let roleArn: Swift.String?
        /// <p>The security groups to attach to the elastic network interfaces.</p>
        public let securityGroupIds: [Swift.String]?
        /// <p>A list of subnets where AWS Ground Station places elastic network interfaces to send streams to your instances.</p>
        public let subnetIds: [Swift.String]?

        public init (
            roleArn: Swift.String? = nil,
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil
        )
        {
            self.roleArn = roleArn
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }
    }

}

extension GroundStationClientTypes.SocketAddress: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case port
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let port = port {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
    }
}

extension GroundStationClientTypes.SocketAddress: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SocketAddress(name: \(Swift.String(describing: name)), port: \(Swift.String(describing: port)))"}
}

extension GroundStationClientTypes {
    /// <p>Information about the socket address.</p>
    public struct SocketAddress: Swift.Equatable {
        /// <p>Name of a socket address.</p>
        public let name: Swift.String?
        /// <p>Port of a socket address.</p>
        public let port: Swift.Int?

        public init (
            name: Swift.String? = nil,
            port: Swift.Int? = nil
        )
        {
            self.name = name
            self.port = port
        }
    }

}

extension GroundStationClientTypes.Source: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configDetails
        case configId
        case configType
        case dataflowSourceRegion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configDetails = configDetails {
            try encodeContainer.encode(configDetails, forKey: .configDetails)
        }
        if let configId = configId {
            try encodeContainer.encode(configId, forKey: .configId)
        }
        if let configType = configType {
            try encodeContainer.encode(configType.rawValue, forKey: .configType)
        }
        if let dataflowSourceRegion = dataflowSourceRegion {
            try encodeContainer.encode(dataflowSourceRegion, forKey: .dataflowSourceRegion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configTypeDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.ConfigCapabilityType.self, forKey: .configType)
        configType = configTypeDecoded
        let configIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configId)
        configId = configIdDecoded
        let configDetailsDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.ConfigDetails.self, forKey: .configDetails)
        configDetails = configDetailsDecoded
        let dataflowSourceRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataflowSourceRegion)
        dataflowSourceRegion = dataflowSourceRegionDecoded
    }
}

extension GroundStationClientTypes.Source: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Source(configDetails: \(Swift.String(describing: configDetails)), configId: \(Swift.String(describing: configId)), configType: \(Swift.String(describing: configType)), dataflowSourceRegion: \(Swift.String(describing: dataflowSourceRegion)))"}
}

extension GroundStationClientTypes {
    /// <p>Dataflow details for the source side.</p>
    public struct Source: Swift.Equatable {
        /// <p>Additional details for a <code>Config</code>, if type is dataflow endpoint or antenna demod decode.</p>
        public let configDetails: GroundStationClientTypes.ConfigDetails?
        /// <p>UUID of a <code>Config</code>.</p>
        public let configId: Swift.String?
        /// <p>Type of a <code>Config</code>.</p>
        public let configType: GroundStationClientTypes.ConfigCapabilityType?
        /// <p>Region of a dataflow source.</p>
        public let dataflowSourceRegion: Swift.String?

        public init (
            configDetails: GroundStationClientTypes.ConfigDetails? = nil,
            configId: Swift.String? = nil,
            configType: GroundStationClientTypes.ConfigCapabilityType? = nil,
            dataflowSourceRegion: Swift.String? = nil
        )
        {
            self.configDetails = configDetails
            self.configId = configId
            self.configType = configType
            self.dataflowSourceRegion = dataflowSourceRegion
        }
    }

}

extension GroundStationClientTypes.SpectrumConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bandwidth
        case centerFrequency
        case polarization
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bandwidth = bandwidth {
            try encodeContainer.encode(bandwidth, forKey: .bandwidth)
        }
        if let centerFrequency = centerFrequency {
            try encodeContainer.encode(centerFrequency, forKey: .centerFrequency)
        }
        if let polarization = polarization {
            try encodeContainer.encode(polarization.rawValue, forKey: .polarization)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let centerFrequencyDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.Frequency.self, forKey: .centerFrequency)
        centerFrequency = centerFrequencyDecoded
        let bandwidthDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.FrequencyBandwidth.self, forKey: .bandwidth)
        bandwidth = bandwidthDecoded
        let polarizationDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.Polarization.self, forKey: .polarization)
        polarization = polarizationDecoded
    }
}

extension GroundStationClientTypes.SpectrumConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SpectrumConfig(bandwidth: \(Swift.String(describing: bandwidth)), centerFrequency: \(Swift.String(describing: centerFrequency)), polarization: \(Swift.String(describing: polarization)))"}
}

extension GroundStationClientTypes {
    /// <p>Object that describes a spectral <code>Config</code>.</p>
    public struct SpectrumConfig: Swift.Equatable {
        /// <p>Bandwidth of a spectral <code>Config</code>. AWS Ground Station currently has the following bandwidth limitations:</p>
        ///             <ul>
        ///             <li>
        ///                <p>For <code>AntennaDownlinkDemodDecodeconfig</code>, valid values are between 125 kHz to 650 MHz.</p>
        ///             </li>
        ///             <li>
        ///                <p>For <code>AntennaDownlinkconfig</code> valid values are between 10 kHz to 54 MHz.</p>
        ///             </li>
        ///             <li>
        ///                <p>For <code>AntennaUplinkConfig</code>, valid values are between 10 kHz to 54 MHz.</p>
        ///             </li>
        ///          </ul>
        public let bandwidth: GroundStationClientTypes.FrequencyBandwidth?
        /// <p>Center frequency of a spectral <code>Config</code>. Valid values are between 2200 to 2300 MHz and 7750 to 8400 MHz for downlink and 2025 to 2120 MHz for uplink.</p>
        public let centerFrequency: GroundStationClientTypes.Frequency?
        /// <p>Polarization of a spectral <code>Config</code>. Capturing both <code>"RIGHT_HAND"</code> and <code>"LEFT_HAND"</code> polarization requires two separate configs.</p>
        public let polarization: GroundStationClientTypes.Polarization?

        public init (
            bandwidth: GroundStationClientTypes.FrequencyBandwidth? = nil,
            centerFrequency: GroundStationClientTypes.Frequency? = nil,
            polarization: GroundStationClientTypes.Polarization? = nil
        )
        {
            self.bandwidth = bandwidth
            self.centerFrequency = centerFrequency
            self.polarization = polarization
        }
    }

}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

/// <p/>
public struct TagResourceInput: Swift.Equatable {
    /// <p>ARN of a resource tag.</p>
    public let resourceArn: Swift.String?
    /// <p>Tags assigned to a resource.</p>
    public let tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// <p/>
public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GroundStationClientTypes.TrackingConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autotrack
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autotrack = autotrack {
            try encodeContainer.encode(autotrack.rawValue, forKey: .autotrack)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autotrackDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.Criticality.self, forKey: .autotrack)
        autotrack = autotrackDecoded
    }
}

extension GroundStationClientTypes.TrackingConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TrackingConfig(autotrack: \(Swift.String(describing: autotrack)))"}
}

extension GroundStationClientTypes {
    /// <p>Object that determines whether tracking should be used during a contact
    ///          executed with this <code>Config</code> in the mission profile.</p>
    public struct TrackingConfig: Swift.Equatable {
        /// <p>Current setting for autotrack.</p>
        public let autotrack: GroundStationClientTypes.Criticality?

        public init (
            autotrack: GroundStationClientTypes.Criticality? = nil
        )
        {
            self.autotrack = autotrack
        }
    }

}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

/// <p/>
public struct UntagResourceInput: Swift.Equatable {
    /// <p>ARN of a resource.</p>
    public let resourceArn: Swift.String?
    /// <p>Keys of a resource tag.</p>
    public let tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// <p/>
public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateConfigInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateConfigOutputError>
}

extension UpdateConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateConfigInput(configData: \(Swift.String(describing: configData)), configId: \(Swift.String(describing: configId)), configType: \(Swift.String(describing: configType)), name: \(Swift.String(describing: name)))"}
}

extension UpdateConfigInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configData
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configData = configData {
            try encodeContainer.encode(configData, forKey: .configData)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateConfigOutputError>
}

public struct UpdateConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateConfigOutputError>
}

/// <p/>
public struct UpdateConfigInput: Swift.Equatable {
    /// <p>Parameters of a <code>Config</code>.</p>
    public let configData: GroundStationClientTypes.ConfigTypeData?
    /// <p>UUID of a <code>Config</code>.</p>
    public let configId: Swift.String?
    /// <p>Type of a <code>Config</code>.</p>
    public let configType: GroundStationClientTypes.ConfigCapabilityType?
    /// <p>Name of a <code>Config</code>.</p>
    public let name: Swift.String?

    public init (
        configData: GroundStationClientTypes.ConfigTypeData? = nil,
        configId: Swift.String? = nil,
        configType: GroundStationClientTypes.ConfigCapabilityType? = nil,
        name: Swift.String? = nil
    )
    {
        self.configData = configData
        self.configId = configId
        self.configType = configType
        self.name = name
    }
}

struct UpdateConfigInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let configData: GroundStationClientTypes.ConfigTypeData?
}

extension UpdateConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configData
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let configDataDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.ConfigTypeData.self, forKey: .configData)
        configData = configDataDecoded
    }
}

extension UpdateConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateConfigOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateConfigOutputResponse(configArn: \(Swift.String(describing: configArn)), configId: \(Swift.String(describing: configId)), configType: \(Swift.String(describing: configType)))"}
}

extension UpdateConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.configArn = output.configArn
            self.configId = output.configId
            self.configType = output.configType
        } else {
            self.configArn = nil
            self.configId = nil
            self.configType = nil
        }
    }
}

/// <p/>
public struct UpdateConfigOutputResponse: Swift.Equatable {
    /// <p>ARN of a <code>Config</code>.</p>
    public let configArn: Swift.String?
    /// <p>UUID of a <code>Config</code>.</p>
    public let configId: Swift.String?
    /// <p>Type of a <code>Config</code>.</p>
    public let configType: GroundStationClientTypes.ConfigCapabilityType?

    public init (
        configArn: Swift.String? = nil,
        configId: Swift.String? = nil,
        configType: GroundStationClientTypes.ConfigCapabilityType? = nil
    )
    {
        self.configArn = configArn
        self.configId = configId
        self.configType = configType
    }
}

struct UpdateConfigOutputResponseBody: Swift.Equatable {
    public let configId: Swift.String?
    public let configType: GroundStationClientTypes.ConfigCapabilityType?
    public let configArn: Swift.String?
}

extension UpdateConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configArn
        case configId
        case configType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configId)
        configId = configIdDecoded
        let configTypeDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.ConfigCapabilityType.self, forKey: .configType)
        configType = configTypeDecoded
        let configArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configArn)
        configArn = configArnDecoded
    }
}

public struct UpdateMissionProfileInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateMissionProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateMissionProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateMissionProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateMissionProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateMissionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateMissionProfileOutputError>
}

extension UpdateMissionProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateMissionProfileInput(contactPostPassDurationSeconds: \(Swift.String(describing: contactPostPassDurationSeconds)), contactPrePassDurationSeconds: \(Swift.String(describing: contactPrePassDurationSeconds)), dataflowEdges: \(Swift.String(describing: dataflowEdges)), minimumViableContactDurationSeconds: \(Swift.String(describing: minimumViableContactDurationSeconds)), missionProfileId: \(Swift.String(describing: missionProfileId)), name: \(Swift.String(describing: name)), trackingConfigArn: \(Swift.String(describing: trackingConfigArn)))"}
}

extension UpdateMissionProfileInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactPostPassDurationSeconds
        case contactPrePassDurationSeconds
        case dataflowEdges
        case minimumViableContactDurationSeconds
        case name
        case trackingConfigArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactPostPassDurationSeconds = contactPostPassDurationSeconds {
            try encodeContainer.encode(contactPostPassDurationSeconds, forKey: .contactPostPassDurationSeconds)
        }
        if let contactPrePassDurationSeconds = contactPrePassDurationSeconds {
            try encodeContainer.encode(contactPrePassDurationSeconds, forKey: .contactPrePassDurationSeconds)
        }
        if let dataflowEdges = dataflowEdges {
            var dataflowEdgesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataflowEdges)
            for dataflowedgelist0 in dataflowEdges {
                var dataflowedgelist0Container = dataflowEdgesContainer.nestedUnkeyedContainer()
                for dataflowedge1 in dataflowedgelist0 {
                    try dataflowedgelist0Container.encode(dataflowedge1)
                }
            }
        }
        if let minimumViableContactDurationSeconds = minimumViableContactDurationSeconds {
            try encodeContainer.encode(minimumViableContactDurationSeconds, forKey: .minimumViableContactDurationSeconds)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let trackingConfigArn = trackingConfigArn {
            try encodeContainer.encode(trackingConfigArn, forKey: .trackingConfigArn)
        }
    }
}

public struct UpdateMissionProfileInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateMissionProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateMissionProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateMissionProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateMissionProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateMissionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateMissionProfileOutputError>
}

public struct UpdateMissionProfileInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateMissionProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateMissionProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateMissionProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateMissionProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateMissionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateMissionProfileOutputError>
}

/// <p/>
public struct UpdateMissionProfileInput: Swift.Equatable {
    /// <p>Amount of time after a contact ends that you‚Äôd like to receive a CloudWatch event indicating the pass has finished.</p>
    public let contactPostPassDurationSeconds: Swift.Int?
    /// <p>Amount of time after a contact ends that you‚Äôd like to receive a CloudWatch event indicating the pass has finished.</p>
    public let contactPrePassDurationSeconds: Swift.Int?
    /// <p>A list of lists of ARNs. Each list of ARNs is an edge, with a <i>from</i>
    ///             <code>Config</code> and a <i>to</i>
    ///             <code>Config</code>.</p>
    public let dataflowEdges: [[Swift.String]]?
    /// <p>Smallest amount of time in seconds that you‚Äôd like to see for an available contact. AWS Ground Station will not present you with contacts shorter than this duration.</p>
    public let minimumViableContactDurationSeconds: Swift.Int?
    /// <p>UUID of a mission profile.</p>
    public let missionProfileId: Swift.String?
    /// <p>Name of a mission profile.</p>
    public let name: Swift.String?
    /// <p>ARN of a tracking <code>Config</code>.</p>
    public let trackingConfigArn: Swift.String?

    public init (
        contactPostPassDurationSeconds: Swift.Int? = nil,
        contactPrePassDurationSeconds: Swift.Int? = nil,
        dataflowEdges: [[Swift.String]]? = nil,
        minimumViableContactDurationSeconds: Swift.Int? = nil,
        missionProfileId: Swift.String? = nil,
        name: Swift.String? = nil,
        trackingConfigArn: Swift.String? = nil
    )
    {
        self.contactPostPassDurationSeconds = contactPostPassDurationSeconds
        self.contactPrePassDurationSeconds = contactPrePassDurationSeconds
        self.dataflowEdges = dataflowEdges
        self.minimumViableContactDurationSeconds = minimumViableContactDurationSeconds
        self.missionProfileId = missionProfileId
        self.name = name
        self.trackingConfigArn = trackingConfigArn
    }
}

struct UpdateMissionProfileInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let contactPrePassDurationSeconds: Swift.Int?
    public let contactPostPassDurationSeconds: Swift.Int?
    public let minimumViableContactDurationSeconds: Swift.Int?
    public let dataflowEdges: [[Swift.String]]?
    public let trackingConfigArn: Swift.String?
}

extension UpdateMissionProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactPostPassDurationSeconds
        case contactPrePassDurationSeconds
        case dataflowEdges
        case minimumViableContactDurationSeconds
        case name
        case trackingConfigArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let contactPrePassDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .contactPrePassDurationSeconds)
        contactPrePassDurationSeconds = contactPrePassDurationSecondsDecoded
        let contactPostPassDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .contactPostPassDurationSeconds)
        contactPostPassDurationSeconds = contactPostPassDurationSecondsDecoded
        let minimumViableContactDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minimumViableContactDurationSeconds)
        minimumViableContactDurationSeconds = minimumViableContactDurationSecondsDecoded
        let dataflowEdgesContainer = try containerValues.decodeIfPresent([[Swift.String?]?].self, forKey: .dataflowEdges)
        var dataflowEdgesDecoded0:[[Swift.String]]? = nil
        if let dataflowEdgesContainer = dataflowEdgesContainer {
            dataflowEdgesDecoded0 = [[Swift.String]]()
            for list0 in dataflowEdgesContainer {
                var list0Decoded0: [Swift.String]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [Swift.String]()
                    for string1 in list0 {
                        if let string1 = string1 {
                            list0Decoded0?.append(string1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    dataflowEdgesDecoded0?.append(list0Decoded0)
                }
            }
        }
        dataflowEdges = dataflowEdgesDecoded0
        let trackingConfigArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trackingConfigArn)
        trackingConfigArn = trackingConfigArnDecoded
    }
}

extension UpdateMissionProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateMissionProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateMissionProfileOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateMissionProfileOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateMissionProfileOutputResponse(missionProfileId: \(Swift.String(describing: missionProfileId)))"}
}

extension UpdateMissionProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateMissionProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.missionProfileId = output.missionProfileId
        } else {
            self.missionProfileId = nil
        }
    }
}

/// <p/>
public struct UpdateMissionProfileOutputResponse: Swift.Equatable {
    /// <p>UUID of a mission profile.</p>
    public let missionProfileId: Swift.String?

    public init (
        missionProfileId: Swift.String? = nil
    )
    {
        self.missionProfileId = missionProfileId
    }
}

struct UpdateMissionProfileOutputResponseBody: Swift.Equatable {
    public let missionProfileId: Swift.String?
}

extension UpdateMissionProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case missionProfileId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let missionProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .missionProfileId)
        missionProfileId = missionProfileIdDecoded
    }
}

extension GroundStationClientTypes.UplinkEchoConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case antennaUplinkConfigArn
        case enabled
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let antennaUplinkConfigArn = antennaUplinkConfigArn {
            try encodeContainer.encode(antennaUplinkConfigArn, forKey: .antennaUplinkConfigArn)
        }
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let antennaUplinkConfigArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .antennaUplinkConfigArn)
        antennaUplinkConfigArn = antennaUplinkConfigArnDecoded
    }
}

extension GroundStationClientTypes.UplinkEchoConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UplinkEchoConfig(antennaUplinkConfigArn: \(Swift.String(describing: antennaUplinkConfigArn)), enabled: \(Swift.String(describing: enabled)))"}
}

extension GroundStationClientTypes {
    /// <p>Information about an uplink echo <code>Config</code>.</p>
    ///          <p>Parameters from the <code>AntennaUplinkConfig</code>, corresponding to the
    ///          specified <code>AntennaUplinkConfigArn</code>, are used when this <code>UplinkEchoConfig</code>
    ///          is used in a contact.</p>
    public struct UplinkEchoConfig: Swift.Equatable {
        /// <p>ARN of an uplink <code>Config</code>.</p>
        public let antennaUplinkConfigArn: Swift.String?
        /// <p>Whether or not an uplink <code>Config</code> is enabled.</p>
        public let enabled: Swift.Bool?

        public init (
            antennaUplinkConfigArn: Swift.String? = nil,
            enabled: Swift.Bool? = nil
        )
        {
            self.antennaUplinkConfigArn = antennaUplinkConfigArn
            self.enabled = enabled
        }
    }

}

extension GroundStationClientTypes.UplinkSpectrumConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case centerFrequency
        case polarization
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let centerFrequency = centerFrequency {
            try encodeContainer.encode(centerFrequency, forKey: .centerFrequency)
        }
        if let polarization = polarization {
            try encodeContainer.encode(polarization.rawValue, forKey: .polarization)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let centerFrequencyDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.Frequency.self, forKey: .centerFrequency)
        centerFrequency = centerFrequencyDecoded
        let polarizationDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.Polarization.self, forKey: .polarization)
        polarization = polarizationDecoded
    }
}

extension GroundStationClientTypes.UplinkSpectrumConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UplinkSpectrumConfig(centerFrequency: \(Swift.String(describing: centerFrequency)), polarization: \(Swift.String(describing: polarization)))"}
}

extension GroundStationClientTypes {
    /// <p>Information about the uplink spectral <code>Config</code>.</p>
    public struct UplinkSpectrumConfig: Swift.Equatable {
        /// <p>Center frequency of an uplink spectral <code>Config</code>. Valid values are between 2025 to 2120 MHz.</p>
        public let centerFrequency: GroundStationClientTypes.Frequency?
        /// <p>Polarization of an uplink spectral <code>Config</code>. Capturing both <code>"RIGHT_HAND"</code> and <code>"LEFT_HAND"</code> polarization requires two separate configs.</p>
        public let polarization: GroundStationClientTypes.Polarization?

        public init (
            centerFrequency: GroundStationClientTypes.Frequency? = nil,
            polarization: GroundStationClientTypes.Polarization? = nil
        )
        {
            self.centerFrequency = centerFrequency
            self.polarization = polarization
        }
    }

}
