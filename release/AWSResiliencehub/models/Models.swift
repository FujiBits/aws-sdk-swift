// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessDeniedException(message: \(Swift.String(describing: message)))"}
}

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You don't have permissions to perform the requested operation. The user or role that is making the request must have at least one IAM permissions policy attached that grants the required permissions.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct AddDraftAppVersionResourceMappingsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddDraftAppVersionResourceMappingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddDraftAppVersionResourceMappingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddDraftAppVersionResourceMappingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddDraftAppVersionResourceMappingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddDraftAppVersionResourceMappingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddDraftAppVersionResourceMappingsOutputError>
}

extension AddDraftAppVersionResourceMappingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddDraftAppVersionResourceMappingsInput(appArn: \(Swift.String(describing: appArn)), resourceMappings: \(Swift.String(describing: resourceMappings)))"}
}

extension AddDraftAppVersionResourceMappingsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case resourceMappings
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let resourceMappings = resourceMappings {
            var resourceMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceMappings)
            for resourcemappinglist0 in resourceMappings {
                try resourceMappingsContainer.encode(resourcemappinglist0)
            }
        }
    }
}

public struct AddDraftAppVersionResourceMappingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddDraftAppVersionResourceMappingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddDraftAppVersionResourceMappingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddDraftAppVersionResourceMappingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddDraftAppVersionResourceMappingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddDraftAppVersionResourceMappingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddDraftAppVersionResourceMappingsOutputError>
}

public struct AddDraftAppVersionResourceMappingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddDraftAppVersionResourceMappingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddDraftAppVersionResourceMappingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddDraftAppVersionResourceMappingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddDraftAppVersionResourceMappingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddDraftAppVersionResourceMappingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddDraftAppVersionResourceMappingsOutputError>
}

public struct AddDraftAppVersionResourceMappingsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddDraftAppVersionResourceMappingsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: AddDraftAppVersionResourceMappingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddDraftAppVersionResourceMappingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AddDraftAppVersionResourceMappingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<AddDraftAppVersionResourceMappingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddDraftAppVersionResourceMappingsOutputError>
}

public struct AddDraftAppVersionResourceMappingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddDraftAppVersionResourceMappingsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: AddDraftAppVersionResourceMappingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddDraftAppVersionResourceMappingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/add-draft-app-version-resource-mappings"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AddDraftAppVersionResourceMappingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<AddDraftAppVersionResourceMappingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddDraftAppVersionResourceMappingsOutputError>
}

public struct AddDraftAppVersionResourceMappingsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var appArn: Swift.String?
    /// Mappings used to map logical resources from the template to physical resources. You can use the mapping type CFN_STACK if the application template uses a logical stack name. Or you can map individual resources by using the mapping type RESOURCE. We recommend using the mapping type CFN_STACK if the application is backed by a CloudFormation stack.
    /// This member is required.
    public var resourceMappings: [ResiliencehubClientTypes.ResourceMapping]?

    public init (
        appArn: Swift.String? = nil,
        resourceMappings: [ResiliencehubClientTypes.ResourceMapping]? = nil
    )
    {
        self.appArn = appArn
        self.resourceMappings = resourceMappings
    }
}

struct AddDraftAppVersionResourceMappingsInputBody: Swift.Equatable {
    public let appArn: Swift.String?
    public let resourceMappings: [ResiliencehubClientTypes.ResourceMapping]?
}

extension AddDraftAppVersionResourceMappingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case resourceMappings
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let resourceMappingsContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.ResourceMapping?].self, forKey: .resourceMappings)
        var resourceMappingsDecoded0:[ResiliencehubClientTypes.ResourceMapping]? = nil
        if let resourceMappingsContainer = resourceMappingsContainer {
            resourceMappingsDecoded0 = [ResiliencehubClientTypes.ResourceMapping]()
            for structure0 in resourceMappingsContainer {
                if let structure0 = structure0 {
                    resourceMappingsDecoded0?.append(structure0)
                }
            }
        }
        resourceMappings = resourceMappingsDecoded0
    }
}

extension AddDraftAppVersionResourceMappingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddDraftAppVersionResourceMappingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddDraftAppVersionResourceMappingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddDraftAppVersionResourceMappingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddDraftAppVersionResourceMappingsOutputResponse(appArn: \(Swift.String(describing: appArn)), appVersion: \(Swift.String(describing: appVersion)), resourceMappings: \(Swift.String(describing: resourceMappings)))"}
}

extension AddDraftAppVersionResourceMappingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AddDraftAppVersionResourceMappingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appArn = output.appArn
            self.appVersion = output.appVersion
            self.resourceMappings = output.resourceMappings
        } else {
            self.appArn = nil
            self.appVersion = nil
            self.resourceMappings = nil
        }
    }
}

public struct AddDraftAppVersionResourceMappingsOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var appArn: Swift.String?
    /// The version of the application.
    /// This member is required.
    public var appVersion: Swift.String?
    /// Mappings used to map logical resources from the template to physical resources. You can use the mapping type CFN_STACK if the application template uses a logical stack name. Or you can map individual resources by using the mapping type RESOURCE. We recommend using the mapping type CFN_STACK if the application is backed by a CloudFormation stack.
    /// This member is required.
    public var resourceMappings: [ResiliencehubClientTypes.ResourceMapping]?

    public init (
        appArn: Swift.String? = nil,
        appVersion: Swift.String? = nil,
        resourceMappings: [ResiliencehubClientTypes.ResourceMapping]? = nil
    )
    {
        self.appArn = appArn
        self.appVersion = appVersion
        self.resourceMappings = resourceMappings
    }
}

struct AddDraftAppVersionResourceMappingsOutputResponseBody: Swift.Equatable {
    public let appArn: Swift.String?
    public let appVersion: Swift.String?
    public let resourceMappings: [ResiliencehubClientTypes.ResourceMapping]?
}

extension AddDraftAppVersionResourceMappingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case resourceMappings
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let resourceMappingsContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.ResourceMapping?].self, forKey: .resourceMappings)
        var resourceMappingsDecoded0:[ResiliencehubClientTypes.ResourceMapping]? = nil
        if let resourceMappingsContainer = resourceMappingsContainer {
            resourceMappingsDecoded0 = [ResiliencehubClientTypes.ResourceMapping]()
            for structure0 in resourceMappingsContainer {
                if let structure0 = structure0 {
                    resourceMappingsDecoded0?.append(structure0)
                }
            }
        }
        resourceMappings = resourceMappingsDecoded0
    }
}

extension ResiliencehubClientTypes.AlarmRecommendation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appComponentName
        case description
        case items
        case name
        case prerequisite
        case recommendationId
        case referenceId
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appComponentName = appComponentName {
            try encodeContainer.encode(appComponentName, forKey: .appComponentName)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let items = items {
            var itemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .items)
            for recommendationitemlist0 in items {
                try itemsContainer.encode(recommendationitemlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let prerequisite = prerequisite {
            try encodeContainer.encode(prerequisite, forKey: .prerequisite)
        }
        if let recommendationId = recommendationId {
            try encodeContainer.encode(recommendationId, forKey: .recommendationId)
        }
        if let referenceId = referenceId {
            try encodeContainer.encode(referenceId, forKey: .referenceId)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendationId)
        recommendationId = recommendationIdDecoded
        let referenceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .referenceId)
        referenceId = referenceIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.AlarmType.self, forKey: .type)
        type = typeDecoded
        let appComponentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appComponentName)
        appComponentName = appComponentNameDecoded
        let itemsContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.RecommendationItem?].self, forKey: .items)
        var itemsDecoded0:[ResiliencehubClientTypes.RecommendationItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ResiliencehubClientTypes.RecommendationItem]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let prerequisiteDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prerequisite)
        prerequisite = prerequisiteDecoded
    }
}

extension ResiliencehubClientTypes.AlarmRecommendation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AlarmRecommendation(appComponentName: \(Swift.String(describing: appComponentName)), description: \(Swift.String(describing: description)), items: \(Swift.String(describing: items)), name: \(Swift.String(describing: name)), prerequisite: \(Swift.String(describing: prerequisite)), recommendationId: \(Swift.String(describing: recommendationId)), referenceId: \(Swift.String(describing: referenceId)), type: \(Swift.String(describing: type)))"}
}

extension ResiliencehubClientTypes {
    /// Defines a recommendation for a CloudWatch alarm.
    public struct AlarmRecommendation: Swift.Equatable {
        /// The application component for the CloudWatch alarm recommendation.
        public var appComponentName: Swift.String?
        /// The description of the recommendation.
        public var description: Swift.String?
        /// The list of CloudWatch alarm recommendations.
        public var items: [ResiliencehubClientTypes.RecommendationItem]?
        /// The name of the alarm recommendation.
        /// This member is required.
        public var name: Swift.String?
        /// The prerequisite for the alarm recommendation.
        public var prerequisite: Swift.String?
        /// The identifier of the alarm recommendation.
        /// This member is required.
        public var recommendationId: Swift.String?
        /// The reference identifier of the alarm recommendation.
        /// This member is required.
        public var referenceId: Swift.String?
        /// The type of alarm recommendation.
        /// This member is required.
        public var type: ResiliencehubClientTypes.AlarmType?

        public init (
            appComponentName: Swift.String? = nil,
            description: Swift.String? = nil,
            items: [ResiliencehubClientTypes.RecommendationItem]? = nil,
            name: Swift.String? = nil,
            prerequisite: Swift.String? = nil,
            recommendationId: Swift.String? = nil,
            referenceId: Swift.String? = nil,
            type: ResiliencehubClientTypes.AlarmType? = nil
        )
        {
            self.appComponentName = appComponentName
            self.description = description
            self.items = items
            self.name = name
            self.prerequisite = prerequisite
            self.recommendationId = recommendationId
            self.referenceId = referenceId
            self.type = type
        }
    }

}

extension ResiliencehubClientTypes {
    public enum AlarmType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canary
        case composite
        case event
        case logs
        case metric
        case sdkUnknown(Swift.String)

        public static var allCases: [AlarmType] {
            return [
                .canary,
                .composite,
                .event,
                .logs,
                .metric,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canary: return "Canary"
            case .composite: return "Composite"
            case .event: return "Event"
            case .logs: return "Logs"
            case .metric: return "Metric"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AlarmType(rawValue: rawValue) ?? AlarmType.sdkUnknown(rawValue)
        }
    }
}

extension ResiliencehubClientTypes.App: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case complianceStatus
        case creationTime
        case description
        case lastAppComplianceEvaluationTime
        case lastResiliencyScoreEvaluationTime
        case name
        case policyArn
        case resiliencyScore
        case status
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let complianceStatus = complianceStatus {
            try encodeContainer.encode(complianceStatus.rawValue, forKey: .complianceStatus)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastAppComplianceEvaluationTime = lastAppComplianceEvaluationTime {
            try encodeContainer.encode(lastAppComplianceEvaluationTime.timeIntervalSince1970, forKey: .lastAppComplianceEvaluationTime)
        }
        if let lastResiliencyScoreEvaluationTime = lastResiliencyScoreEvaluationTime {
            try encodeContainer.encode(lastResiliencyScoreEvaluationTime.timeIntervalSince1970, forKey: .lastResiliencyScoreEvaluationTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let policyArn = policyArn {
            try encodeContainer.encode(policyArn, forKey: .policyArn)
        }
        if resiliencyScore != 0.0 {
            try encodeContainer.encode(resiliencyScore, forKey: .resiliencyScore)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.AppStatusType.self, forKey: .status)
        status = statusDecoded
        let complianceStatusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.AppComplianceStatusType.self, forKey: .complianceStatus)
        complianceStatus = complianceStatusDecoded
        let lastAppComplianceEvaluationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastAppComplianceEvaluationTime)
        lastAppComplianceEvaluationTime = lastAppComplianceEvaluationTimeDecoded
        let resiliencyScoreDecoded = try containerValues.decode(Swift.Double.self, forKey: .resiliencyScore)
        resiliencyScore = resiliencyScoreDecoded
        let lastResiliencyScoreEvaluationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastResiliencyScoreEvaluationTime)
        lastResiliencyScoreEvaluationTime = lastResiliencyScoreEvaluationTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ResiliencehubClientTypes.App: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "App(appArn: \(Swift.String(describing: appArn)), complianceStatus: \(Swift.String(describing: complianceStatus)), creationTime: \(Swift.String(describing: creationTime)), description: \(Swift.String(describing: description)), lastAppComplianceEvaluationTime: \(Swift.String(describing: lastAppComplianceEvaluationTime)), lastResiliencyScoreEvaluationTime: \(Swift.String(describing: lastResiliencyScoreEvaluationTime)), name: \(Swift.String(describing: name)), policyArn: \(Swift.String(describing: policyArn)), resiliencyScore: \(Swift.String(describing: resiliencyScore)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)))"}
}

extension ResiliencehubClientTypes {
    /// Defines a Resilience Hub application.
    public struct App: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
        /// This member is required.
        public var appArn: Swift.String?
        /// The current status of compliance for the resiliency policy.
        public var complianceStatus: ResiliencehubClientTypes.AppComplianceStatusType?
        /// The timestamp for when the app was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The optional description for an app.
        public var description: Swift.String?
        /// The timestamp for the most recent compliance evaluation.
        public var lastAppComplianceEvaluationTime: ClientRuntime.Date?
        /// The timestamp for the most recent resiliency score evaluation.
        public var lastResiliencyScoreEvaluationTime: ClientRuntime.Date?
        /// The name for the application.
        /// This member is required.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the resiliency policy. The format for this ARN is: arn:partition:dcps:region:account:resiliency-policy/policy-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
        public var policyArn: Swift.String?
        /// The current resiliency score for the application.
        public var resiliencyScore: Swift.Double
        /// The status of the action.
        public var status: ResiliencehubClientTypes.AppStatusType?
        /// The tags assigned to the resource. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key/value pair.
        public var tags: [Swift.String:Swift.String]?

        public init (
            appArn: Swift.String? = nil,
            complianceStatus: ResiliencehubClientTypes.AppComplianceStatusType? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            lastAppComplianceEvaluationTime: ClientRuntime.Date? = nil,
            lastResiliencyScoreEvaluationTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            policyArn: Swift.String? = nil,
            resiliencyScore: Swift.Double = 0.0,
            status: ResiliencehubClientTypes.AppStatusType? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.appArn = appArn
            self.complianceStatus = complianceStatus
            self.creationTime = creationTime
            self.description = description
            self.lastAppComplianceEvaluationTime = lastAppComplianceEvaluationTime
            self.lastResiliencyScoreEvaluationTime = lastResiliencyScoreEvaluationTime
            self.name = name
            self.policyArn = policyArn
            self.resiliencyScore = resiliencyScore
            self.status = status
            self.tags = tags
        }
    }

}

extension ResiliencehubClientTypes.AppAssessment: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case assessmentArn
        case assessmentName
        case assessmentStatus
        case compliance
        case complianceStatus
        case cost
        case endTime
        case invoker
        case message
        case policy
        case resiliencyScore
        case startTime
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let appVersion = appVersion {
            try encodeContainer.encode(appVersion, forKey: .appVersion)
        }
        if let assessmentArn = assessmentArn {
            try encodeContainer.encode(assessmentArn, forKey: .assessmentArn)
        }
        if let assessmentName = assessmentName {
            try encodeContainer.encode(assessmentName, forKey: .assessmentName)
        }
        if let assessmentStatus = assessmentStatus {
            try encodeContainer.encode(assessmentStatus.rawValue, forKey: .assessmentStatus)
        }
        if let compliance = compliance {
            var complianceContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .compliance)
            for (dictKey0, assessmentcompliance0) in compliance {
                try complianceContainer.encode(assessmentcompliance0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let complianceStatus = complianceStatus {
            try encodeContainer.encode(complianceStatus.rawValue, forKey: .complianceStatus)
        }
        if let cost = cost {
            try encodeContainer.encode(cost, forKey: .cost)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let invoker = invoker {
            try encodeContainer.encode(invoker.rawValue, forKey: .invoker)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let resiliencyScore = resiliencyScore {
            try encodeContainer.encode(resiliencyScore, forKey: .resiliencyScore)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let invokerDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.AssessmentInvoker.self, forKey: .invoker)
        invoker = invokerDecoded
        let costDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.Cost.self, forKey: .cost)
        cost = costDecoded
        let resiliencyScoreDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ResiliencyScore.self, forKey: .resiliencyScore)
        resiliencyScore = resiliencyScoreDecoded
        let complianceContainer = try containerValues.decodeIfPresent([Swift.String: ResiliencehubClientTypes.DisruptionCompliance?].self, forKey: .compliance)
        var complianceDecoded0: [Swift.String:ResiliencehubClientTypes.DisruptionCompliance]? = nil
        if let complianceContainer = complianceContainer {
            complianceDecoded0 = [Swift.String:ResiliencehubClientTypes.DisruptionCompliance]()
            for (key0, disruptioncompliance0) in complianceContainer {
                if let disruptioncompliance0 = disruptioncompliance0 {
                    complianceDecoded0?[key0] = disruptioncompliance0
                }
            }
        }
        compliance = complianceDecoded0
        let complianceStatusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ComplianceStatus.self, forKey: .complianceStatus)
        complianceStatus = complianceStatusDecoded
        let assessmentStatusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.AssessmentStatus.self, forKey: .assessmentStatus)
        assessmentStatus = assessmentStatusDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let assessmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentName)
        assessmentName = assessmentNameDecoded
        let assessmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentArn)
        assessmentArn = assessmentArnDecoded
        let policyDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ResiliencyPolicy.self, forKey: .policy)
        policy = policyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ResiliencehubClientTypes.AppAssessment: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AppAssessment(appArn: \(Swift.String(describing: appArn)), appVersion: \(Swift.String(describing: appVersion)), assessmentArn: \(Swift.String(describing: assessmentArn)), assessmentName: \(Swift.String(describing: assessmentName)), assessmentStatus: \(Swift.String(describing: assessmentStatus)), compliance: \(Swift.String(describing: compliance)), complianceStatus: \(Swift.String(describing: complianceStatus)), cost: \(Swift.String(describing: cost)), endTime: \(Swift.String(describing: endTime)), invoker: \(Swift.String(describing: invoker)), message: \(Swift.String(describing: message)), policy: \(Swift.String(describing: policy)), resiliencyScore: \(Swift.String(describing: resiliencyScore)), startTime: \(Swift.String(describing: startTime)), tags: \(Swift.String(describing: tags)))"}
}

extension ResiliencehubClientTypes {
    /// Defines an application assessment.
    public struct AppAssessment: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
        public var appArn: Swift.String?
        /// The version of the application.
        public var appVersion: Swift.String?
        /// The Amazon Resource Name (ARN) of the assessment. The format for this ARN is: arn:partition:dcps:region:account:app-assessment/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
        /// This member is required.
        public var assessmentArn: Swift.String?
        /// The name of the assessment.
        public var assessmentName: Swift.String?
        /// The current status of the assessment for the resiliency policy.
        /// This member is required.
        public var assessmentStatus: ResiliencehubClientTypes.AssessmentStatus?
        /// The application compliance against the resiliency policy.
        public var compliance: [Swift.String:ResiliencehubClientTypes.DisruptionCompliance]?
        /// The current status of the compliance for the resiliency policy.
        public var complianceStatus: ResiliencehubClientTypes.ComplianceStatus?
        /// The cost for the application.
        public var cost: ResiliencehubClientTypes.Cost?
        /// The end time for the action.
        public var endTime: ClientRuntime.Date?
        /// The entity that invoked the assessment.
        /// This member is required.
        public var invoker: ResiliencehubClientTypes.AssessmentInvoker?
        /// Error or warning message from the assessment execution
        public var message: Swift.String?
        /// The resiliency policy.
        public var policy: ResiliencehubClientTypes.ResiliencyPolicy?
        /// The current resiliency score for the application.
        public var resiliencyScore: ResiliencehubClientTypes.ResiliencyScore?
        /// The starting time for the action.
        public var startTime: ClientRuntime.Date?
        /// The tags assigned to the resource. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key/value pair.
        public var tags: [Swift.String:Swift.String]?

        public init (
            appArn: Swift.String? = nil,
            appVersion: Swift.String? = nil,
            assessmentArn: Swift.String? = nil,
            assessmentName: Swift.String? = nil,
            assessmentStatus: ResiliencehubClientTypes.AssessmentStatus? = nil,
            compliance: [Swift.String:ResiliencehubClientTypes.DisruptionCompliance]? = nil,
            complianceStatus: ResiliencehubClientTypes.ComplianceStatus? = nil,
            cost: ResiliencehubClientTypes.Cost? = nil,
            endTime: ClientRuntime.Date? = nil,
            invoker: ResiliencehubClientTypes.AssessmentInvoker? = nil,
            message: Swift.String? = nil,
            policy: ResiliencehubClientTypes.ResiliencyPolicy? = nil,
            resiliencyScore: ResiliencehubClientTypes.ResiliencyScore? = nil,
            startTime: ClientRuntime.Date? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.appArn = appArn
            self.appVersion = appVersion
            self.assessmentArn = assessmentArn
            self.assessmentName = assessmentName
            self.assessmentStatus = assessmentStatus
            self.compliance = compliance
            self.complianceStatus = complianceStatus
            self.cost = cost
            self.endTime = endTime
            self.invoker = invoker
            self.message = message
            self.policy = policy
            self.resiliencyScore = resiliencyScore
            self.startTime = startTime
            self.tags = tags
        }
    }

}

extension ResiliencehubClientTypes.AppAssessmentSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case assessmentArn
        case assessmentName
        case assessmentStatus
        case complianceStatus
        case cost
        case endTime
        case invoker
        case message
        case resiliencyScore
        case startTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let appVersion = appVersion {
            try encodeContainer.encode(appVersion, forKey: .appVersion)
        }
        if let assessmentArn = assessmentArn {
            try encodeContainer.encode(assessmentArn, forKey: .assessmentArn)
        }
        if let assessmentName = assessmentName {
            try encodeContainer.encode(assessmentName, forKey: .assessmentName)
        }
        if let assessmentStatus = assessmentStatus {
            try encodeContainer.encode(assessmentStatus.rawValue, forKey: .assessmentStatus)
        }
        if let complianceStatus = complianceStatus {
            try encodeContainer.encode(complianceStatus.rawValue, forKey: .complianceStatus)
        }
        if let cost = cost {
            try encodeContainer.encode(cost, forKey: .cost)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let invoker = invoker {
            try encodeContainer.encode(invoker.rawValue, forKey: .invoker)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if resiliencyScore != 0.0 {
            try encodeContainer.encode(resiliencyScore, forKey: .resiliencyScore)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let assessmentStatusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.AssessmentStatus.self, forKey: .assessmentStatus)
        assessmentStatus = assessmentStatusDecoded
        let invokerDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.AssessmentInvoker.self, forKey: .invoker)
        invoker = invokerDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let assessmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentName)
        assessmentName = assessmentNameDecoded
        let assessmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentArn)
        assessmentArn = assessmentArnDecoded
        let complianceStatusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ComplianceStatus.self, forKey: .complianceStatus)
        complianceStatus = complianceStatusDecoded
        let costDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.Cost.self, forKey: .cost)
        cost = costDecoded
        let resiliencyScoreDecoded = try containerValues.decode(Swift.Double.self, forKey: .resiliencyScore)
        resiliencyScore = resiliencyScoreDecoded
    }
}

extension ResiliencehubClientTypes.AppAssessmentSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AppAssessmentSummary(appArn: \(Swift.String(describing: appArn)), appVersion: \(Swift.String(describing: appVersion)), assessmentArn: \(Swift.String(describing: assessmentArn)), assessmentName: \(Swift.String(describing: assessmentName)), assessmentStatus: \(Swift.String(describing: assessmentStatus)), complianceStatus: \(Swift.String(describing: complianceStatus)), cost: \(Swift.String(describing: cost)), endTime: \(Swift.String(describing: endTime)), invoker: \(Swift.String(describing: invoker)), message: \(Swift.String(describing: message)), resiliencyScore: \(Swift.String(describing: resiliencyScore)), startTime: \(Swift.String(describing: startTime)))"}
}

extension ResiliencehubClientTypes {
    /// Defines an application assessment summary.
    public struct AppAssessmentSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
        public var appArn: Swift.String?
        /// The version of the application.
        public var appVersion: Swift.String?
        /// The Amazon Resource Name (ARN) of the assessment. The format for this ARN is: arn:partition:dcps:region:account:app-assessment/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
        /// This member is required.
        public var assessmentArn: Swift.String?
        /// The name of the assessment.
        public var assessmentName: Swift.String?
        /// The current status of the assessment for the resiliency policy.
        /// This member is required.
        public var assessmentStatus: ResiliencehubClientTypes.AssessmentStatus?
        /// The current status of compliance for the resiliency policy.
        public var complianceStatus: ResiliencehubClientTypes.ComplianceStatus?
        /// The cost for the application.
        public var cost: ResiliencehubClientTypes.Cost?
        /// The end time for the action.
        public var endTime: ClientRuntime.Date?
        /// The entity that invoked the assessment.
        public var invoker: ResiliencehubClientTypes.AssessmentInvoker?
        /// The message from the assessment run.
        public var message: Swift.String?
        /// The current resiliency score for the application.
        public var resiliencyScore: Swift.Double
        /// The starting time for the action.
        public var startTime: ClientRuntime.Date?

        public init (
            appArn: Swift.String? = nil,
            appVersion: Swift.String? = nil,
            assessmentArn: Swift.String? = nil,
            assessmentName: Swift.String? = nil,
            assessmentStatus: ResiliencehubClientTypes.AssessmentStatus? = nil,
            complianceStatus: ResiliencehubClientTypes.ComplianceStatus? = nil,
            cost: ResiliencehubClientTypes.Cost? = nil,
            endTime: ClientRuntime.Date? = nil,
            invoker: ResiliencehubClientTypes.AssessmentInvoker? = nil,
            message: Swift.String? = nil,
            resiliencyScore: Swift.Double = 0.0,
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.appArn = appArn
            self.appVersion = appVersion
            self.assessmentArn = assessmentArn
            self.assessmentName = assessmentName
            self.assessmentStatus = assessmentStatus
            self.complianceStatus = complianceStatus
            self.cost = cost
            self.endTime = endTime
            self.invoker = invoker
            self.message = message
            self.resiliencyScore = resiliencyScore
            self.startTime = startTime
        }
    }

}

extension ResiliencehubClientTypes {
    public enum AppComplianceStatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case changesDetected
        case notAssessed
        case policyBreached
        case policyMet
        case sdkUnknown(Swift.String)

        public static var allCases: [AppComplianceStatusType] {
            return [
                .changesDetected,
                .notAssessed,
                .policyBreached,
                .policyMet,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .changesDetected: return "ChangesDetected"
            case .notAssessed: return "NotAssessed"
            case .policyBreached: return "PolicyBreached"
            case .policyMet: return "PolicyMet"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AppComplianceStatusType(rawValue: rawValue) ?? AppComplianceStatusType.sdkUnknown(rawValue)
        }
    }
}

extension ResiliencehubClientTypes.AppComponent: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension ResiliencehubClientTypes.AppComponent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AppComponent(name: \(Swift.String(describing: name)), type: \(Swift.String(describing: type)))"}
}

extension ResiliencehubClientTypes {
    /// Defines an application component.
    public struct AppComponent: Swift.Equatable {
        /// The name of the application component.
        /// This member is required.
        public var name: Swift.String?
        /// The type of application component.
        /// This member is required.
        public var type: Swift.String?

        public init (
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.name = name
            self.type = type
        }
    }

}

extension ResiliencehubClientTypes.AppComponentCompliance: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appComponentName
        case compliance
        case cost
        case message
        case resiliencyScore
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appComponentName = appComponentName {
            try encodeContainer.encode(appComponentName, forKey: .appComponentName)
        }
        if let compliance = compliance {
            var complianceContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .compliance)
            for (dictKey0, assessmentcompliance0) in compliance {
                try complianceContainer.encode(assessmentcompliance0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let cost = cost {
            try encodeContainer.encode(cost, forKey: .cost)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let resiliencyScore = resiliencyScore {
            try encodeContainer.encode(resiliencyScore, forKey: .resiliencyScore)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let costDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.Cost.self, forKey: .cost)
        cost = costDecoded
        let appComponentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appComponentName)
        appComponentName = appComponentNameDecoded
        let complianceContainer = try containerValues.decodeIfPresent([Swift.String: ResiliencehubClientTypes.DisruptionCompliance?].self, forKey: .compliance)
        var complianceDecoded0: [Swift.String:ResiliencehubClientTypes.DisruptionCompliance]? = nil
        if let complianceContainer = complianceContainer {
            complianceDecoded0 = [Swift.String:ResiliencehubClientTypes.DisruptionCompliance]()
            for (key0, disruptioncompliance0) in complianceContainer {
                if let disruptioncompliance0 = disruptioncompliance0 {
                    complianceDecoded0?[key0] = disruptioncompliance0
                }
            }
        }
        compliance = complianceDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ComplianceStatus.self, forKey: .status)
        status = statusDecoded
        let resiliencyScoreDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ResiliencyScore.self, forKey: .resiliencyScore)
        resiliencyScore = resiliencyScoreDecoded
    }
}

extension ResiliencehubClientTypes.AppComponentCompliance: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AppComponentCompliance(appComponentName: \(Swift.String(describing: appComponentName)), compliance: \(Swift.String(describing: compliance)), cost: \(Swift.String(describing: cost)), message: \(Swift.String(describing: message)), resiliencyScore: \(Swift.String(describing: resiliencyScore)), status: \(Swift.String(describing: status)))"}
}

extension ResiliencehubClientTypes {
    /// Defines the compliance of an application component against the resiliency policy.
    public struct AppComponentCompliance: Swift.Equatable {
        /// The name of the application component.
        public var appComponentName: Swift.String?
        /// The compliance of the application component against the resiliency policy.
        public var compliance: [Swift.String:ResiliencehubClientTypes.DisruptionCompliance]?
        /// The cost for the application.
        public var cost: ResiliencehubClientTypes.Cost?
        /// The compliance message.
        public var message: Swift.String?
        /// The current resiliency score for the application.
        public var resiliencyScore: ResiliencehubClientTypes.ResiliencyScore?
        /// The status of the action.
        public var status: ResiliencehubClientTypes.ComplianceStatus?

        public init (
            appComponentName: Swift.String? = nil,
            compliance: [Swift.String:ResiliencehubClientTypes.DisruptionCompliance]? = nil,
            cost: ResiliencehubClientTypes.Cost? = nil,
            message: Swift.String? = nil,
            resiliencyScore: ResiliencehubClientTypes.ResiliencyScore? = nil,
            status: ResiliencehubClientTypes.ComplianceStatus? = nil
        )
        {
            self.appComponentName = appComponentName
            self.compliance = compliance
            self.cost = cost
            self.message = message
            self.resiliencyScore = resiliencyScore
            self.status = status
        }
    }

}

extension ResiliencehubClientTypes {
    public enum AppStatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [AppStatusType] {
            return [
                .active,
                .deleting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .deleting: return "Deleting"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AppStatusType(rawValue: rawValue) ?? AppStatusType.sdkUnknown(rawValue)
        }
    }
}

extension ResiliencehubClientTypes.AppSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case complianceStatus
        case creationTime
        case description
        case name
        case resiliencyScore
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let complianceStatus = complianceStatus {
            try encodeContainer.encode(complianceStatus.rawValue, forKey: .complianceStatus)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if resiliencyScore != 0.0 {
            try encodeContainer.encode(resiliencyScore, forKey: .resiliencyScore)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let complianceStatusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.AppComplianceStatusType.self, forKey: .complianceStatus)
        complianceStatus = complianceStatusDecoded
        let resiliencyScoreDecoded = try containerValues.decode(Swift.Double.self, forKey: .resiliencyScore)
        resiliencyScore = resiliencyScoreDecoded
    }
}

extension ResiliencehubClientTypes.AppSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AppSummary(appArn: \(Swift.String(describing: appArn)), complianceStatus: \(Swift.String(describing: complianceStatus)), creationTime: \(Swift.String(describing: creationTime)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), resiliencyScore: \(Swift.String(describing: resiliencyScore)))"}
}

extension ResiliencehubClientTypes {
    /// Defines an application summary.
    public struct AppSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
        /// This member is required.
        public var appArn: Swift.String?
        /// The current status of compliance for the resiliency policy.
        public var complianceStatus: ResiliencehubClientTypes.AppComplianceStatusType?
        /// The timestamp for when the app was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The optional description for an app.
        public var description: Swift.String?
        /// The name of the application.
        /// This member is required.
        public var name: Swift.String?
        /// The current resiliency score for the application.
        public var resiliencyScore: Swift.Double

        public init (
            appArn: Swift.String? = nil,
            complianceStatus: ResiliencehubClientTypes.AppComplianceStatusType? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            resiliencyScore: Swift.Double = 0.0
        )
        {
            self.appArn = appArn
            self.complianceStatus = complianceStatus
            self.creationTime = creationTime
            self.description = description
            self.name = name
            self.resiliencyScore = resiliencyScore
        }
    }

}

extension ResiliencehubClientTypes.AppVersionSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appVersion = appVersion {
            try encodeContainer.encode(appVersion, forKey: .appVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
    }
}

extension ResiliencehubClientTypes.AppVersionSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AppVersionSummary(appVersion: \(Swift.String(describing: appVersion)))"}
}

extension ResiliencehubClientTypes {
    /// The version of the application.
    public struct AppVersionSummary: Swift.Equatable {
        /// The version of the application.
        /// This member is required.
        public var appVersion: Swift.String?

        public init (
            appVersion: Swift.String? = nil
        )
        {
            self.appVersion = appVersion
        }
    }

}

extension ResiliencehubClientTypes {
    public enum AssessmentInvoker: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case system
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [AssessmentInvoker] {
            return [
                .system,
                .user,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .system: return "System"
            case .user: return "User"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssessmentInvoker(rawValue: rawValue) ?? AssessmentInvoker.sdkUnknown(rawValue)
        }
    }
}

extension ResiliencehubClientTypes {
    public enum AssessmentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inprogress
        case pending
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [AssessmentStatus] {
            return [
                .failed,
                .inprogress,
                .pending,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .inprogress: return "InProgress"
            case .pending: return "Pending"
            case .success: return "Success"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssessmentStatus(rawValue: rawValue) ?? AssessmentStatus.sdkUnknown(rawValue)
        }
    }
}

extension ResiliencehubClientTypes {
    public enum ComplianceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case policyBreached
        case policyMet
        case sdkUnknown(Swift.String)

        public static var allCases: [ComplianceStatus] {
            return [
                .policyBreached,
                .policyMet,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .policyBreached: return "PolicyBreached"
            case .policyMet: return "PolicyMet"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComplianceStatus(rawValue: rawValue) ?? ComplianceStatus.sdkUnknown(rawValue)
        }
    }
}

extension ResiliencehubClientTypes.ComponentRecommendation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appComponentName
        case configRecommendations
        case recommendationStatus
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appComponentName = appComponentName {
            try encodeContainer.encode(appComponentName, forKey: .appComponentName)
        }
        if let configRecommendations = configRecommendations {
            var configRecommendationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configRecommendations)
            for configrecommendationlist0 in configRecommendations {
                try configRecommendationsContainer.encode(configrecommendationlist0)
            }
        }
        if let recommendationStatus = recommendationStatus {
            try encodeContainer.encode(recommendationStatus.rawValue, forKey: .recommendationStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appComponentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appComponentName)
        appComponentName = appComponentNameDecoded
        let recommendationStatusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.RecommendationComplianceStatus.self, forKey: .recommendationStatus)
        recommendationStatus = recommendationStatusDecoded
        let configRecommendationsContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.ConfigRecommendation?].self, forKey: .configRecommendations)
        var configRecommendationsDecoded0:[ResiliencehubClientTypes.ConfigRecommendation]? = nil
        if let configRecommendationsContainer = configRecommendationsContainer {
            configRecommendationsDecoded0 = [ResiliencehubClientTypes.ConfigRecommendation]()
            for structure0 in configRecommendationsContainer {
                if let structure0 = structure0 {
                    configRecommendationsDecoded0?.append(structure0)
                }
            }
        }
        configRecommendations = configRecommendationsDecoded0
    }
}

extension ResiliencehubClientTypes.ComponentRecommendation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ComponentRecommendation(appComponentName: \(Swift.String(describing: appComponentName)), configRecommendations: \(Swift.String(describing: configRecommendations)), recommendationStatus: \(Swift.String(describing: recommendationStatus)))"}
}

extension ResiliencehubClientTypes {
    /// Defines recommendations for a Resilience Hub application component, returned as an object. This object contains component names, configuration recommendations, and recommendation statuses.
    public struct ComponentRecommendation: Swift.Equatable {
        /// The name of the application component.
        /// This member is required.
        public var appComponentName: Swift.String?
        /// The list of recommendations.
        /// This member is required.
        public var configRecommendations: [ResiliencehubClientTypes.ConfigRecommendation]?
        /// The recommendation status.
        /// This member is required.
        public var recommendationStatus: ResiliencehubClientTypes.RecommendationComplianceStatus?

        public init (
            appComponentName: Swift.String? = nil,
            configRecommendations: [ResiliencehubClientTypes.ConfigRecommendation]? = nil,
            recommendationStatus: ResiliencehubClientTypes.RecommendationComplianceStatus? = nil
        )
        {
            self.appComponentName = appComponentName
            self.configRecommendations = configRecommendations
            self.recommendationStatus = recommendationStatus
        }
    }

}

extension ResiliencehubClientTypes.ConfigRecommendation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appComponentName
        case compliance
        case cost
        case description
        case haArchitecture
        case name
        case optimizationType
        case recommendationCompliance
        case referenceId
        case suggestedChanges
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appComponentName = appComponentName {
            try encodeContainer.encode(appComponentName, forKey: .appComponentName)
        }
        if let compliance = compliance {
            var complianceContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .compliance)
            for (dictKey0, assessmentcompliance0) in compliance {
                try complianceContainer.encode(assessmentcompliance0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let cost = cost {
            try encodeContainer.encode(cost, forKey: .cost)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let haArchitecture = haArchitecture {
            try encodeContainer.encode(haArchitecture.rawValue, forKey: .haArchitecture)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let optimizationType = optimizationType {
            try encodeContainer.encode(optimizationType.rawValue, forKey: .optimizationType)
        }
        if let recommendationCompliance = recommendationCompliance {
            var recommendationComplianceContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .recommendationCompliance)
            for (dictKey0, recommendationcompliance0) in recommendationCompliance {
                try recommendationComplianceContainer.encode(recommendationcompliance0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let referenceId = referenceId {
            try encodeContainer.encode(referenceId, forKey: .referenceId)
        }
        if let suggestedChanges = suggestedChanges {
            var suggestedChangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .suggestedChanges)
            for suggestedchangeslist0 in suggestedChanges {
                try suggestedChangesContainer.encode(suggestedchangeslist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let costDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.Cost.self, forKey: .cost)
        cost = costDecoded
        let appComponentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appComponentName)
        appComponentName = appComponentNameDecoded
        let complianceContainer = try containerValues.decodeIfPresent([Swift.String: ResiliencehubClientTypes.DisruptionCompliance?].self, forKey: .compliance)
        var complianceDecoded0: [Swift.String:ResiliencehubClientTypes.DisruptionCompliance]? = nil
        if let complianceContainer = complianceContainer {
            complianceDecoded0 = [Swift.String:ResiliencehubClientTypes.DisruptionCompliance]()
            for (key0, disruptioncompliance0) in complianceContainer {
                if let disruptioncompliance0 = disruptioncompliance0 {
                    complianceDecoded0?[key0] = disruptioncompliance0
                }
            }
        }
        compliance = complianceDecoded0
        let recommendationComplianceContainer = try containerValues.decodeIfPresent([Swift.String: ResiliencehubClientTypes.RecommendationDisruptionCompliance?].self, forKey: .recommendationCompliance)
        var recommendationComplianceDecoded0: [Swift.String:ResiliencehubClientTypes.RecommendationDisruptionCompliance]? = nil
        if let recommendationComplianceContainer = recommendationComplianceContainer {
            recommendationComplianceDecoded0 = [Swift.String:ResiliencehubClientTypes.RecommendationDisruptionCompliance]()
            for (key0, recommendationdisruptioncompliance0) in recommendationComplianceContainer {
                if let recommendationdisruptioncompliance0 = recommendationdisruptioncompliance0 {
                    recommendationComplianceDecoded0?[key0] = recommendationdisruptioncompliance0
                }
            }
        }
        recommendationCompliance = recommendationComplianceDecoded0
        let optimizationTypeDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ConfigRecommendationOptimizationType.self, forKey: .optimizationType)
        optimizationType = optimizationTypeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let suggestedChangesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .suggestedChanges)
        var suggestedChangesDecoded0:[Swift.String]? = nil
        if let suggestedChangesContainer = suggestedChangesContainer {
            suggestedChangesDecoded0 = [Swift.String]()
            for string0 in suggestedChangesContainer {
                if let string0 = string0 {
                    suggestedChangesDecoded0?.append(string0)
                }
            }
        }
        suggestedChanges = suggestedChangesDecoded0
        let haArchitectureDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.HaArchitecture.self, forKey: .haArchitecture)
        haArchitecture = haArchitectureDecoded
        let referenceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .referenceId)
        referenceId = referenceIdDecoded
    }
}

extension ResiliencehubClientTypes.ConfigRecommendation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConfigRecommendation(appComponentName: \(Swift.String(describing: appComponentName)), compliance: \(Swift.String(describing: compliance)), cost: \(Swift.String(describing: cost)), description: \(Swift.String(describing: description)), haArchitecture: \(Swift.String(describing: haArchitecture)), name: \(Swift.String(describing: name)), optimizationType: \(Swift.String(describing: optimizationType)), recommendationCompliance: \(Swift.String(describing: recommendationCompliance)), referenceId: \(Swift.String(describing: referenceId)), suggestedChanges: \(Swift.String(describing: suggestedChanges)))"}
}

extension ResiliencehubClientTypes {
    /// Defines a configuration recommendation.
    public struct ConfigRecommendation: Swift.Equatable {
        /// The application component name.
        public var appComponentName: Swift.String?
        /// The current compliance against the resiliency policy before applying the configuration change.
        public var compliance: [Swift.String:ResiliencehubClientTypes.DisruptionCompliance]?
        /// The cost for the application.
        public var cost: ResiliencehubClientTypes.Cost?
        /// The optional description for an app.
        public var description: Swift.String?
        /// The architecture type.
        public var haArchitecture: ResiliencehubClientTypes.HaArchitecture?
        /// The name of the recommendation configuration.
        /// This member is required.
        public var name: Swift.String?
        /// The type of optimization.
        /// This member is required.
        public var optimizationType: ResiliencehubClientTypes.ConfigRecommendationOptimizationType?
        /// The expected compliance against the resiliency policy after applying the configuration change.
        public var recommendationCompliance: [Swift.String:ResiliencehubClientTypes.RecommendationDisruptionCompliance]?
        /// The reference identifier for the recommendation configuration.
        /// This member is required.
        public var referenceId: Swift.String?
        /// List of the suggested configuration changes.
        public var suggestedChanges: [Swift.String]?

        public init (
            appComponentName: Swift.String? = nil,
            compliance: [Swift.String:ResiliencehubClientTypes.DisruptionCompliance]? = nil,
            cost: ResiliencehubClientTypes.Cost? = nil,
            description: Swift.String? = nil,
            haArchitecture: ResiliencehubClientTypes.HaArchitecture? = nil,
            name: Swift.String? = nil,
            optimizationType: ResiliencehubClientTypes.ConfigRecommendationOptimizationType? = nil,
            recommendationCompliance: [Swift.String:ResiliencehubClientTypes.RecommendationDisruptionCompliance]? = nil,
            referenceId: Swift.String? = nil,
            suggestedChanges: [Swift.String]? = nil
        )
        {
            self.appComponentName = appComponentName
            self.compliance = compliance
            self.cost = cost
            self.description = description
            self.haArchitecture = haArchitecture
            self.name = name
            self.optimizationType = optimizationType
            self.recommendationCompliance = recommendationCompliance
            self.referenceId = referenceId
            self.suggestedChanges = suggestedChanges
        }
    }

}

extension ResiliencehubClientTypes {
    public enum ConfigRecommendationOptimizationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bestAttainable
        case bestAzRecovery
        case leastChange
        case leastCost
        case leastErrors
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfigRecommendationOptimizationType] {
            return [
                .bestAttainable,
                .bestAzRecovery,
                .leastChange,
                .leastCost,
                .leastErrors,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bestAttainable: return "BestAttainable"
            case .bestAzRecovery: return "BestAZRecovery"
            case .leastChange: return "LeastChange"
            case .leastCost: return "LeastCost"
            case .leastErrors: return "LeastErrors"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConfigRecommendationOptimizationType(rawValue: rawValue) ?? ConfigRecommendationOptimizationType.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictException(message: \(Swift.String(describing: message)), resourceId: \(Swift.String(describing: resourceId)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Occurs when a conflict with a previous successful write is detected. This generally occurs when the previous write did not have time to propagate to the host serving the current request. A retry (with appropriate backoff logic) is the recommended response to this exception.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The identifier of the resource that the exception applies to.
    public var resourceId: Swift.String?
    /// The type of the resource that the exception applies to.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceId: Swift.String?
    public let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ResiliencehubClientTypes.Cost: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amount
        case currency
        case frequency
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if amount != 0.0 {
            try encodeContainer.encode(amount, forKey: .amount)
        }
        if let currency = currency {
            try encodeContainer.encode(currency, forKey: .currency)
        }
        if let frequency = frequency {
            try encodeContainer.encode(frequency.rawValue, forKey: .frequency)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amountDecoded = try containerValues.decode(Swift.Double.self, forKey: .amount)
        amount = amountDecoded
        let currencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currency)
        currency = currencyDecoded
        let frequencyDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.CostFrequency.self, forKey: .frequency)
        frequency = frequencyDecoded
    }
}

extension ResiliencehubClientTypes.Cost: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Cost(amount: \(Swift.String(describing: amount)), currency: \(Swift.String(describing: currency)), frequency: \(Swift.String(describing: frequency)))"}
}

extension ResiliencehubClientTypes {
    /// Defines a cost object.
    public struct Cost: Swift.Equatable {
        /// The cost amount.
        /// This member is required.
        public var amount: Swift.Double
        /// The cost currency, for example USD.
        /// This member is required.
        public var currency: Swift.String?
        /// The cost frequency.
        /// This member is required.
        public var frequency: ResiliencehubClientTypes.CostFrequency?

        public init (
            amount: Swift.Double = 0.0,
            currency: Swift.String? = nil,
            frequency: ResiliencehubClientTypes.CostFrequency? = nil
        )
        {
            self.amount = amount
            self.currency = currency
            self.frequency = frequency
        }
    }

}

extension ResiliencehubClientTypes {
    public enum CostFrequency: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case daily
        case hourly
        case monthly
        case yearly
        case sdkUnknown(Swift.String)

        public static var allCases: [CostFrequency] {
            return [
                .daily,
                .hourly,
                .monthly,
                .yearly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .daily: return "Daily"
            case .hourly: return "Hourly"
            case .monthly: return "Monthly"
            case .yearly: return "Yearly"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CostFrequency(rawValue: rawValue) ?? CostFrequency.sdkUnknown(rawValue)
        }
    }
}

public struct CreateAppInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAppInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAppInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAppInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAppOutputError>
}

extension CreateAppInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAppInput(clientToken: \(Swift.String(describing: clientToken)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), policyArn: \(Swift.String(describing: policyArn)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateAppInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case policyArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let policyArn = policyArn {
            try encodeContainer.encode(policyArn, forKey: .policyArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateAppInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAppInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAppInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAppInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAppOutputError>
}

public struct CreateAppInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAppInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAppInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAppInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAppOutputError>
}

public struct CreateAppInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAppInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateAppInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateAppInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAppOutputError>
}

public struct CreateAppInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAppInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateAppInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/create-app"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateAppInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAppOutputError>
}

public struct CreateAppInput: Swift.Equatable {
    /// Used for an idempotency token. A client token is a unique, case-sensitive string of up to 64 ASCII characters. You should not reuse the same client token for other API requests.
    public var clientToken: Swift.String?
    /// The optional description for an app.
    public var description: Swift.String?
    /// The name for the application.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the resiliency policy. The format for this ARN is: arn:partition:dcps:region:account:resiliency-policy/policy-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    public var policyArn: Swift.String?
    /// The tags assigned to the resource. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key/value pair.
    public var tags: [Swift.String:Swift.String]?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        policyArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.policyArn = policyArn
        self.tags = tags
    }
}

struct CreateAppInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let description: Swift.String?
    public let policyArn: Swift.String?
    public let tags: [Swift.String:Swift.String]?
    public let clientToken: Swift.String?
}

extension CreateAppInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case policyArn
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateAppOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAppOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAppOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAppOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAppOutputResponse(app: \(Swift.String(describing: app)))"}
}

extension CreateAppOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateAppOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.app = output.app
        } else {
            self.app = nil
        }
    }
}

public struct CreateAppOutputResponse: Swift.Equatable {
    /// The created application returned as an object with details including compliance status, creation time, description, resiliency score, and more.
    /// This member is required.
    public var app: ResiliencehubClientTypes.App?

    public init (
        app: ResiliencehubClientTypes.App? = nil
    )
    {
        self.app = app
    }
}

struct CreateAppOutputResponseBody: Swift.Equatable {
    public let app: ResiliencehubClientTypes.App?
}

extension CreateAppOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case app
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.App.self, forKey: .app)
        app = appDecoded
    }
}

public struct CreateRecommendationTemplateInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRecommendationTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRecommendationTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRecommendationTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRecommendationTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRecommendationTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRecommendationTemplateOutputError>
}

extension CreateRecommendationTemplateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateRecommendationTemplateInput(assessmentArn: \(Swift.String(describing: assessmentArn)), bucketName: \(Swift.String(describing: bucketName)), clientToken: \(Swift.String(describing: clientToken)), format: \(Swift.String(describing: format)), name: \(Swift.String(describing: name)), recommendationIds: \(Swift.String(describing: recommendationIds)), recommendationTypes: \(Swift.String(describing: recommendationTypes)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateRecommendationTemplateInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentArn
        case bucketName
        case clientToken
        case format
        case name
        case recommendationIds
        case recommendationTypes
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentArn = assessmentArn {
            try encodeContainer.encode(assessmentArn, forKey: .assessmentArn)
        }
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let recommendationIds = recommendationIds {
            var recommendationIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recommendationIds)
            for recommendationidlist0 in recommendationIds {
                try recommendationIdsContainer.encode(recommendationidlist0)
            }
        }
        if let recommendationTypes = recommendationTypes {
            var recommendationTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recommendationTypes)
            for renderrecommendationtypelist0 in recommendationTypes {
                try recommendationTypesContainer.encode(renderrecommendationtypelist0.rawValue)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateRecommendationTemplateInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRecommendationTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRecommendationTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRecommendationTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRecommendationTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRecommendationTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRecommendationTemplateOutputError>
}

public struct CreateRecommendationTemplateInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRecommendationTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRecommendationTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRecommendationTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRecommendationTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRecommendationTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRecommendationTemplateOutputError>
}

public struct CreateRecommendationTemplateInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRecommendationTemplateInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateRecommendationTemplateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRecommendationTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateRecommendationTemplateInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRecommendationTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRecommendationTemplateOutputError>
}

public struct CreateRecommendationTemplateInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRecommendationTemplateInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateRecommendationTemplateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRecommendationTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/create-recommendation-template"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateRecommendationTemplateInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRecommendationTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRecommendationTemplateOutputError>
}

public struct CreateRecommendationTemplateInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the assessment. The format for this ARN is: arn:partition:dcps:region:account:app-assessment/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var assessmentArn: Swift.String?
    /// The name of the Amazon S3 bucket that will contain the recommendation template.
    public var bucketName: Swift.String?
    /// Used for an idempotency token. A client token is a unique, case-sensitive string of up to 64 ASCII characters. You should not reuse the same client token for other API requests.
    public var clientToken: Swift.String?
    /// The format for the recommendation template. CfnJson The template is CloudFormation JSON. CfnYaml The template is CloudFormation YAML.
    public var format: ResiliencehubClientTypes.TemplateFormat?
    /// The name for the recommendation template.
    /// This member is required.
    public var name: Swift.String?
    /// Identifiers for the recommendations used to create a recommendation template.
    public var recommendationIds: [Swift.String]?
    /// An array of strings that specify the recommendation template type or types. Alarm The template is an [AlarmRecommendation] template. Sop The template is a [SopRecommendation] template. Test The template is a [TestRecommendation] template.
    public var recommendationTypes: [ResiliencehubClientTypes.RenderRecommendationType]?
    /// The tags assigned to the resource. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key/value pair.
    public var tags: [Swift.String:Swift.String]?

    public init (
        assessmentArn: Swift.String? = nil,
        bucketName: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        format: ResiliencehubClientTypes.TemplateFormat? = nil,
        name: Swift.String? = nil,
        recommendationIds: [Swift.String]? = nil,
        recommendationTypes: [ResiliencehubClientTypes.RenderRecommendationType]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.assessmentArn = assessmentArn
        self.bucketName = bucketName
        self.clientToken = clientToken
        self.format = format
        self.name = name
        self.recommendationIds = recommendationIds
        self.recommendationTypes = recommendationTypes
        self.tags = tags
    }
}

struct CreateRecommendationTemplateInputBody: Swift.Equatable {
    public let recommendationIds: [Swift.String]?
    public let format: ResiliencehubClientTypes.TemplateFormat?
    public let recommendationTypes: [ResiliencehubClientTypes.RenderRecommendationType]?
    public let assessmentArn: Swift.String?
    public let name: Swift.String?
    public let clientToken: Swift.String?
    public let tags: [Swift.String:Swift.String]?
    public let bucketName: Swift.String?
}

extension CreateRecommendationTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentArn
        case bucketName
        case clientToken
        case format
        case name
        case recommendationIds
        case recommendationTypes
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .recommendationIds)
        var recommendationIdsDecoded0:[Swift.String]? = nil
        if let recommendationIdsContainer = recommendationIdsContainer {
            recommendationIdsDecoded0 = [Swift.String]()
            for string0 in recommendationIdsContainer {
                if let string0 = string0 {
                    recommendationIdsDecoded0?.append(string0)
                }
            }
        }
        recommendationIds = recommendationIdsDecoded0
        let formatDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.TemplateFormat.self, forKey: .format)
        format = formatDecoded
        let recommendationTypesContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.RenderRecommendationType?].self, forKey: .recommendationTypes)
        var recommendationTypesDecoded0:[ResiliencehubClientTypes.RenderRecommendationType]? = nil
        if let recommendationTypesContainer = recommendationTypesContainer {
            recommendationTypesDecoded0 = [ResiliencehubClientTypes.RenderRecommendationType]()
            for string0 in recommendationTypesContainer {
                if let string0 = string0 {
                    recommendationTypesDecoded0?.append(string0)
                }
            }
        }
        recommendationTypes = recommendationTypesDecoded0
        let assessmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentArn)
        assessmentArn = assessmentArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
    }
}

extension CreateRecommendationTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRecommendationTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRecommendationTemplateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRecommendationTemplateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateRecommendationTemplateOutputResponse(recommendationTemplate: \(Swift.String(describing: recommendationTemplate)))"}
}

extension CreateRecommendationTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateRecommendationTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.recommendationTemplate = output.recommendationTemplate
        } else {
            self.recommendationTemplate = nil
        }
    }
}

public struct CreateRecommendationTemplateOutputResponse: Swift.Equatable {
    /// The newly created recommendation template, returned as an object. This object includes the template's name, format, status, tags, Amazon S3 bucket location, and more.
    public var recommendationTemplate: ResiliencehubClientTypes.RecommendationTemplate?

    public init (
        recommendationTemplate: ResiliencehubClientTypes.RecommendationTemplate? = nil
    )
    {
        self.recommendationTemplate = recommendationTemplate
    }
}

struct CreateRecommendationTemplateOutputResponseBody: Swift.Equatable {
    public let recommendationTemplate: ResiliencehubClientTypes.RecommendationTemplate?
}

extension CreateRecommendationTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommendationTemplate
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationTemplateDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.RecommendationTemplate.self, forKey: .recommendationTemplate)
        recommendationTemplate = recommendationTemplateDecoded
    }
}

public struct CreateResiliencyPolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateResiliencyPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateResiliencyPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateResiliencyPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateResiliencyPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateResiliencyPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateResiliencyPolicyOutputError>
}

extension CreateResiliencyPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateResiliencyPolicyInput(clientToken: \(Swift.String(describing: clientToken)), dataLocationConstraint: \(Swift.String(describing: dataLocationConstraint)), policy: \(Swift.String(describing: policy)), policyDescription: \(Swift.String(describing: policyDescription)), policyName: \(Swift.String(describing: policyName)), tags: \(Swift.String(describing: tags)), tier: \(Swift.String(describing: tier)))"}
}

extension CreateResiliencyPolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case dataLocationConstraint
        case policy
        case policyDescription
        case policyName
        case tags
        case tier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let dataLocationConstraint = dataLocationConstraint {
            try encodeContainer.encode(dataLocationConstraint.rawValue, forKey: .dataLocationConstraint)
        }
        if let policy = policy {
            var policyContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .policy)
            for (dictKey0, disruptionpolicy0) in policy {
                try policyContainer.encode(disruptionpolicy0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let policyDescription = policyDescription {
            try encodeContainer.encode(policyDescription, forKey: .policyDescription)
        }
        if let policyName = policyName {
            try encodeContainer.encode(policyName, forKey: .policyName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tier = tier {
            try encodeContainer.encode(tier.rawValue, forKey: .tier)
        }
    }
}

public struct CreateResiliencyPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateResiliencyPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateResiliencyPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateResiliencyPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateResiliencyPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateResiliencyPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateResiliencyPolicyOutputError>
}

public struct CreateResiliencyPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateResiliencyPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateResiliencyPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateResiliencyPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateResiliencyPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateResiliencyPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateResiliencyPolicyOutputError>
}

public struct CreateResiliencyPolicyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateResiliencyPolicyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateResiliencyPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateResiliencyPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateResiliencyPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateResiliencyPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateResiliencyPolicyOutputError>
}

public struct CreateResiliencyPolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateResiliencyPolicyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateResiliencyPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateResiliencyPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/create-resiliency-policy"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateResiliencyPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateResiliencyPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateResiliencyPolicyOutputError>
}

public struct CreateResiliencyPolicyInput: Swift.Equatable {
    /// Used for an idempotency token. A client token is a unique, case-sensitive string of up to 64 ASCII characters. You should not reuse the same client token for other API requests.
    public var clientToken: Swift.String?
    /// Specifies a high-level geographical location constraint for where your resilience policy data can be stored.
    public var dataLocationConstraint: ResiliencehubClientTypes.DataLocationConstraint?
    /// The type of resiliency policy to be created, including the recovery time objective (RTO) and recovery point objective (RPO) in seconds.
    /// This member is required.
    public var policy: [Swift.String:ResiliencehubClientTypes.FailurePolicy]?
    /// The description for the policy.
    public var policyDescription: Swift.String?
    /// The name of the policy
    /// This member is required.
    public var policyName: Swift.String?
    /// The tags assigned to the resource. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key/value pair.
    public var tags: [Swift.String:Swift.String]?
    /// The tier for this resiliency policy, ranging from the highest severity (MissionCritical) to lowest (NonCritical).
    /// This member is required.
    public var tier: ResiliencehubClientTypes.ResiliencyPolicyTier?

    public init (
        clientToken: Swift.String? = nil,
        dataLocationConstraint: ResiliencehubClientTypes.DataLocationConstraint? = nil,
        policy: [Swift.String:ResiliencehubClientTypes.FailurePolicy]? = nil,
        policyDescription: Swift.String? = nil,
        policyName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        tier: ResiliencehubClientTypes.ResiliencyPolicyTier? = nil
    )
    {
        self.clientToken = clientToken
        self.dataLocationConstraint = dataLocationConstraint
        self.policy = policy
        self.policyDescription = policyDescription
        self.policyName = policyName
        self.tags = tags
        self.tier = tier
    }
}

struct CreateResiliencyPolicyInputBody: Swift.Equatable {
    public let policyName: Swift.String?
    public let policyDescription: Swift.String?
    public let dataLocationConstraint: ResiliencehubClientTypes.DataLocationConstraint?
    public let tier: ResiliencehubClientTypes.ResiliencyPolicyTier?
    public let policy: [Swift.String:ResiliencehubClientTypes.FailurePolicy]?
    public let clientToken: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateResiliencyPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case dataLocationConstraint
        case policy
        case policyDescription
        case policyName
        case tags
        case tier
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyDescription)
        policyDescription = policyDescriptionDecoded
        let dataLocationConstraintDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.DataLocationConstraint.self, forKey: .dataLocationConstraint)
        dataLocationConstraint = dataLocationConstraintDecoded
        let tierDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ResiliencyPolicyTier.self, forKey: .tier)
        tier = tierDecoded
        let policyContainer = try containerValues.decodeIfPresent([Swift.String: ResiliencehubClientTypes.FailurePolicy?].self, forKey: .policy)
        var policyDecoded0: [Swift.String:ResiliencehubClientTypes.FailurePolicy]? = nil
        if let policyContainer = policyContainer {
            policyDecoded0 = [Swift.String:ResiliencehubClientTypes.FailurePolicy]()
            for (key0, failurepolicy0) in policyContainer {
                if let failurepolicy0 = failurepolicy0 {
                    policyDecoded0?[key0] = failurepolicy0
                }
            }
        }
        policy = policyDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateResiliencyPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateResiliencyPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateResiliencyPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateResiliencyPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateResiliencyPolicyOutputResponse(policy: \(Swift.String(describing: policy)))"}
}

extension CreateResiliencyPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateResiliencyPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct CreateResiliencyPolicyOutputResponse: Swift.Equatable {
    /// The type of resiliency policy that was created, including the recovery time objective (RTO) and recovery point objective (RPO) in seconds.
    /// This member is required.
    public var policy: ResiliencehubClientTypes.ResiliencyPolicy?

    public init (
        policy: ResiliencehubClientTypes.ResiliencyPolicy? = nil
    )
    {
        self.policy = policy
    }
}

struct CreateResiliencyPolicyOutputResponseBody: Swift.Equatable {
    public let policy: ResiliencehubClientTypes.ResiliencyPolicy?
}

extension CreateResiliencyPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ResiliencyPolicy.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension ResiliencehubClientTypes {
    public enum DataLocationConstraint: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case anyLocation
        case sameContinent
        case sameCountry
        case sdkUnknown(Swift.String)

        public static var allCases: [DataLocationConstraint] {
            return [
                .anyLocation,
                .sameContinent,
                .sameCountry,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .anyLocation: return "AnyLocation"
            case .sameContinent: return "SameContinent"
            case .sameCountry: return "SameCountry"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataLocationConstraint(rawValue: rawValue) ?? DataLocationConstraint.sdkUnknown(rawValue)
        }
    }
}

public struct DeleteAppAssessmentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAppAssessmentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAppAssessmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAppAssessmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAppAssessmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAppAssessmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAppAssessmentOutputError>
}

extension DeleteAppAssessmentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAppAssessmentInput(assessmentArn: \(Swift.String(describing: assessmentArn)), clientToken: \(Swift.String(describing: clientToken)))"}
}

extension DeleteAppAssessmentInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentArn
        case clientToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentArn = assessmentArn {
            try encodeContainer.encode(assessmentArn, forKey: .assessmentArn)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

public struct DeleteAppAssessmentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAppAssessmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAppAssessmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAppAssessmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAppAssessmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAppAssessmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAppAssessmentOutputError>
}

public struct DeleteAppAssessmentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAppAssessmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAppAssessmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAppAssessmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAppAssessmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAppAssessmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAppAssessmentOutputError>
}

public struct DeleteAppAssessmentInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAppAssessmentInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteAppAssessmentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAppAssessmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteAppAssessmentInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAppAssessmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAppAssessmentOutputError>
}

public struct DeleteAppAssessmentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAppAssessmentInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteAppAssessmentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAppAssessmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/delete-app-assessment"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteAppAssessmentInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAppAssessmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAppAssessmentOutputError>
}

public struct DeleteAppAssessmentInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the assessment. The format for this ARN is: arn:partition:dcps:region:account:app-assessment/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var assessmentArn: Swift.String?
    /// Used for an idempotency token. A client token is a unique, case-sensitive string of up to 64 ASCII characters. You should not reuse the same client token for other API requests.
    public var clientToken: Swift.String?

    public init (
        assessmentArn: Swift.String? = nil,
        clientToken: Swift.String? = nil
    )
    {
        self.assessmentArn = assessmentArn
        self.clientToken = clientToken
    }
}

struct DeleteAppAssessmentInputBody: Swift.Equatable {
    public let assessmentArn: Swift.String?
    public let clientToken: Swift.String?
}

extension DeleteAppAssessmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentArn
        case clientToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentArn)
        assessmentArn = assessmentArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DeleteAppAssessmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAppAssessmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAppAssessmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAppAssessmentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAppAssessmentOutputResponse(assessmentArn: \(Swift.String(describing: assessmentArn)), assessmentStatus: \(Swift.String(describing: assessmentStatus)))"}
}

extension DeleteAppAssessmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteAppAssessmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assessmentArn = output.assessmentArn
            self.assessmentStatus = output.assessmentStatus
        } else {
            self.assessmentArn = nil
            self.assessmentStatus = nil
        }
    }
}

public struct DeleteAppAssessmentOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the assessment. The format for this ARN is: arn:partition:dcps:region:account:app-assessment/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var assessmentArn: Swift.String?
    /// The current status of the assessment for the resiliency policy.
    /// This member is required.
    public var assessmentStatus: ResiliencehubClientTypes.AssessmentStatus?

    public init (
        assessmentArn: Swift.String? = nil,
        assessmentStatus: ResiliencehubClientTypes.AssessmentStatus? = nil
    )
    {
        self.assessmentArn = assessmentArn
        self.assessmentStatus = assessmentStatus
    }
}

struct DeleteAppAssessmentOutputResponseBody: Swift.Equatable {
    public let assessmentArn: Swift.String?
    public let assessmentStatus: ResiliencehubClientTypes.AssessmentStatus?
}

extension DeleteAppAssessmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentArn
        case assessmentStatus
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentArn)
        assessmentArn = assessmentArnDecoded
        let assessmentStatusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.AssessmentStatus.self, forKey: .assessmentStatus)
        assessmentStatus = assessmentStatusDecoded
    }
}

public struct DeleteAppInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAppInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAppInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAppInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAppOutputError>
}

extension DeleteAppInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAppInput(appArn: \(Swift.String(describing: appArn)), clientToken: \(Swift.String(describing: clientToken)), forceDelete: \(Swift.String(describing: forceDelete)))"}
}

extension DeleteAppInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case clientToken
        case forceDelete
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let forceDelete = forceDelete {
            try encodeContainer.encode(forceDelete, forKey: .forceDelete)
        }
    }
}

public struct DeleteAppInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAppInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAppInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAppInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAppOutputError>
}

public struct DeleteAppInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAppInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAppInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAppInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAppOutputError>
}

public struct DeleteAppInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAppInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteAppInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteAppInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAppOutputError>
}

public struct DeleteAppInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAppInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteAppInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/delete-app"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteAppInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAppOutputError>
}

public struct DeleteAppInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var appArn: Swift.String?
    /// Used for an idempotency token. A client token is a unique, case-sensitive string of up to 64 ASCII characters. You should not reuse the same client token for other API requests.
    public var clientToken: Swift.String?
    /// A boolean option to force the deletion of a Resilience Hub application.
    public var forceDelete: Swift.Bool?

    public init (
        appArn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        forceDelete: Swift.Bool? = nil
    )
    {
        self.appArn = appArn
        self.clientToken = clientToken
        self.forceDelete = forceDelete
    }
}

struct DeleteAppInputBody: Swift.Equatable {
    public let appArn: Swift.String?
    public let forceDelete: Swift.Bool?
    public let clientToken: Swift.String?
}

extension DeleteAppInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case clientToken
        case forceDelete
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let forceDeleteDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .forceDelete)
        forceDelete = forceDeleteDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DeleteAppOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAppOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAppOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAppOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAppOutputResponse(appArn: \(Swift.String(describing: appArn)))"}
}

extension DeleteAppOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteAppOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appArn = output.appArn
        } else {
            self.appArn = nil
        }
    }
}

public struct DeleteAppOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var appArn: Swift.String?

    public init (
        appArn: Swift.String? = nil
    )
    {
        self.appArn = appArn
    }
}

struct DeleteAppOutputResponseBody: Swift.Equatable {
    public let appArn: Swift.String?
}

extension DeleteAppOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
    }
}

public struct DeleteRecommendationTemplateInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRecommendationTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRecommendationTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRecommendationTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRecommendationTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRecommendationTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRecommendationTemplateOutputError>
}

extension DeleteRecommendationTemplateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteRecommendationTemplateInput(clientToken: \(Swift.String(describing: clientToken)), recommendationTemplateArn: \(Swift.String(describing: recommendationTemplateArn)))"}
}

extension DeleteRecommendationTemplateInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case recommendationTemplateArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let recommendationTemplateArn = recommendationTemplateArn {
            try encodeContainer.encode(recommendationTemplateArn, forKey: .recommendationTemplateArn)
        }
    }
}

public struct DeleteRecommendationTemplateInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRecommendationTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRecommendationTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRecommendationTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRecommendationTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRecommendationTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRecommendationTemplateOutputError>
}

public struct DeleteRecommendationTemplateInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRecommendationTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRecommendationTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRecommendationTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRecommendationTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRecommendationTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRecommendationTemplateOutputError>
}

public struct DeleteRecommendationTemplateInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRecommendationTemplateInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteRecommendationTemplateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRecommendationTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteRecommendationTemplateInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRecommendationTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRecommendationTemplateOutputError>
}

public struct DeleteRecommendationTemplateInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRecommendationTemplateInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteRecommendationTemplateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRecommendationTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/delete-recommendation-template"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteRecommendationTemplateInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRecommendationTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRecommendationTemplateOutputError>
}

public struct DeleteRecommendationTemplateInput: Swift.Equatable {
    /// Used for an idempotency token. A client token is a unique, case-sensitive string of up to 64 ASCII characters. You should not reuse the same client token for other API requests.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) for a recommendation template.
    /// This member is required.
    public var recommendationTemplateArn: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        recommendationTemplateArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.recommendationTemplateArn = recommendationTemplateArn
    }
}

struct DeleteRecommendationTemplateInputBody: Swift.Equatable {
    public let recommendationTemplateArn: Swift.String?
    public let clientToken: Swift.String?
}

extension DeleteRecommendationTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case recommendationTemplateArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationTemplateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendationTemplateArn)
        recommendationTemplateArn = recommendationTemplateArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DeleteRecommendationTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRecommendationTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRecommendationTemplateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRecommendationTemplateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteRecommendationTemplateOutputResponse(recommendationTemplateArn: \(Swift.String(describing: recommendationTemplateArn)), status: \(Swift.String(describing: status)))"}
}

extension DeleteRecommendationTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteRecommendationTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.recommendationTemplateArn = output.recommendationTemplateArn
            self.status = output.status
        } else {
            self.recommendationTemplateArn = nil
            self.status = nil
        }
    }
}

public struct DeleteRecommendationTemplateOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for a recommendation template.
    /// This member is required.
    public var recommendationTemplateArn: Swift.String?
    /// The status of the action.
    /// This member is required.
    public var status: ResiliencehubClientTypes.RecommendationTemplateStatus?

    public init (
        recommendationTemplateArn: Swift.String? = nil,
        status: ResiliencehubClientTypes.RecommendationTemplateStatus? = nil
    )
    {
        self.recommendationTemplateArn = recommendationTemplateArn
        self.status = status
    }
}

struct DeleteRecommendationTemplateOutputResponseBody: Swift.Equatable {
    public let recommendationTemplateArn: Swift.String?
    public let status: ResiliencehubClientTypes.RecommendationTemplateStatus?
}

extension DeleteRecommendationTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommendationTemplateArn
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationTemplateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendationTemplateArn)
        recommendationTemplateArn = recommendationTemplateArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.RecommendationTemplateStatus.self, forKey: .status)
        status = statusDecoded
    }
}

public struct DeleteResiliencyPolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteResiliencyPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteResiliencyPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteResiliencyPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteResiliencyPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteResiliencyPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteResiliencyPolicyOutputError>
}

extension DeleteResiliencyPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteResiliencyPolicyInput(clientToken: \(Swift.String(describing: clientToken)), policyArn: \(Swift.String(describing: policyArn)))"}
}

extension DeleteResiliencyPolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case policyArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let policyArn = policyArn {
            try encodeContainer.encode(policyArn, forKey: .policyArn)
        }
    }
}

public struct DeleteResiliencyPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteResiliencyPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteResiliencyPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteResiliencyPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteResiliencyPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteResiliencyPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteResiliencyPolicyOutputError>
}

public struct DeleteResiliencyPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteResiliencyPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteResiliencyPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteResiliencyPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteResiliencyPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteResiliencyPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteResiliencyPolicyOutputError>
}

public struct DeleteResiliencyPolicyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteResiliencyPolicyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteResiliencyPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteResiliencyPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteResiliencyPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteResiliencyPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteResiliencyPolicyOutputError>
}

public struct DeleteResiliencyPolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteResiliencyPolicyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteResiliencyPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteResiliencyPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/delete-resiliency-policy"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteResiliencyPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteResiliencyPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteResiliencyPolicyOutputError>
}

public struct DeleteResiliencyPolicyInput: Swift.Equatable {
    /// Used for an idempotency token. A client token is a unique, case-sensitive string of up to 64 ASCII characters. You should not reuse the same client token for other API requests.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the resiliency policy. The format for this ARN is: arn:partition:dcps:region:account:resiliency-policy/policy-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var policyArn: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        policyArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.policyArn = policyArn
    }
}

struct DeleteResiliencyPolicyInputBody: Swift.Equatable {
    public let policyArn: Swift.String?
    public let clientToken: Swift.String?
}

extension DeleteResiliencyPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case policyArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DeleteResiliencyPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteResiliencyPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteResiliencyPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteResiliencyPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteResiliencyPolicyOutputResponse(policyArn: \(Swift.String(describing: policyArn)))"}
}

extension DeleteResiliencyPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteResiliencyPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policyArn = output.policyArn
        } else {
            self.policyArn = nil
        }
    }
}

public struct DeleteResiliencyPolicyOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resiliency policy. The format for this ARN is: arn:partition:dcps:region:account:resiliency-policy/policy-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var policyArn: Swift.String?

    public init (
        policyArn: Swift.String? = nil
    )
    {
        self.policyArn = policyArn
    }
}

struct DeleteResiliencyPolicyOutputResponseBody: Swift.Equatable {
    public let policyArn: Swift.String?
}

extension DeleteResiliencyPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
    }
}

public struct DescribeAppAssessmentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAppAssessmentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAppAssessmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAppAssessmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAppAssessmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAppAssessmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAppAssessmentOutputError>
}

extension DescribeAppAssessmentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAppAssessmentInput(assessmentArn: \(Swift.String(describing: assessmentArn)))"}
}

extension DescribeAppAssessmentInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentArn = assessmentArn {
            try encodeContainer.encode(assessmentArn, forKey: .assessmentArn)
        }
    }
}

public struct DescribeAppAssessmentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAppAssessmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAppAssessmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAppAssessmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAppAssessmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAppAssessmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAppAssessmentOutputError>
}

public struct DescribeAppAssessmentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAppAssessmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAppAssessmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAppAssessmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAppAssessmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAppAssessmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAppAssessmentOutputError>
}

public struct DescribeAppAssessmentInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAppAssessmentInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeAppAssessmentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAppAssessmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeAppAssessmentInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAppAssessmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAppAssessmentOutputError>
}

public struct DescribeAppAssessmentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAppAssessmentInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeAppAssessmentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAppAssessmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/describe-app-assessment"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeAppAssessmentInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAppAssessmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAppAssessmentOutputError>
}

public struct DescribeAppAssessmentInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the assessment. The format for this ARN is: arn:partition:dcps:region:account:app-assessment/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var assessmentArn: Swift.String?

    public init (
        assessmentArn: Swift.String? = nil
    )
    {
        self.assessmentArn = assessmentArn
    }
}

struct DescribeAppAssessmentInputBody: Swift.Equatable {
    public let assessmentArn: Swift.String?
}

extension DescribeAppAssessmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentArn)
        assessmentArn = assessmentArnDecoded
    }
}

extension DescribeAppAssessmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAppAssessmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAppAssessmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAppAssessmentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAppAssessmentOutputResponse(assessment: \(Swift.String(describing: assessment)))"}
}

extension DescribeAppAssessmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAppAssessmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assessment = output.assessment
        } else {
            self.assessment = nil
        }
    }
}

public struct DescribeAppAssessmentOutputResponse: Swift.Equatable {
    /// The assessment for an AWS Resilience Hub application, returned as an object. This object includes Amazon Resource Names (ARNs), compliance information, compliance status, cost, messages, resiliency scores, and more.
    /// This member is required.
    public var assessment: ResiliencehubClientTypes.AppAssessment?

    public init (
        assessment: ResiliencehubClientTypes.AppAssessment? = nil
    )
    {
        self.assessment = assessment
    }
}

struct DescribeAppAssessmentOutputResponseBody: Swift.Equatable {
    public let assessment: ResiliencehubClientTypes.AppAssessment?
}

extension DescribeAppAssessmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessment
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.AppAssessment.self, forKey: .assessment)
        assessment = assessmentDecoded
    }
}

public struct DescribeAppInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAppInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAppInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAppInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAppOutputError>
}

extension DescribeAppInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAppInput(appArn: \(Swift.String(describing: appArn)))"}
}

extension DescribeAppInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
    }
}

public struct DescribeAppInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAppInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAppInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAppInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAppOutputError>
}

public struct DescribeAppInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAppInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAppInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAppInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAppOutputError>
}

public struct DescribeAppInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAppInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeAppInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeAppInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAppOutputError>
}

public struct DescribeAppInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAppInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeAppInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/describe-app"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeAppInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAppOutputError>
}

public struct DescribeAppInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var appArn: Swift.String?

    public init (
        appArn: Swift.String? = nil
    )
    {
        self.appArn = appArn
    }
}

struct DescribeAppInputBody: Swift.Equatable {
    public let appArn: Swift.String?
}

extension DescribeAppInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
    }
}

extension DescribeAppOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAppOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAppOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAppOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAppOutputResponse(app: \(Swift.String(describing: app)))"}
}

extension DescribeAppOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAppOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.app = output.app
        } else {
            self.app = nil
        }
    }
}

public struct DescribeAppOutputResponse: Swift.Equatable {
    /// The specified application, returned as an object with details including compliance status, creation time, description, resiliency score, and more.
    /// This member is required.
    public var app: ResiliencehubClientTypes.App?

    public init (
        app: ResiliencehubClientTypes.App? = nil
    )
    {
        self.app = app
    }
}

struct DescribeAppOutputResponseBody: Swift.Equatable {
    public let app: ResiliencehubClientTypes.App?
}

extension DescribeAppOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case app
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.App.self, forKey: .app)
        app = appDecoded
    }
}

public struct DescribeAppVersionResourcesResolutionStatusInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAppVersionResourcesResolutionStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAppVersionResourcesResolutionStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAppVersionResourcesResolutionStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAppVersionResourcesResolutionStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAppVersionResourcesResolutionStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAppVersionResourcesResolutionStatusOutputError>
}

extension DescribeAppVersionResourcesResolutionStatusInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAppVersionResourcesResolutionStatusInput(appArn: \(Swift.String(describing: appArn)), appVersion: \(Swift.String(describing: appVersion)), resolutionId: \(Swift.String(describing: resolutionId)))"}
}

extension DescribeAppVersionResourcesResolutionStatusInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case resolutionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let appVersion = appVersion {
            try encodeContainer.encode(appVersion, forKey: .appVersion)
        }
        if let resolutionId = resolutionId {
            try encodeContainer.encode(resolutionId, forKey: .resolutionId)
        }
    }
}

public struct DescribeAppVersionResourcesResolutionStatusInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAppVersionResourcesResolutionStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAppVersionResourcesResolutionStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAppVersionResourcesResolutionStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAppVersionResourcesResolutionStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAppVersionResourcesResolutionStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAppVersionResourcesResolutionStatusOutputError>
}

public struct DescribeAppVersionResourcesResolutionStatusInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAppVersionResourcesResolutionStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAppVersionResourcesResolutionStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAppVersionResourcesResolutionStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAppVersionResourcesResolutionStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAppVersionResourcesResolutionStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAppVersionResourcesResolutionStatusOutputError>
}

public struct DescribeAppVersionResourcesResolutionStatusInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAppVersionResourcesResolutionStatusInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeAppVersionResourcesResolutionStatusInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAppVersionResourcesResolutionStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeAppVersionResourcesResolutionStatusInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAppVersionResourcesResolutionStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAppVersionResourcesResolutionStatusOutputError>
}

public struct DescribeAppVersionResourcesResolutionStatusInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAppVersionResourcesResolutionStatusInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeAppVersionResourcesResolutionStatusInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAppVersionResourcesResolutionStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/describe-app-version-resources-resolution-status"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeAppVersionResourcesResolutionStatusInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAppVersionResourcesResolutionStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAppVersionResourcesResolutionStatusOutputError>
}

public struct DescribeAppVersionResourcesResolutionStatusInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var appArn: Swift.String?
    /// The version of the application.
    /// This member is required.
    public var appVersion: Swift.String?
    /// The identifier for a specific resolution.
    public var resolutionId: Swift.String?

    public init (
        appArn: Swift.String? = nil,
        appVersion: Swift.String? = nil,
        resolutionId: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.appVersion = appVersion
        self.resolutionId = resolutionId
    }
}

struct DescribeAppVersionResourcesResolutionStatusInputBody: Swift.Equatable {
    public let appArn: Swift.String?
    public let appVersion: Swift.String?
    public let resolutionId: Swift.String?
}

extension DescribeAppVersionResourcesResolutionStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case resolutionId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let resolutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolutionId)
        resolutionId = resolutionIdDecoded
    }
}

extension DescribeAppVersionResourcesResolutionStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAppVersionResourcesResolutionStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAppVersionResourcesResolutionStatusOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAppVersionResourcesResolutionStatusOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAppVersionResourcesResolutionStatusOutputResponse(appArn: \(Swift.String(describing: appArn)), appVersion: \(Swift.String(describing: appVersion)), errorMessage: \(Swift.String(describing: errorMessage)), resolutionId: \(Swift.String(describing: resolutionId)), status: \(Swift.String(describing: status)))"}
}

extension DescribeAppVersionResourcesResolutionStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAppVersionResourcesResolutionStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appArn = output.appArn
            self.appVersion = output.appVersion
            self.errorMessage = output.errorMessage
            self.resolutionId = output.resolutionId
            self.status = output.status
        } else {
            self.appArn = nil
            self.appVersion = nil
            self.errorMessage = nil
            self.resolutionId = nil
            self.status = nil
        }
    }
}

public struct DescribeAppVersionResourcesResolutionStatusOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var appArn: Swift.String?
    /// The version of the application.
    /// This member is required.
    public var appVersion: Swift.String?
    /// The returned error message for the request.
    public var errorMessage: Swift.String?
    /// The identifier for a specific resolution.
    /// This member is required.
    public var resolutionId: Swift.String?
    /// The status of the action.
    /// This member is required.
    public var status: ResiliencehubClientTypes.ResourceResolutionStatusType?

    public init (
        appArn: Swift.String? = nil,
        appVersion: Swift.String? = nil,
        errorMessage: Swift.String? = nil,
        resolutionId: Swift.String? = nil,
        status: ResiliencehubClientTypes.ResourceResolutionStatusType? = nil
    )
    {
        self.appArn = appArn
        self.appVersion = appVersion
        self.errorMessage = errorMessage
        self.resolutionId = resolutionId
        self.status = status
    }
}

struct DescribeAppVersionResourcesResolutionStatusOutputResponseBody: Swift.Equatable {
    public let appArn: Swift.String?
    public let appVersion: Swift.String?
    public let resolutionId: Swift.String?
    public let status: ResiliencehubClientTypes.ResourceResolutionStatusType?
    public let errorMessage: Swift.String?
}

extension DescribeAppVersionResourcesResolutionStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case errorMessage
        case resolutionId
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let resolutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolutionId)
        resolutionId = resolutionIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ResourceResolutionStatusType.self, forKey: .status)
        status = statusDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

public struct DescribeAppVersionTemplateInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAppVersionTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAppVersionTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAppVersionTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAppVersionTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAppVersionTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAppVersionTemplateOutputError>
}

extension DescribeAppVersionTemplateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAppVersionTemplateInput(appArn: \(Swift.String(describing: appArn)), appVersion: \(Swift.String(describing: appVersion)))"}
}

extension DescribeAppVersionTemplateInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let appVersion = appVersion {
            try encodeContainer.encode(appVersion, forKey: .appVersion)
        }
    }
}

public struct DescribeAppVersionTemplateInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAppVersionTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAppVersionTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAppVersionTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAppVersionTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAppVersionTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAppVersionTemplateOutputError>
}

public struct DescribeAppVersionTemplateInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAppVersionTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAppVersionTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAppVersionTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAppVersionTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAppVersionTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAppVersionTemplateOutputError>
}

public struct DescribeAppVersionTemplateInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAppVersionTemplateInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeAppVersionTemplateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAppVersionTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeAppVersionTemplateInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAppVersionTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAppVersionTemplateOutputError>
}

public struct DescribeAppVersionTemplateInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAppVersionTemplateInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeAppVersionTemplateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAppVersionTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/describe-app-version-template"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeAppVersionTemplateInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAppVersionTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAppVersionTemplateOutputError>
}

public struct DescribeAppVersionTemplateInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var appArn: Swift.String?
    /// The version of the application.
    /// This member is required.
    public var appVersion: Swift.String?

    public init (
        appArn: Swift.String? = nil,
        appVersion: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.appVersion = appVersion
    }
}

struct DescribeAppVersionTemplateInputBody: Swift.Equatable {
    public let appArn: Swift.String?
    public let appVersion: Swift.String?
}

extension DescribeAppVersionTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
    }
}

extension DescribeAppVersionTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAppVersionTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAppVersionTemplateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAppVersionTemplateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAppVersionTemplateOutputResponse(appArn: \(Swift.String(describing: appArn)), appTemplateBody: \(Swift.String(describing: appTemplateBody)), appVersion: \(Swift.String(describing: appVersion)))"}
}

extension DescribeAppVersionTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAppVersionTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appArn = output.appArn
            self.appTemplateBody = output.appTemplateBody
            self.appVersion = output.appVersion
        } else {
            self.appArn = nil
            self.appTemplateBody = nil
            self.appVersion = nil
        }
    }
}

public struct DescribeAppVersionTemplateOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var appArn: Swift.String?
    /// The body of the template.
    /// This member is required.
    public var appTemplateBody: Swift.String?
    /// The version of the application.
    /// This member is required.
    public var appVersion: Swift.String?

    public init (
        appArn: Swift.String? = nil,
        appTemplateBody: Swift.String? = nil,
        appVersion: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.appTemplateBody = appTemplateBody
        self.appVersion = appVersion
    }
}

struct DescribeAppVersionTemplateOutputResponseBody: Swift.Equatable {
    public let appArn: Swift.String?
    public let appVersion: Swift.String?
    public let appTemplateBody: Swift.String?
}

extension DescribeAppVersionTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appTemplateBody
        case appVersion
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let appTemplateBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appTemplateBody)
        appTemplateBody = appTemplateBodyDecoded
    }
}

public struct DescribeDraftAppVersionResourcesImportStatusInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDraftAppVersionResourcesImportStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDraftAppVersionResourcesImportStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDraftAppVersionResourcesImportStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDraftAppVersionResourcesImportStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDraftAppVersionResourcesImportStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDraftAppVersionResourcesImportStatusOutputError>
}

extension DescribeDraftAppVersionResourcesImportStatusInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDraftAppVersionResourcesImportStatusInput(appArn: \(Swift.String(describing: appArn)))"}
}

extension DescribeDraftAppVersionResourcesImportStatusInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
    }
}

public struct DescribeDraftAppVersionResourcesImportStatusInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDraftAppVersionResourcesImportStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDraftAppVersionResourcesImportStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDraftAppVersionResourcesImportStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDraftAppVersionResourcesImportStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDraftAppVersionResourcesImportStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDraftAppVersionResourcesImportStatusOutputError>
}

public struct DescribeDraftAppVersionResourcesImportStatusInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDraftAppVersionResourcesImportStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDraftAppVersionResourcesImportStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDraftAppVersionResourcesImportStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDraftAppVersionResourcesImportStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDraftAppVersionResourcesImportStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDraftAppVersionResourcesImportStatusOutputError>
}

public struct DescribeDraftAppVersionResourcesImportStatusInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDraftAppVersionResourcesImportStatusInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeDraftAppVersionResourcesImportStatusInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDraftAppVersionResourcesImportStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeDraftAppVersionResourcesImportStatusInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDraftAppVersionResourcesImportStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDraftAppVersionResourcesImportStatusOutputError>
}

public struct DescribeDraftAppVersionResourcesImportStatusInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDraftAppVersionResourcesImportStatusInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeDraftAppVersionResourcesImportStatusInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDraftAppVersionResourcesImportStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/describe-draft-app-version-resources-import-status"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeDraftAppVersionResourcesImportStatusInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDraftAppVersionResourcesImportStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDraftAppVersionResourcesImportStatusOutputError>
}

public struct DescribeDraftAppVersionResourcesImportStatusInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var appArn: Swift.String?

    public init (
        appArn: Swift.String? = nil
    )
    {
        self.appArn = appArn
    }
}

struct DescribeDraftAppVersionResourcesImportStatusInputBody: Swift.Equatable {
    public let appArn: Swift.String?
}

extension DescribeDraftAppVersionResourcesImportStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
    }
}

extension DescribeDraftAppVersionResourcesImportStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDraftAppVersionResourcesImportStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDraftAppVersionResourcesImportStatusOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDraftAppVersionResourcesImportStatusOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDraftAppVersionResourcesImportStatusOutputResponse(appArn: \(Swift.String(describing: appArn)), appVersion: \(Swift.String(describing: appVersion)), errorMessage: \(Swift.String(describing: errorMessage)), status: \(Swift.String(describing: status)), statusChangeTime: \(Swift.String(describing: statusChangeTime)))"}
}

extension DescribeDraftAppVersionResourcesImportStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDraftAppVersionResourcesImportStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appArn = output.appArn
            self.appVersion = output.appVersion
            self.errorMessage = output.errorMessage
            self.status = output.status
            self.statusChangeTime = output.statusChangeTime
        } else {
            self.appArn = nil
            self.appVersion = nil
            self.errorMessage = nil
            self.status = nil
            self.statusChangeTime = nil
        }
    }
}

public struct DescribeDraftAppVersionResourcesImportStatusOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var appArn: Swift.String?
    /// The version of the application.
    /// This member is required.
    public var appVersion: Swift.String?
    /// The returned error message for the request.
    public var errorMessage: Swift.String?
    /// The status of the action.
    /// This member is required.
    public var status: ResiliencehubClientTypes.ResourceImportStatusType?
    /// The timestamp for when the status last changed.
    /// This member is required.
    public var statusChangeTime: ClientRuntime.Date?

    public init (
        appArn: Swift.String? = nil,
        appVersion: Swift.String? = nil,
        errorMessage: Swift.String? = nil,
        status: ResiliencehubClientTypes.ResourceImportStatusType? = nil,
        statusChangeTime: ClientRuntime.Date? = nil
    )
    {
        self.appArn = appArn
        self.appVersion = appVersion
        self.errorMessage = errorMessage
        self.status = status
        self.statusChangeTime = statusChangeTime
    }
}

struct DescribeDraftAppVersionResourcesImportStatusOutputResponseBody: Swift.Equatable {
    public let appArn: Swift.String?
    public let appVersion: Swift.String?
    public let status: ResiliencehubClientTypes.ResourceImportStatusType?
    public let statusChangeTime: ClientRuntime.Date?
    public let errorMessage: Swift.String?
}

extension DescribeDraftAppVersionResourcesImportStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case errorMessage
        case status
        case statusChangeTime
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ResourceImportStatusType.self, forKey: .status)
        status = statusDecoded
        let statusChangeTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .statusChangeTime)
        statusChangeTime = statusChangeTimeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

public struct DescribeResiliencyPolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeResiliencyPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeResiliencyPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeResiliencyPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeResiliencyPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeResiliencyPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeResiliencyPolicyOutputError>
}

extension DescribeResiliencyPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeResiliencyPolicyInput(policyArn: \(Swift.String(describing: policyArn)))"}
}

extension DescribeResiliencyPolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyArn = policyArn {
            try encodeContainer.encode(policyArn, forKey: .policyArn)
        }
    }
}

public struct DescribeResiliencyPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeResiliencyPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeResiliencyPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeResiliencyPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeResiliencyPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeResiliencyPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeResiliencyPolicyOutputError>
}

public struct DescribeResiliencyPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeResiliencyPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeResiliencyPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeResiliencyPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeResiliencyPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeResiliencyPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeResiliencyPolicyOutputError>
}

public struct DescribeResiliencyPolicyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeResiliencyPolicyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeResiliencyPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeResiliencyPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeResiliencyPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeResiliencyPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeResiliencyPolicyOutputError>
}

public struct DescribeResiliencyPolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeResiliencyPolicyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeResiliencyPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeResiliencyPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/describe-resiliency-policy"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeResiliencyPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeResiliencyPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeResiliencyPolicyOutputError>
}

public struct DescribeResiliencyPolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resiliency policy. The format for this ARN is: arn:partition:dcps:region:account:resiliency-policy/policy-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var policyArn: Swift.String?

    public init (
        policyArn: Swift.String? = nil
    )
    {
        self.policyArn = policyArn
    }
}

struct DescribeResiliencyPolicyInputBody: Swift.Equatable {
    public let policyArn: Swift.String?
}

extension DescribeResiliencyPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
    }
}

extension DescribeResiliencyPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeResiliencyPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeResiliencyPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeResiliencyPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeResiliencyPolicyOutputResponse(policy: \(Swift.String(describing: policy)))"}
}

extension DescribeResiliencyPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeResiliencyPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct DescribeResiliencyPolicyOutputResponse: Swift.Equatable {
    /// Information about the specific resiliency policy, returned as an object. This object includes creation time, data location constraints, its name, description, tags, the recovery time objective (RTO) and recovery point objective (RPO) in seconds, and more.
    /// This member is required.
    public var policy: ResiliencehubClientTypes.ResiliencyPolicy?

    public init (
        policy: ResiliencehubClientTypes.ResiliencyPolicy? = nil
    )
    {
        self.policy = policy
    }
}

struct DescribeResiliencyPolicyOutputResponseBody: Swift.Equatable {
    public let policy: ResiliencehubClientTypes.ResiliencyPolicy?
}

extension DescribeResiliencyPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ResiliencyPolicy.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension ResiliencehubClientTypes.DisruptionCompliance: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case achievableRpoInSecs
        case achievableRtoInSecs
        case complianceStatus
        case currentRpoInSecs
        case currentRtoInSecs
        case message
        case rpoDescription
        case rpoReferenceId
        case rtoDescription
        case rtoReferenceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if achievableRpoInSecs != 0 {
            try encodeContainer.encode(achievableRpoInSecs, forKey: .achievableRpoInSecs)
        }
        if achievableRtoInSecs != 0 {
            try encodeContainer.encode(achievableRtoInSecs, forKey: .achievableRtoInSecs)
        }
        if let complianceStatus = complianceStatus {
            try encodeContainer.encode(complianceStatus.rawValue, forKey: .complianceStatus)
        }
        if currentRpoInSecs != 0 {
            try encodeContainer.encode(currentRpoInSecs, forKey: .currentRpoInSecs)
        }
        if currentRtoInSecs != 0 {
            try encodeContainer.encode(currentRtoInSecs, forKey: .currentRtoInSecs)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let rpoDescription = rpoDescription {
            try encodeContainer.encode(rpoDescription, forKey: .rpoDescription)
        }
        if let rpoReferenceId = rpoReferenceId {
            try encodeContainer.encode(rpoReferenceId, forKey: .rpoReferenceId)
        }
        if let rtoDescription = rtoDescription {
            try encodeContainer.encode(rtoDescription, forKey: .rtoDescription)
        }
        if let rtoReferenceId = rtoReferenceId {
            try encodeContainer.encode(rtoReferenceId, forKey: .rtoReferenceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let achievableRtoInSecsDecoded = try containerValues.decode(Swift.Int.self, forKey: .achievableRtoInSecs)
        achievableRtoInSecs = achievableRtoInSecsDecoded
        let currentRtoInSecsDecoded = try containerValues.decode(Swift.Int.self, forKey: .currentRtoInSecs)
        currentRtoInSecs = currentRtoInSecsDecoded
        let rtoReferenceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rtoReferenceId)
        rtoReferenceId = rtoReferenceIdDecoded
        let rtoDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rtoDescription)
        rtoDescription = rtoDescriptionDecoded
        let currentRpoInSecsDecoded = try containerValues.decode(Swift.Int.self, forKey: .currentRpoInSecs)
        currentRpoInSecs = currentRpoInSecsDecoded
        let rpoReferenceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rpoReferenceId)
        rpoReferenceId = rpoReferenceIdDecoded
        let rpoDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rpoDescription)
        rpoDescription = rpoDescriptionDecoded
        let complianceStatusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ComplianceStatus.self, forKey: .complianceStatus)
        complianceStatus = complianceStatusDecoded
        let achievableRpoInSecsDecoded = try containerValues.decode(Swift.Int.self, forKey: .achievableRpoInSecs)
        achievableRpoInSecs = achievableRpoInSecsDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResiliencehubClientTypes.DisruptionCompliance: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisruptionCompliance(achievableRpoInSecs: \(Swift.String(describing: achievableRpoInSecs)), achievableRtoInSecs: \(Swift.String(describing: achievableRtoInSecs)), complianceStatus: \(Swift.String(describing: complianceStatus)), currentRpoInSecs: \(Swift.String(describing: currentRpoInSecs)), currentRtoInSecs: \(Swift.String(describing: currentRtoInSecs)), message: \(Swift.String(describing: message)), rpoDescription: \(Swift.String(describing: rpoDescription)), rpoReferenceId: \(Swift.String(describing: rpoReferenceId)), rtoDescription: \(Swift.String(describing: rtoDescription)), rtoReferenceId: \(Swift.String(describing: rtoReferenceId)))"}
}

extension ResiliencehubClientTypes {
    /// Defines the compliance against the resiliency policy for a disruption.
    public struct DisruptionCompliance: Swift.Equatable {
        /// The Recovery Point Objective (RPO) that is achievable, in seconds.
        public var achievableRpoInSecs: Swift.Int
        /// The Recovery Time Objective (RTO) that is achievable, in seconds
        public var achievableRtoInSecs: Swift.Int
        /// The current status of compliance for the resiliency policy.
        /// This member is required.
        public var complianceStatus: ResiliencehubClientTypes.ComplianceStatus?
        /// The current RPO, in seconds.
        public var currentRpoInSecs: Swift.Int
        /// The current RTO, in seconds.
        public var currentRtoInSecs: Swift.Int
        /// The disruption compliance message.
        public var message: Swift.String?
        /// The RPO description.
        public var rpoDescription: Swift.String?
        /// The RPO reference identifier.
        public var rpoReferenceId: Swift.String?
        /// The RTO description.
        public var rtoDescription: Swift.String?
        /// The RTO reference identifier.
        public var rtoReferenceId: Swift.String?

        public init (
            achievableRpoInSecs: Swift.Int = 0,
            achievableRtoInSecs: Swift.Int = 0,
            complianceStatus: ResiliencehubClientTypes.ComplianceStatus? = nil,
            currentRpoInSecs: Swift.Int = 0,
            currentRtoInSecs: Swift.Int = 0,
            message: Swift.String? = nil,
            rpoDescription: Swift.String? = nil,
            rpoReferenceId: Swift.String? = nil,
            rtoDescription: Swift.String? = nil,
            rtoReferenceId: Swift.String? = nil
        )
        {
            self.achievableRpoInSecs = achievableRpoInSecs
            self.achievableRtoInSecs = achievableRtoInSecs
            self.complianceStatus = complianceStatus
            self.currentRpoInSecs = currentRpoInSecs
            self.currentRtoInSecs = currentRtoInSecs
            self.message = message
            self.rpoDescription = rpoDescription
            self.rpoReferenceId = rpoReferenceId
            self.rtoDescription = rtoDescription
            self.rtoReferenceId = rtoReferenceId
        }
    }

}

extension ResiliencehubClientTypes {
    public enum DisruptionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case az
        case hardware
        case region
        case software
        case sdkUnknown(Swift.String)

        public static var allCases: [DisruptionType] {
            return [
                .az,
                .hardware,
                .region,
                .software,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .az: return "AZ"
            case .hardware: return "Hardware"
            case .region: return "Region"
            case .software: return "Software"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DisruptionType(rawValue: rawValue) ?? DisruptionType.sdkUnknown(rawValue)
        }
    }
}

extension ResiliencehubClientTypes {
    public enum EstimatedCostTier: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case l1
        case l2
        case l3
        case l4
        case sdkUnknown(Swift.String)

        public static var allCases: [EstimatedCostTier] {
            return [
                .l1,
                .l2,
                .l3,
                .l4,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .l1: return "L1"
            case .l2: return "L2"
            case .l3: return "L3"
            case .l4: return "L4"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EstimatedCostTier(rawValue: rawValue) ?? EstimatedCostTier.sdkUnknown(rawValue)
        }
    }
}

extension ResiliencehubClientTypes.FailurePolicy: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rpoInSecs
        case rtoInSecs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if rpoInSecs != 0 {
            try encodeContainer.encode(rpoInSecs, forKey: .rpoInSecs)
        }
        if rtoInSecs != 0 {
            try encodeContainer.encode(rtoInSecs, forKey: .rtoInSecs)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rtoInSecsDecoded = try containerValues.decode(Swift.Int.self, forKey: .rtoInSecs)
        rtoInSecs = rtoInSecsDecoded
        let rpoInSecsDecoded = try containerValues.decode(Swift.Int.self, forKey: .rpoInSecs)
        rpoInSecs = rpoInSecsDecoded
    }
}

extension ResiliencehubClientTypes.FailurePolicy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FailurePolicy(rpoInSecs: \(Swift.String(describing: rpoInSecs)), rtoInSecs: \(Swift.String(describing: rtoInSecs)))"}
}

extension ResiliencehubClientTypes {
    /// Defines a failure policy.
    public struct FailurePolicy: Swift.Equatable {
        /// The Recovery Point Objective (RPO), in seconds.
        /// This member is required.
        public var rpoInSecs: Swift.Int
        /// The Recovery Time Objective (RTO), in seconds.
        /// This member is required.
        public var rtoInSecs: Swift.Int

        public init (
            rpoInSecs: Swift.Int = 0,
            rtoInSecs: Swift.Int = 0
        )
        {
            self.rpoInSecs = rpoInSecs
            self.rtoInSecs = rtoInSecs
        }
    }

}

extension ResiliencehubClientTypes {
    public enum HaArchitecture: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case backupAndRestore
        case multiSite
        case noRecoveryPlan
        case pilotLight
        case warmStandby
        case sdkUnknown(Swift.String)

        public static var allCases: [HaArchitecture] {
            return [
                .backupAndRestore,
                .multiSite,
                .noRecoveryPlan,
                .pilotLight,
                .warmStandby,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .backupAndRestore: return "BackupAndRestore"
            case .multiSite: return "MultiSite"
            case .noRecoveryPlan: return "NoRecoveryPlan"
            case .pilotLight: return "PilotLight"
            case .warmStandby: return "WarmStandby"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HaArchitecture(rawValue: rawValue) ?? HaArchitecture.sdkUnknown(rawValue)
        }
    }
}

public struct ImportResourcesToDraftAppVersionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ImportResourcesToDraftAppVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ImportResourcesToDraftAppVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ImportResourcesToDraftAppVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ImportResourcesToDraftAppVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ImportResourcesToDraftAppVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ImportResourcesToDraftAppVersionOutputError>
}

extension ImportResourcesToDraftAppVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImportResourcesToDraftAppVersionInput(appArn: \(Swift.String(describing: appArn)), sourceArns: \(Swift.String(describing: sourceArns)))"}
}

extension ImportResourcesToDraftAppVersionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case sourceArns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let sourceArns = sourceArns {
            var sourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceArns)
            for arnlist0 in sourceArns {
                try sourceArnsContainer.encode(arnlist0)
            }
        }
    }
}

public struct ImportResourcesToDraftAppVersionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ImportResourcesToDraftAppVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ImportResourcesToDraftAppVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ImportResourcesToDraftAppVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ImportResourcesToDraftAppVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ImportResourcesToDraftAppVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ImportResourcesToDraftAppVersionOutputError>
}

public struct ImportResourcesToDraftAppVersionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ImportResourcesToDraftAppVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ImportResourcesToDraftAppVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ImportResourcesToDraftAppVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ImportResourcesToDraftAppVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ImportResourcesToDraftAppVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ImportResourcesToDraftAppVersionOutputError>
}

public struct ImportResourcesToDraftAppVersionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ImportResourcesToDraftAppVersionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ImportResourcesToDraftAppVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ImportResourcesToDraftAppVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ImportResourcesToDraftAppVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<ImportResourcesToDraftAppVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ImportResourcesToDraftAppVersionOutputError>
}

public struct ImportResourcesToDraftAppVersionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ImportResourcesToDraftAppVersionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ImportResourcesToDraftAppVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ImportResourcesToDraftAppVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/import-resources-to-draft-app-version"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ImportResourcesToDraftAppVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<ImportResourcesToDraftAppVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ImportResourcesToDraftAppVersionOutputError>
}

public struct ImportResourcesToDraftAppVersionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var appArn: Swift.String?
    /// The Amazon Resource Names (ARNs) for the resources that you want to import.
    /// This member is required.
    public var sourceArns: [Swift.String]?

    public init (
        appArn: Swift.String? = nil,
        sourceArns: [Swift.String]? = nil
    )
    {
        self.appArn = appArn
        self.sourceArns = sourceArns
    }
}

struct ImportResourcesToDraftAppVersionInputBody: Swift.Equatable {
    public let appArn: Swift.String?
    public let sourceArns: [Swift.String]?
}

extension ImportResourcesToDraftAppVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case sourceArns
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let sourceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sourceArns)
        var sourceArnsDecoded0:[Swift.String]? = nil
        if let sourceArnsContainer = sourceArnsContainer {
            sourceArnsDecoded0 = [Swift.String]()
            for string0 in sourceArnsContainer {
                if let string0 = string0 {
                    sourceArnsDecoded0?.append(string0)
                }
            }
        }
        sourceArns = sourceArnsDecoded0
    }
}

extension ImportResourcesToDraftAppVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportResourcesToDraftAppVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ImportResourcesToDraftAppVersionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportResourcesToDraftAppVersionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImportResourcesToDraftAppVersionOutputResponse(appArn: \(Swift.String(describing: appArn)), appVersion: \(Swift.String(describing: appVersion)), sourceArns: \(Swift.String(describing: sourceArns)), status: \(Swift.String(describing: status)))"}
}

extension ImportResourcesToDraftAppVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ImportResourcesToDraftAppVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appArn = output.appArn
            self.appVersion = output.appVersion
            self.sourceArns = output.sourceArns
            self.status = output.status
        } else {
            self.appArn = nil
            self.appVersion = nil
            self.sourceArns = nil
            self.status = nil
        }
    }
}

public struct ImportResourcesToDraftAppVersionOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var appArn: Swift.String?
    /// The version of the application.
    /// This member is required.
    public var appVersion: Swift.String?
    /// The Amazon Resource Names (ARNs) for the resources that you imported.
    /// This member is required.
    public var sourceArns: [Swift.String]?
    /// The status of the action.
    /// This member is required.
    public var status: ResiliencehubClientTypes.ResourceImportStatusType?

    public init (
        appArn: Swift.String? = nil,
        appVersion: Swift.String? = nil,
        sourceArns: [Swift.String]? = nil,
        status: ResiliencehubClientTypes.ResourceImportStatusType? = nil
    )
    {
        self.appArn = appArn
        self.appVersion = appVersion
        self.sourceArns = sourceArns
        self.status = status
    }
}

struct ImportResourcesToDraftAppVersionOutputResponseBody: Swift.Equatable {
    public let appArn: Swift.String?
    public let appVersion: Swift.String?
    public let sourceArns: [Swift.String]?
    public let status: ResiliencehubClientTypes.ResourceImportStatusType?
}

extension ImportResourcesToDraftAppVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case sourceArns
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let sourceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sourceArns)
        var sourceArnsDecoded0:[Swift.String]? = nil
        if let sourceArnsContainer = sourceArnsContainer {
            sourceArnsDecoded0 = [Swift.String]()
            for string0 in sourceArnsContainer {
                if let string0 = string0 {
                    sourceArnsDecoded0?.append(string0)
                }
            }
        }
        sourceArns = sourceArnsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ResourceImportStatusType.self, forKey: .status)
        status = statusDecoded
    }
}

extension InternalServerException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerException(message: \(Swift.String(describing: message)))"}
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception occurs when there is an internal failure in the AWS Resilience Hub service.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListAlarmRecommendationsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAlarmRecommendationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAlarmRecommendationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAlarmRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAlarmRecommendationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAlarmRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAlarmRecommendationsOutputError>
}

extension ListAlarmRecommendationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAlarmRecommendationsInput(assessmentArn: \(Swift.String(describing: assessmentArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAlarmRecommendationsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentArn = assessmentArn {
            try encodeContainer.encode(assessmentArn, forKey: .assessmentArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListAlarmRecommendationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAlarmRecommendationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAlarmRecommendationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAlarmRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAlarmRecommendationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAlarmRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAlarmRecommendationsOutputError>
}

public struct ListAlarmRecommendationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAlarmRecommendationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAlarmRecommendationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAlarmRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAlarmRecommendationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAlarmRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAlarmRecommendationsOutputError>
}

public struct ListAlarmRecommendationsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAlarmRecommendationsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListAlarmRecommendationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAlarmRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAlarmRecommendationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAlarmRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAlarmRecommendationsOutputError>
}

public struct ListAlarmRecommendationsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAlarmRecommendationsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListAlarmRecommendationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAlarmRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/list-alarm-recommendations"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAlarmRecommendationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAlarmRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAlarmRecommendationsOutputError>
}

public struct ListAlarmRecommendationsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the assessment. The format for this ARN is: arn:partition:dcps:region:account:app-assessment/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var assessmentArn: Swift.String?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// Null, or the token from a previous call to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        assessmentArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentArn = assessmentArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAlarmRecommendationsInputBody: Swift.Equatable {
    public let assessmentArn: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListAlarmRecommendationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentArn
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentArn)
        assessmentArn = assessmentArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAlarmRecommendationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAlarmRecommendationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAlarmRecommendationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAlarmRecommendationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAlarmRecommendationsOutputResponse(alarmRecommendations: \(Swift.String(describing: alarmRecommendations)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAlarmRecommendationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAlarmRecommendationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.alarmRecommendations = output.alarmRecommendations
            self.nextToken = output.nextToken
        } else {
            self.alarmRecommendations = nil
            self.nextToken = nil
        }
    }
}

public struct ListAlarmRecommendationsOutputResponse: Swift.Equatable {
    /// The alarm recommendations for an AWS Resilience Hub application, returned as an object. This object includes application component names, descriptions, information about whether a recommendation has already been implemented or not, prerequisites, and more.
    /// This member is required.
    public var alarmRecommendations: [ResiliencehubClientTypes.AlarmRecommendation]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        alarmRecommendations: [ResiliencehubClientTypes.AlarmRecommendation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.alarmRecommendations = alarmRecommendations
        self.nextToken = nextToken
    }
}

struct ListAlarmRecommendationsOutputResponseBody: Swift.Equatable {
    public let alarmRecommendations: [ResiliencehubClientTypes.AlarmRecommendation]?
    public let nextToken: Swift.String?
}

extension ListAlarmRecommendationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarmRecommendations
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alarmRecommendationsContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.AlarmRecommendation?].self, forKey: .alarmRecommendations)
        var alarmRecommendationsDecoded0:[ResiliencehubClientTypes.AlarmRecommendation]? = nil
        if let alarmRecommendationsContainer = alarmRecommendationsContainer {
            alarmRecommendationsDecoded0 = [ResiliencehubClientTypes.AlarmRecommendation]()
            for structure0 in alarmRecommendationsContainer {
                if let structure0 = structure0 {
                    alarmRecommendationsDecoded0?.append(structure0)
                }
            }
        }
        alarmRecommendations = alarmRecommendationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAppAssessmentsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAppAssessmentsInput(appArn: \(Swift.String(describing: appArn)), assessmentName: \(Swift.String(describing: assessmentName)), assessmentStatus: \(Swift.String(describing: assessmentStatus)), complianceStatus: \(Swift.String(describing: complianceStatus)), invoker: \(Swift.String(describing: invoker)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), reverseOrder: \(Swift.String(describing: reverseOrder)))"}
}

extension ListAppAssessmentsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListAppAssessmentsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppAssessmentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAppAssessmentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppAssessmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAppAssessmentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppAssessmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppAssessmentsOutputError>
}

public struct ListAppAssessmentsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppAssessmentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAppAssessmentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppAssessmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let reverseOrder = input.operationInput.reverseOrder {
            let reverseOrderQueryItem = ClientRuntime.URLQueryItem(name: "reverseOrder".urlPercentEncoding(), value: Swift.String(reverseOrder).urlPercentEncoding())
            input.builder.withQueryItem(reverseOrderQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let assessmentName = input.operationInput.assessmentName {
            let assessmentNameQueryItem = ClientRuntime.URLQueryItem(name: "assessmentName".urlPercentEncoding(), value: Swift.String(assessmentName).urlPercentEncoding())
            input.builder.withQueryItem(assessmentNameQueryItem)
        }
        if let appArn = input.operationInput.appArn {
            let appArnQueryItem = ClientRuntime.URLQueryItem(name: "appArn".urlPercentEncoding(), value: Swift.String(appArn).urlPercentEncoding())
            input.builder.withQueryItem(appArnQueryItem)
        }
        if let complianceStatus = input.operationInput.complianceStatus {
            let complianceStatusQueryItem = ClientRuntime.URLQueryItem(name: "complianceStatus".urlPercentEncoding(), value: Swift.String(complianceStatus.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(complianceStatusQueryItem)
        }
        if let assessmentStatus = input.operationInput.assessmentStatus {
            assessmentStatus.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "assessmentStatus".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let invoker = input.operationInput.invoker {
            let invokerQueryItem = ClientRuntime.URLQueryItem(name: "invoker".urlPercentEncoding(), value: Swift.String(invoker.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(invokerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAppAssessmentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppAssessmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppAssessmentsOutputError>
}

public struct ListAppAssessmentsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppAssessmentsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListAppAssessmentsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppAssessmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAppAssessmentsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppAssessmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppAssessmentsOutputError>
}

public struct ListAppAssessmentsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppAssessmentsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListAppAssessmentsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppAssessmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/list-app-assessments"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAppAssessmentsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppAssessmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppAssessmentsOutputError>
}

public struct ListAppAssessmentsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    public var appArn: Swift.String?
    /// The name for the assessment.
    public var assessmentName: Swift.String?
    /// The current status of the assessment for the resiliency policy.
    public var assessmentStatus: [ResiliencehubClientTypes.AssessmentStatus]?
    /// The current status of compliance for the resiliency policy.
    public var complianceStatus: ResiliencehubClientTypes.ComplianceStatus?
    /// Specifies the entity that invoked a specific assessment, either a User or the System.
    public var invoker: ResiliencehubClientTypes.AssessmentInvoker?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// Null, or the token from a previous call to get the next set of results.
    public var nextToken: Swift.String?
    /// The default is to sort by ascending startTime. To sort by descending startTime, set reverseOrder to true.
    public var reverseOrder: Swift.Bool?

    public init (
        appArn: Swift.String? = nil,
        assessmentName: Swift.String? = nil,
        assessmentStatus: [ResiliencehubClientTypes.AssessmentStatus]? = nil,
        complianceStatus: ResiliencehubClientTypes.ComplianceStatus? = nil,
        invoker: ResiliencehubClientTypes.AssessmentInvoker? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        reverseOrder: Swift.Bool? = nil
    )
    {
        self.appArn = appArn
        self.assessmentName = assessmentName
        self.assessmentStatus = assessmentStatus
        self.complianceStatus = complianceStatus
        self.invoker = invoker
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.reverseOrder = reverseOrder
    }
}

struct ListAppAssessmentsInputBody: Swift.Equatable {
}

extension ListAppAssessmentsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAppAssessmentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAppAssessmentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAppAssessmentsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAppAssessmentsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAppAssessmentsOutputResponse(assessmentSummaries: \(Swift.String(describing: assessmentSummaries)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAppAssessmentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAppAssessmentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assessmentSummaries = output.assessmentSummaries
            self.nextToken = output.nextToken
        } else {
            self.assessmentSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListAppAssessmentsOutputResponse: Swift.Equatable {
    /// The summaries for the specified assessments, returned as an object. This object includes application versions, associated Amazon Resource Numbers (ARNs), cost, messages, resiliency scores, and more.
    /// This member is required.
    public var assessmentSummaries: [ResiliencehubClientTypes.AppAssessmentSummary]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        assessmentSummaries: [ResiliencehubClientTypes.AppAssessmentSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentSummaries = assessmentSummaries
        self.nextToken = nextToken
    }
}

struct ListAppAssessmentsOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let assessmentSummaries: [ResiliencehubClientTypes.AppAssessmentSummary]?
}

extension ListAppAssessmentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentSummaries
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let assessmentSummariesContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.AppAssessmentSummary?].self, forKey: .assessmentSummaries)
        var assessmentSummariesDecoded0:[ResiliencehubClientTypes.AppAssessmentSummary]? = nil
        if let assessmentSummariesContainer = assessmentSummariesContainer {
            assessmentSummariesDecoded0 = [ResiliencehubClientTypes.AppAssessmentSummary]()
            for structure0 in assessmentSummariesContainer {
                if let structure0 = structure0 {
                    assessmentSummariesDecoded0?.append(structure0)
                }
            }
        }
        assessmentSummaries = assessmentSummariesDecoded0
    }
}

public struct ListAppComponentCompliancesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppComponentCompliancesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAppComponentCompliancesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppComponentCompliancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAppComponentCompliancesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppComponentCompliancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppComponentCompliancesOutputError>
}

extension ListAppComponentCompliancesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAppComponentCompliancesInput(assessmentArn: \(Swift.String(describing: assessmentArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAppComponentCompliancesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentArn = assessmentArn {
            try encodeContainer.encode(assessmentArn, forKey: .assessmentArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListAppComponentCompliancesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppComponentCompliancesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAppComponentCompliancesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppComponentCompliancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAppComponentCompliancesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppComponentCompliancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppComponentCompliancesOutputError>
}

public struct ListAppComponentCompliancesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppComponentCompliancesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAppComponentCompliancesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppComponentCompliancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAppComponentCompliancesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppComponentCompliancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppComponentCompliancesOutputError>
}

public struct ListAppComponentCompliancesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppComponentCompliancesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListAppComponentCompliancesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppComponentCompliancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAppComponentCompliancesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppComponentCompliancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppComponentCompliancesOutputError>
}

public struct ListAppComponentCompliancesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppComponentCompliancesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListAppComponentCompliancesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppComponentCompliancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/list-app-component-compliances"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAppComponentCompliancesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppComponentCompliancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppComponentCompliancesOutputError>
}

public struct ListAppComponentCompliancesInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the assessment. The format for this ARN is: arn:partition:dcps:region:account:app-assessment/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var assessmentArn: Swift.String?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// Null, or the token from a previous call to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        assessmentArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentArn = assessmentArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAppComponentCompliancesInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
    public let assessmentArn: Swift.String?
}

extension ListAppComponentCompliancesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentArn
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let assessmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentArn)
        assessmentArn = assessmentArnDecoded
    }
}

extension ListAppComponentCompliancesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAppComponentCompliancesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAppComponentCompliancesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAppComponentCompliancesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAppComponentCompliancesOutputResponse(componentCompliances: \(Swift.String(describing: componentCompliances)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAppComponentCompliancesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAppComponentCompliancesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.componentCompliances = output.componentCompliances
            self.nextToken = output.nextToken
        } else {
            self.componentCompliances = nil
            self.nextToken = nil
        }
    }
}

public struct ListAppComponentCompliancesOutputResponse: Swift.Equatable {
    /// The compliances for an AWS Resilience Hub application component, returned as an object. This object contains component names, compliances, costs, resiliency scores, outage scores, and more.
    /// This member is required.
    public var componentCompliances: [ResiliencehubClientTypes.AppComponentCompliance]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        componentCompliances: [ResiliencehubClientTypes.AppComponentCompliance]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.componentCompliances = componentCompliances
        self.nextToken = nextToken
    }
}

struct ListAppComponentCompliancesOutputResponseBody: Swift.Equatable {
    public let componentCompliances: [ResiliencehubClientTypes.AppComponentCompliance]?
    public let nextToken: Swift.String?
}

extension ListAppComponentCompliancesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentCompliances
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentCompliancesContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.AppComponentCompliance?].self, forKey: .componentCompliances)
        var componentCompliancesDecoded0:[ResiliencehubClientTypes.AppComponentCompliance]? = nil
        if let componentCompliancesContainer = componentCompliancesContainer {
            componentCompliancesDecoded0 = [ResiliencehubClientTypes.AppComponentCompliance]()
            for structure0 in componentCompliancesContainer {
                if let structure0 = structure0 {
                    componentCompliancesDecoded0?.append(structure0)
                }
            }
        }
        componentCompliances = componentCompliancesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListAppComponentRecommendationsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppComponentRecommendationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAppComponentRecommendationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppComponentRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAppComponentRecommendationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppComponentRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppComponentRecommendationsOutputError>
}

extension ListAppComponentRecommendationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAppComponentRecommendationsInput(assessmentArn: \(Swift.String(describing: assessmentArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAppComponentRecommendationsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentArn = assessmentArn {
            try encodeContainer.encode(assessmentArn, forKey: .assessmentArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListAppComponentRecommendationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppComponentRecommendationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAppComponentRecommendationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppComponentRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAppComponentRecommendationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppComponentRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppComponentRecommendationsOutputError>
}

public struct ListAppComponentRecommendationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppComponentRecommendationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAppComponentRecommendationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppComponentRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAppComponentRecommendationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppComponentRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppComponentRecommendationsOutputError>
}

public struct ListAppComponentRecommendationsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppComponentRecommendationsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListAppComponentRecommendationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppComponentRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAppComponentRecommendationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppComponentRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppComponentRecommendationsOutputError>
}

public struct ListAppComponentRecommendationsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppComponentRecommendationsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListAppComponentRecommendationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppComponentRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/list-app-component-recommendations"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAppComponentRecommendationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppComponentRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppComponentRecommendationsOutputError>
}

public struct ListAppComponentRecommendationsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the assessment. The format for this ARN is: arn:partition:dcps:region:account:app-assessment/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var assessmentArn: Swift.String?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// Null, or the token from a previous call to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        assessmentArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentArn = assessmentArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAppComponentRecommendationsInputBody: Swift.Equatable {
    public let assessmentArn: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListAppComponentRecommendationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentArn
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentArn)
        assessmentArn = assessmentArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAppComponentRecommendationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAppComponentRecommendationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAppComponentRecommendationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAppComponentRecommendationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAppComponentRecommendationsOutputResponse(componentRecommendations: \(Swift.String(describing: componentRecommendations)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAppComponentRecommendationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAppComponentRecommendationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.componentRecommendations = output.componentRecommendations
            self.nextToken = output.nextToken
        } else {
            self.componentRecommendations = nil
            self.nextToken = nil
        }
    }
}

public struct ListAppComponentRecommendationsOutputResponse: Swift.Equatable {
    /// The recommendations for an Resilience Hub application component, returned as an object. This object contains component names, configuration recommendations, and recommendation statuses.
    /// This member is required.
    public var componentRecommendations: [ResiliencehubClientTypes.ComponentRecommendation]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        componentRecommendations: [ResiliencehubClientTypes.ComponentRecommendation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.componentRecommendations = componentRecommendations
        self.nextToken = nextToken
    }
}

struct ListAppComponentRecommendationsOutputResponseBody: Swift.Equatable {
    public let componentRecommendations: [ResiliencehubClientTypes.ComponentRecommendation]?
    public let nextToken: Swift.String?
}

extension ListAppComponentRecommendationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentRecommendations
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentRecommendationsContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.ComponentRecommendation?].self, forKey: .componentRecommendations)
        var componentRecommendationsDecoded0:[ResiliencehubClientTypes.ComponentRecommendation]? = nil
        if let componentRecommendationsContainer = componentRecommendationsContainer {
            componentRecommendationsDecoded0 = [ResiliencehubClientTypes.ComponentRecommendation]()
            for structure0 in componentRecommendationsContainer {
                if let structure0 = structure0 {
                    componentRecommendationsDecoded0?.append(structure0)
                }
            }
        }
        componentRecommendations = componentRecommendationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListAppVersionResourceMappingsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppVersionResourceMappingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAppVersionResourceMappingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppVersionResourceMappingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAppVersionResourceMappingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppVersionResourceMappingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppVersionResourceMappingsOutputError>
}

extension ListAppVersionResourceMappingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAppVersionResourceMappingsInput(appArn: \(Swift.String(describing: appArn)), appVersion: \(Swift.String(describing: appVersion)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAppVersionResourceMappingsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let appVersion = appVersion {
            try encodeContainer.encode(appVersion, forKey: .appVersion)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListAppVersionResourceMappingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppVersionResourceMappingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAppVersionResourceMappingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppVersionResourceMappingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAppVersionResourceMappingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppVersionResourceMappingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppVersionResourceMappingsOutputError>
}

public struct ListAppVersionResourceMappingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppVersionResourceMappingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAppVersionResourceMappingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppVersionResourceMappingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAppVersionResourceMappingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppVersionResourceMappingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppVersionResourceMappingsOutputError>
}

public struct ListAppVersionResourceMappingsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppVersionResourceMappingsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListAppVersionResourceMappingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppVersionResourceMappingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAppVersionResourceMappingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppVersionResourceMappingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppVersionResourceMappingsOutputError>
}

public struct ListAppVersionResourceMappingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppVersionResourceMappingsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListAppVersionResourceMappingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppVersionResourceMappingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/list-app-version-resource-mappings"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAppVersionResourceMappingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppVersionResourceMappingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppVersionResourceMappingsOutputError>
}

public struct ListAppVersionResourceMappingsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var appArn: Swift.String?
    /// The version of the application.
    /// This member is required.
    public var appVersion: Swift.String?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// Null, or the token from a previous call to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        appArn: Swift.String? = nil,
        appVersion: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.appVersion = appVersion
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAppVersionResourceMappingsInputBody: Swift.Equatable {
    public let appArn: Swift.String?
    public let appVersion: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListAppVersionResourceMappingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAppVersionResourceMappingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAppVersionResourceMappingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAppVersionResourceMappingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAppVersionResourceMappingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAppVersionResourceMappingsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), resourceMappings: \(Swift.String(describing: resourceMappings)))"}
}

extension ListAppVersionResourceMappingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAppVersionResourceMappingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resourceMappings = output.resourceMappings
        } else {
            self.nextToken = nil
            self.resourceMappings = nil
        }
    }
}

public struct ListAppVersionResourceMappingsOutputResponse: Swift.Equatable {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// Mappings used to map logical resources from the template to physical resources. You can use the mapping type CFN_STACK if the application template uses a logical stack name. Or you can map individual resources by using the mapping type RESOURCE. We recommend using the mapping type CFN_STACK if the application is backed by a CloudFormation stack.
    /// This member is required.
    public var resourceMappings: [ResiliencehubClientTypes.ResourceMapping]?

    public init (
        nextToken: Swift.String? = nil,
        resourceMappings: [ResiliencehubClientTypes.ResourceMapping]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceMappings = resourceMappings
    }
}

struct ListAppVersionResourceMappingsOutputResponseBody: Swift.Equatable {
    public let resourceMappings: [ResiliencehubClientTypes.ResourceMapping]?
    public let nextToken: Swift.String?
}

extension ListAppVersionResourceMappingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case resourceMappings
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceMappingsContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.ResourceMapping?].self, forKey: .resourceMappings)
        var resourceMappingsDecoded0:[ResiliencehubClientTypes.ResourceMapping]? = nil
        if let resourceMappingsContainer = resourceMappingsContainer {
            resourceMappingsDecoded0 = [ResiliencehubClientTypes.ResourceMapping]()
            for structure0 in resourceMappingsContainer {
                if let structure0 = structure0 {
                    resourceMappingsDecoded0?.append(structure0)
                }
            }
        }
        resourceMappings = resourceMappingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListAppVersionResourcesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppVersionResourcesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAppVersionResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppVersionResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAppVersionResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppVersionResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppVersionResourcesOutputError>
}

extension ListAppVersionResourcesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAppVersionResourcesInput(appArn: \(Swift.String(describing: appArn)), appVersion: \(Swift.String(describing: appVersion)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), resolutionId: \(Swift.String(describing: resolutionId)))"}
}

extension ListAppVersionResourcesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case maxResults
        case nextToken
        case resolutionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let appVersion = appVersion {
            try encodeContainer.encode(appVersion, forKey: .appVersion)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resolutionId = resolutionId {
            try encodeContainer.encode(resolutionId, forKey: .resolutionId)
        }
    }
}

public struct ListAppVersionResourcesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppVersionResourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAppVersionResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppVersionResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAppVersionResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppVersionResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppVersionResourcesOutputError>
}

public struct ListAppVersionResourcesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppVersionResourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAppVersionResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppVersionResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAppVersionResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppVersionResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppVersionResourcesOutputError>
}

public struct ListAppVersionResourcesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppVersionResourcesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListAppVersionResourcesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppVersionResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAppVersionResourcesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppVersionResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppVersionResourcesOutputError>
}

public struct ListAppVersionResourcesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppVersionResourcesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListAppVersionResourcesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppVersionResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/list-app-version-resources"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAppVersionResourcesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppVersionResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppVersionResourcesOutputError>
}

public struct ListAppVersionResourcesInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var appArn: Swift.String?
    /// The version of the application.
    /// This member is required.
    public var appVersion: Swift.String?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// Null, or the token from a previous call to get the next set of results.
    public var nextToken: Swift.String?
    /// The identifier for a specific resolution.
    public var resolutionId: Swift.String?

    public init (
        appArn: Swift.String? = nil,
        appVersion: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resolutionId: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.appVersion = appVersion
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resolutionId = resolutionId
    }
}

struct ListAppVersionResourcesInputBody: Swift.Equatable {
    public let appArn: Swift.String?
    public let appVersion: Swift.String?
    public let resolutionId: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListAppVersionResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case maxResults
        case nextToken
        case resolutionId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let resolutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolutionId)
        resolutionId = resolutionIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAppVersionResourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAppVersionResourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAppVersionResourcesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAppVersionResourcesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAppVersionResourcesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), physicalResources: \(Swift.String(describing: physicalResources)), resolutionId: \(Swift.String(describing: resolutionId)))"}
}

extension ListAppVersionResourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAppVersionResourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.physicalResources = output.physicalResources
            self.resolutionId = output.resolutionId
        } else {
            self.nextToken = nil
            self.physicalResources = nil
            self.resolutionId = nil
        }
    }
}

public struct ListAppVersionResourcesOutputResponse: Swift.Equatable {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The physical resources in the application version.
    /// This member is required.
    public var physicalResources: [ResiliencehubClientTypes.PhysicalResource]?
    /// The identifier for a specific resolution.
    /// This member is required.
    public var resolutionId: Swift.String?

    public init (
        nextToken: Swift.String? = nil,
        physicalResources: [ResiliencehubClientTypes.PhysicalResource]? = nil,
        resolutionId: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.physicalResources = physicalResources
        self.resolutionId = resolutionId
    }
}

struct ListAppVersionResourcesOutputResponseBody: Swift.Equatable {
    public let physicalResources: [ResiliencehubClientTypes.PhysicalResource]?
    public let resolutionId: Swift.String?
    public let nextToken: Swift.String?
}

extension ListAppVersionResourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case physicalResources
        case resolutionId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let physicalResourcesContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.PhysicalResource?].self, forKey: .physicalResources)
        var physicalResourcesDecoded0:[ResiliencehubClientTypes.PhysicalResource]? = nil
        if let physicalResourcesContainer = physicalResourcesContainer {
            physicalResourcesDecoded0 = [ResiliencehubClientTypes.PhysicalResource]()
            for structure0 in physicalResourcesContainer {
                if let structure0 = structure0 {
                    physicalResourcesDecoded0?.append(structure0)
                }
            }
        }
        physicalResources = physicalResourcesDecoded0
        let resolutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolutionId)
        resolutionId = resolutionIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListAppVersionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppVersionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAppVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAppVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppVersionsOutputError>
}

extension ListAppVersionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAppVersionsInput(appArn: \(Swift.String(describing: appArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAppVersionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListAppVersionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAppVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAppVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppVersionsOutputError>
}

public struct ListAppVersionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAppVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAppVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppVersionsOutputError>
}

public struct ListAppVersionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppVersionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListAppVersionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAppVersionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppVersionsOutputError>
}

public struct ListAppVersionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppVersionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListAppVersionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/list-app-versions"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAppVersionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppVersionsOutputError>
}

public struct ListAppVersionsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var appArn: Swift.String?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// Null, or the token from a previous call to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        appArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAppVersionsInputBody: Swift.Equatable {
    public let appArn: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListAppVersionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAppVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAppVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAppVersionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAppVersionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAppVersionsOutputResponse(appVersions: \(Swift.String(describing: appVersions)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAppVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAppVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appVersions = output.appVersions
            self.nextToken = output.nextToken
        } else {
            self.appVersions = nil
            self.nextToken = nil
        }
    }
}

public struct ListAppVersionsOutputResponse: Swift.Equatable {
    /// The version of the application.
    /// This member is required.
    public var appVersions: [ResiliencehubClientTypes.AppVersionSummary]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        appVersions: [ResiliencehubClientTypes.AppVersionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appVersions = appVersions
        self.nextToken = nextToken
    }
}

struct ListAppVersionsOutputResponseBody: Swift.Equatable {
    public let appVersions: [ResiliencehubClientTypes.AppVersionSummary]?
    public let nextToken: Swift.String?
}

extension ListAppVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appVersions
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appVersionsContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.AppVersionSummary?].self, forKey: .appVersions)
        var appVersionsDecoded0:[ResiliencehubClientTypes.AppVersionSummary]? = nil
        if let appVersionsContainer = appVersionsContainer {
            appVersionsDecoded0 = [ResiliencehubClientTypes.AppVersionSummary]()
            for structure0 in appVersionsContainer {
                if let structure0 = structure0 {
                    appVersionsDecoded0?.append(structure0)
                }
            }
        }
        appVersions = appVersionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAppsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAppsInput(appArn: \(Swift.String(describing: appArn)), maxResults: \(Swift.String(describing: maxResults)), name: \(Swift.String(describing: name)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAppsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListAppsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAppsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAppsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppsOutputError>
}

public struct ListAppsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAppsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let name = input.operationInput.name {
            let nameQueryItem = ClientRuntime.URLQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(name).urlPercentEncoding())
            input.builder.withQueryItem(nameQueryItem)
        }
        if let appArn = input.operationInput.appArn {
            let appArnQueryItem = ClientRuntime.URLQueryItem(name: "appArn".urlPercentEncoding(), value: Swift.String(appArn).urlPercentEncoding())
            input.builder.withQueryItem(appArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAppsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppsOutputError>
}

public struct ListAppsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListAppsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAppsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppsOutputError>
}

public struct ListAppsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListAppsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/list-apps"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAppsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppsOutputError>
}

public struct ListAppsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    public var appArn: Swift.String?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// The name for the one of the listed applications.
    public var name: Swift.String?
    /// Null, or the token from a previous call to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        appArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

struct ListAppsInputBody: Swift.Equatable {
}

extension ListAppsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAppsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAppsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAppsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAppsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAppsOutputResponse(appSummaries: \(Swift.String(describing: appSummaries)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAppsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAppsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appSummaries = output.appSummaries
            self.nextToken = output.nextToken
        } else {
            self.appSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListAppsOutputResponse: Swift.Equatable {
    /// Summaries for the Resilience Hub application.
    /// This member is required.
    public var appSummaries: [ResiliencehubClientTypes.AppSummary]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        appSummaries: [ResiliencehubClientTypes.AppSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appSummaries = appSummaries
        self.nextToken = nextToken
    }
}

struct ListAppsOutputResponseBody: Swift.Equatable {
    public let appSummaries: [ResiliencehubClientTypes.AppSummary]?
    public let nextToken: Swift.String?
}

extension ListAppsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appSummaries
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appSummariesContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.AppSummary?].self, forKey: .appSummaries)
        var appSummariesDecoded0:[ResiliencehubClientTypes.AppSummary]? = nil
        if let appSummariesContainer = appSummariesContainer {
            appSummariesDecoded0 = [ResiliencehubClientTypes.AppSummary]()
            for structure0 in appSummariesContainer {
                if let structure0 = structure0 {
                    appSummariesDecoded0?.append(structure0)
                }
            }
        }
        appSummaries = appSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRecommendationTemplatesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRecommendationTemplatesInput(assessmentArn: \(Swift.String(describing: assessmentArn)), maxResults: \(Swift.String(describing: maxResults)), name: \(Swift.String(describing: name)), nextToken: \(Swift.String(describing: nextToken)), recommendationTemplateArn: \(Swift.String(describing: recommendationTemplateArn)), reverseOrder: \(Swift.String(describing: reverseOrder)), status: \(Swift.String(describing: status)))"}
}

extension ListRecommendationTemplatesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListRecommendationTemplatesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRecommendationTemplatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRecommendationTemplatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRecommendationTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRecommendationTemplatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRecommendationTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRecommendationTemplatesOutputError>
}

public struct ListRecommendationTemplatesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRecommendationTemplatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRecommendationTemplatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRecommendationTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let reverseOrder = input.operationInput.reverseOrder {
            let reverseOrderQueryItem = ClientRuntime.URLQueryItem(name: "reverseOrder".urlPercentEncoding(), value: Swift.String(reverseOrder).urlPercentEncoding())
            input.builder.withQueryItem(reverseOrderQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let name = input.operationInput.name {
            let nameQueryItem = ClientRuntime.URLQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(name).urlPercentEncoding())
            input.builder.withQueryItem(nameQueryItem)
        }
        if let assessmentArn = input.operationInput.assessmentArn {
            let assessmentArnQueryItem = ClientRuntime.URLQueryItem(name: "assessmentArn".urlPercentEncoding(), value: Swift.String(assessmentArn).urlPercentEncoding())
            input.builder.withQueryItem(assessmentArnQueryItem)
        }
        if let recommendationTemplateArn = input.operationInput.recommendationTemplateArn {
            let recommendationTemplateArnQueryItem = ClientRuntime.URLQueryItem(name: "recommendationTemplateArn".urlPercentEncoding(), value: Swift.String(recommendationTemplateArn).urlPercentEncoding())
            input.builder.withQueryItem(recommendationTemplateArnQueryItem)
        }
        if let status = input.operationInput.status {
            status.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRecommendationTemplatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRecommendationTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRecommendationTemplatesOutputError>
}

public struct ListRecommendationTemplatesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRecommendationTemplatesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListRecommendationTemplatesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRecommendationTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListRecommendationTemplatesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListRecommendationTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRecommendationTemplatesOutputError>
}

public struct ListRecommendationTemplatesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRecommendationTemplatesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListRecommendationTemplatesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRecommendationTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/list-recommendation-templates"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListRecommendationTemplatesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListRecommendationTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRecommendationTemplatesOutputError>
}

public struct ListRecommendationTemplatesInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the assessment. The format for this ARN is: arn:partition:dcps:region:account:app-assessment/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var assessmentArn: Swift.String?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// The name for one of the listed recommendation templates.
    public var name: Swift.String?
    /// Null, or the token from a previous call to get the next set of results.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) for a recommendation template.
    public var recommendationTemplateArn: Swift.String?
    /// The default is to sort by ascending startTime. To sort by descending startTime, set reverseOrder to true.
    public var reverseOrder: Swift.Bool?
    /// The status of the action.
    public var status: [ResiliencehubClientTypes.RecommendationTemplateStatus]?

    public init (
        assessmentArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        recommendationTemplateArn: Swift.String? = nil,
        reverseOrder: Swift.Bool? = nil,
        status: [ResiliencehubClientTypes.RecommendationTemplateStatus]? = nil
    )
    {
        self.assessmentArn = assessmentArn
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.recommendationTemplateArn = recommendationTemplateArn
        self.reverseOrder = reverseOrder
        self.status = status
    }
}

struct ListRecommendationTemplatesInputBody: Swift.Equatable {
}

extension ListRecommendationTemplatesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListRecommendationTemplatesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRecommendationTemplatesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRecommendationTemplatesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRecommendationTemplatesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRecommendationTemplatesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), recommendationTemplates: \(Swift.String(describing: recommendationTemplates)))"}
}

extension ListRecommendationTemplatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListRecommendationTemplatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.recommendationTemplates = output.recommendationTemplates
        } else {
            self.nextToken = nil
            self.recommendationTemplates = nil
        }
    }
}

public struct ListRecommendationTemplatesOutputResponse: Swift.Equatable {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The recommendation templates for the Resilience Hub applications.
    public var recommendationTemplates: [ResiliencehubClientTypes.RecommendationTemplate]?

    public init (
        nextToken: Swift.String? = nil,
        recommendationTemplates: [ResiliencehubClientTypes.RecommendationTemplate]? = nil
    )
    {
        self.nextToken = nextToken
        self.recommendationTemplates = recommendationTemplates
    }
}

struct ListRecommendationTemplatesOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let recommendationTemplates: [ResiliencehubClientTypes.RecommendationTemplate]?
}

extension ListRecommendationTemplatesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case recommendationTemplates
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let recommendationTemplatesContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.RecommendationTemplate?].self, forKey: .recommendationTemplates)
        var recommendationTemplatesDecoded0:[ResiliencehubClientTypes.RecommendationTemplate]? = nil
        if let recommendationTemplatesContainer = recommendationTemplatesContainer {
            recommendationTemplatesDecoded0 = [ResiliencehubClientTypes.RecommendationTemplate]()
            for structure0 in recommendationTemplatesContainer {
                if let structure0 = structure0 {
                    recommendationTemplatesDecoded0?.append(structure0)
                }
            }
        }
        recommendationTemplates = recommendationTemplatesDecoded0
    }
}

extension ListResiliencyPoliciesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListResiliencyPoliciesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), policyName: \(Swift.String(describing: policyName)))"}
}

extension ListResiliencyPoliciesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListResiliencyPoliciesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResiliencyPoliciesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListResiliencyPoliciesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResiliencyPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListResiliencyPoliciesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListResiliencyPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResiliencyPoliciesOutputError>
}

public struct ListResiliencyPoliciesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResiliencyPoliciesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListResiliencyPoliciesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResiliencyPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let policyName = input.operationInput.policyName {
            let policyNameQueryItem = ClientRuntime.URLQueryItem(name: "policyName".urlPercentEncoding(), value: Swift.String(policyName).urlPercentEncoding())
            input.builder.withQueryItem(policyNameQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListResiliencyPoliciesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListResiliencyPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResiliencyPoliciesOutputError>
}

public struct ListResiliencyPoliciesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResiliencyPoliciesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListResiliencyPoliciesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResiliencyPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListResiliencyPoliciesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListResiliencyPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResiliencyPoliciesOutputError>
}

public struct ListResiliencyPoliciesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResiliencyPoliciesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListResiliencyPoliciesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResiliencyPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/list-resiliency-policies"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListResiliencyPoliciesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListResiliencyPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResiliencyPoliciesOutputError>
}

public struct ListResiliencyPoliciesInput: Swift.Equatable {
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// Null, or the token from a previous call to get the next set of results.
    public var nextToken: Swift.String?
    /// The name of the policy
    public var policyName: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        policyName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.policyName = policyName
    }
}

struct ListResiliencyPoliciesInputBody: Swift.Equatable {
}

extension ListResiliencyPoliciesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListResiliencyPoliciesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResiliencyPoliciesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResiliencyPoliciesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResiliencyPoliciesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListResiliencyPoliciesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), resiliencyPolicies: \(Swift.String(describing: resiliencyPolicies)))"}
}

extension ListResiliencyPoliciesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListResiliencyPoliciesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resiliencyPolicies = output.resiliencyPolicies
        } else {
            self.nextToken = nil
            self.resiliencyPolicies = nil
        }
    }
}

public struct ListResiliencyPoliciesOutputResponse: Swift.Equatable {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The resiliency policies for the Resilience Hub applications.
    /// This member is required.
    public var resiliencyPolicies: [ResiliencehubClientTypes.ResiliencyPolicy]?

    public init (
        nextToken: Swift.String? = nil,
        resiliencyPolicies: [ResiliencehubClientTypes.ResiliencyPolicy]? = nil
    )
    {
        self.nextToken = nextToken
        self.resiliencyPolicies = resiliencyPolicies
    }
}

struct ListResiliencyPoliciesOutputResponseBody: Swift.Equatable {
    public let resiliencyPolicies: [ResiliencehubClientTypes.ResiliencyPolicy]?
    public let nextToken: Swift.String?
}

extension ListResiliencyPoliciesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case resiliencyPolicies
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resiliencyPoliciesContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.ResiliencyPolicy?].self, forKey: .resiliencyPolicies)
        var resiliencyPoliciesDecoded0:[ResiliencehubClientTypes.ResiliencyPolicy]? = nil
        if let resiliencyPoliciesContainer = resiliencyPoliciesContainer {
            resiliencyPoliciesDecoded0 = [ResiliencehubClientTypes.ResiliencyPolicy]()
            for structure0 in resiliencyPoliciesContainer {
                if let structure0 = structure0 {
                    resiliencyPoliciesDecoded0?.append(structure0)
                }
            }
        }
        resiliencyPolicies = resiliencyPoliciesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListSopRecommendationsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSopRecommendationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSopRecommendationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSopRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSopRecommendationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSopRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSopRecommendationsOutputError>
}

extension ListSopRecommendationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSopRecommendationsInput(assessmentArn: \(Swift.String(describing: assessmentArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListSopRecommendationsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentArn = assessmentArn {
            try encodeContainer.encode(assessmentArn, forKey: .assessmentArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListSopRecommendationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSopRecommendationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSopRecommendationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSopRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSopRecommendationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSopRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSopRecommendationsOutputError>
}

public struct ListSopRecommendationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSopRecommendationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSopRecommendationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSopRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSopRecommendationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSopRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSopRecommendationsOutputError>
}

public struct ListSopRecommendationsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSopRecommendationsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListSopRecommendationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSopRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListSopRecommendationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListSopRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSopRecommendationsOutputError>
}

public struct ListSopRecommendationsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSopRecommendationsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListSopRecommendationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSopRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/list-sop-recommendations"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListSopRecommendationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListSopRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSopRecommendationsOutputError>
}

public struct ListSopRecommendationsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the assessment. The format for this ARN is: arn:partition:dcps:region:account:app-assessment/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var assessmentArn: Swift.String?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// Null, or the token from a previous call to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        assessmentArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentArn = assessmentArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSopRecommendationsInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
    public let assessmentArn: Swift.String?
}

extension ListSopRecommendationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentArn
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let assessmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentArn)
        assessmentArn = assessmentArnDecoded
    }
}

extension ListSopRecommendationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSopRecommendationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSopRecommendationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSopRecommendationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSopRecommendationsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), sopRecommendations: \(Swift.String(describing: sopRecommendations)))"}
}

extension ListSopRecommendationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListSopRecommendationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.sopRecommendations = output.sopRecommendations
        } else {
            self.nextToken = nil
            self.sopRecommendations = nil
        }
    }
}

public struct ListSopRecommendationsOutputResponse: Swift.Equatable {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The standard operating procedure (SOP) recommendations for the Resilience Hub applications.
    /// This member is required.
    public var sopRecommendations: [ResiliencehubClientTypes.SopRecommendation]?

    public init (
        nextToken: Swift.String? = nil,
        sopRecommendations: [ResiliencehubClientTypes.SopRecommendation]? = nil
    )
    {
        self.nextToken = nextToken
        self.sopRecommendations = sopRecommendations
    }
}

struct ListSopRecommendationsOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let sopRecommendations: [ResiliencehubClientTypes.SopRecommendation]?
}

extension ListSopRecommendationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case sopRecommendations
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let sopRecommendationsContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.SopRecommendation?].self, forKey: .sopRecommendations)
        var sopRecommendationsDecoded0:[ResiliencehubClientTypes.SopRecommendation]? = nil
        if let sopRecommendationsContainer = sopRecommendationsContainer {
            sopRecommendationsDecoded0 = [ResiliencehubClientTypes.SopRecommendation]()
            for structure0 in sopRecommendationsContainer {
                if let structure0 = structure0 {
                    sopRecommendationsDecoded0?.append(structure0)
                }
            }
        }
        sopRecommendations = sopRecommendationsDecoded0
    }
}

extension ListSuggestedResiliencyPoliciesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSuggestedResiliencyPoliciesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListSuggestedResiliencyPoliciesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListSuggestedResiliencyPoliciesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSuggestedResiliencyPoliciesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSuggestedResiliencyPoliciesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSuggestedResiliencyPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSuggestedResiliencyPoliciesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSuggestedResiliencyPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSuggestedResiliencyPoliciesOutputError>
}

public struct ListSuggestedResiliencyPoliciesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSuggestedResiliencyPoliciesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSuggestedResiliencyPoliciesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSuggestedResiliencyPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSuggestedResiliencyPoliciesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSuggestedResiliencyPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSuggestedResiliencyPoliciesOutputError>
}

public struct ListSuggestedResiliencyPoliciesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSuggestedResiliencyPoliciesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListSuggestedResiliencyPoliciesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSuggestedResiliencyPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListSuggestedResiliencyPoliciesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListSuggestedResiliencyPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSuggestedResiliencyPoliciesOutputError>
}

public struct ListSuggestedResiliencyPoliciesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSuggestedResiliencyPoliciesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListSuggestedResiliencyPoliciesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSuggestedResiliencyPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/list-suggested-resiliency-policies"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListSuggestedResiliencyPoliciesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListSuggestedResiliencyPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSuggestedResiliencyPoliciesOutputError>
}

public struct ListSuggestedResiliencyPoliciesInput: Swift.Equatable {
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// Null, or the token from a previous call to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSuggestedResiliencyPoliciesInputBody: Swift.Equatable {
}

extension ListSuggestedResiliencyPoliciesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListSuggestedResiliencyPoliciesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSuggestedResiliencyPoliciesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSuggestedResiliencyPoliciesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSuggestedResiliencyPoliciesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSuggestedResiliencyPoliciesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), resiliencyPolicies: \(Swift.String(describing: resiliencyPolicies)))"}
}

extension ListSuggestedResiliencyPoliciesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListSuggestedResiliencyPoliciesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resiliencyPolicies = output.resiliencyPolicies
        } else {
            self.nextToken = nil
            self.resiliencyPolicies = nil
        }
    }
}

public struct ListSuggestedResiliencyPoliciesOutputResponse: Swift.Equatable {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The suggested resiliency policies for the Resilience Hub applications.
    /// This member is required.
    public var resiliencyPolicies: [ResiliencehubClientTypes.ResiliencyPolicy]?

    public init (
        nextToken: Swift.String? = nil,
        resiliencyPolicies: [ResiliencehubClientTypes.ResiliencyPolicy]? = nil
    )
    {
        self.nextToken = nextToken
        self.resiliencyPolicies = resiliencyPolicies
    }
}

struct ListSuggestedResiliencyPoliciesOutputResponseBody: Swift.Equatable {
    public let resiliencyPolicies: [ResiliencehubClientTypes.ResiliencyPolicy]?
    public let nextToken: Swift.String?
}

extension ListSuggestedResiliencyPoliciesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case resiliencyPolicies
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resiliencyPoliciesContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.ResiliencyPolicy?].self, forKey: .resiliencyPolicies)
        var resiliencyPoliciesDecoded0:[ResiliencehubClientTypes.ResiliencyPolicy]? = nil
        if let resiliencyPoliciesContainer = resiliencyPoliciesContainer {
            resiliencyPoliciesDecoded0 = [ResiliencehubClientTypes.ResiliencyPolicy]()
            for structure0 in resiliencyPoliciesContainer {
                if let structure0 = structure0 {
                    resiliencyPoliciesDecoded0?.append(structure0)
                }
            }
        }
        resiliencyPolicies = resiliencyPoliciesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for a specific resource in your Resilience Hub application.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags assigned to the resource. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key/value pair.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct ListTestRecommendationsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTestRecommendationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTestRecommendationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTestRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTestRecommendationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTestRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTestRecommendationsOutputError>
}

extension ListTestRecommendationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTestRecommendationsInput(assessmentArn: \(Swift.String(describing: assessmentArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListTestRecommendationsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentArn = assessmentArn {
            try encodeContainer.encode(assessmentArn, forKey: .assessmentArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListTestRecommendationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTestRecommendationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTestRecommendationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTestRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTestRecommendationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTestRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTestRecommendationsOutputError>
}

public struct ListTestRecommendationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTestRecommendationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTestRecommendationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTestRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTestRecommendationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTestRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTestRecommendationsOutputError>
}

public struct ListTestRecommendationsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTestRecommendationsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListTestRecommendationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTestRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTestRecommendationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTestRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTestRecommendationsOutputError>
}

public struct ListTestRecommendationsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTestRecommendationsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListTestRecommendationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTestRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/list-test-recommendations"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTestRecommendationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTestRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTestRecommendationsOutputError>
}

public struct ListTestRecommendationsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the assessment. The format for this ARN is: arn:partition:dcps:region:account:app-assessment/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var assessmentArn: Swift.String?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// Null, or the token from a previous call to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        assessmentArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentArn = assessmentArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListTestRecommendationsInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
    public let assessmentArn: Swift.String?
}

extension ListTestRecommendationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentArn
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let assessmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentArn)
        assessmentArn = assessmentArnDecoded
    }
}

extension ListTestRecommendationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTestRecommendationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTestRecommendationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTestRecommendationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTestRecommendationsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), testRecommendations: \(Swift.String(describing: testRecommendations)))"}
}

extension ListTestRecommendationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTestRecommendationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.testRecommendations = output.testRecommendations
        } else {
            self.nextToken = nil
            self.testRecommendations = nil
        }
    }
}

public struct ListTestRecommendationsOutputResponse: Swift.Equatable {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The test recommendations for the Resilience Hub application.
    /// This member is required.
    public var testRecommendations: [ResiliencehubClientTypes.TestRecommendation]?

    public init (
        nextToken: Swift.String? = nil,
        testRecommendations: [ResiliencehubClientTypes.TestRecommendation]? = nil
    )
    {
        self.nextToken = nextToken
        self.testRecommendations = testRecommendations
    }
}

struct ListTestRecommendationsOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let testRecommendations: [ResiliencehubClientTypes.TestRecommendation]?
}

extension ListTestRecommendationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case testRecommendations
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let testRecommendationsContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.TestRecommendation?].self, forKey: .testRecommendations)
        var testRecommendationsDecoded0:[ResiliencehubClientTypes.TestRecommendation]? = nil
        if let testRecommendationsContainer = testRecommendationsContainer {
            testRecommendationsDecoded0 = [ResiliencehubClientTypes.TestRecommendation]()
            for structure0 in testRecommendationsContainer {
                if let structure0 = structure0 {
                    testRecommendationsDecoded0?.append(structure0)
                }
            }
        }
        testRecommendations = testRecommendationsDecoded0
    }
}

public struct ListUnsupportedAppVersionResourcesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListUnsupportedAppVersionResourcesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListUnsupportedAppVersionResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListUnsupportedAppVersionResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListUnsupportedAppVersionResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListUnsupportedAppVersionResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListUnsupportedAppVersionResourcesOutputError>
}

extension ListUnsupportedAppVersionResourcesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListUnsupportedAppVersionResourcesInput(appArn: \(Swift.String(describing: appArn)), appVersion: \(Swift.String(describing: appVersion)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), resolutionId: \(Swift.String(describing: resolutionId)))"}
}

extension ListUnsupportedAppVersionResourcesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case maxResults
        case nextToken
        case resolutionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let appVersion = appVersion {
            try encodeContainer.encode(appVersion, forKey: .appVersion)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resolutionId = resolutionId {
            try encodeContainer.encode(resolutionId, forKey: .resolutionId)
        }
    }
}

public struct ListUnsupportedAppVersionResourcesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListUnsupportedAppVersionResourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListUnsupportedAppVersionResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListUnsupportedAppVersionResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListUnsupportedAppVersionResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListUnsupportedAppVersionResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListUnsupportedAppVersionResourcesOutputError>
}

public struct ListUnsupportedAppVersionResourcesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListUnsupportedAppVersionResourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListUnsupportedAppVersionResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListUnsupportedAppVersionResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListUnsupportedAppVersionResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListUnsupportedAppVersionResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListUnsupportedAppVersionResourcesOutputError>
}

public struct ListUnsupportedAppVersionResourcesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListUnsupportedAppVersionResourcesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListUnsupportedAppVersionResourcesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListUnsupportedAppVersionResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListUnsupportedAppVersionResourcesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListUnsupportedAppVersionResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListUnsupportedAppVersionResourcesOutputError>
}

public struct ListUnsupportedAppVersionResourcesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListUnsupportedAppVersionResourcesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListUnsupportedAppVersionResourcesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListUnsupportedAppVersionResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/list-unsupported-app-version-resources"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListUnsupportedAppVersionResourcesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListUnsupportedAppVersionResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListUnsupportedAppVersionResourcesOutputError>
}

public struct ListUnsupportedAppVersionResourcesInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var appArn: Swift.String?
    /// The version of the application.
    /// This member is required.
    public var appVersion: Swift.String?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// Null, or the token from a previous call to get the next set of results.
    public var nextToken: Swift.String?
    /// The identifier for a specific resolution.
    public var resolutionId: Swift.String?

    public init (
        appArn: Swift.String? = nil,
        appVersion: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resolutionId: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.appVersion = appVersion
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resolutionId = resolutionId
    }
}

struct ListUnsupportedAppVersionResourcesInputBody: Swift.Equatable {
    public let appArn: Swift.String?
    public let appVersion: Swift.String?
    public let resolutionId: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListUnsupportedAppVersionResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case maxResults
        case nextToken
        case resolutionId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let resolutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolutionId)
        resolutionId = resolutionIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListUnsupportedAppVersionResourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListUnsupportedAppVersionResourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListUnsupportedAppVersionResourcesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListUnsupportedAppVersionResourcesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListUnsupportedAppVersionResourcesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), resolutionId: \(Swift.String(describing: resolutionId)), unsupportedResources: \(Swift.String(describing: unsupportedResources)))"}
}

extension ListUnsupportedAppVersionResourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListUnsupportedAppVersionResourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resolutionId = output.resolutionId
            self.unsupportedResources = output.unsupportedResources
        } else {
            self.nextToken = nil
            self.resolutionId = nil
            self.unsupportedResources = nil
        }
    }
}

public struct ListUnsupportedAppVersionResourcesOutputResponse: Swift.Equatable {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The identifier for a specific resolution.
    /// This member is required.
    public var resolutionId: Swift.String?
    /// The unsupported resources for the application.
    /// This member is required.
    public var unsupportedResources: [ResiliencehubClientTypes.UnsupportedResource]?

    public init (
        nextToken: Swift.String? = nil,
        resolutionId: Swift.String? = nil,
        unsupportedResources: [ResiliencehubClientTypes.UnsupportedResource]? = nil
    )
    {
        self.nextToken = nextToken
        self.resolutionId = resolutionId
        self.unsupportedResources = unsupportedResources
    }
}

struct ListUnsupportedAppVersionResourcesOutputResponseBody: Swift.Equatable {
    public let unsupportedResources: [ResiliencehubClientTypes.UnsupportedResource]?
    public let resolutionId: Swift.String?
    public let nextToken: Swift.String?
}

extension ListUnsupportedAppVersionResourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case resolutionId
        case unsupportedResources
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unsupportedResourcesContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.UnsupportedResource?].self, forKey: .unsupportedResources)
        var unsupportedResourcesDecoded0:[ResiliencehubClientTypes.UnsupportedResource]? = nil
        if let unsupportedResourcesContainer = unsupportedResourcesContainer {
            unsupportedResourcesDecoded0 = [ResiliencehubClientTypes.UnsupportedResource]()
            for structure0 in unsupportedResourcesContainer {
                if let structure0 = structure0 {
                    unsupportedResourcesDecoded0?.append(structure0)
                }
            }
        }
        unsupportedResources = unsupportedResourcesDecoded0
        let resolutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolutionId)
        resolutionId = resolutionIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ResiliencehubClientTypes.LogicalResourceId: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier
        case logicalStackName
        case resourceGroupName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifier = identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let logicalStackName = logicalStackName {
            try encodeContainer.encode(logicalStackName, forKey: .logicalStackName)
        }
        if let resourceGroupName = resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let logicalStackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logicalStackName)
        logicalStackName = logicalStackNameDecoded
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
    }
}

extension ResiliencehubClientTypes.LogicalResourceId: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LogicalResourceId(identifier: \(Swift.String(describing: identifier)), logicalStackName: \(Swift.String(describing: logicalStackName)), resourceGroupName: \(Swift.String(describing: resourceGroupName)))"}
}

extension ResiliencehubClientTypes {
    /// Defines a logical resource identifier.
    public struct LogicalResourceId: Swift.Equatable {
        /// The identifier of the resource.
        /// This member is required.
        public var identifier: Swift.String?
        /// The name of the CloudFormation stack this resource belongs to.
        public var logicalStackName: Swift.String?
        /// The name of the resource group that this resource belongs to.
        public var resourceGroupName: Swift.String?

        public init (
            identifier: Swift.String? = nil,
            logicalStackName: Swift.String? = nil,
            resourceGroupName: Swift.String? = nil
        )
        {
            self.identifier = identifier
            self.logicalStackName = logicalStackName
            self.resourceGroupName = resourceGroupName
        }
    }

}

extension ResiliencehubClientTypes {
    public enum PhysicalIdentifierType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case arn
        case native
        case sdkUnknown(Swift.String)

        public static var allCases: [PhysicalIdentifierType] {
            return [
                .arn,
                .native,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .arn: return "Arn"
            case .native: return "Native"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PhysicalIdentifierType(rawValue: rawValue) ?? PhysicalIdentifierType.sdkUnknown(rawValue)
        }
    }
}

extension ResiliencehubClientTypes.PhysicalResource: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appComponents
        case logicalResourceId
        case physicalResourceId
        case resourceName
        case resourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appComponents = appComponents {
            var appComponentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .appComponents)
            for appcomponentlist0 in appComponents {
                try appComponentsContainer.encode(appcomponentlist0)
            }
        }
        if let logicalResourceId = logicalResourceId {
            try encodeContainer.encode(logicalResourceId, forKey: .logicalResourceId)
        }
        if let physicalResourceId = physicalResourceId {
            try encodeContainer.encode(physicalResourceId, forKey: .physicalResourceId)
        }
        if let resourceName = resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
        let logicalResourceIdDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.LogicalResourceId.self, forKey: .logicalResourceId)
        logicalResourceId = logicalResourceIdDecoded
        let physicalResourceIdDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.PhysicalResourceId.self, forKey: .physicalResourceId)
        physicalResourceId = physicalResourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let appComponentsContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.AppComponent?].self, forKey: .appComponents)
        var appComponentsDecoded0:[ResiliencehubClientTypes.AppComponent]? = nil
        if let appComponentsContainer = appComponentsContainer {
            appComponentsDecoded0 = [ResiliencehubClientTypes.AppComponent]()
            for structure0 in appComponentsContainer {
                if let structure0 = structure0 {
                    appComponentsDecoded0?.append(structure0)
                }
            }
        }
        appComponents = appComponentsDecoded0
    }
}

extension ResiliencehubClientTypes.PhysicalResource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PhysicalResource(appComponents: \(Swift.String(describing: appComponents)), logicalResourceId: \(Swift.String(describing: logicalResourceId)), physicalResourceId: \(Swift.String(describing: physicalResourceId)), resourceName: \(Swift.String(describing: resourceName)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension ResiliencehubClientTypes {
    /// Defines a physical resource. A physical resource is a resource that exists in your account. It can be identified using an Amazon Resource Name (ARN) or a Resilience Hub-native identifier.
    public struct PhysicalResource: Swift.Equatable {
        /// The application components that belong to this resource.
        public var appComponents: [ResiliencehubClientTypes.AppComponent]?
        /// The logical identifier of the resource.
        /// This member is required.
        public var logicalResourceId: ResiliencehubClientTypes.LogicalResourceId?
        /// The physical identifier of the resource.
        /// This member is required.
        public var physicalResourceId: ResiliencehubClientTypes.PhysicalResourceId?
        /// The name of the resource.
        public var resourceName: Swift.String?
        /// The type of resource.
        /// This member is required.
        public var resourceType: Swift.String?

        public init (
            appComponents: [ResiliencehubClientTypes.AppComponent]? = nil,
            logicalResourceId: ResiliencehubClientTypes.LogicalResourceId? = nil,
            physicalResourceId: ResiliencehubClientTypes.PhysicalResourceId? = nil,
            resourceName: Swift.String? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.appComponents = appComponents
            self.logicalResourceId = logicalResourceId
            self.physicalResourceId = physicalResourceId
            self.resourceName = resourceName
            self.resourceType = resourceType
        }
    }

}

extension ResiliencehubClientTypes.PhysicalResourceId: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountId
        case awsRegion
        case identifier
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsAccountId = awsAccountId {
            try encodeContainer.encode(awsAccountId, forKey: .awsAccountId)
        }
        if let awsRegion = awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let identifier = identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.PhysicalIdentifierType.self, forKey: .type)
        type = typeDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
    }
}

extension ResiliencehubClientTypes.PhysicalResourceId: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PhysicalResourceId(awsAccountId: \(Swift.String(describing: awsAccountId)), awsRegion: \(Swift.String(describing: awsRegion)), identifier: \(Swift.String(describing: identifier)), type: \(Swift.String(describing: type)))"}
}

extension ResiliencehubClientTypes {
    /// Defines a physical resource identifier.
    public struct PhysicalResourceId: Swift.Equatable {
        /// The Amazon Web Services account that owns the physical resource.
        public var awsAccountId: Swift.String?
        /// The Amazon Web Services Region that the physical resource is located in.
        public var awsRegion: Swift.String?
        /// The identifier of the physical resource.
        /// This member is required.
        public var identifier: Swift.String?
        /// Specifies the type of physical resource identifier. Arn The resource identifier is an Amazon Resource Name (ARN) . Native The resource identifier is a Resilience Hub-native identifier.
        /// This member is required.
        public var type: ResiliencehubClientTypes.PhysicalIdentifierType?

        public init (
            awsAccountId: Swift.String? = nil,
            awsRegion: Swift.String? = nil,
            identifier: Swift.String? = nil,
            type: ResiliencehubClientTypes.PhysicalIdentifierType? = nil
        )
        {
            self.awsAccountId = awsAccountId
            self.awsRegion = awsRegion
            self.identifier = identifier
            self.type = type
        }
    }

}

public struct PublishAppVersionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PublishAppVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PublishAppVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PublishAppVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PublishAppVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PublishAppVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PublishAppVersionOutputError>
}

extension PublishAppVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PublishAppVersionInput(appArn: \(Swift.String(describing: appArn)))"}
}

extension PublishAppVersionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
    }
}

public struct PublishAppVersionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PublishAppVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PublishAppVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PublishAppVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PublishAppVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PublishAppVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PublishAppVersionOutputError>
}

public struct PublishAppVersionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PublishAppVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PublishAppVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PublishAppVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PublishAppVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PublishAppVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PublishAppVersionOutputError>
}

public struct PublishAppVersionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PublishAppVersionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: PublishAppVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PublishAppVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PublishAppVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<PublishAppVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PublishAppVersionOutputError>
}

public struct PublishAppVersionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PublishAppVersionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: PublishAppVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PublishAppVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/publish-app-version"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PublishAppVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<PublishAppVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PublishAppVersionOutputError>
}

public struct PublishAppVersionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var appArn: Swift.String?

    public init (
        appArn: Swift.String? = nil
    )
    {
        self.appArn = appArn
    }
}

struct PublishAppVersionInputBody: Swift.Equatable {
    public let appArn: Swift.String?
}

extension PublishAppVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
    }
}

extension PublishAppVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PublishAppVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PublishAppVersionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PublishAppVersionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PublishAppVersionOutputResponse(appArn: \(Swift.String(describing: appArn)), appVersion: \(Swift.String(describing: appVersion)))"}
}

extension PublishAppVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PublishAppVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appArn = output.appArn
            self.appVersion = output.appVersion
        } else {
            self.appArn = nil
            self.appVersion = nil
        }
    }
}

public struct PublishAppVersionOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var appArn: Swift.String?
    /// The version of the application.
    public var appVersion: Swift.String?

    public init (
        appArn: Swift.String? = nil,
        appVersion: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.appVersion = appVersion
    }
}

struct PublishAppVersionOutputResponseBody: Swift.Equatable {
    public let appArn: Swift.String?
    public let appVersion: Swift.String?
}

extension PublishAppVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
    }
}

public struct PutDraftAppVersionTemplateInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutDraftAppVersionTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutDraftAppVersionTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutDraftAppVersionTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutDraftAppVersionTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutDraftAppVersionTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutDraftAppVersionTemplateOutputError>
}

extension PutDraftAppVersionTemplateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutDraftAppVersionTemplateInput(appArn: \(Swift.String(describing: appArn)), appTemplateBody: \(Swift.String(describing: appTemplateBody)))"}
}

extension PutDraftAppVersionTemplateInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appTemplateBody
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let appTemplateBody = appTemplateBody {
            try encodeContainer.encode(appTemplateBody, forKey: .appTemplateBody)
        }
    }
}

public struct PutDraftAppVersionTemplateInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutDraftAppVersionTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutDraftAppVersionTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutDraftAppVersionTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutDraftAppVersionTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutDraftAppVersionTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutDraftAppVersionTemplateOutputError>
}

public struct PutDraftAppVersionTemplateInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutDraftAppVersionTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutDraftAppVersionTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutDraftAppVersionTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutDraftAppVersionTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutDraftAppVersionTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutDraftAppVersionTemplateOutputError>
}

public struct PutDraftAppVersionTemplateInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutDraftAppVersionTemplateInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: PutDraftAppVersionTemplateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutDraftAppVersionTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutDraftAppVersionTemplateInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutDraftAppVersionTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutDraftAppVersionTemplateOutputError>
}

public struct PutDraftAppVersionTemplateInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutDraftAppVersionTemplateInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: PutDraftAppVersionTemplateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutDraftAppVersionTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/put-draft-app-version-template"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutDraftAppVersionTemplateInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutDraftAppVersionTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutDraftAppVersionTemplateOutputError>
}

public struct PutDraftAppVersionTemplateInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var appArn: Swift.String?
    /// A JSON string that contains the body of the app template.
    /// This member is required.
    public var appTemplateBody: Swift.String?

    public init (
        appArn: Swift.String? = nil,
        appTemplateBody: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.appTemplateBody = appTemplateBody
    }
}

struct PutDraftAppVersionTemplateInputBody: Swift.Equatable {
    public let appArn: Swift.String?
    public let appTemplateBody: Swift.String?
}

extension PutDraftAppVersionTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appTemplateBody
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appTemplateBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appTemplateBody)
        appTemplateBody = appTemplateBodyDecoded
    }
}

extension PutDraftAppVersionTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutDraftAppVersionTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutDraftAppVersionTemplateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutDraftAppVersionTemplateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutDraftAppVersionTemplateOutputResponse(appArn: \(Swift.String(describing: appArn)), appVersion: \(Swift.String(describing: appVersion)))"}
}

extension PutDraftAppVersionTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutDraftAppVersionTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appArn = output.appArn
            self.appVersion = output.appVersion
        } else {
            self.appArn = nil
            self.appVersion = nil
        }
    }
}

public struct PutDraftAppVersionTemplateOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    public var appArn: Swift.String?
    /// The version of the application.
    public var appVersion: Swift.String?

    public init (
        appArn: Swift.String? = nil,
        appVersion: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.appVersion = appVersion
    }
}

struct PutDraftAppVersionTemplateOutputResponseBody: Swift.Equatable {
    public let appArn: Swift.String?
    public let appVersion: Swift.String?
}

extension PutDraftAppVersionTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
    }
}

extension ResiliencehubClientTypes {
    public enum RecommendationComplianceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case breachedCanMeet
        case breachedUnattainable
        case metCanImprove
        case sdkUnknown(Swift.String)

        public static var allCases: [RecommendationComplianceStatus] {
            return [
                .breachedCanMeet,
                .breachedUnattainable,
                .metCanImprove,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .breachedCanMeet: return "BreachedCanMeet"
            case .breachedUnattainable: return "BreachedUnattainable"
            case .metCanImprove: return "MetCanImprove"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecommendationComplianceStatus(rawValue: rawValue) ?? RecommendationComplianceStatus.sdkUnknown(rawValue)
        }
    }
}

extension ResiliencehubClientTypes.RecommendationDisruptionCompliance: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expectedComplianceStatus
        case expectedRpoDescription
        case expectedRpoInSecs
        case expectedRtoDescription
        case expectedRtoInSecs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expectedComplianceStatus = expectedComplianceStatus {
            try encodeContainer.encode(expectedComplianceStatus.rawValue, forKey: .expectedComplianceStatus)
        }
        if let expectedRpoDescription = expectedRpoDescription {
            try encodeContainer.encode(expectedRpoDescription, forKey: .expectedRpoDescription)
        }
        if expectedRpoInSecs != 0 {
            try encodeContainer.encode(expectedRpoInSecs, forKey: .expectedRpoInSecs)
        }
        if let expectedRtoDescription = expectedRtoDescription {
            try encodeContainer.encode(expectedRtoDescription, forKey: .expectedRtoDescription)
        }
        if expectedRtoInSecs != 0 {
            try encodeContainer.encode(expectedRtoInSecs, forKey: .expectedRtoInSecs)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expectedComplianceStatusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ComplianceStatus.self, forKey: .expectedComplianceStatus)
        expectedComplianceStatus = expectedComplianceStatusDecoded
        let expectedRtoInSecsDecoded = try containerValues.decode(Swift.Int.self, forKey: .expectedRtoInSecs)
        expectedRtoInSecs = expectedRtoInSecsDecoded
        let expectedRtoDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expectedRtoDescription)
        expectedRtoDescription = expectedRtoDescriptionDecoded
        let expectedRpoInSecsDecoded = try containerValues.decode(Swift.Int.self, forKey: .expectedRpoInSecs)
        expectedRpoInSecs = expectedRpoInSecsDecoded
        let expectedRpoDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expectedRpoDescription)
        expectedRpoDescription = expectedRpoDescriptionDecoded
    }
}

extension ResiliencehubClientTypes.RecommendationDisruptionCompliance: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RecommendationDisruptionCompliance(expectedComplianceStatus: \(Swift.String(describing: expectedComplianceStatus)), expectedRpoDescription: \(Swift.String(describing: expectedRpoDescription)), expectedRpoInSecs: \(Swift.String(describing: expectedRpoInSecs)), expectedRtoDescription: \(Swift.String(describing: expectedRtoDescription)), expectedRtoInSecs: \(Swift.String(describing: expectedRtoInSecs)))"}
}

extension ResiliencehubClientTypes {
    /// Defines a disruption compliance recommendation.
    public struct RecommendationDisruptionCompliance: Swift.Equatable {
        /// The expected compliance status after applying the recommended configuration change.
        /// This member is required.
        public var expectedComplianceStatus: ResiliencehubClientTypes.ComplianceStatus?
        /// The expected Recovery Point Objective (RPO) description after applying the recommended configuration change.
        public var expectedRpoDescription: Swift.String?
        /// The expected RPO after applying the recommended configuration change.
        public var expectedRpoInSecs: Swift.Int
        /// The expected Recovery Time Objective (RTO) description after applying the recommended configuration change.
        public var expectedRtoDescription: Swift.String?
        /// The expected RTO after applying the recommended configuration change.
        public var expectedRtoInSecs: Swift.Int

        public init (
            expectedComplianceStatus: ResiliencehubClientTypes.ComplianceStatus? = nil,
            expectedRpoDescription: Swift.String? = nil,
            expectedRpoInSecs: Swift.Int = 0,
            expectedRtoDescription: Swift.String? = nil,
            expectedRtoInSecs: Swift.Int = 0
        )
        {
            self.expectedComplianceStatus = expectedComplianceStatus
            self.expectedRpoDescription = expectedRpoDescription
            self.expectedRpoInSecs = expectedRpoInSecs
            self.expectedRtoDescription = expectedRtoDescription
            self.expectedRtoInSecs = expectedRtoInSecs
        }
    }

}

extension ResiliencehubClientTypes.RecommendationItem: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alreadyImplemented
        case resourceId
        case targetAccountId
        case targetRegion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alreadyImplemented = alreadyImplemented {
            try encodeContainer.encode(alreadyImplemented, forKey: .alreadyImplemented)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let targetAccountId = targetAccountId {
            try encodeContainer.encode(targetAccountId, forKey: .targetAccountId)
        }
        if let targetRegion = targetRegion {
            try encodeContainer.encode(targetRegion, forKey: .targetRegion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let targetAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetAccountId)
        targetAccountId = targetAccountIdDecoded
        let targetRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetRegion)
        targetRegion = targetRegionDecoded
        let alreadyImplementedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .alreadyImplemented)
        alreadyImplemented = alreadyImplementedDecoded
    }
}

extension ResiliencehubClientTypes.RecommendationItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RecommendationItem(alreadyImplemented: \(Swift.String(describing: alreadyImplemented)), resourceId: \(Swift.String(describing: resourceId)), targetAccountId: \(Swift.String(describing: targetAccountId)), targetRegion: \(Swift.String(describing: targetRegion)))"}
}

extension ResiliencehubClientTypes {
    /// Defines a recommendation.
    public struct RecommendationItem: Swift.Equatable {
        /// Specifies if the recommendation has already been implemented.
        public var alreadyImplemented: Swift.Bool?
        /// The resource identifier.
        public var resourceId: Swift.String?
        /// The target account identifier.
        public var targetAccountId: Swift.String?
        /// The target region.
        public var targetRegion: Swift.String?

        public init (
            alreadyImplemented: Swift.Bool? = nil,
            resourceId: Swift.String? = nil,
            targetAccountId: Swift.String? = nil,
            targetRegion: Swift.String? = nil
        )
        {
            self.alreadyImplemented = alreadyImplemented
            self.resourceId = resourceId
            self.targetAccountId = targetAccountId
            self.targetRegion = targetRegion
        }
    }

}

extension ResiliencehubClientTypes.RecommendationTemplate: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case assessmentArn
        case endTime
        case format
        case message
        case name
        case needsReplacements
        case recommendationIds
        case recommendationTemplateArn
        case recommendationTypes
        case startTime
        case status
        case tags
        case templatesLocation
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let assessmentArn = assessmentArn {
            try encodeContainer.encode(assessmentArn, forKey: .assessmentArn)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let needsReplacements = needsReplacements {
            try encodeContainer.encode(needsReplacements, forKey: .needsReplacements)
        }
        if let recommendationIds = recommendationIds {
            var recommendationIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recommendationIds)
            for recommendationidlist0 in recommendationIds {
                try recommendationIdsContainer.encode(recommendationidlist0)
            }
        }
        if let recommendationTemplateArn = recommendationTemplateArn {
            try encodeContainer.encode(recommendationTemplateArn, forKey: .recommendationTemplateArn)
        }
        if let recommendationTypes = recommendationTypes {
            var recommendationTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recommendationTypes)
            for renderrecommendationtypelist0 in recommendationTypes {
                try recommendationTypesContainer.encode(renderrecommendationtypelist0.rawValue)
            }
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let templatesLocation = templatesLocation {
            try encodeContainer.encode(templatesLocation, forKey: .templatesLocation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templatesLocationDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.S3Location.self, forKey: .templatesLocation)
        templatesLocation = templatesLocationDecoded
        let assessmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentArn)
        assessmentArn = assessmentArnDecoded
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let recommendationIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .recommendationIds)
        var recommendationIdsDecoded0:[Swift.String]? = nil
        if let recommendationIdsContainer = recommendationIdsContainer {
            recommendationIdsDecoded0 = [Swift.String]()
            for string0 in recommendationIdsContainer {
                if let string0 = string0 {
                    recommendationIdsDecoded0?.append(string0)
                }
            }
        }
        recommendationIds = recommendationIdsDecoded0
        let recommendationTypesContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.RenderRecommendationType?].self, forKey: .recommendationTypes)
        var recommendationTypesDecoded0:[ResiliencehubClientTypes.RenderRecommendationType]? = nil
        if let recommendationTypesContainer = recommendationTypesContainer {
            recommendationTypesDecoded0 = [ResiliencehubClientTypes.RenderRecommendationType]()
            for string0 in recommendationTypesContainer {
                if let string0 = string0 {
                    recommendationTypesDecoded0?.append(string0)
                }
            }
        }
        recommendationTypes = recommendationTypesDecoded0
        let formatDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.TemplateFormat.self, forKey: .format)
        format = formatDecoded
        let recommendationTemplateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendationTemplateArn)
        recommendationTemplateArn = recommendationTemplateArnDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.RecommendationTemplateStatus.self, forKey: .status)
        status = statusDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let needsReplacementsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .needsReplacements)
        needsReplacements = needsReplacementsDecoded
    }
}

extension ResiliencehubClientTypes.RecommendationTemplate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RecommendationTemplate(appArn: \(Swift.String(describing: appArn)), assessmentArn: \(Swift.String(describing: assessmentArn)), endTime: \(Swift.String(describing: endTime)), format: \(Swift.String(describing: format)), message: \(Swift.String(describing: message)), name: \(Swift.String(describing: name)), needsReplacements: \(Swift.String(describing: needsReplacements)), recommendationIds: \(Swift.String(describing: recommendationIds)), recommendationTemplateArn: \(Swift.String(describing: recommendationTemplateArn)), recommendationTypes: \(Swift.String(describing: recommendationTypes)), startTime: \(Swift.String(describing: startTime)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)), templatesLocation: \(Swift.String(describing: templatesLocation)))"}
}

extension ResiliencehubClientTypes {
    /// Defines a recommendation template created with the [CreateRecommendationTemplate] action.
    public struct RecommendationTemplate: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
        public var appArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the assessment. The format for this ARN is: arn:partition:dcps:region:account:app-assessment/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
        /// This member is required.
        public var assessmentArn: Swift.String?
        /// The end time for the action.
        public var endTime: ClientRuntime.Date?
        /// The format of the recommendation template. CfnJson The template is CloudFormation JSON. CfnYaml The template is CloudFormation YAML.
        /// This member is required.
        public var format: ResiliencehubClientTypes.TemplateFormat?
        /// The message for the recommendation template.
        public var message: Swift.String?
        /// The name for the recommendation template.
        /// This member is required.
        public var name: Swift.String?
        /// Indicates if replacements are needed.
        public var needsReplacements: Swift.Bool?
        /// Identifiers for the recommendations used in the recommendation template.
        public var recommendationIds: [Swift.String]?
        /// The Amazon Resource Name (ARN) for the recommendation template.
        /// This member is required.
        public var recommendationTemplateArn: Swift.String?
        /// An array of strings that specify the recommendation template type or types. Alarm The template is an [AlarmRecommendation] template. Sop The template is a [SopRecommendation] template. Test The template is a [TestRecommendation] template.
        /// This member is required.
        public var recommendationTypes: [ResiliencehubClientTypes.RenderRecommendationType]?
        /// The start time for the action.
        public var startTime: ClientRuntime.Date?
        /// The status of the action.
        /// This member is required.
        public var status: ResiliencehubClientTypes.RecommendationTemplateStatus?
        /// The tags assigned to the resource. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key/value pair.
        public var tags: [Swift.String:Swift.String]?
        /// The file location of the template.
        public var templatesLocation: ResiliencehubClientTypes.S3Location?

        public init (
            appArn: Swift.String? = nil,
            assessmentArn: Swift.String? = nil,
            endTime: ClientRuntime.Date? = nil,
            format: ResiliencehubClientTypes.TemplateFormat? = nil,
            message: Swift.String? = nil,
            name: Swift.String? = nil,
            needsReplacements: Swift.Bool? = nil,
            recommendationIds: [Swift.String]? = nil,
            recommendationTemplateArn: Swift.String? = nil,
            recommendationTypes: [ResiliencehubClientTypes.RenderRecommendationType]? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: ResiliencehubClientTypes.RecommendationTemplateStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            templatesLocation: ResiliencehubClientTypes.S3Location? = nil
        )
        {
            self.appArn = appArn
            self.assessmentArn = assessmentArn
            self.endTime = endTime
            self.format = format
            self.message = message
            self.name = name
            self.needsReplacements = needsReplacements
            self.recommendationIds = recommendationIds
            self.recommendationTemplateArn = recommendationTemplateArn
            self.recommendationTypes = recommendationTypes
            self.startTime = startTime
            self.status = status
            self.tags = tags
            self.templatesLocation = templatesLocation
        }
    }

}

extension ResiliencehubClientTypes {
    public enum RecommendationTemplateStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case pending
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [RecommendationTemplateStatus] {
            return [
                .failed,
                .inProgress,
                .pending,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case .pending: return "Pending"
            case .success: return "Success"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecommendationTemplateStatus(rawValue: rawValue) ?? RecommendationTemplateStatus.sdkUnknown(rawValue)
        }
    }
}

public struct RemoveDraftAppVersionResourceMappingsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveDraftAppVersionResourceMappingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveDraftAppVersionResourceMappingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveDraftAppVersionResourceMappingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveDraftAppVersionResourceMappingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveDraftAppVersionResourceMappingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveDraftAppVersionResourceMappingsOutputError>
}

extension RemoveDraftAppVersionResourceMappingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveDraftAppVersionResourceMappingsInput(appArn: \(Swift.String(describing: appArn)), appRegistryAppNames: \(Swift.String(describing: appRegistryAppNames)), logicalStackNames: \(Swift.String(describing: logicalStackNames)), resourceGroupNames: \(Swift.String(describing: resourceGroupNames)), resourceNames: \(Swift.String(describing: resourceNames)))"}
}

extension RemoveDraftAppVersionResourceMappingsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appRegistryAppNames
        case logicalStackNames
        case resourceGroupNames
        case resourceNames
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let appRegistryAppNames = appRegistryAppNames {
            var appRegistryAppNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .appRegistryAppNames)
            for entitynamelist0 in appRegistryAppNames {
                try appRegistryAppNamesContainer.encode(entitynamelist0)
            }
        }
        if let logicalStackNames = logicalStackNames {
            var logicalStackNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .logicalStackNames)
            for string255list0 in logicalStackNames {
                try logicalStackNamesContainer.encode(string255list0)
            }
        }
        if let resourceGroupNames = resourceGroupNames {
            var resourceGroupNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceGroupNames)
            for entitynamelist0 in resourceGroupNames {
                try resourceGroupNamesContainer.encode(entitynamelist0)
            }
        }
        if let resourceNames = resourceNames {
            var resourceNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceNames)
            for entitynamelist0 in resourceNames {
                try resourceNamesContainer.encode(entitynamelist0)
            }
        }
    }
}

public struct RemoveDraftAppVersionResourceMappingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveDraftAppVersionResourceMappingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveDraftAppVersionResourceMappingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveDraftAppVersionResourceMappingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveDraftAppVersionResourceMappingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveDraftAppVersionResourceMappingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveDraftAppVersionResourceMappingsOutputError>
}

public struct RemoveDraftAppVersionResourceMappingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveDraftAppVersionResourceMappingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveDraftAppVersionResourceMappingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveDraftAppVersionResourceMappingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveDraftAppVersionResourceMappingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveDraftAppVersionResourceMappingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveDraftAppVersionResourceMappingsOutputError>
}

public struct RemoveDraftAppVersionResourceMappingsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveDraftAppVersionResourceMappingsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: RemoveDraftAppVersionResourceMappingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveDraftAppVersionResourceMappingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RemoveDraftAppVersionResourceMappingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveDraftAppVersionResourceMappingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveDraftAppVersionResourceMappingsOutputError>
}

public struct RemoveDraftAppVersionResourceMappingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveDraftAppVersionResourceMappingsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: RemoveDraftAppVersionResourceMappingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveDraftAppVersionResourceMappingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/remove-draft-app-version-resource-mappings"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RemoveDraftAppVersionResourceMappingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveDraftAppVersionResourceMappingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveDraftAppVersionResourceMappingsOutputError>
}

public struct RemoveDraftAppVersionResourceMappingsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var appArn: Swift.String?
    /// The names of the registered applications to remove from the resource mappings.
    public var appRegistryAppNames: [Swift.String]?
    /// The names of the CloudFormation stacks to remove from the resource mappings.
    public var logicalStackNames: [Swift.String]?
    /// The names of the resource groups to remove from the resource mappings.
    public var resourceGroupNames: [Swift.String]?
    /// The names of the resources to remove from the resource mappings.
    public var resourceNames: [Swift.String]?

    public init (
        appArn: Swift.String? = nil,
        appRegistryAppNames: [Swift.String]? = nil,
        logicalStackNames: [Swift.String]? = nil,
        resourceGroupNames: [Swift.String]? = nil,
        resourceNames: [Swift.String]? = nil
    )
    {
        self.appArn = appArn
        self.appRegistryAppNames = appRegistryAppNames
        self.logicalStackNames = logicalStackNames
        self.resourceGroupNames = resourceGroupNames
        self.resourceNames = resourceNames
    }
}

struct RemoveDraftAppVersionResourceMappingsInputBody: Swift.Equatable {
    public let appArn: Swift.String?
    public let resourceNames: [Swift.String]?
    public let logicalStackNames: [Swift.String]?
    public let appRegistryAppNames: [Swift.String]?
    public let resourceGroupNames: [Swift.String]?
}

extension RemoveDraftAppVersionResourceMappingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appRegistryAppNames
        case logicalStackNames
        case resourceGroupNames
        case resourceNames
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let resourceNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceNames)
        var resourceNamesDecoded0:[Swift.String]? = nil
        if let resourceNamesContainer = resourceNamesContainer {
            resourceNamesDecoded0 = [Swift.String]()
            for string0 in resourceNamesContainer {
                if let string0 = string0 {
                    resourceNamesDecoded0?.append(string0)
                }
            }
        }
        resourceNames = resourceNamesDecoded0
        let logicalStackNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .logicalStackNames)
        var logicalStackNamesDecoded0:[Swift.String]? = nil
        if let logicalStackNamesContainer = logicalStackNamesContainer {
            logicalStackNamesDecoded0 = [Swift.String]()
            for string0 in logicalStackNamesContainer {
                if let string0 = string0 {
                    logicalStackNamesDecoded0?.append(string0)
                }
            }
        }
        logicalStackNames = logicalStackNamesDecoded0
        let appRegistryAppNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .appRegistryAppNames)
        var appRegistryAppNamesDecoded0:[Swift.String]? = nil
        if let appRegistryAppNamesContainer = appRegistryAppNamesContainer {
            appRegistryAppNamesDecoded0 = [Swift.String]()
            for string0 in appRegistryAppNamesContainer {
                if let string0 = string0 {
                    appRegistryAppNamesDecoded0?.append(string0)
                }
            }
        }
        appRegistryAppNames = appRegistryAppNamesDecoded0
        let resourceGroupNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceGroupNames)
        var resourceGroupNamesDecoded0:[Swift.String]? = nil
        if let resourceGroupNamesContainer = resourceGroupNamesContainer {
            resourceGroupNamesDecoded0 = [Swift.String]()
            for string0 in resourceGroupNamesContainer {
                if let string0 = string0 {
                    resourceGroupNamesDecoded0?.append(string0)
                }
            }
        }
        resourceGroupNames = resourceGroupNamesDecoded0
    }
}

extension RemoveDraftAppVersionResourceMappingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveDraftAppVersionResourceMappingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveDraftAppVersionResourceMappingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveDraftAppVersionResourceMappingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveDraftAppVersionResourceMappingsOutputResponse(appArn: \(Swift.String(describing: appArn)), appVersion: \(Swift.String(describing: appVersion)))"}
}

extension RemoveDraftAppVersionResourceMappingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RemoveDraftAppVersionResourceMappingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appArn = output.appArn
            self.appVersion = output.appVersion
        } else {
            self.appArn = nil
            self.appVersion = nil
        }
    }
}

public struct RemoveDraftAppVersionResourceMappingsOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    public var appArn: Swift.String?
    /// The version of the application.
    public var appVersion: Swift.String?

    public init (
        appArn: Swift.String? = nil,
        appVersion: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.appVersion = appVersion
    }
}

struct RemoveDraftAppVersionResourceMappingsOutputResponseBody: Swift.Equatable {
    public let appArn: Swift.String?
    public let appVersion: Swift.String?
}

extension RemoveDraftAppVersionResourceMappingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
    }
}

extension ResiliencehubClientTypes {
    public enum RenderRecommendationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case alarm
        case sop
        case test
        case sdkUnknown(Swift.String)

        public static var allCases: [RenderRecommendationType] {
            return [
                .alarm,
                .sop,
                .test,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .alarm: return "Alarm"
            case .sop: return "Sop"
            case .test: return "Test"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RenderRecommendationType(rawValue: rawValue) ?? RenderRecommendationType.sdkUnknown(rawValue)
        }
    }
}

extension ResiliencehubClientTypes.ResiliencyPolicy: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case dataLocationConstraint
        case estimatedCostTier
        case policy
        case policyArn
        case policyDescription
        case policyName
        case tags
        case tier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let dataLocationConstraint = dataLocationConstraint {
            try encodeContainer.encode(dataLocationConstraint.rawValue, forKey: .dataLocationConstraint)
        }
        if let estimatedCostTier = estimatedCostTier {
            try encodeContainer.encode(estimatedCostTier.rawValue, forKey: .estimatedCostTier)
        }
        if let policy = policy {
            var policyContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .policy)
            for (dictKey0, disruptionpolicy0) in policy {
                try policyContainer.encode(disruptionpolicy0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let policyArn = policyArn {
            try encodeContainer.encode(policyArn, forKey: .policyArn)
        }
        if let policyDescription = policyDescription {
            try encodeContainer.encode(policyDescription, forKey: .policyDescription)
        }
        if let policyName = policyName {
            try encodeContainer.encode(policyName, forKey: .policyName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tier = tier {
            try encodeContainer.encode(tier.rawValue, forKey: .tier)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyDescription)
        policyDescription = policyDescriptionDecoded
        let dataLocationConstraintDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.DataLocationConstraint.self, forKey: .dataLocationConstraint)
        dataLocationConstraint = dataLocationConstraintDecoded
        let tierDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ResiliencyPolicyTier.self, forKey: .tier)
        tier = tierDecoded
        let estimatedCostTierDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.EstimatedCostTier.self, forKey: .estimatedCostTier)
        estimatedCostTier = estimatedCostTierDecoded
        let policyContainer = try containerValues.decodeIfPresent([Swift.String: ResiliencehubClientTypes.FailurePolicy?].self, forKey: .policy)
        var policyDecoded0: [Swift.String:ResiliencehubClientTypes.FailurePolicy]? = nil
        if let policyContainer = policyContainer {
            policyDecoded0 = [Swift.String:ResiliencehubClientTypes.FailurePolicy]()
            for (key0, failurepolicy0) in policyContainer {
                if let failurepolicy0 = failurepolicy0 {
                    policyDecoded0?[key0] = failurepolicy0
                }
            }
        }
        policy = policyDecoded0
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ResiliencehubClientTypes.ResiliencyPolicy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResiliencyPolicy(creationTime: \(Swift.String(describing: creationTime)), dataLocationConstraint: \(Swift.String(describing: dataLocationConstraint)), estimatedCostTier: \(Swift.String(describing: estimatedCostTier)), policy: \(Swift.String(describing: policy)), policyArn: \(Swift.String(describing: policyArn)), policyDescription: \(Swift.String(describing: policyDescription)), policyName: \(Swift.String(describing: policyName)), tags: \(Swift.String(describing: tags)), tier: \(Swift.String(describing: tier)))"}
}

extension ResiliencehubClientTypes {
    /// Defines a resiliency policy.
    public struct ResiliencyPolicy: Swift.Equatable {
        /// The timestamp for when the resiliency policy was created.
        public var creationTime: ClientRuntime.Date?
        /// Specifies a high-level geographical location constraint for where your resilience policy data can be stored.
        public var dataLocationConstraint: ResiliencehubClientTypes.DataLocationConstraint?
        /// Specifies the estimated cost tier of the resiliency policy.
        public var estimatedCostTier: ResiliencehubClientTypes.EstimatedCostTier?
        /// The resiliency policy.
        public var policy: [Swift.String:ResiliencehubClientTypes.FailurePolicy]?
        /// The Amazon Resource Name (ARN) of the resiliency policy. The format for this ARN is: arn:partition:dcps:region:account:resiliency-policy/policy-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
        public var policyArn: Swift.String?
        /// The description for the policy.
        public var policyDescription: Swift.String?
        /// The name of the policy
        public var policyName: Swift.String?
        /// The tags assigned to the resource. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key/value pair.
        public var tags: [Swift.String:Swift.String]?
        /// The tier for this resiliency policy, ranging from the highest severity (MissionCritical) to lowest (NonCritical).
        public var tier: ResiliencehubClientTypes.ResiliencyPolicyTier?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            dataLocationConstraint: ResiliencehubClientTypes.DataLocationConstraint? = nil,
            estimatedCostTier: ResiliencehubClientTypes.EstimatedCostTier? = nil,
            policy: [Swift.String:ResiliencehubClientTypes.FailurePolicy]? = nil,
            policyArn: Swift.String? = nil,
            policyDescription: Swift.String? = nil,
            policyName: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            tier: ResiliencehubClientTypes.ResiliencyPolicyTier? = nil
        )
        {
            self.creationTime = creationTime
            self.dataLocationConstraint = dataLocationConstraint
            self.estimatedCostTier = estimatedCostTier
            self.policy = policy
            self.policyArn = policyArn
            self.policyDescription = policyDescription
            self.policyName = policyName
            self.tags = tags
            self.tier = tier
        }
    }

}

extension ResiliencehubClientTypes {
    public enum ResiliencyPolicyTier: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case coreServices
        case critical
        case important
        case missionCritical
        case nonCritical
        case sdkUnknown(Swift.String)

        public static var allCases: [ResiliencyPolicyTier] {
            return [
                .coreServices,
                .critical,
                .important,
                .missionCritical,
                .nonCritical,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .coreServices: return "CoreServices"
            case .critical: return "Critical"
            case .important: return "Important"
            case .missionCritical: return "MissionCritical"
            case .nonCritical: return "NonCritical"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResiliencyPolicyTier(rawValue: rawValue) ?? ResiliencyPolicyTier.sdkUnknown(rawValue)
        }
    }
}

extension ResiliencehubClientTypes.ResiliencyScore: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disruptionScore
        case score
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let disruptionScore = disruptionScore {
            var disruptionScoreContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .disruptionScore)
            for (dictKey0, disruptionresiliencyscore0) in disruptionScore {
                try disruptionScoreContainer.encode(disruptionresiliencyscore0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if score != 0.0 {
            try encodeContainer.encode(score, forKey: .score)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scoreDecoded = try containerValues.decode(Swift.Double.self, forKey: .score)
        score = scoreDecoded
        let disruptionScoreContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Double?].self, forKey: .disruptionScore)
        var disruptionScoreDecoded0: [Swift.String:Swift.Double]? = nil
        if let disruptionScoreContainer = disruptionScoreContainer {
            disruptionScoreDecoded0 = [Swift.String:Swift.Double]()
            for (key0, double0) in disruptionScoreContainer {
                if let double0 = double0 {
                    disruptionScoreDecoded0?[key0] = double0
                }
            }
        }
        disruptionScore = disruptionScoreDecoded0
    }
}

extension ResiliencehubClientTypes.ResiliencyScore: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResiliencyScore(disruptionScore: \(Swift.String(describing: disruptionScore)), score: \(Swift.String(describing: score)))"}
}

extension ResiliencehubClientTypes {
    /// The overall resiliency score, returned as an object that includes the disruption score and outage score.
    public struct ResiliencyScore: Swift.Equatable {
        /// The disruption score for a valid key.
        /// This member is required.
        public var disruptionScore: [Swift.String:Swift.Double]?
        /// The outage score for a valid key.
        /// This member is required.
        public var score: Swift.Double

        public init (
            disruptionScore: [Swift.String:Swift.Double]? = nil,
            score: Swift.Double = 0.0
        )
        {
            self.disruptionScore = disruptionScore
            self.score = score
        }
    }

}

public struct ResolveAppVersionResourcesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResolveAppVersionResourcesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ResolveAppVersionResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResolveAppVersionResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ResolveAppVersionResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ResolveAppVersionResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResolveAppVersionResourcesOutputError>
}

extension ResolveAppVersionResourcesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResolveAppVersionResourcesInput(appArn: \(Swift.String(describing: appArn)), appVersion: \(Swift.String(describing: appVersion)))"}
}

extension ResolveAppVersionResourcesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let appVersion = appVersion {
            try encodeContainer.encode(appVersion, forKey: .appVersion)
        }
    }
}

public struct ResolveAppVersionResourcesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResolveAppVersionResourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ResolveAppVersionResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResolveAppVersionResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ResolveAppVersionResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ResolveAppVersionResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResolveAppVersionResourcesOutputError>
}

public struct ResolveAppVersionResourcesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResolveAppVersionResourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ResolveAppVersionResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResolveAppVersionResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ResolveAppVersionResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ResolveAppVersionResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResolveAppVersionResourcesOutputError>
}

public struct ResolveAppVersionResourcesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResolveAppVersionResourcesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ResolveAppVersionResourcesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResolveAppVersionResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ResolveAppVersionResourcesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ResolveAppVersionResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResolveAppVersionResourcesOutputError>
}

public struct ResolveAppVersionResourcesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResolveAppVersionResourcesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ResolveAppVersionResourcesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResolveAppVersionResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/resolve-app-version-resources"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ResolveAppVersionResourcesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ResolveAppVersionResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResolveAppVersionResourcesOutputError>
}

public struct ResolveAppVersionResourcesInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var appArn: Swift.String?
    /// The version of the application.
    /// This member is required.
    public var appVersion: Swift.String?

    public init (
        appArn: Swift.String? = nil,
        appVersion: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.appVersion = appVersion
    }
}

struct ResolveAppVersionResourcesInputBody: Swift.Equatable {
    public let appArn: Swift.String?
    public let appVersion: Swift.String?
}

extension ResolveAppVersionResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
    }
}

extension ResolveAppVersionResourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ResolveAppVersionResourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ResolveAppVersionResourcesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResolveAppVersionResourcesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResolveAppVersionResourcesOutputResponse(appArn: \(Swift.String(describing: appArn)), appVersion: \(Swift.String(describing: appVersion)), resolutionId: \(Swift.String(describing: resolutionId)), status: \(Swift.String(describing: status)))"}
}

extension ResolveAppVersionResourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResolveAppVersionResourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appArn = output.appArn
            self.appVersion = output.appVersion
            self.resolutionId = output.resolutionId
            self.status = output.status
        } else {
            self.appArn = nil
            self.appVersion = nil
            self.resolutionId = nil
            self.status = nil
        }
    }
}

public struct ResolveAppVersionResourcesOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var appArn: Swift.String?
    /// The version of the application.
    /// This member is required.
    public var appVersion: Swift.String?
    /// The identifier for a specific resolution.
    /// This member is required.
    public var resolutionId: Swift.String?
    /// The status of the action.
    /// This member is required.
    public var status: ResiliencehubClientTypes.ResourceResolutionStatusType?

    public init (
        appArn: Swift.String? = nil,
        appVersion: Swift.String? = nil,
        resolutionId: Swift.String? = nil,
        status: ResiliencehubClientTypes.ResourceResolutionStatusType? = nil
    )
    {
        self.appArn = appArn
        self.appVersion = appVersion
        self.resolutionId = resolutionId
        self.status = status
    }
}

struct ResolveAppVersionResourcesOutputResponseBody: Swift.Equatable {
    public let appArn: Swift.String?
    public let appVersion: Swift.String?
    public let resolutionId: Swift.String?
    public let status: ResiliencehubClientTypes.ResourceResolutionStatusType?
}

extension ResolveAppVersionResourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case resolutionId
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let resolutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolutionId)
        resolutionId = resolutionIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ResourceResolutionStatusType.self, forKey: .status)
        status = statusDecoded
    }
}

extension ResiliencehubClientTypes {
    public enum ResourceImportStatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case pending
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceImportStatusType] {
            return [
                .failed,
                .inProgress,
                .pending,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case .pending: return "Pending"
            case .success: return "Success"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceImportStatusType(rawValue: rawValue) ?? ResourceImportStatusType.sdkUnknown(rawValue)
        }
    }
}

extension ResiliencehubClientTypes.ResourceMapping: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appRegistryAppName
        case logicalStackName
        case mappingType
        case physicalResourceId
        case resourceGroupName
        case resourceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appRegistryAppName = appRegistryAppName {
            try encodeContainer.encode(appRegistryAppName, forKey: .appRegistryAppName)
        }
        if let logicalStackName = logicalStackName {
            try encodeContainer.encode(logicalStackName, forKey: .logicalStackName)
        }
        if let mappingType = mappingType {
            try encodeContainer.encode(mappingType.rawValue, forKey: .mappingType)
        }
        if let physicalResourceId = physicalResourceId {
            try encodeContainer.encode(physicalResourceId, forKey: .physicalResourceId)
        }
        if let resourceGroupName = resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
        if let resourceName = resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
        let logicalStackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logicalStackName)
        logicalStackName = logicalStackNameDecoded
        let appRegistryAppNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appRegistryAppName)
        appRegistryAppName = appRegistryAppNameDecoded
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let mappingTypeDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ResourceMappingType.self, forKey: .mappingType)
        mappingType = mappingTypeDecoded
        let physicalResourceIdDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.PhysicalResourceId.self, forKey: .physicalResourceId)
        physicalResourceId = physicalResourceIdDecoded
    }
}

extension ResiliencehubClientTypes.ResourceMapping: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceMapping(appRegistryAppName: \(Swift.String(describing: appRegistryAppName)), logicalStackName: \(Swift.String(describing: logicalStackName)), mappingType: \(Swift.String(describing: mappingType)), physicalResourceId: \(Swift.String(describing: physicalResourceId)), resourceGroupName: \(Swift.String(describing: resourceGroupName)), resourceName: \(Swift.String(describing: resourceName)))"}
}

extension ResiliencehubClientTypes {
    /// Defines a resource mapping.
    public struct ResourceMapping: Swift.Equatable {
        /// The name of the application this resource is mapped to.
        public var appRegistryAppName: Swift.String?
        /// The name of the CloudFormation stack this resource is mapped to.
        public var logicalStackName: Swift.String?
        /// Specifies the type of resource mapping. AppRegistryApp The resource is mapped to another application. The name of the application is contained in the appRegistryAppName property. CfnStack The resource is mapped to a CloudFormation stack. The name of the CloudFormation stack is contained in the logicalStackName property. Resource The resource is mapped to another resource. The name of the resource is contained in the resourceName property. ResourceGroup The resource is mapped to a resource group. The name of the resource group is contained in the resourceGroupName property.
        /// This member is required.
        public var mappingType: ResiliencehubClientTypes.ResourceMappingType?
        /// The identifier of this resource.
        /// This member is required.
        public var physicalResourceId: ResiliencehubClientTypes.PhysicalResourceId?
        /// The name of the resource group this resource is mapped to.
        public var resourceGroupName: Swift.String?
        /// The name of the resource this resource is mapped to.
        public var resourceName: Swift.String?

        public init (
            appRegistryAppName: Swift.String? = nil,
            logicalStackName: Swift.String? = nil,
            mappingType: ResiliencehubClientTypes.ResourceMappingType? = nil,
            physicalResourceId: ResiliencehubClientTypes.PhysicalResourceId? = nil,
            resourceGroupName: Swift.String? = nil,
            resourceName: Swift.String? = nil
        )
        {
            self.appRegistryAppName = appRegistryAppName
            self.logicalStackName = logicalStackName
            self.mappingType = mappingType
            self.physicalResourceId = physicalResourceId
            self.resourceGroupName = resourceGroupName
            self.resourceName = resourceName
        }
    }

}

extension ResiliencehubClientTypes {
    public enum ResourceMappingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case appRegistryApp
        case cfnStack
        case resource
        case resourceGroup
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceMappingType] {
            return [
                .appRegistryApp,
                .cfnStack,
                .resource,
                .resourceGroup,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .appRegistryApp: return "AppRegistryApp"
            case .cfnStack: return "CfnStack"
            case .resource: return "Resource"
            case .resourceGroup: return "ResourceGroup"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceMappingType(rawValue: rawValue) ?? ResourceMappingType.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)), resourceId: \(Swift.String(describing: resourceId)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource could not be found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The identifier of the resource that the exception applies to.
    public var resourceId: Swift.String?
    /// The type of the resource that the exception applies to.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceId: Swift.String?
    public let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ResiliencehubClientTypes {
    public enum ResourceResolutionStatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case pending
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceResolutionStatusType] {
            return [
                .failed,
                .inProgress,
                .pending,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case .pending: return "Pending"
            case .success: return "Success"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceResolutionStatusType(rawValue: rawValue) ?? ResourceResolutionStatusType.sdkUnknown(rawValue)
        }
    }
}

extension ResiliencehubClientTypes.S3Location: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket
        case `prefix` = "prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let `prefix` = `prefix` {
            try encodeContainer.encode(`prefix`, forKey: .`prefix`)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
    }
}

extension ResiliencehubClientTypes.S3Location: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "S3Location(bucket: \(Swift.String(describing: bucket)), prefix: \(Swift.String(describing: `prefix`)))"}
}

extension ResiliencehubClientTypes {
    /// The location of the Amazon S3 bucket.
    public struct S3Location: Swift.Equatable {
        /// The prefix for the Amazon S3 bucket.
        public var `prefix`: Swift.String?
        /// The name of the Amazon S3 bucket.
        public var bucket: Swift.String?

        public init (
            `prefix`: Swift.String? = nil,
            bucket: Swift.String? = nil
        )
        {
            self.`prefix` = `prefix`
            self.bucket = bucket
        }
    }

}

extension ServiceQuotaExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceQuotaExceededException(message: \(Swift.String(describing: message)))"}
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have exceeded your service quota. To perform the requested action, remove some of the relevant resources, or use Service Quotas to request a service quota increase.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResiliencehubClientTypes.SopRecommendation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appComponentName
        case description
        case items
        case name
        case prerequisite
        case recommendationId
        case referenceId
        case serviceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appComponentName = appComponentName {
            try encodeContainer.encode(appComponentName, forKey: .appComponentName)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let items = items {
            var itemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .items)
            for recommendationitemlist0 in items {
                try itemsContainer.encode(recommendationitemlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let prerequisite = prerequisite {
            try encodeContainer.encode(prerequisite, forKey: .prerequisite)
        }
        if let recommendationId = recommendationId {
            try encodeContainer.encode(recommendationId, forKey: .recommendationId)
        }
        if let referenceId = referenceId {
            try encodeContainer.encode(referenceId, forKey: .referenceId)
        }
        if let serviceType = serviceType {
            try encodeContainer.encode(serviceType.rawValue, forKey: .serviceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceTypeDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.SopServiceType.self, forKey: .serviceType)
        serviceType = serviceTypeDecoded
        let appComponentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appComponentName)
        appComponentName = appComponentNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let recommendationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendationId)
        recommendationId = recommendationIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let itemsContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.RecommendationItem?].self, forKey: .items)
        var itemsDecoded0:[ResiliencehubClientTypes.RecommendationItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ResiliencehubClientTypes.RecommendationItem]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let referenceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .referenceId)
        referenceId = referenceIdDecoded
        let prerequisiteDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prerequisite)
        prerequisite = prerequisiteDecoded
    }
}

extension ResiliencehubClientTypes.SopRecommendation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SopRecommendation(appComponentName: \(Swift.String(describing: appComponentName)), description: \(Swift.String(describing: description)), items: \(Swift.String(describing: items)), name: \(Swift.String(describing: name)), prerequisite: \(Swift.String(describing: prerequisite)), recommendationId: \(Swift.String(describing: recommendationId)), referenceId: \(Swift.String(describing: referenceId)), serviceType: \(Swift.String(describing: serviceType)))"}
}

extension ResiliencehubClientTypes {
    /// Defines a standard operating procedure (SOP) recommendation.
    public struct SopRecommendation: Swift.Equatable {
        /// The application component name.
        public var appComponentName: Swift.String?
        /// The description of the SOP recommendation.
        public var description: Swift.String?
        /// The recommendation items.
        public var items: [ResiliencehubClientTypes.RecommendationItem]?
        /// The name of the SOP recommendation.
        public var name: Swift.String?
        /// The prerequisite for the SOP recommendation.
        public var prerequisite: Swift.String?
        /// Identifier for the SOP recommendation.
        /// This member is required.
        public var recommendationId: Swift.String?
        /// The reference identifier for the SOP recommendation.
        /// This member is required.
        public var referenceId: Swift.String?
        /// The service type.
        /// This member is required.
        public var serviceType: ResiliencehubClientTypes.SopServiceType?

        public init (
            appComponentName: Swift.String? = nil,
            description: Swift.String? = nil,
            items: [ResiliencehubClientTypes.RecommendationItem]? = nil,
            name: Swift.String? = nil,
            prerequisite: Swift.String? = nil,
            recommendationId: Swift.String? = nil,
            referenceId: Swift.String? = nil,
            serviceType: ResiliencehubClientTypes.SopServiceType? = nil
        )
        {
            self.appComponentName = appComponentName
            self.description = description
            self.items = items
            self.name = name
            self.prerequisite = prerequisite
            self.recommendationId = recommendationId
            self.referenceId = referenceId
            self.serviceType = serviceType
        }
    }

}

extension ResiliencehubClientTypes {
    public enum SopServiceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ssm
        case sdkUnknown(Swift.String)

        public static var allCases: [SopServiceType] {
            return [
                .ssm,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ssm: return "SSM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SopServiceType(rawValue: rawValue) ?? SopServiceType.sdkUnknown(rawValue)
        }
    }
}

public struct StartAppAssessmentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartAppAssessmentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartAppAssessmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartAppAssessmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartAppAssessmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartAppAssessmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartAppAssessmentOutputError>
}

extension StartAppAssessmentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartAppAssessmentInput(appArn: \(Swift.String(describing: appArn)), appVersion: \(Swift.String(describing: appVersion)), assessmentName: \(Swift.String(describing: assessmentName)), clientToken: \(Swift.String(describing: clientToken)), tags: \(Swift.String(describing: tags)))"}
}

extension StartAppAssessmentInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case assessmentName
        case clientToken
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let appVersion = appVersion {
            try encodeContainer.encode(appVersion, forKey: .appVersion)
        }
        if let assessmentName = assessmentName {
            try encodeContainer.encode(assessmentName, forKey: .assessmentName)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct StartAppAssessmentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartAppAssessmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartAppAssessmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartAppAssessmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartAppAssessmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartAppAssessmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartAppAssessmentOutputError>
}

public struct StartAppAssessmentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartAppAssessmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartAppAssessmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartAppAssessmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartAppAssessmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartAppAssessmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartAppAssessmentOutputError>
}

public struct StartAppAssessmentInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartAppAssessmentInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: StartAppAssessmentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartAppAssessmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartAppAssessmentInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartAppAssessmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartAppAssessmentOutputError>
}

public struct StartAppAssessmentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartAppAssessmentInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: StartAppAssessmentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartAppAssessmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/start-app-assessment"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartAppAssessmentInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartAppAssessmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartAppAssessmentOutputError>
}

public struct StartAppAssessmentInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var appArn: Swift.String?
    /// The version of the application.
    /// This member is required.
    public var appVersion: Swift.String?
    /// The name for the assessment.
    /// This member is required.
    public var assessmentName: Swift.String?
    /// Used for an idempotency token. A client token is a unique, case-sensitive string of up to 64 ASCII characters. You should not reuse the same client token for other API requests.
    public var clientToken: Swift.String?
    /// The tags assigned to the resource. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key/value pair.
    public var tags: [Swift.String:Swift.String]?

    public init (
        appArn: Swift.String? = nil,
        appVersion: Swift.String? = nil,
        assessmentName: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.appArn = appArn
        self.appVersion = appVersion
        self.assessmentName = assessmentName
        self.clientToken = clientToken
        self.tags = tags
    }
}

struct StartAppAssessmentInputBody: Swift.Equatable {
    public let appArn: Swift.String?
    public let appVersion: Swift.String?
    public let assessmentName: Swift.String?
    public let clientToken: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension StartAppAssessmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case assessmentName
        case clientToken
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let assessmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentName)
        assessmentName = assessmentNameDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension StartAppAssessmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartAppAssessmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartAppAssessmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartAppAssessmentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartAppAssessmentOutputResponse(assessment: \(Swift.String(describing: assessment)))"}
}

extension StartAppAssessmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartAppAssessmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assessment = output.assessment
        } else {
            self.assessment = nil
        }
    }
}

public struct StartAppAssessmentOutputResponse: Swift.Equatable {
    /// The assessment created.
    /// This member is required.
    public var assessment: ResiliencehubClientTypes.AppAssessment?

    public init (
        assessment: ResiliencehubClientTypes.AppAssessment? = nil
    )
    {
        self.assessment = assessment
    }
}

struct StartAppAssessmentOutputResponseBody: Swift.Equatable {
    public let assessment: ResiliencehubClientTypes.AppAssessment?
}

extension StartAppAssessmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessment
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.AppAssessment.self, forKey: .assessment)
        assessment = assessmentDecoded
    }
}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to assign to the resource. Each tag consists of a key/value pair.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ResiliencehubClientTypes {
    public enum TemplateFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cfnJson
        case cfnYaml
        case sdkUnknown(Swift.String)

        public static var allCases: [TemplateFormat] {
            return [
                .cfnJson,
                .cfnYaml,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cfnJson: return "CfnJson"
            case .cfnYaml: return "CfnYaml"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TemplateFormat(rawValue: rawValue) ?? TemplateFormat.sdkUnknown(rawValue)
        }
    }
}

extension ResiliencehubClientTypes.TestRecommendation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appComponentName
        case description
        case intent
        case items
        case name
        case prerequisite
        case recommendationId
        case referenceId
        case risk
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appComponentName = appComponentName {
            try encodeContainer.encode(appComponentName, forKey: .appComponentName)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let intent = intent {
            try encodeContainer.encode(intent, forKey: .intent)
        }
        if let items = items {
            var itemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .items)
            for recommendationitemlist0 in items {
                try itemsContainer.encode(recommendationitemlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let prerequisite = prerequisite {
            try encodeContainer.encode(prerequisite, forKey: .prerequisite)
        }
        if let recommendationId = recommendationId {
            try encodeContainer.encode(recommendationId, forKey: .recommendationId)
        }
        if let referenceId = referenceId {
            try encodeContainer.encode(referenceId, forKey: .referenceId)
        }
        if let risk = risk {
            try encodeContainer.encode(risk.rawValue, forKey: .risk)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendationId)
        recommendationId = recommendationIdDecoded
        let referenceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .referenceId)
        referenceId = referenceIdDecoded
        let appComponentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appComponentName)
        appComponentName = appComponentNameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let intentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .intent)
        intent = intentDecoded
        let riskDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.TestRisk.self, forKey: .risk)
        risk = riskDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.TestType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let itemsContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.RecommendationItem?].self, forKey: .items)
        var itemsDecoded0:[ResiliencehubClientTypes.RecommendationItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ResiliencehubClientTypes.RecommendationItem]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let prerequisiteDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prerequisite)
        prerequisite = prerequisiteDecoded
    }
}

extension ResiliencehubClientTypes.TestRecommendation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TestRecommendation(appComponentName: \(Swift.String(describing: appComponentName)), description: \(Swift.String(describing: description)), intent: \(Swift.String(describing: intent)), items: \(Swift.String(describing: items)), name: \(Swift.String(describing: name)), prerequisite: \(Swift.String(describing: prerequisite)), recommendationId: \(Swift.String(describing: recommendationId)), referenceId: \(Swift.String(describing: referenceId)), risk: \(Swift.String(describing: risk)), type: \(Swift.String(describing: type)))"}
}

extension ResiliencehubClientTypes {
    /// Defines a test recommendation.
    public struct TestRecommendation: Swift.Equatable {
        /// The name of the application component.
        public var appComponentName: Swift.String?
        /// The description for the test recommendation.
        public var description: Swift.String?
        /// The intent of the test recommendation.
        public var intent: Swift.String?
        /// The test recommendation items.
        public var items: [ResiliencehubClientTypes.RecommendationItem]?
        /// The name of the test recommendation.
        public var name: Swift.String?
        /// The prerequisite of the test recommendation.
        public var prerequisite: Swift.String?
        /// Identifier for the test recommendation.
        public var recommendationId: Swift.String?
        /// The reference identifier for the test recommendation.
        /// This member is required.
        public var referenceId: Swift.String?
        /// The level of risk for this test recommendation.
        public var risk: ResiliencehubClientTypes.TestRisk?
        /// The type of test recommendation.
        public var type: ResiliencehubClientTypes.TestType?

        public init (
            appComponentName: Swift.String? = nil,
            description: Swift.String? = nil,
            intent: Swift.String? = nil,
            items: [ResiliencehubClientTypes.RecommendationItem]? = nil,
            name: Swift.String? = nil,
            prerequisite: Swift.String? = nil,
            recommendationId: Swift.String? = nil,
            referenceId: Swift.String? = nil,
            risk: ResiliencehubClientTypes.TestRisk? = nil,
            type: ResiliencehubClientTypes.TestType? = nil
        )
        {
            self.appComponentName = appComponentName
            self.description = description
            self.intent = intent
            self.items = items
            self.name = name
            self.prerequisite = prerequisite
            self.recommendationId = recommendationId
            self.referenceId = referenceId
            self.risk = risk
            self.type = type
        }
    }

}

extension ResiliencehubClientTypes {
    public enum TestRisk: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case high
        case medium
        case small
        case sdkUnknown(Swift.String)

        public static var allCases: [TestRisk] {
            return [
                .high,
                .medium,
                .small,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .high: return "High"
            case .medium: return "Medium"
            case .small: return "Small"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TestRisk(rawValue: rawValue) ?? TestRisk.sdkUnknown(rawValue)
        }
    }
}

extension ResiliencehubClientTypes {
    public enum TestType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case az
        case hardware
        case region
        case software
        case sdkUnknown(Swift.String)

        public static var allCases: [TestType] {
            return [
                .az,
                .hardware,
                .region,
                .software,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .az: return "AZ"
            case .hardware: return "Hardware"
            case .region: return "Region"
            case .software: return "Software"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TestType(rawValue: rawValue) ?? TestType.sdkUnknown(rawValue)
        }
    }
}

extension ThrottlingException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ThrottlingException(message: \(Swift.String(describing: message)), retryAfterSeconds: \(Swift.String(describing: retryAfterSeconds)))"}
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.retryAfterSeconds = output.retryAfterSeconds
        } else {
            self.message = nil
            self.retryAfterSeconds = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The limit on the number of requests per second was exceeded.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The number of seconds to wait before retrying the operation.
    public var retryAfterSeconds: Swift.Int?

    public init (
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let retryAfterSeconds: Swift.Int?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case retryAfterSeconds
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let retryAfterSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retryAfterSeconds)
        retryAfterSeconds = retryAfterSecondsDecoded
    }
}

extension ResiliencehubClientTypes.UnsupportedResource: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logicalResourceId
        case physicalResourceId
        case resourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logicalResourceId = logicalResourceId {
            try encodeContainer.encode(logicalResourceId, forKey: .logicalResourceId)
        }
        if let physicalResourceId = physicalResourceId {
            try encodeContainer.encode(physicalResourceId, forKey: .physicalResourceId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logicalResourceIdDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.LogicalResourceId.self, forKey: .logicalResourceId)
        logicalResourceId = logicalResourceIdDecoded
        let physicalResourceIdDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.PhysicalResourceId.self, forKey: .physicalResourceId)
        physicalResourceId = physicalResourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ResiliencehubClientTypes.UnsupportedResource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnsupportedResource(logicalResourceId: \(Swift.String(describing: logicalResourceId)), physicalResourceId: \(Swift.String(describing: physicalResourceId)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension ResiliencehubClientTypes {
    /// Defines a resource that is not supported by Resilience Hub.
    public struct UnsupportedResource: Swift.Equatable {
        /// The logical resource identifier for the unsupported resource.
        /// This member is required.
        public var logicalResourceId: ResiliencehubClientTypes.LogicalResourceId?
        /// The physical resource identifier for the unsupported resource.
        /// This member is required.
        public var physicalResourceId: ResiliencehubClientTypes.PhysicalResourceId?
        /// The type of resource.
        /// This member is required.
        public var resourceType: Swift.String?

        public init (
            logicalResourceId: ResiliencehubClientTypes.LogicalResourceId? = nil,
            physicalResourceId: ResiliencehubClientTypes.PhysicalResourceId? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.logicalResourceId = logicalResourceId
            self.physicalResourceId = physicalResourceId
            self.resourceType = resourceType
        }
    }

}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of the tags to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateAppInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAppInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAppInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAppInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAppOutputError>
}

extension UpdateAppInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAppInput(appArn: \(Swift.String(describing: appArn)), clearResiliencyPolicyArn: \(Swift.String(describing: clearResiliencyPolicyArn)), description: \(Swift.String(describing: description)), policyArn: \(Swift.String(describing: policyArn)))"}
}

extension UpdateAppInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case clearResiliencyPolicyArn
        case description
        case policyArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let clearResiliencyPolicyArn = clearResiliencyPolicyArn {
            try encodeContainer.encode(clearResiliencyPolicyArn, forKey: .clearResiliencyPolicyArn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let policyArn = policyArn {
            try encodeContainer.encode(policyArn, forKey: .policyArn)
        }
    }
}

public struct UpdateAppInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAppInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAppInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAppInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAppOutputError>
}

public struct UpdateAppInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAppInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAppInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAppInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAppOutputError>
}

public struct UpdateAppInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAppInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateAppInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateAppInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAppOutputError>
}

public struct UpdateAppInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAppInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateAppInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/update-app"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateAppInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAppOutputError>
}

public struct UpdateAppInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var appArn: Swift.String?
    /// Specifies if the resiliency policy ARN should be cleared.
    public var clearResiliencyPolicyArn: Swift.Bool?
    /// The optional description for an app.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the resiliency policy. The format for this ARN is: arn:partition:dcps:region:account:resiliency-policy/policy-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    public var policyArn: Swift.String?

    public init (
        appArn: Swift.String? = nil,
        clearResiliencyPolicyArn: Swift.Bool? = nil,
        description: Swift.String? = nil,
        policyArn: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.clearResiliencyPolicyArn = clearResiliencyPolicyArn
        self.description = description
        self.policyArn = policyArn
    }
}

struct UpdateAppInputBody: Swift.Equatable {
    public let appArn: Swift.String?
    public let description: Swift.String?
    public let policyArn: Swift.String?
    public let clearResiliencyPolicyArn: Swift.Bool?
}

extension UpdateAppInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case clearResiliencyPolicyArn
        case description
        case policyArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let clearResiliencyPolicyArnDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .clearResiliencyPolicyArn)
        clearResiliencyPolicyArn = clearResiliencyPolicyArnDecoded
    }
}

extension UpdateAppOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAppOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAppOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAppOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAppOutputResponse(app: \(Swift.String(describing: app)))"}
}

extension UpdateAppOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateAppOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.app = output.app
        } else {
            self.app = nil
        }
    }
}

public struct UpdateAppOutputResponse: Swift.Equatable {
    /// The specified application, returned as an object with details including compliance status, creation time, description, resiliency score, and more.
    /// This member is required.
    public var app: ResiliencehubClientTypes.App?

    public init (
        app: ResiliencehubClientTypes.App? = nil
    )
    {
        self.app = app
    }
}

struct UpdateAppOutputResponseBody: Swift.Equatable {
    public let app: ResiliencehubClientTypes.App?
}

extension UpdateAppOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case app
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.App.self, forKey: .app)
        app = appDecoded
    }
}

public struct UpdateResiliencyPolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateResiliencyPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateResiliencyPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateResiliencyPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateResiliencyPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateResiliencyPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateResiliencyPolicyOutputError>
}

extension UpdateResiliencyPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateResiliencyPolicyInput(dataLocationConstraint: \(Swift.String(describing: dataLocationConstraint)), policy: \(Swift.String(describing: policy)), policyArn: \(Swift.String(describing: policyArn)), policyDescription: \(Swift.String(describing: policyDescription)), policyName: \(Swift.String(describing: policyName)), tier: \(Swift.String(describing: tier)))"}
}

extension UpdateResiliencyPolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataLocationConstraint
        case policy
        case policyArn
        case policyDescription
        case policyName
        case tier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataLocationConstraint = dataLocationConstraint {
            try encodeContainer.encode(dataLocationConstraint.rawValue, forKey: .dataLocationConstraint)
        }
        if let policy = policy {
            var policyContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .policy)
            for (dictKey0, disruptionpolicy0) in policy {
                try policyContainer.encode(disruptionpolicy0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let policyArn = policyArn {
            try encodeContainer.encode(policyArn, forKey: .policyArn)
        }
        if let policyDescription = policyDescription {
            try encodeContainer.encode(policyDescription, forKey: .policyDescription)
        }
        if let policyName = policyName {
            try encodeContainer.encode(policyName, forKey: .policyName)
        }
        if let tier = tier {
            try encodeContainer.encode(tier.rawValue, forKey: .tier)
        }
    }
}

public struct UpdateResiliencyPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateResiliencyPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateResiliencyPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateResiliencyPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateResiliencyPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateResiliencyPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateResiliencyPolicyOutputError>
}

public struct UpdateResiliencyPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateResiliencyPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateResiliencyPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateResiliencyPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateResiliencyPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateResiliencyPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateResiliencyPolicyOutputError>
}

public struct UpdateResiliencyPolicyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateResiliencyPolicyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateResiliencyPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateResiliencyPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateResiliencyPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateResiliencyPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateResiliencyPolicyOutputError>
}

public struct UpdateResiliencyPolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateResiliencyPolicyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateResiliencyPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateResiliencyPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/update-resiliency-policy"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateResiliencyPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateResiliencyPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateResiliencyPolicyOutputError>
}

public struct UpdateResiliencyPolicyInput: Swift.Equatable {
    /// Specifies a high-level geographical location constraint for where your resilience policy data can be stored.
    public var dataLocationConstraint: ResiliencehubClientTypes.DataLocationConstraint?
    /// The type of resiliency policy to be created, including the recovery time objective (RTO) and recovery point objective (RPO) in seconds.
    public var policy: [Swift.String:ResiliencehubClientTypes.FailurePolicy]?
    /// The Amazon Resource Name (ARN) of the resiliency policy. The format for this ARN is: arn:partition:dcps:region:account:resiliency-policy/policy-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var policyArn: Swift.String?
    /// The description for the policy.
    public var policyDescription: Swift.String?
    /// The name of the policy
    public var policyName: Swift.String?
    /// The tier for this resiliency policy, ranging from the highest severity (MissionCritical) to lowest (NonCritical).
    public var tier: ResiliencehubClientTypes.ResiliencyPolicyTier?

    public init (
        dataLocationConstraint: ResiliencehubClientTypes.DataLocationConstraint? = nil,
        policy: [Swift.String:ResiliencehubClientTypes.FailurePolicy]? = nil,
        policyArn: Swift.String? = nil,
        policyDescription: Swift.String? = nil,
        policyName: Swift.String? = nil,
        tier: ResiliencehubClientTypes.ResiliencyPolicyTier? = nil
    )
    {
        self.dataLocationConstraint = dataLocationConstraint
        self.policy = policy
        self.policyArn = policyArn
        self.policyDescription = policyDescription
        self.policyName = policyName
        self.tier = tier
    }
}

struct UpdateResiliencyPolicyInputBody: Swift.Equatable {
    public let policyArn: Swift.String?
    public let policyName: Swift.String?
    public let policyDescription: Swift.String?
    public let dataLocationConstraint: ResiliencehubClientTypes.DataLocationConstraint?
    public let tier: ResiliencehubClientTypes.ResiliencyPolicyTier?
    public let policy: [Swift.String:ResiliencehubClientTypes.FailurePolicy]?
}

extension UpdateResiliencyPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataLocationConstraint
        case policy
        case policyArn
        case policyDescription
        case policyName
        case tier
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyDescription)
        policyDescription = policyDescriptionDecoded
        let dataLocationConstraintDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.DataLocationConstraint.self, forKey: .dataLocationConstraint)
        dataLocationConstraint = dataLocationConstraintDecoded
        let tierDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ResiliencyPolicyTier.self, forKey: .tier)
        tier = tierDecoded
        let policyContainer = try containerValues.decodeIfPresent([Swift.String: ResiliencehubClientTypes.FailurePolicy?].self, forKey: .policy)
        var policyDecoded0: [Swift.String:ResiliencehubClientTypes.FailurePolicy]? = nil
        if let policyContainer = policyContainer {
            policyDecoded0 = [Swift.String:ResiliencehubClientTypes.FailurePolicy]()
            for (key0, failurepolicy0) in policyContainer {
                if let failurepolicy0 = failurepolicy0 {
                    policyDecoded0?[key0] = failurepolicy0
                }
            }
        }
        policy = policyDecoded0
    }
}

extension UpdateResiliencyPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateResiliencyPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateResiliencyPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateResiliencyPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateResiliencyPolicyOutputResponse(policy: \(Swift.String(describing: policy)))"}
}

extension UpdateResiliencyPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateResiliencyPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct UpdateResiliencyPolicyOutputResponse: Swift.Equatable {
    /// The type of resiliency policy that was updated, including the recovery time objective (RTO) and recovery point objective (RPO) in seconds.
    /// This member is required.
    public var policy: ResiliencehubClientTypes.ResiliencyPolicy?

    public init (
        policy: ResiliencehubClientTypes.ResiliencyPolicy? = nil
    )
    {
        self.policy = policy
    }
}

struct UpdateResiliencyPolicyOutputResponseBody: Swift.Equatable {
    public let policy: ResiliencehubClientTypes.ResiliencyPolicy?
}

extension UpdateResiliencyPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ResiliencyPolicy.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(message: \(Swift.String(describing: message)))"}
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that a request was not valid.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
