// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

#if swift(>=5.5)
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, macCatalyst 15.0, *)
public extension HoneycodeClient {
    /// <p>
    ///             The BatchCreateTableRows API allows you to create one or more rows at the end of a table in a workbook.
    ///             The API allows you to specify the values to set in some or all of the columns in the new rows.
    ///         </p>
    ///         <p>
    ///             If a column is not explicitly set in a specific row, then the column level formula specified in the table
    ///             will be applied to the new row. If there is no column level formula but the last row of the table has a
    ///             formula, then that formula will be copied down to the new row. If there is no column level formula and
    ///             no formula in the last row of the table, then that column will be left blank for the new rows.
    ///         </p>
    func batchCreateTableRows(input: BatchCreateTableRowsInput) async throws -> BatchCreateTableRowsOutputResponse
    {
        typealias batchCreateTableRowsContinuation = CheckedContinuation<BatchCreateTableRowsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: batchCreateTableRowsContinuation) in
            batchCreateTableRows(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>
    ///             The BatchDeleteTableRows API allows you to delete one or more rows from a table in a workbook.
    ///             You need to specify the ids of the rows that you want to delete from the table.
    ///         </p>
    func batchDeleteTableRows(input: BatchDeleteTableRowsInput) async throws -> BatchDeleteTableRowsOutputResponse
    {
        typealias batchDeleteTableRowsContinuation = CheckedContinuation<BatchDeleteTableRowsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: batchDeleteTableRowsContinuation) in
            batchDeleteTableRows(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>
    ///             The BatchUpdateTableRows API allows you to update one or more rows in a table in a workbook.
    ///         </p>
    ///         <p>
    ///             You can specify the values to set in some or all of the columns in the table for the specified
    ///             rows.
    ///             If a column is not explicitly specified in a particular row, then that column will not be updated
    ///             for that row. To clear out the data in a specific cell, you need to set the value as an empty string
    ///             ("").
    ///         </p>
    func batchUpdateTableRows(input: BatchUpdateTableRowsInput) async throws -> BatchUpdateTableRowsOutputResponse
    {
        typealias batchUpdateTableRowsContinuation = CheckedContinuation<BatchUpdateTableRowsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: batchUpdateTableRowsContinuation) in
            batchUpdateTableRows(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>
    ///             The BatchUpsertTableRows API allows you to upsert one or more rows in a table. The upsert
    ///             operation takes a filter expression as input and evaluates it to find matching rows on the destination
    ///             table. If matching rows are found, it will update the cells in the matching rows to new values specified
    ///             in the request. If no matching rows are found, a new row is added at the end of the table and the cells in
    ///             that row are set to the new values specified in the request.
    ///         </p>
    ///         <p>
    ///             You can specify the values to set in some or all of the columns in the table for the
    ///             matching or newly appended rows. If a column is not explicitly specified for a particular row, then that
    ///             column will not be updated for that row. To clear out the data in a specific cell, you need to set the value
    ///             as an empty string ("").
    ///         </p>
    func batchUpsertTableRows(input: BatchUpsertTableRowsInput) async throws -> BatchUpsertTableRowsOutputResponse
    {
        typealias batchUpsertTableRowsContinuation = CheckedContinuation<BatchUpsertTableRowsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: batchUpsertTableRowsContinuation) in
            batchUpsertTableRows(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>
    ///             The DescribeTableDataImportJob API allows you to retrieve the status and details of a table data import job.
    ///         </p>
    func describeTableDataImportJob(input: DescribeTableDataImportJobInput) async throws -> DescribeTableDataImportJobOutputResponse
    {
        typealias describeTableDataImportJobContinuation = CheckedContinuation<DescribeTableDataImportJobOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeTableDataImportJobContinuation) in
            describeTableDataImportJob(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>
    ///             The GetScreenData API allows retrieval of data from a screen in a Honeycode app.
    ///             The API allows setting local variables in the screen to filter, sort or otherwise affect what will be
    ///             displayed on the screen.
    ///         </p>
    func getScreenData(input: GetScreenDataInput) async throws -> GetScreenDataOutputResponse
    {
        typealias getScreenDataContinuation = CheckedContinuation<GetScreenDataOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getScreenDataContinuation) in
            getScreenData(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>
    ///             The InvokeScreenAutomation API allows invoking an action defined in a screen in a Honeycode app.
    ///             The API allows setting local variables, which can then be used in the automation being invoked.
    ///             This allows automating the Honeycode app interactions to write, update or delete data in the workbook.
    ///         </p>
    func invokeScreenAutomation(input: InvokeScreenAutomationInput) async throws -> InvokeScreenAutomationOutputResponse
    {
        typealias invokeScreenAutomationContinuation = CheckedContinuation<InvokeScreenAutomationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: invokeScreenAutomationContinuation) in
            invokeScreenAutomation(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>
    ///             The ListTableColumns API allows you to retrieve a list of all the columns in a table in a workbook.
    ///         </p>
    func listTableColumns(input: ListTableColumnsInput) async throws -> ListTableColumnsOutputResponse
    {
        typealias listTableColumnsContinuation = CheckedContinuation<ListTableColumnsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listTableColumnsContinuation) in
            listTableColumns(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>
    ///             The ListTableRows API allows you to retrieve a list of all the rows in a table in a workbook.
    ///         </p>
    func listTableRows(input: ListTableRowsInput) async throws -> ListTableRowsOutputResponse
    {
        typealias listTableRowsContinuation = CheckedContinuation<ListTableRowsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listTableRowsContinuation) in
            listTableRows(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>
    ///             The ListTables API allows you to retrieve a list of all the tables in a workbook.
    ///         </p>
    func listTables(input: ListTablesInput) async throws -> ListTablesOutputResponse
    {
        typealias listTablesContinuation = CheckedContinuation<ListTablesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listTablesContinuation) in
            listTables(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>
    ///             The QueryTableRows API allows you to use a filter formula to query for specific rows in a table.
    ///         </p>
    func queryTableRows(input: QueryTableRowsInput) async throws -> QueryTableRowsOutputResponse
    {
        typealias queryTableRowsContinuation = CheckedContinuation<QueryTableRowsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: queryTableRowsContinuation) in
            queryTableRows(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>
    ///             The StartTableDataImportJob API allows you to start an import job on a table. This API will only return
    ///             the id of the job that was started. To find out the status of the import request, you need to call the
    ///             DescribeTableDataImportJob API.
    ///         </p>
    func startTableDataImportJob(input: StartTableDataImportJobInput) async throws -> StartTableDataImportJobOutputResponse
    {
        typealias startTableDataImportJobContinuation = CheckedContinuation<StartTableDataImportJobOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: startTableDataImportJobContinuation) in
            startTableDataImportJob(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

}
#endif
