// Code generated by smithy-swift-codegen. DO NOT EDIT!

import AWSClientRuntime
import ClientRuntime
import Foundation
import Logging

public class HoneycodeClient {
    let client: ClientRuntime.SdkHttpClient
    let config: AWSClientRuntime.AWSClientConfiguration
    let serviceName = "Honeycode"
    let encoder: ClientRuntime.RequestEncoder
    let decoder: ClientRuntime.ResponseDecoder

    public init(config: AWSClientRuntime.AWSClientConfiguration) {
        client = ClientRuntime.SdkHttpClient(engine: config.httpClientEngine, config: config.httpClientConfiguration)
        let encoder = ClientRuntime.JSONEncoder()
        encoder.dateEncodingStrategy = .secondsSince1970
        encoder.nonConformingFloatEncodingStrategy = .convertToString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        self.encoder = config.encoder ?? encoder
        let decoder = ClientRuntime.JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        self.decoder = config.decoder ?? decoder
        self.config = config
    }

    public convenience init(region: Swift.String? = nil) throws {
        let config = try HoneycodeClientConfiguration(region: region)
        self.init(config: config)
    }

    deinit {
        client.close()
    }

    public class HoneycodeClientConfiguration: AWSClientRuntime.AWSClientConfiguration {

        public var clientLogMode: ClientRuntime.ClientLogMode
        public var decoder: ClientRuntime.ResponseDecoder?
        public var encoder: ClientRuntime.RequestEncoder?
        public var httpClientConfiguration: ClientRuntime.HttpClientConfiguration
        public var httpClientEngine: ClientRuntime.HttpClientEngine
        public var idempotencyTokenGenerator: ClientRuntime.IdempotencyTokenGenerator
        public var logger: ClientRuntime.LogAgent
        public var retryer: ClientRuntime.SDKRetryer

        public var credentialsProvider: AWSClientRuntime.CredentialsProvider
        public var endpointResolver: AWSClientRuntime.EndpointResolver
        public var region: Swift.String?
        public var regionResolver: AWSClientRuntime.RegionResolver
        public var signingRegion: Swift.String?

        public init(
            credentialsProvider: AWSClientRuntime.CredentialsProvider? = nil,
            endpointResolver: AWSClientRuntime.EndpointResolver? = nil,
            region: Swift.String? = nil,
            regionResolver: AWSClientRuntime.RegionResolver? = nil,
            signingRegion: Swift.String? = nil,
            runtimeConfig: ClientRuntime.SDKRuntimeConfiguration
        ) throws {
            self.regionResolver = regionResolver ?? DefaultRegionResolver()
            let defaultRegion = self.regionResolver.resolveRegion()
            self.region = region ?? defaultRegion
            self.signingRegion = signingRegion ?? defaultRegion
            self.endpointResolver = endpointResolver ?? DefaultEndpointResolver()
            if let credProvider = credentialsProvider {
                self.credentialsProvider = try AWSClientRuntime.AWSCredentialsProvider.fromCustom(credProvider)
            } else {
                self.credentialsProvider = try AWSClientRuntime.AWSCredentialsProvider.fromChain()
            }
            self.clientLogMode = runtimeConfig.clientLogMode
            self.decoder = runtimeConfig.decoder
            self.encoder = runtimeConfig.encoder
            self.httpClientConfiguration = runtimeConfig.httpClientConfiguration
            self.httpClientEngine = runtimeConfig.httpClientEngine
            self.idempotencyTokenGenerator = runtimeConfig.idempotencyTokenGenerator
            self.logger = runtimeConfig.logger
            self.retryer = runtimeConfig.retryer
        }

        public convenience init(
            credentialsProvider: AWSClientRuntime.CredentialsProvider? = nil,
            endpointResolver: AWSClientRuntime.EndpointResolver? = nil,
            region: Swift.String? = nil,
            regionResolver: AWSClientRuntime.RegionResolver? = nil,
            signingRegion: Swift.String? = nil
        ) throws {
            let defaultRuntimeConfig = try ClientRuntime.DefaultSDKRuntimeConfiguration("HoneycodeClient")
            try self.init(credentialsProvider: credentialsProvider, endpointResolver: endpointResolver, region: region, regionResolver: regionResolver, signingRegion: signingRegion, runtimeConfig: defaultRuntimeConfig)
        }
    }
}

public struct HoneycodeClientLogHandlerFactory: ClientRuntime.SDKLogHandlerFactory {
    public var label = "HoneycodeClient"
    let logLevel: ClientRuntime.SDKLogLevel
    public func construct(label: String) -> LogHandler {
        var handler = StreamLogHandler.standardOutput(label: label)
        handler.logLevel = logLevel.toLoggerType()
        return handler
    }
    public init(logLevel: ClientRuntime.SDKLogLevel) {
        self.logLevel = logLevel
    }
}

extension HoneycodeClient: HoneycodeClientProtocol {
    ///
    ///             The BatchCreateTableRows API allows you to create one or more rows at the end of a table in a workbook.
    ///             The API allows you to specify the values to set in some or all of the columns in the new rows.
    ///
    ///
    ///             If a column is not explicitly set in a specific row, then the column level formula specified in the table
    ///             will be applied to the new row. If there is no column level formula but the last row of the table has a
    ///             formula, then that formula will be copied down to the new row. If there is no column level formula and
    ///             no formula in the last row of the table, then that column will be left blank for the new rows.
    ///
    public func batchCreateTableRows(input: BatchCreateTableRowsInput, completion: @escaping (ClientRuntime.SdkResult<BatchCreateTableRowsOutputResponse, BatchCreateTableRowsOutputError>) -> Void)
    {
        guard let workbookId = input.workbookId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component workbookId unexpectedly nil"))))
            return
        }
        guard let tableId = input.tableId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component tableId unexpectedly nil"))))
            return
        }
        let urlPath = "/workbooks/\(workbookId)/tables/\(tableId)/rows/batchcreate"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "batchCreateTableRows")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "honeycode")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<BatchCreateTableRowsInput, BatchCreateTableRowsOutputResponse, BatchCreateTableRowsOutputError>(id: "batchCreateTableRows")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: BatchCreateTableRowsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: BatchCreateTableRowsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<BatchCreateTableRowsInput, BatchCreateTableRowsOutputResponse, BatchCreateTableRowsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: BatchCreateTableRowsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    ///
    ///             The BatchDeleteTableRows API allows you to delete one or more rows from a table in a workbook.
    ///             You need to specify the ids of the rows that you want to delete from the table.
    ///
    public func batchDeleteTableRows(input: BatchDeleteTableRowsInput, completion: @escaping (ClientRuntime.SdkResult<BatchDeleteTableRowsOutputResponse, BatchDeleteTableRowsOutputError>) -> Void)
    {
        guard let workbookId = input.workbookId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component workbookId unexpectedly nil"))))
            return
        }
        guard let tableId = input.tableId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component tableId unexpectedly nil"))))
            return
        }
        let urlPath = "/workbooks/\(workbookId)/tables/\(tableId)/rows/batchdelete"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "batchDeleteTableRows")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "honeycode")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<BatchDeleteTableRowsInput, BatchDeleteTableRowsOutputResponse, BatchDeleteTableRowsOutputError>(id: "batchDeleteTableRows")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: BatchDeleteTableRowsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: BatchDeleteTableRowsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<BatchDeleteTableRowsInput, BatchDeleteTableRowsOutputResponse, BatchDeleteTableRowsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: BatchDeleteTableRowsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    ///
    ///             The BatchUpdateTableRows API allows you to update one or more rows in a table in a workbook.
    ///
    ///
    ///             You can specify the values to set in some or all of the columns in the table for the specified
    ///             rows.
    ///             If a column is not explicitly specified in a particular row, then that column will not be updated
    ///             for that row. To clear out the data in a specific cell, you need to set the value as an empty string
    ///             ("").
    ///
    public func batchUpdateTableRows(input: BatchUpdateTableRowsInput, completion: @escaping (ClientRuntime.SdkResult<BatchUpdateTableRowsOutputResponse, BatchUpdateTableRowsOutputError>) -> Void)
    {
        guard let workbookId = input.workbookId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component workbookId unexpectedly nil"))))
            return
        }
        guard let tableId = input.tableId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component tableId unexpectedly nil"))))
            return
        }
        let urlPath = "/workbooks/\(workbookId)/tables/\(tableId)/rows/batchupdate"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "batchUpdateTableRows")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "honeycode")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<BatchUpdateTableRowsInput, BatchUpdateTableRowsOutputResponse, BatchUpdateTableRowsOutputError>(id: "batchUpdateTableRows")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: BatchUpdateTableRowsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: BatchUpdateTableRowsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<BatchUpdateTableRowsInput, BatchUpdateTableRowsOutputResponse, BatchUpdateTableRowsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: BatchUpdateTableRowsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    ///
    ///             The BatchUpsertTableRows API allows you to upsert one or more rows in a table. The upsert
    ///             operation takes a filter expression as input and evaluates it to find matching rows on the destination
    ///             table. If matching rows are found, it will update the cells in the matching rows to new values specified
    ///             in the request. If no matching rows are found, a new row is added at the end of the table and the cells in
    ///             that row are set to the new values specified in the request.
    ///
    ///
    ///             You can specify the values to set in some or all of the columns in the table for the
    ///             matching or newly appended rows. If a column is not explicitly specified for a particular row, then that
    ///             column will not be updated for that row. To clear out the data in a specific cell, you need to set the value
    ///             as an empty string ("").
    ///
    public func batchUpsertTableRows(input: BatchUpsertTableRowsInput, completion: @escaping (ClientRuntime.SdkResult<BatchUpsertTableRowsOutputResponse, BatchUpsertTableRowsOutputError>) -> Void)
    {
        guard let workbookId = input.workbookId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component workbookId unexpectedly nil"))))
            return
        }
        guard let tableId = input.tableId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component tableId unexpectedly nil"))))
            return
        }
        let urlPath = "/workbooks/\(workbookId)/tables/\(tableId)/rows/batchupsert"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "batchUpsertTableRows")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "honeycode")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<BatchUpsertTableRowsInput, BatchUpsertTableRowsOutputResponse, BatchUpsertTableRowsOutputError>(id: "batchUpsertTableRows")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: BatchUpsertTableRowsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: BatchUpsertTableRowsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<BatchUpsertTableRowsInput, BatchUpsertTableRowsOutputResponse, BatchUpsertTableRowsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: BatchUpsertTableRowsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    ///
    ///             The DescribeTableDataImportJob API allows you to retrieve the status and details of a table data import job.
    ///
    public func describeTableDataImportJob(input: DescribeTableDataImportJobInput, completion: @escaping (ClientRuntime.SdkResult<DescribeTableDataImportJobOutputResponse, DescribeTableDataImportJobOutputError>) -> Void)
    {
        guard let workbookId = input.workbookId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component workbookId unexpectedly nil"))))
            return
        }
        guard let tableId = input.tableId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component tableId unexpectedly nil"))))
            return
        }
        guard let jobId = input.jobId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component jobId unexpectedly nil"))))
            return
        }
        let urlPath = "/workbooks/\(workbookId)/tables/\(tableId)/import/\(jobId)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeTableDataImportJob")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "honeycode")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeTableDataImportJobInput, DescribeTableDataImportJobOutputResponse, DescribeTableDataImportJobOutputError>(id: "describeTableDataImportJob")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeTableDataImportJobInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeTableDataImportJobInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DescribeTableDataImportJobInput, DescribeTableDataImportJobOutputResponse, DescribeTableDataImportJobOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    ///
    ///             The GetScreenData API allows retrieval of data from a screen in a Honeycode app.
    ///             The API allows setting local variables in the screen to filter, sort or otherwise affect what will be
    ///             displayed on the screen.
    ///
    public func getScreenData(input: GetScreenDataInput, completion: @escaping (ClientRuntime.SdkResult<GetScreenDataOutputResponse, GetScreenDataOutputError>) -> Void)
    {
        let urlPath = "/screendata"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getScreenData")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "honeycode")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetScreenDataInput, GetScreenDataOutputResponse, GetScreenDataOutputError>(id: "getScreenData")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetScreenDataInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetScreenDataInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetScreenDataInput, GetScreenDataOutputResponse, GetScreenDataOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: GetScreenDataInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    ///
    ///             The InvokeScreenAutomation API allows invoking an action defined in a screen in a Honeycode app.
    ///             The API allows setting local variables, which can then be used in the automation being invoked.
    ///             This allows automating the Honeycode app interactions to write, update or delete data in the workbook.
    ///
    public func invokeScreenAutomation(input: InvokeScreenAutomationInput, completion: @escaping (ClientRuntime.SdkResult<InvokeScreenAutomationOutputResponse, InvokeScreenAutomationOutputError>) -> Void)
    {
        guard let workbookId = input.workbookId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component workbookId unexpectedly nil"))))
            return
        }
        guard let appId = input.appId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component appId unexpectedly nil"))))
            return
        }
        guard let screenId = input.screenId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component screenId unexpectedly nil"))))
            return
        }
        guard let screenAutomationId = input.screenAutomationId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component screenAutomationId unexpectedly nil"))))
            return
        }
        let urlPath = "/workbooks/\(workbookId)/apps/\(appId)/screens/\(screenId)/automations/\(screenAutomationId)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "invokeScreenAutomation")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "honeycode")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<InvokeScreenAutomationInput, InvokeScreenAutomationOutputResponse, InvokeScreenAutomationOutputError>(id: "invokeScreenAutomation")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: InvokeScreenAutomationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: InvokeScreenAutomationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<InvokeScreenAutomationInput, InvokeScreenAutomationOutputResponse, InvokeScreenAutomationOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: InvokeScreenAutomationInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    ///
    ///             The ListTableColumns API allows you to retrieve a list of all the columns in a table in a workbook.
    ///
    public func listTableColumns(input: ListTableColumnsInput, completion: @escaping (ClientRuntime.SdkResult<ListTableColumnsOutputResponse, ListTableColumnsOutputError>) -> Void)
    {
        guard let workbookId = input.workbookId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component workbookId unexpectedly nil"))))
            return
        }
        guard let tableId = input.tableId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component tableId unexpectedly nil"))))
            return
        }
        let urlPath = "/workbooks/\(workbookId)/tables/\(tableId)/columns"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listTableColumns")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "honeycode")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListTableColumnsInput, ListTableColumnsOutputResponse, ListTableColumnsOutputError>(id: "listTableColumns")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListTableColumnsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListTableColumnsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<ListTableColumnsInput, ListTableColumnsOutputResponse, ListTableColumnsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    ///
    ///             The ListTableRows API allows you to retrieve a list of all the rows in a table in a workbook.
    ///
    public func listTableRows(input: ListTableRowsInput, completion: @escaping (ClientRuntime.SdkResult<ListTableRowsOutputResponse, ListTableRowsOutputError>) -> Void)
    {
        guard let workbookId = input.workbookId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component workbookId unexpectedly nil"))))
            return
        }
        guard let tableId = input.tableId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component tableId unexpectedly nil"))))
            return
        }
        let urlPath = "/workbooks/\(workbookId)/tables/\(tableId)/rows/list"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listTableRows")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "honeycode")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListTableRowsInput, ListTableRowsOutputResponse, ListTableRowsOutputError>(id: "listTableRows")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListTableRowsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListTableRowsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<ListTableRowsInput, ListTableRowsOutputResponse, ListTableRowsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: ListTableRowsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    ///
    ///             The ListTables API allows you to retrieve a list of all the tables in a workbook.
    ///
    public func listTables(input: ListTablesInput, completion: @escaping (ClientRuntime.SdkResult<ListTablesOutputResponse, ListTablesOutputError>) -> Void)
    {
        guard let workbookId = input.workbookId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component workbookId unexpectedly nil"))))
            return
        }
        let urlPath = "/workbooks/\(workbookId)/tables"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listTables")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "honeycode")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListTablesInput, ListTablesOutputResponse, ListTablesOutputError>(id: "listTables")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListTablesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListTablesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<ListTablesInput, ListTablesOutputResponse, ListTablesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    ///
    ///             The QueryTableRows API allows you to use a filter formula to query for specific rows in a table.
    ///
    public func queryTableRows(input: QueryTableRowsInput, completion: @escaping (ClientRuntime.SdkResult<QueryTableRowsOutputResponse, QueryTableRowsOutputError>) -> Void)
    {
        guard let workbookId = input.workbookId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component workbookId unexpectedly nil"))))
            return
        }
        guard let tableId = input.tableId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component tableId unexpectedly nil"))))
            return
        }
        let urlPath = "/workbooks/\(workbookId)/tables/\(tableId)/rows/query"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "queryTableRows")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "honeycode")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<QueryTableRowsInput, QueryTableRowsOutputResponse, QueryTableRowsOutputError>(id: "queryTableRows")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: QueryTableRowsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: QueryTableRowsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<QueryTableRowsInput, QueryTableRowsOutputResponse, QueryTableRowsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: QueryTableRowsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    ///
    ///             The StartTableDataImportJob API allows you to start an import job on a table. This API will only return
    ///             the id of the job that was started. To find out the status of the import request, you need to call the
    ///             DescribeTableDataImportJob API.
    ///
    public func startTableDataImportJob(input: StartTableDataImportJobInput, completion: @escaping (ClientRuntime.SdkResult<StartTableDataImportJobOutputResponse, StartTableDataImportJobOutputError>) -> Void)
    {
        guard let workbookId = input.workbookId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component workbookId unexpectedly nil"))))
            return
        }
        guard let destinationTableId = input.destinationTableId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component destinationTableId unexpectedly nil"))))
            return
        }
        let urlPath = "/workbooks/\(workbookId)/tables/\(destinationTableId)/import"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "startTableDataImportJob")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "honeycode")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<StartTableDataImportJobInput, StartTableDataImportJobOutputResponse, StartTableDataImportJobOutputError>(id: "startTableDataImportJob")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: StartTableDataImportJobInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: StartTableDataImportJobInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<StartTableDataImportJobInput, StartTableDataImportJobOutputResponse, StartTableDataImportJobOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: StartTableDataImportJobInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

}
