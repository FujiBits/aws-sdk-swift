// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension PiClientTypes.DataPoint: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case timestamp = "Timestamp"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp.timeIntervalSince1970, forKey: .timestamp)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .value)
        value = valueDecoded
    }
}

extension PiClientTypes.DataPoint: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataPoint(timestamp: \(Swift.String(describing: timestamp)), value: \(Swift.String(describing: value)))"}
}

extension PiClientTypes {
    /// <p>A timestamp, and a single numerical value, which together represent a measurement at a particular point in time.</p>
    public struct DataPoint: Swift.Equatable {
        /// <p>The time, in epoch format, associated with a particular <code>Value</code>.</p>
        public let timestamp: ClientRuntime.Date?
        /// <p>The actual value associated with a particular <code>Timestamp</code>.</p>
        public let value: Swift.Double?

        public init (
            timestamp: ClientRuntime.Date? = nil,
            value: Swift.Double? = nil
        )
        {
            self.timestamp = timestamp
            self.value = value
        }
    }

}

public struct DescribeDimensionKeysInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDimensionKeysInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDimensionKeysInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDimensionKeysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDimensionKeysInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDimensionKeysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDimensionKeysOutputError>
}

extension DescribeDimensionKeysInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDimensionKeysInput(endTime: \(Swift.String(describing: endTime)), filter: \(Swift.String(describing: filter)), groupBy: \(Swift.String(describing: groupBy)), identifier: \(Swift.String(describing: identifier)), maxResults: \(Swift.String(describing: maxResults)), metric: \(Swift.String(describing: metric)), nextToken: \(Swift.String(describing: nextToken)), partitionBy: \(Swift.String(describing: partitionBy)), periodInSeconds: \(Swift.String(describing: periodInSeconds)), serviceType: \(Swift.String(describing: serviceType)), startTime: \(Swift.String(describing: startTime)))"}
}

extension DescribeDimensionKeysInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case filter = "Filter"
        case groupBy = "GroupBy"
        case identifier = "Identifier"
        case maxResults = "MaxResults"
        case metric = "Metric"
        case nextToken = "NextToken"
        case partitionBy = "PartitionBy"
        case periodInSeconds = "PeriodInSeconds"
        case serviceType = "ServiceType"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let filter = filter {
            var filterContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .filter)
            for (dictKey0, metricqueryfiltermap0) in filter {
                try filterContainer.encode(metricqueryfiltermap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let groupBy = groupBy {
            try encodeContainer.encode(groupBy, forKey: .groupBy)
        }
        if let identifier = identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let metric = metric {
            try encodeContainer.encode(metric, forKey: .metric)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let partitionBy = partitionBy {
            try encodeContainer.encode(partitionBy, forKey: .partitionBy)
        }
        if let periodInSeconds = periodInSeconds {
            try encodeContainer.encode(periodInSeconds, forKey: .periodInSeconds)
        }
        if let serviceType = serviceType {
            try encodeContainer.encode(serviceType.rawValue, forKey: .serviceType)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }
}

public struct DescribeDimensionKeysInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDimensionKeysInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDimensionKeysInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDimensionKeysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDimensionKeysInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDimensionKeysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDimensionKeysOutputError>
}

public struct DescribeDimensionKeysInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDimensionKeysInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDimensionKeysInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDimensionKeysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDimensionKeysInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDimensionKeysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDimensionKeysOutputError>
}

public struct DescribeDimensionKeysInput: Swift.Equatable {
    /// <p>The date and time specifying the end of the requested time series data. The value specified is
    ///       <i>exclusive</i>, which means that data points less than (but not equal to) <code>EndTime</code> are
    ///       returned.</p>
    ///          <p>The value for <code>EndTime</code> must be later than the value for
    ///       <code>StartTime</code>.</p>
    public let endTime: ClientRuntime.Date?
    /// <p>One or more filters to apply in the request.  Restrictions:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Any number of filters by the same dimension, as specified in the <code>GroupBy</code> or
    ///           <code>Partition</code> parameters.</p>
    ///             </li>
    ///             <li>
    ///                <p>A single filter for any other dimension in this dimension group.</p>
    ///             </li>
    ///          </ul>
    public let filter: [Swift.String:Swift.String]?
    /// <p>A specification for how to aggregate the data points from a query result. You must specify a valid dimension group.
    ///       Performance Insights returns all dimensions within this group, unless you provide the names of specific dimensions within this group.
    ///       You can also request that Performance Insights return a limited number of values for a dimension.</p>
    public let groupBy: PiClientTypes.DimensionGroup?
    /// <p>An immutable, AWS Region-unique identifier for a data source. Performance Insights gathers metrics from
    ///       this data source.</p>
    ///          <p>To use an Amazon RDS instance as a data source, you specify its <code>DbiResourceId</code> value. For example,
    ///       specify <code>db-FAIHNTYBKTGAUSUZQYPDS2GW4A</code>
    ///          </p>
    public let identifier: Swift.String?
    /// <p>The maximum number of items to return in the response.
    ///       If more items exist than the specified <code>MaxRecords</code> value, a pagination
    ///       token is included in the response so that the remaining
    ///       results can be retrieved.
    ///     </p>
    public let maxResults: Swift.Int?
    /// <p>The name of a Performance Insights metric to be measured.</p>
    ///          <p>Valid values for <code>Metric</code> are:</p>
    ///
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>db.load.avg</code> - a scaled representation of the number of active sessions
    ///           for the database engine.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>db.sampledload.avg</code> - the raw number of active sessions for the
    ///           database engine.</p>
    ///             </li>
    ///          </ul>
    ///          <p>If the number of active sessions is less than an internal Performance Insights threshold, <code>db.load.avg</code> and <code>db.sampledload.avg</code>
    ///           are the same value. If the number of active sessions is greater than the internal threshold, Performance Insights samples the active sessions, with <code>db.load.avg</code>
    ///           showing the scaled values, <code>db.sampledload.avg</code> showing the raw values, and <code>db.sampledload.avg</code> less than <code>db.load.avg</code>.
    ///           For most use cases, you can query <code>db.load.avg</code> only. </p>
    public let metric: Swift.String?
    /// <p>An optional pagination token provided by a previous request. If
    ///       this parameter is specified, the response includes only records beyond the token, up to the
    ///       value specified by <code>MaxRecords</code>.</p>
    public let nextToken: Swift.String?
    /// <p>For each dimension specified in
    ///       <code>GroupBy</code>, specify a secondary dimension to further subdivide the partition keys in the response.</p>
    public let partitionBy: PiClientTypes.DimensionGroup?
    /// <p>The granularity, in seconds, of the data points returned from Performance Insights. A period can be as short as
    ///       one second, or as long as one day (86400 seconds).  Valid values are:</p>
    ///
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>1</code> (one second)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>60</code> (one minute)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>300</code> (five minutes)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>3600</code> (one hour)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>86400</code> (twenty-four hours)</p>
    ///             </li>
    ///          </ul>
    ///
    ///          <p>If you don't specify <code>PeriodInSeconds</code>, then Performance Insights chooses a value for you, with a goal of returning
    ///       roughly 100-200 data points in the response.</p>
    public let periodInSeconds: Swift.Int?
    /// <p>The AWS service for which Performance Insights will return metrics. The only valid value for <i>ServiceType</i> is
    ///         <code>RDS</code>.</p>
    public let serviceType: PiClientTypes.ServiceType?
    /// <p>The date and time specifying the beginning of the requested time series data. You must specify a
    ///         <code>StartTime</code> within the past 7 days. The value specified is <i>inclusive</i>, which means
    ///       that data points equal to or greater than <code>StartTime</code> are returned.</p>
    ///          <p>The value for <code>StartTime</code> must be earlier than the value for
    ///         <code>EndTime</code>.</p>
    public let startTime: ClientRuntime.Date?

    public init (
        endTime: ClientRuntime.Date? = nil,
        filter: [Swift.String:Swift.String]? = nil,
        groupBy: PiClientTypes.DimensionGroup? = nil,
        identifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        metric: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        partitionBy: PiClientTypes.DimensionGroup? = nil,
        periodInSeconds: Swift.Int? = nil,
        serviceType: PiClientTypes.ServiceType? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.endTime = endTime
        self.filter = filter
        self.groupBy = groupBy
        self.identifier = identifier
        self.maxResults = maxResults
        self.metric = metric
        self.nextToken = nextToken
        self.partitionBy = partitionBy
        self.periodInSeconds = periodInSeconds
        self.serviceType = serviceType
        self.startTime = startTime
    }
}

struct DescribeDimensionKeysInputBody: Swift.Equatable {
    public let serviceType: PiClientTypes.ServiceType?
    public let identifier: Swift.String?
    public let startTime: ClientRuntime.Date?
    public let endTime: ClientRuntime.Date?
    public let metric: Swift.String?
    public let periodInSeconds: Swift.Int?
    public let groupBy: PiClientTypes.DimensionGroup?
    public let partitionBy: PiClientTypes.DimensionGroup?
    public let filter: [Swift.String:Swift.String]?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension DescribeDimensionKeysInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case filter = "Filter"
        case groupBy = "GroupBy"
        case identifier = "Identifier"
        case maxResults = "MaxResults"
        case metric = "Metric"
        case nextToken = "NextToken"
        case partitionBy = "PartitionBy"
        case periodInSeconds = "PeriodInSeconds"
        case serviceType = "ServiceType"
        case startTime = "StartTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceTypeDecoded = try containerValues.decodeIfPresent(PiClientTypes.ServiceType.self, forKey: .serviceType)
        serviceType = serviceTypeDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let metricDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metric)
        metric = metricDecoded
        let periodInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .periodInSeconds)
        periodInSeconds = periodInSecondsDecoded
        let groupByDecoded = try containerValues.decodeIfPresent(PiClientTypes.DimensionGroup.self, forKey: .groupBy)
        groupBy = groupByDecoded
        let partitionByDecoded = try containerValues.decodeIfPresent(PiClientTypes.DimensionGroup.self, forKey: .partitionBy)
        partitionBy = partitionByDecoded
        let filterContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .filter)
        var filterDecoded0: [Swift.String:Swift.String]? = nil
        if let filterContainer = filterContainer {
            filterDecoded0 = [Swift.String:Swift.String]()
            for (key0, requeststring0) in filterContainer {
                if let requeststring0 = requeststring0 {
                    filterDecoded0?[key0] = requeststring0
                }
            }
        }
        filter = filterDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeDimensionKeysOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDimensionKeysOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDimensionKeysOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidArgumentException(InvalidArgumentException)
    case notAuthorizedException(NotAuthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDimensionKeysOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDimensionKeysOutputResponse(alignedEndTime: \(Swift.String(describing: alignedEndTime)), alignedStartTime: \(Swift.String(describing: alignedStartTime)), keys: \(Swift.String(describing: keys)), nextToken: \(Swift.String(describing: nextToken)), partitionKeys: \(Swift.String(describing: partitionKeys)))"}
}

extension DescribeDimensionKeysOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDimensionKeysOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.alignedEndTime = output.alignedEndTime
            self.alignedStartTime = output.alignedStartTime
            self.keys = output.keys
            self.nextToken = output.nextToken
            self.partitionKeys = output.partitionKeys
        } else {
            self.alignedEndTime = nil
            self.alignedStartTime = nil
            self.keys = nil
            self.nextToken = nil
            self.partitionKeys = nil
        }
    }
}

public struct DescribeDimensionKeysOutputResponse: Swift.Equatable {
    /// <p>The end time for the returned dimension keys, after alignment to a granular boundary (as
    ///       specified by <code>PeriodInSeconds</code>). <code>AlignedEndTime</code> will be greater than
    ///       or equal to the value of the user-specified <code>Endtime</code>.</p>
    public let alignedEndTime: ClientRuntime.Date?
    /// <p>The start time for the returned dimension keys, after alignment to a granular boundary (as
    ///       specified by <code>PeriodInSeconds</code>). <code>AlignedStartTime</code> will be less than or
    ///       equal to the value of the user-specified <code>StartTime</code>.</p>
    public let alignedStartTime: ClientRuntime.Date?
    /// <p>The dimension keys that were requested.</p>
    public let keys: [PiClientTypes.DimensionKeyDescription]?
    /// <p>An optional pagination token provided by a previous request. If
    ///       this parameter is specified, the response includes only records beyond the token, up to the
    ///       value specified by <code>MaxRecords</code>.</p>
    public let nextToken: Swift.String?
    /// <p>If <code>PartitionBy</code> was present in the request, <code>PartitionKeys</code> contains the breakdown of dimension keys by the specified partitions.</p>
    public let partitionKeys: [PiClientTypes.ResponsePartitionKey]?

    public init (
        alignedEndTime: ClientRuntime.Date? = nil,
        alignedStartTime: ClientRuntime.Date? = nil,
        keys: [PiClientTypes.DimensionKeyDescription]? = nil,
        nextToken: Swift.String? = nil,
        partitionKeys: [PiClientTypes.ResponsePartitionKey]? = nil
    )
    {
        self.alignedEndTime = alignedEndTime
        self.alignedStartTime = alignedStartTime
        self.keys = keys
        self.nextToken = nextToken
        self.partitionKeys = partitionKeys
    }
}

struct DescribeDimensionKeysOutputResponseBody: Swift.Equatable {
    public let alignedStartTime: ClientRuntime.Date?
    public let alignedEndTime: ClientRuntime.Date?
    public let partitionKeys: [PiClientTypes.ResponsePartitionKey]?
    public let keys: [PiClientTypes.DimensionKeyDescription]?
    public let nextToken: Swift.String?
}

extension DescribeDimensionKeysOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alignedEndTime = "AlignedEndTime"
        case alignedStartTime = "AlignedStartTime"
        case keys = "Keys"
        case nextToken = "NextToken"
        case partitionKeys = "PartitionKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alignedStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .alignedStartTime)
        alignedStartTime = alignedStartTimeDecoded
        let alignedEndTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .alignedEndTime)
        alignedEndTime = alignedEndTimeDecoded
        let partitionKeysContainer = try containerValues.decodeIfPresent([PiClientTypes.ResponsePartitionKey?].self, forKey: .partitionKeys)
        var partitionKeysDecoded0:[PiClientTypes.ResponsePartitionKey]? = nil
        if let partitionKeysContainer = partitionKeysContainer {
            partitionKeysDecoded0 = [PiClientTypes.ResponsePartitionKey]()
            for structure0 in partitionKeysContainer {
                if let structure0 = structure0 {
                    partitionKeysDecoded0?.append(structure0)
                }
            }
        }
        partitionKeys = partitionKeysDecoded0
        let keysContainer = try containerValues.decodeIfPresent([PiClientTypes.DimensionKeyDescription?].self, forKey: .keys)
        var keysDecoded0:[PiClientTypes.DimensionKeyDescription]? = nil
        if let keysContainer = keysContainer {
            keysDecoded0 = [PiClientTypes.DimensionKeyDescription]()
            for structure0 in keysContainer {
                if let structure0 = structure0 {
                    keysDecoded0?.append(structure0)
                }
            }
        }
        keys = keysDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension PiClientTypes {
    public enum DetailStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case processing
        case unavailable
        case sdkUnknown(Swift.String)

        public static var allCases: [DetailStatus] {
            return [
                .available,
                .processing,
                .unavailable,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .processing: return "PROCESSING"
            case .unavailable: return "UNAVAILABLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DetailStatus(rawValue: rawValue) ?? DetailStatus.sdkUnknown(rawValue)
        }
    }
}

extension PiClientTypes.DimensionGroup: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensions = "Dimensions"
        case group = "Group"
        case limit = "Limit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensions = dimensions {
            var dimensionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dimensions)
            for requeststringlist0 in dimensions {
                try dimensionsContainer.encode(requeststringlist0)
            }
        }
        if let group = group {
            try encodeContainer.encode(group, forKey: .group)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .group)
        group = groupDecoded
        let dimensionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dimensions)
        var dimensionsDecoded0:[Swift.String]? = nil
        if let dimensionsContainer = dimensionsContainer {
            dimensionsDecoded0 = [Swift.String]()
            for string0 in dimensionsContainer {
                if let string0 = string0 {
                    dimensionsDecoded0?.append(string0)
                }
            }
        }
        dimensions = dimensionsDecoded0
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension PiClientTypes.DimensionGroup: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DimensionGroup(dimensions: \(Swift.String(describing: dimensions)), group: \(Swift.String(describing: group)), limit: \(Swift.String(describing: limit)))"}
}

extension PiClientTypes {
    /// <p>A logical grouping of Performance Insights metrics for a related subject area. For example, the
    ///         <code>db.sql</code> dimension group consists of the following dimensions:
    ///         <code>db.sql.id</code>, <code>db.sql.db_id</code>, <code>db.sql.statement</code>, and
    ///         <code>db.sql.tokenized_id</code>.</p>
    ///          <note>
    ///             <p>Each response element returns a maximum of 500 bytes. For larger elements, such as SQL statements,
    ///         only the first 500 bytes are returned.</p>
    ///          </note>
    public struct DimensionGroup: Swift.Equatable {
        /// <p>A list of specific dimensions from a dimension group. If this parameter is not present,
        ///       then it signifies that all of the dimensions in the group were requested, or are present in
        ///       the response.</p>
        ///          <p>Valid values for elements in the <code>Dimensions</code> array are:</p>
        ///
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <code>db.application.name</code> - The name of the application that is connected to the database (only
        ///       Aurora PostgreSQL and RDS PostgreSQL)</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>db.host.id</code> - The host ID of the connected client (all engines)</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>db.host.name</code> - The host name of the connected client (all engines)</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>db.name</code> - The name of the database to which the client is connected (only Aurora
        ///       PostgreSQL, RDS PostgreSQL, Aurora MySQL, RDS MySQL, and MariaDB)</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>db.session_type.name</code> - The type of the current session (only Aurora PostgreSQL and RDS PostgreSQL)</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>db.sql.id</code> - The SQL ID generated by Performance Insights (all engines)</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>db.sql.db_id</code> - The SQL ID generated by the database (all engines)</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>db.sql.statement</code> - The SQL text that is being executed (all engines)</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>db.sql.tokenized_id</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>db.sql_tokenized.id</code> - The SQL digest ID generated by Performance Insights (all engines)</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>db.sql_tokenized.db_id</code> - SQL digest ID generated by the database (all engines)</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>db.sql_tokenized.statement</code> - The SQL digest text (all engines)</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>db.user.id</code> - The ID of the user logged in to the database (all engines)</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>db.user.name</code> - The name of the user logged in to the database (all engines)</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>db.wait_event.name</code> - The event for which the backend is waiting (all engines)</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>db.wait_event.type</code> - The type of event for which the backend is waiting (all engines)</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>db.wait_event_type.name</code> - The name of the event type for which the backend is waiting (all
        ///       engines)</p>
        ///             </li>
        ///          </ul>
        public let dimensions: [Swift.String]?
        /// <p>The name of the dimension group.  Valid values are:</p>
        ///
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <code>db</code> - The name of the database to which the client is connected (only Aurora PostgreSQL, RDS
        ///         PostgreSQL, Aurora MySQL, RDS MySQL, and MariaDB)</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>db.application</code> - The name of the application that is connected to the database (only Aurora
        ///         PostgreSQL and RDS PostgreSQL)</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>db.host</code> - The host name of the connected client (all engines)</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>db.session_type</code> - The type of the current session (only Aurora PostgreSQL and RDS PostgreSQL)</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>db.sql</code> - The SQL that is currently executing (all engines)</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>db.sql_tokenized</code> - The SQL digest (all engines)</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>db.wait_event</code> - The event for which the database backend is waiting  (all engines)</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>db.wait_event_type</code> - The type of event for which the database backend is waiting (all engines)</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>db.user</code> - The user logged in to the database (all engines)</p>
        ///             </li>
        ///          </ul>
        public let group: Swift.String?
        /// <p>The maximum number of items to fetch for this dimension group.</p>
        public let limit: Swift.Int?

        public init (
            dimensions: [Swift.String]? = nil,
            group: Swift.String? = nil,
            limit: Swift.Int? = nil
        )
        {
            self.dimensions = dimensions
            self.group = group
            self.limit = limit
        }
    }

}

extension PiClientTypes.DimensionKeyDescription: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensions = "Dimensions"
        case partitions = "Partitions"
        case total = "Total"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensions = dimensions {
            var dimensionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .dimensions)
            for (dictKey0, dimensionmap0) in dimensions {
                try dimensionsContainer.encode(dimensionmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let partitions = partitions {
            var partitionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .partitions)
            for metricvalueslist0 in partitions {
                try partitionsContainer.encode(metricvalueslist0)
            }
        }
        if let total = total {
            try encodeContainer.encode(total, forKey: .total)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .dimensions)
        var dimensionsDecoded0: [Swift.String:Swift.String]? = nil
        if let dimensionsContainer = dimensionsContainer {
            dimensionsDecoded0 = [Swift.String:Swift.String]()
            for (key0, requeststring0) in dimensionsContainer {
                if let requeststring0 = requeststring0 {
                    dimensionsDecoded0?[key0] = requeststring0
                }
            }
        }
        dimensions = dimensionsDecoded0
        let totalDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .total)
        total = totalDecoded
        let partitionsContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .partitions)
        var partitionsDecoded0:[Swift.Double]? = nil
        if let partitionsContainer = partitionsContainer {
            partitionsDecoded0 = [Swift.Double]()
            for double0 in partitionsContainer {
                if let double0 = double0 {
                    partitionsDecoded0?.append(double0)
                }
            }
        }
        partitions = partitionsDecoded0
    }
}

extension PiClientTypes.DimensionKeyDescription: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DimensionKeyDescription(dimensions: \(Swift.String(describing: dimensions)), partitions: \(Swift.String(describing: partitions)), total: \(Swift.String(describing: total)))"}
}

extension PiClientTypes {
    /// <p>An array of descriptions and aggregated values for
    ///       each dimension within a dimension group.</p>
    public struct DimensionKeyDescription: Swift.Equatable {
        /// <p>A map of name-value pairs for the dimensions in the group.</p>
        public let dimensions: [Swift.String:Swift.String]?
        /// <p>If <code>PartitionBy</code> was specified, <code>PartitionKeys</code> contains the dimensions that were.</p>
        public let partitions: [Swift.Double]?
        /// <p>The aggregated metric value for the dimension(s), over the requested time range.</p>
        public let total: Swift.Double?

        public init (
            dimensions: [Swift.String:Swift.String]? = nil,
            partitions: [Swift.Double]? = nil,
            total: Swift.Double? = nil
        )
        {
            self.dimensions = dimensions
            self.partitions = partitions
            self.total = total
        }
    }

}

extension PiClientTypes.DimensionKeyDetail: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimension = "Dimension"
        case status = "Status"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimension = dimension {
            try encodeContainer.encode(dimension, forKey: .dimension)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let dimensionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dimension)
        dimension = dimensionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PiClientTypes.DetailStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension PiClientTypes.DimensionKeyDetail: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DimensionKeyDetail(dimension: \(Swift.String(describing: dimension)), status: \(Swift.String(describing: status)), value: \(Swift.String(describing: value)))"}
}

extension PiClientTypes {
    /// <p>An object that describes the details for a specified dimension.</p>
    public struct DimensionKeyDetail: Swift.Equatable {
        /// <p>The full name of the dimension. The full name includes the group name and key name. The only valid value is
        ///         <code>db.sql.statement</code>. </p>
        public let dimension: Swift.String?
        /// <p>The status of the dimension detail data. Possible values include the following:</p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <code>AVAILABLE</code> - The dimension detail data is ready to be retrieved.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>PROCESSING</code> - The dimension detail data isn't ready to be retrieved because more processing time is
        ///           required. If the requested detail data for <code>db.sql.statement</code> has the status <code>PROCESSING</code>,
        ///           Performance Insights returns the truncated query.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>UNAVAILABLE</code> - The dimension detail data could not be collected successfully.</p>
        ///             </li>
        ///          </ul>
        public let status: PiClientTypes.DetailStatus?
        /// <p>The value of the dimension detail data. For the <code>db.sql.statement</code> dimension, this value is either the
        ///       full or truncated SQL query, depending on the return status.</p>
        public let value: Swift.String?

        public init (
            dimension: Swift.String? = nil,
            status: PiClientTypes.DetailStatus? = nil,
            value: Swift.String? = nil
        )
        {
            self.dimension = dimension
            self.status = status
            self.value = value
        }
    }

}

public struct GetDimensionKeyDetailsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDimensionKeyDetailsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDimensionKeyDetailsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDimensionKeyDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDimensionKeyDetailsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDimensionKeyDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDimensionKeyDetailsOutputError>
}

extension GetDimensionKeyDetailsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDimensionKeyDetailsInput(group: \(Swift.String(describing: group)), groupIdentifier: \(Swift.String(describing: groupIdentifier)), identifier: \(Swift.String(describing: identifier)), requestedDimensions: \(Swift.String(describing: requestedDimensions)), serviceType: \(Swift.String(describing: serviceType)))"}
}

extension GetDimensionKeyDetailsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case group = "Group"
        case groupIdentifier = "GroupIdentifier"
        case identifier = "Identifier"
        case requestedDimensions = "RequestedDimensions"
        case serviceType = "ServiceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let group = group {
            try encodeContainer.encode(group, forKey: .group)
        }
        if let groupIdentifier = groupIdentifier {
            try encodeContainer.encode(groupIdentifier, forKey: .groupIdentifier)
        }
        if let identifier = identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let requestedDimensions = requestedDimensions {
            var requestedDimensionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .requestedDimensions)
            for requesteddimensionlist0 in requestedDimensions {
                try requestedDimensionsContainer.encode(requesteddimensionlist0)
            }
        }
        if let serviceType = serviceType {
            try encodeContainer.encode(serviceType.rawValue, forKey: .serviceType)
        }
    }
}

public struct GetDimensionKeyDetailsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDimensionKeyDetailsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDimensionKeyDetailsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDimensionKeyDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDimensionKeyDetailsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDimensionKeyDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDimensionKeyDetailsOutputError>
}

public struct GetDimensionKeyDetailsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDimensionKeyDetailsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDimensionKeyDetailsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDimensionKeyDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDimensionKeyDetailsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDimensionKeyDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDimensionKeyDetailsOutputError>
}

public struct GetDimensionKeyDetailsInput: Swift.Equatable {
    /// <p>The name of the dimension group. The only valid value is <code>db.sql</code>. Performance Insights searches the
    ///       specified group for the dimension group ID.</p>
    public let group: Swift.String?
    /// <p>The ID of the dimension group from which to retrieve dimension details. For dimension group <code>db.sql</code>,
    ///       the group ID is <code>db.sql.id</code>.</p>
    public let groupIdentifier: Swift.String?
    /// <p>The ID for a data source from which to gather dimension data. This ID must be immutable and unique within an AWS
    ///       Region. When a DB instance is the data source, specify its <code>DbiResourceId</code> value. For example, specify
    ///         <code>db-ABCDEFGHIJKLMNOPQRSTU1VW2X</code>. </p>
    public let identifier: Swift.String?
    /// <p>A list of dimensions to retrieve the detail data for within the given dimension group. For the dimension group
    ///                 <code>db.sql</code>, specify either the full dimension name <code>db.sql.statement</code> or the short
    ///             dimension name <code>statement</code>. If you don't specify this parameter, Performance Insights returns all
    ///             dimension data within the specified dimension group.</p>
    public let requestedDimensions: [Swift.String]?
    /// <p>The AWS service for which Performance Insights returns data. The only valid value is <code>RDS</code>.</p>
    public let serviceType: PiClientTypes.ServiceType?

    public init (
        group: Swift.String? = nil,
        groupIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil,
        requestedDimensions: [Swift.String]? = nil,
        serviceType: PiClientTypes.ServiceType? = nil
    )
    {
        self.group = group
        self.groupIdentifier = groupIdentifier
        self.identifier = identifier
        self.requestedDimensions = requestedDimensions
        self.serviceType = serviceType
    }
}

struct GetDimensionKeyDetailsInputBody: Swift.Equatable {
    public let serviceType: PiClientTypes.ServiceType?
    public let identifier: Swift.String?
    public let group: Swift.String?
    public let groupIdentifier: Swift.String?
    public let requestedDimensions: [Swift.String]?
}

extension GetDimensionKeyDetailsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case group = "Group"
        case groupIdentifier = "GroupIdentifier"
        case identifier = "Identifier"
        case requestedDimensions = "RequestedDimensions"
        case serviceType = "ServiceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceTypeDecoded = try containerValues.decodeIfPresent(PiClientTypes.ServiceType.self, forKey: .serviceType)
        serviceType = serviceTypeDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let groupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .group)
        group = groupDecoded
        let groupIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupIdentifier)
        groupIdentifier = groupIdentifierDecoded
        let requestedDimensionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .requestedDimensions)
        var requestedDimensionsDecoded0:[Swift.String]? = nil
        if let requestedDimensionsContainer = requestedDimensionsContainer {
            requestedDimensionsDecoded0 = [Swift.String]()
            for string0 in requestedDimensionsContainer {
                if let string0 = string0 {
                    requestedDimensionsDecoded0?.append(string0)
                }
            }
        }
        requestedDimensions = requestedDimensionsDecoded0
    }
}

extension GetDimensionKeyDetailsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDimensionKeyDetailsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDimensionKeyDetailsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidArgumentException(InvalidArgumentException)
    case notAuthorizedException(NotAuthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDimensionKeyDetailsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDimensionKeyDetailsOutputResponse(dimensions: \(Swift.String(describing: dimensions)))"}
}

extension GetDimensionKeyDetailsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDimensionKeyDetailsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dimensions = output.dimensions
        } else {
            self.dimensions = nil
        }
    }
}

public struct GetDimensionKeyDetailsOutputResponse: Swift.Equatable {
    /// <p>The details for the requested dimensions.</p>
    public let dimensions: [PiClientTypes.DimensionKeyDetail]?

    public init (
        dimensions: [PiClientTypes.DimensionKeyDetail]? = nil
    )
    {
        self.dimensions = dimensions
    }
}

struct GetDimensionKeyDetailsOutputResponseBody: Swift.Equatable {
    public let dimensions: [PiClientTypes.DimensionKeyDetail]?
}

extension GetDimensionKeyDetailsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensions = "Dimensions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionsContainer = try containerValues.decodeIfPresent([PiClientTypes.DimensionKeyDetail?].self, forKey: .dimensions)
        var dimensionsDecoded0:[PiClientTypes.DimensionKeyDetail]? = nil
        if let dimensionsContainer = dimensionsContainer {
            dimensionsDecoded0 = [PiClientTypes.DimensionKeyDetail]()
            for structure0 in dimensionsContainer {
                if let structure0 = structure0 {
                    dimensionsDecoded0?.append(structure0)
                }
            }
        }
        dimensions = dimensionsDecoded0
    }
}

public struct GetResourceMetricsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetResourceMetricsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetResourceMetricsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetResourceMetricsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetResourceMetricsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetResourceMetricsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetResourceMetricsOutputError>
}

extension GetResourceMetricsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetResourceMetricsInput(endTime: \(Swift.String(describing: endTime)), identifier: \(Swift.String(describing: identifier)), maxResults: \(Swift.String(describing: maxResults)), metricQueries: \(Swift.String(describing: metricQueries)), nextToken: \(Swift.String(describing: nextToken)), periodInSeconds: \(Swift.String(describing: periodInSeconds)), serviceType: \(Swift.String(describing: serviceType)), startTime: \(Swift.String(describing: startTime)))"}
}

extension GetResourceMetricsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case identifier = "Identifier"
        case maxResults = "MaxResults"
        case metricQueries = "MetricQueries"
        case nextToken = "NextToken"
        case periodInSeconds = "PeriodInSeconds"
        case serviceType = "ServiceType"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let identifier = identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let metricQueries = metricQueries {
            var metricQueriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metricQueries)
            for metricquerylist0 in metricQueries {
                try metricQueriesContainer.encode(metricquerylist0)
            }
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let periodInSeconds = periodInSeconds {
            try encodeContainer.encode(periodInSeconds, forKey: .periodInSeconds)
        }
        if let serviceType = serviceType {
            try encodeContainer.encode(serviceType.rawValue, forKey: .serviceType)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }
}

public struct GetResourceMetricsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetResourceMetricsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetResourceMetricsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetResourceMetricsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetResourceMetricsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetResourceMetricsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetResourceMetricsOutputError>
}

public struct GetResourceMetricsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetResourceMetricsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetResourceMetricsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetResourceMetricsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetResourceMetricsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetResourceMetricsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetResourceMetricsOutputError>
}

public struct GetResourceMetricsInput: Swift.Equatable {
    /// <p>The date and time specifying the end of the requested time series data.  The value specified is
    ///       <i>exclusive</i> - data points less than (but not equal to) <code>EndTime</code> will be returned.</p>
    ///          <p>The value for <code>EndTime</code> must be later than the value for <code>StartTime</code>.</p>
    public let endTime: ClientRuntime.Date?
    /// <p>An immutable, AWS Region-unique identifier for a data source. Performance Insights gathers metrics from
    ///       this data source.</p>
    ///          <p>To use a DB instance as a data source, specify its <code>DbiResourceId</code> value. For example, specify
    ///         <code>db-FAIHNTYBKTGAUSUZQYPDS2GW4A</code>.</p>
    public let identifier: Swift.String?
    /// <p>The maximum number of items to return in the response.
    ///       If more items exist than the specified <code>MaxRecords</code> value, a pagination
    ///       token is included in the response so that the remaining
    ///       results can be retrieved.
    ///     </p>
    public let maxResults: Swift.Int?
    /// <p>An array of one or more queries to perform. Each query must specify a Performance Insights metric, and
    ///       can optionally specify aggregation and filtering criteria.</p>
    public let metricQueries: [PiClientTypes.MetricQuery]?
    /// <p>An optional pagination token provided by a previous request. If
    ///       this parameter is specified, the response includes only records beyond the token, up to the
    ///       value specified by <code>MaxRecords</code>.</p>
    public let nextToken: Swift.String?
    /// <p>The granularity, in seconds, of the data points returned from Performance Insights. A period can be as short as
    ///       one second, or as long as one day (86400 seconds).  Valid values are:</p>
    ///
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>1</code> (one second)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>60</code> (one minute)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>300</code> (five minutes)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>3600</code> (one hour)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>86400</code> (twenty-four hours)</p>
    ///             </li>
    ///          </ul>
    ///
    ///          <p>If you don't specify <code>PeriodInSeconds</code>, then Performance Insights will choose a value for
    ///       you, with a goal of returning roughly 100-200 data points in the response.</p>
    public let periodInSeconds: Swift.Int?
    /// <p>The AWS service for which Performance Insights returns metrics. The only valid value for <i>ServiceType</i> is
    ///         <code>RDS</code>.</p>
    public let serviceType: PiClientTypes.ServiceType?
    /// <p>The date and time specifying the beginning of the requested time series data. You can't
    ///       specify a <code>StartTime</code> that's earlier than 7 days ago. The value specified is
    ///         <i>inclusive</i> - data points equal to or greater than <code>StartTime</code>
    ///       will be returned.</p>
    ///          <p>The value for <code>StartTime</code> must be earlier than the value for <code>EndTime</code>.</p>
    public let startTime: ClientRuntime.Date?

    public init (
        endTime: ClientRuntime.Date? = nil,
        identifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        metricQueries: [PiClientTypes.MetricQuery]? = nil,
        nextToken: Swift.String? = nil,
        periodInSeconds: Swift.Int? = nil,
        serviceType: PiClientTypes.ServiceType? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.endTime = endTime
        self.identifier = identifier
        self.maxResults = maxResults
        self.metricQueries = metricQueries
        self.nextToken = nextToken
        self.periodInSeconds = periodInSeconds
        self.serviceType = serviceType
        self.startTime = startTime
    }
}

struct GetResourceMetricsInputBody: Swift.Equatable {
    public let serviceType: PiClientTypes.ServiceType?
    public let identifier: Swift.String?
    public let metricQueries: [PiClientTypes.MetricQuery]?
    public let startTime: ClientRuntime.Date?
    public let endTime: ClientRuntime.Date?
    public let periodInSeconds: Swift.Int?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension GetResourceMetricsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case identifier = "Identifier"
        case maxResults = "MaxResults"
        case metricQueries = "MetricQueries"
        case nextToken = "NextToken"
        case periodInSeconds = "PeriodInSeconds"
        case serviceType = "ServiceType"
        case startTime = "StartTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceTypeDecoded = try containerValues.decodeIfPresent(PiClientTypes.ServiceType.self, forKey: .serviceType)
        serviceType = serviceTypeDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let metricQueriesContainer = try containerValues.decodeIfPresent([PiClientTypes.MetricQuery?].self, forKey: .metricQueries)
        var metricQueriesDecoded0:[PiClientTypes.MetricQuery]? = nil
        if let metricQueriesContainer = metricQueriesContainer {
            metricQueriesDecoded0 = [PiClientTypes.MetricQuery]()
            for structure0 in metricQueriesContainer {
                if let structure0 = structure0 {
                    metricQueriesDecoded0?.append(structure0)
                }
            }
        }
        metricQueries = metricQueriesDecoded0
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let periodInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .periodInSeconds)
        periodInSeconds = periodInSecondsDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetResourceMetricsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourceMetricsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResourceMetricsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidArgumentException(InvalidArgumentException)
    case notAuthorizedException(NotAuthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourceMetricsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetResourceMetricsOutputResponse(alignedEndTime: \(Swift.String(describing: alignedEndTime)), alignedStartTime: \(Swift.String(describing: alignedStartTime)), identifier: \(Swift.String(describing: identifier)), metricList: \(Swift.String(describing: metricList)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetResourceMetricsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetResourceMetricsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.alignedEndTime = output.alignedEndTime
            self.alignedStartTime = output.alignedStartTime
            self.identifier = output.identifier
            self.metricList = output.metricList
            self.nextToken = output.nextToken
        } else {
            self.alignedEndTime = nil
            self.alignedStartTime = nil
            self.identifier = nil
            self.metricList = nil
            self.nextToken = nil
        }
    }
}

public struct GetResourceMetricsOutputResponse: Swift.Equatable {
    /// <p>The end time for the returned metrics, after alignment to a granular boundary (as
    ///       specified by <code>PeriodInSeconds</code>). <code>AlignedEndTime</code> will be greater than
    ///       or equal to the value of the user-specified <code>Endtime</code>.</p>
    public let alignedEndTime: ClientRuntime.Date?
    /// <p>The start time for the returned metrics, after alignment to a granular boundary (as
    ///       specified by <code>PeriodInSeconds</code>). <code>AlignedStartTime</code> will be less than or
    ///       equal to the value of the user-specified <code>StartTime</code>.</p>
    public let alignedStartTime: ClientRuntime.Date?
    /// <p>An immutable, AWS Region-unique identifier for a data source. Performance Insights gathers metrics from
    ///       this data source.</p>
    ///          <p>To use a DB instance as a data source, you specify its
    ///       <code>DbiResourceId</code> value - for example:
    ///       <code>db-FAIHNTYBKTGAUSUZQYPDS2GW4A</code>
    ///          </p>
    public let identifier: Swift.String?
    /// <p>An array of metric results,, where each array element contains all of the data points for a particular dimension.</p>
    public let metricList: [PiClientTypes.MetricKeyDataPoints]?
    /// <p>An optional pagination token provided by a previous request. If
    ///       this parameter is specified, the response includes only records beyond the token, up to the
    ///       value specified by <code>MaxRecords</code>.</p>
    public let nextToken: Swift.String?

    public init (
        alignedEndTime: ClientRuntime.Date? = nil,
        alignedStartTime: ClientRuntime.Date? = nil,
        identifier: Swift.String? = nil,
        metricList: [PiClientTypes.MetricKeyDataPoints]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.alignedEndTime = alignedEndTime
        self.alignedStartTime = alignedStartTime
        self.identifier = identifier
        self.metricList = metricList
        self.nextToken = nextToken
    }
}

struct GetResourceMetricsOutputResponseBody: Swift.Equatable {
    public let alignedStartTime: ClientRuntime.Date?
    public let alignedEndTime: ClientRuntime.Date?
    public let identifier: Swift.String?
    public let metricList: [PiClientTypes.MetricKeyDataPoints]?
    public let nextToken: Swift.String?
}

extension GetResourceMetricsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alignedEndTime = "AlignedEndTime"
        case alignedStartTime = "AlignedStartTime"
        case identifier = "Identifier"
        case metricList = "MetricList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alignedStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .alignedStartTime)
        alignedStartTime = alignedStartTimeDecoded
        let alignedEndTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .alignedEndTime)
        alignedEndTime = alignedEndTimeDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let metricListContainer = try containerValues.decodeIfPresent([PiClientTypes.MetricKeyDataPoints?].self, forKey: .metricList)
        var metricListDecoded0:[PiClientTypes.MetricKeyDataPoints]? = nil
        if let metricListContainer = metricListContainer {
            metricListDecoded0 = [PiClientTypes.MetricKeyDataPoints]()
            for structure0 in metricListContainer {
                if let structure0 = structure0 {
                    metricListDecoded0?.append(structure0)
                }
            }
        }
        metricList = metricListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension InternalServiceError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServiceError(message: \(Swift.String(describing: message)))"}
}

extension InternalServiceError: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServiceErrorBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request failed due to an unknown error.</p>
public struct InternalServiceError: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServiceErrorBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServiceErrorBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidArgumentException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidArgumentException(message: \(Swift.String(describing: message)))"}
}

extension InvalidArgumentException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidArgumentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One of the arguments provided is invalid for this request.</p>
public struct InvalidArgumentException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidArgumentExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidArgumentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PiClientTypes.MetricKeyDataPoints: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataPoints = "DataPoints"
        case key = "Key"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataPoints = dataPoints {
            var dataPointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataPoints)
            for datapointslist0 in dataPoints {
                try dataPointsContainer.encode(datapointslist0)
            }
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(PiClientTypes.ResponseResourceMetricKey.self, forKey: .key)
        key = keyDecoded
        let dataPointsContainer = try containerValues.decodeIfPresent([PiClientTypes.DataPoint?].self, forKey: .dataPoints)
        var dataPointsDecoded0:[PiClientTypes.DataPoint]? = nil
        if let dataPointsContainer = dataPointsContainer {
            dataPointsDecoded0 = [PiClientTypes.DataPoint]()
            for structure0 in dataPointsContainer {
                if let structure0 = structure0 {
                    dataPointsDecoded0?.append(structure0)
                }
            }
        }
        dataPoints = dataPointsDecoded0
    }
}

extension PiClientTypes.MetricKeyDataPoints: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MetricKeyDataPoints(dataPoints: \(Swift.String(describing: dataPoints)), key: \(Swift.String(describing: key)))"}
}

extension PiClientTypes {
    /// <p>A time-ordered series of data points, corresponding to a dimension of a Performance Insights
    ///       metric.</p>
    public struct MetricKeyDataPoints: Swift.Equatable {
        /// <p>An array of timestamp-value pairs, representing measurements over a period of time.</p>
        public let dataPoints: [PiClientTypes.DataPoint]?
        /// <p>The dimension(s) to which the data points apply.</p>
        public let key: PiClientTypes.ResponseResourceMetricKey?

        public init (
            dataPoints: [PiClientTypes.DataPoint]? = nil,
            key: PiClientTypes.ResponseResourceMetricKey? = nil
        )
        {
            self.dataPoints = dataPoints
            self.key = key
        }
    }

}

extension PiClientTypes.MetricQuery: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case groupBy = "GroupBy"
        case metric = "Metric"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            var filterContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .filter)
            for (dictKey0, metricqueryfiltermap0) in filter {
                try filterContainer.encode(metricqueryfiltermap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let groupBy = groupBy {
            try encodeContainer.encode(groupBy, forKey: .groupBy)
        }
        if let metric = metric {
            try encodeContainer.encode(metric, forKey: .metric)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metric)
        metric = metricDecoded
        let groupByDecoded = try containerValues.decodeIfPresent(PiClientTypes.DimensionGroup.self, forKey: .groupBy)
        groupBy = groupByDecoded
        let filterContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .filter)
        var filterDecoded0: [Swift.String:Swift.String]? = nil
        if let filterContainer = filterContainer {
            filterDecoded0 = [Swift.String:Swift.String]()
            for (key0, requeststring0) in filterContainer {
                if let requeststring0 = requeststring0 {
                    filterDecoded0?[key0] = requeststring0
                }
            }
        }
        filter = filterDecoded0
    }
}

extension PiClientTypes.MetricQuery: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MetricQuery(filter: \(Swift.String(describing: filter)), groupBy: \(Swift.String(describing: groupBy)), metric: \(Swift.String(describing: metric)))"}
}

extension PiClientTypes {
    /// <p>A single query to be processed. You must provide the metric to query. If no other
    ///       parameters are specified, Performance Insights returns all of the data points for that metric. You can
    ///       optionally request that the data points be aggregated by dimension group (
    ///       <code>GroupBy</code>), and return only those data points that match your criteria (<code>Filter</code>).</p>
    public struct MetricQuery: Swift.Equatable {
        /// <p>One or more filters to apply in the request.  Restrictions:</p>
        ///          <ul>
        ///             <li>
        ///                <p>Any number of filters by the same dimension, as specified in the <code>GroupBy</code> parameter.</p>
        ///             </li>
        ///             <li>
        ///                <p>A single filter for any other dimension in this dimension group.</p>
        ///             </li>
        ///          </ul>
        public let filter: [Swift.String:Swift.String]?
        /// <p>A specification for how to aggregate the data points from a query result. You must
        ///       specify a valid dimension group.  Performance Insights will return all of the dimensions within that group,
        ///       unless you provide the names of specific dimensions within that group. You can also request
        ///       that Performance Insights return a limited number of values for a dimension.</p>
        public let groupBy: PiClientTypes.DimensionGroup?
        /// <p>The name of a Performance Insights metric to be measured.</p>
        ///          <p>Valid values for <code>Metric</code> are:</p>
        ///
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <code>db.load.avg</code> - a scaled representation of the number of active sessions
        ///           for the database engine.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>db.sampledload.avg</code> - the raw number of active sessions for the
        ///           database engine.</p>
        ///             </li>
        ///          </ul>
        ///          <p>If the number of active sessions is less than an internal Performance Insights threshold, <code>db.load.avg</code> and <code>db.sampledload.avg</code>
        ///           are the same value. If the number of active sessions is greater than the internal threshold, Performance Insights samples the active sessions, with <code>db.load.avg</code>
        ///           showing the scaled values, <code>db.sampledload.avg</code> showing the raw values, and <code>db.sampledload.avg</code> less than <code>db.load.avg</code>.
        ///           For most use cases, you can query <code>db.load.avg</code> only. </p>
        public let metric: Swift.String?

        public init (
            filter: [Swift.String:Swift.String]? = nil,
            groupBy: PiClientTypes.DimensionGroup? = nil,
            metric: Swift.String? = nil
        )
        {
            self.filter = filter
            self.groupBy = groupBy
            self.metric = metric
        }
    }

}

extension NotAuthorizedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotAuthorizedException(message: \(Swift.String(describing: message)))"}
}

extension NotAuthorizedException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NotAuthorizedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The user is not authorized to perform this request.</p>
public struct NotAuthorizedException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NotAuthorizedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NotAuthorizedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PiClientTypes.ResponsePartitionKey: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensions = "Dimensions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensions = dimensions {
            var dimensionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .dimensions)
            for (dictKey0, dimensionmap0) in dimensions {
                try dimensionsContainer.encode(dimensionmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .dimensions)
        var dimensionsDecoded0: [Swift.String:Swift.String]? = nil
        if let dimensionsContainer = dimensionsContainer {
            dimensionsDecoded0 = [Swift.String:Swift.String]()
            for (key0, requeststring0) in dimensionsContainer {
                if let requeststring0 = requeststring0 {
                    dimensionsDecoded0?[key0] = requeststring0
                }
            }
        }
        dimensions = dimensionsDecoded0
    }
}

extension PiClientTypes.ResponsePartitionKey: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResponsePartitionKey(dimensions: \(Swift.String(describing: dimensions)))"}
}

extension PiClientTypes {
    /// <p>If <code>PartitionBy</code> was specified in a <code>DescribeDimensionKeys</code>
    ///       request, the dimensions are returned in an array. Each element in the array specifies one
    ///       dimension. </p>
    public struct ResponsePartitionKey: Swift.Equatable {
        /// <p>A dimension map that contains the dimension(s) for this partition.</p>
        public let dimensions: [Swift.String:Swift.String]?

        public init (
            dimensions: [Swift.String:Swift.String]? = nil
        )
        {
            self.dimensions = dimensions
        }
    }

}

extension PiClientTypes.ResponseResourceMetricKey: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensions = "Dimensions"
        case metric = "Metric"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensions = dimensions {
            var dimensionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .dimensions)
            for (dictKey0, dimensionmap0) in dimensions {
                try dimensionsContainer.encode(dimensionmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let metric = metric {
            try encodeContainer.encode(metric, forKey: .metric)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metric)
        metric = metricDecoded
        let dimensionsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .dimensions)
        var dimensionsDecoded0: [Swift.String:Swift.String]? = nil
        if let dimensionsContainer = dimensionsContainer {
            dimensionsDecoded0 = [Swift.String:Swift.String]()
            for (key0, requeststring0) in dimensionsContainer {
                if let requeststring0 = requeststring0 {
                    dimensionsDecoded0?[key0] = requeststring0
                }
            }
        }
        dimensions = dimensionsDecoded0
    }
}

extension PiClientTypes.ResponseResourceMetricKey: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResponseResourceMetricKey(dimensions: \(Swift.String(describing: dimensions)), metric: \(Swift.String(describing: metric)))"}
}

extension PiClientTypes {
    /// <p>An object describing a Performance Insights metric and one or more dimensions for that metric.</p>
    public struct ResponseResourceMetricKey: Swift.Equatable {
        /// <p>The valid dimensions for the metric.</p>
        public let dimensions: [Swift.String:Swift.String]?
        /// <p>The name of a Performance Insights metric to be measured.</p>
        ///          <p>Valid values for <code>Metric</code> are:</p>
        ///
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <code>db.load.avg</code> - a scaled representation of the number of active sessions
        ///           for the database engine.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>db.sampledload.avg</code> - the raw number of active sessions for the
        ///           database engine.</p>
        ///             </li>
        ///          </ul>
        ///          <p>If the number of active sessions is less than an internal Performance Insights threshold, <code>db.load.avg</code> and <code>db.sampledload.avg</code>
        ///           are the same value. If the number of active sessions is greater than the internal threshold, Performance Insights samples the active sessions, with <code>db.load.avg</code>
        ///           showing the scaled values, <code>db.sampledload.avg</code> showing the raw values, and <code>db.sampledload.avg</code> less than <code>db.load.avg</code>.
        ///           For most use cases, you can query <code>db.load.avg</code> only. </p>
        public let metric: Swift.String?

        public init (
            dimensions: [Swift.String:Swift.String]? = nil,
            metric: Swift.String? = nil
        )
        {
            self.dimensions = dimensions
            self.metric = metric
        }
    }

}

extension PiClientTypes {
    public enum ServiceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case rds
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceType] {
            return [
                .rds,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .rds: return "RDS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceType(rawValue: rawValue) ?? ServiceType.sdkUnknown(rawValue)
        }
    }
}
