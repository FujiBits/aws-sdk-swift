// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

#if swift(>=5.5)
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, macCatalyst 15.0, *)
public extension BackupClient {
    /// <p>Creates a backup plan using a backup plan name and backup rules. A backup plan is a
    ///          document that contains information that AWS Backup uses to schedule tasks that create
    ///          recovery points for resources.</p>
    ///          <p>If you call <code>CreateBackupPlan</code> with a plan that already exists, an
    ///             <code>AlreadyExistsException</code> is returned.</p>
    func createBackupPlan(input: CreateBackupPlanInput) async throws -> CreateBackupPlanOutputResponse
    {
        typealias createBackupPlanContinuation = CheckedContinuation<CreateBackupPlanOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createBackupPlanContinuation) in
            createBackupPlan(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates a JSON document that specifies a set of resources to assign to a backup plan.
    ///          Resources can be included by specifying patterns for a <code>ListOfTags</code> and selected
    ///             <code>Resources</code>. </p>
    ///          <p>For example, consider the following patterns:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Resources: "arn:aws:ec2:region:account-id:volume/volume-id"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ConditionKey:"department"</code>
    ///                </p>
    ///                <p>
    ///                   <code>ConditionValue:"finance"</code>
    ///                </p>
    ///                <p>
    ///                   <code>ConditionType:"StringEquals"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ConditionKey:"importance"</code>
    ///                </p>
    ///                <p>
    ///                   <code>ConditionValue:"critical"</code>
    ///                </p>
    ///                <p>
    ///                   <code>ConditionType:"StringEquals"</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>Using these patterns would back up all Amazon Elastic Block Store (Amazon EBS) volumes
    ///          that are tagged as <code>"department=finance"</code>, <code>"importance=critical"</code>,
    ///          in addition to an EBS volume with the specified volume ID.</p>
    ///          <p>Resources and conditions are additive in that all resources that match the pattern are
    ///          selected. This shouldn't be confused with a logical AND, where all conditions must match.
    ///          The matching patterns are logically put together using the OR operator.
    ///          In other words, all patterns that match are selected for backup.</p>
    func createBackupSelection(input: CreateBackupSelectionInput) async throws -> CreateBackupSelectionOutputResponse
    {
        typealias createBackupSelectionContinuation = CheckedContinuation<CreateBackupSelectionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createBackupSelectionContinuation) in
            createBackupSelection(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates a logical container where backups are stored. A <code>CreateBackupVault</code>
    ///          request includes a name, optionally one or more resource tags, an encryption key, and a
    ///          request ID.</p>
    ///          <note>
    ///             <p>Sensitive data, such as passport numbers, should not be included the name of a backup
    ///             vault.</p>
    ///          </note>
    func createBackupVault(input: CreateBackupVaultInput) async throws -> CreateBackupVaultOutputResponse
    {
        typealias createBackupVaultContinuation = CheckedContinuation<CreateBackupVaultOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createBackupVaultContinuation) in
            createBackupVault(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes a backup plan. A backup plan can only be deleted after all associated selections
    ///          of resources have been deleted. Deleting a backup plan deletes the current version of a
    ///          backup plan. Previous versions, if any, will still exist.</p>
    func deleteBackupPlan(input: DeleteBackupPlanInput) async throws -> DeleteBackupPlanOutputResponse
    {
        typealias deleteBackupPlanContinuation = CheckedContinuation<DeleteBackupPlanOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteBackupPlanContinuation) in
            deleteBackupPlan(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes the resource selection associated with a backup plan that is specified by the
    ///             <code>SelectionId</code>.</p>
    func deleteBackupSelection(input: DeleteBackupSelectionInput) async throws -> DeleteBackupSelectionOutputResponse
    {
        typealias deleteBackupSelectionContinuation = CheckedContinuation<DeleteBackupSelectionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteBackupSelectionContinuation) in
            deleteBackupSelection(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes the backup vault identified by its name. A vault can be deleted only if it is
    ///          empty.</p>
    func deleteBackupVault(input: DeleteBackupVaultInput) async throws -> DeleteBackupVaultOutputResponse
    {
        typealias deleteBackupVaultContinuation = CheckedContinuation<DeleteBackupVaultOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteBackupVaultContinuation) in
            deleteBackupVault(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes the policy document that manages permissions on a backup vault.</p>
    func deleteBackupVaultAccessPolicy(input: DeleteBackupVaultAccessPolicyInput) async throws -> DeleteBackupVaultAccessPolicyOutputResponse
    {
        typealias deleteBackupVaultAccessPolicyContinuation = CheckedContinuation<DeleteBackupVaultAccessPolicyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteBackupVaultAccessPolicyContinuation) in
            deleteBackupVaultAccessPolicy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes event notifications for the specified backup vault.</p>
    func deleteBackupVaultNotifications(input: DeleteBackupVaultNotificationsInput) async throws -> DeleteBackupVaultNotificationsOutputResponse
    {
        typealias deleteBackupVaultNotificationsContinuation = CheckedContinuation<DeleteBackupVaultNotificationsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteBackupVaultNotificationsContinuation) in
            deleteBackupVaultNotifications(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes the recovery point specified by a recovery point ID.</p>
    ///          <p>If the recovery point ID belongs to a continuous backup, calling this endpoint deletes
    ///          the existing continuous backup and stops future continuous backup.</p>
    func deleteRecoveryPoint(input: DeleteRecoveryPointInput) async throws -> DeleteRecoveryPointOutputResponse
    {
        typealias deleteRecoveryPointContinuation = CheckedContinuation<DeleteRecoveryPointOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteRecoveryPointContinuation) in
            deleteRecoveryPoint(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns backup job details for the specified <code>BackupJobId</code>.</p>
    func describeBackupJob(input: DescribeBackupJobInput) async throws -> DescribeBackupJobOutputResponse
    {
        typealias describeBackupJobContinuation = CheckedContinuation<DescribeBackupJobOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeBackupJobContinuation) in
            describeBackupJob(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns metadata about a backup vault specified by its name.</p>
    func describeBackupVault(input: DescribeBackupVaultInput) async throws -> DescribeBackupVaultOutputResponse
    {
        typealias describeBackupVaultContinuation = CheckedContinuation<DescribeBackupVaultOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeBackupVaultContinuation) in
            describeBackupVault(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns metadata associated with creating a copy of a resource.</p>
    func describeCopyJob(input: DescribeCopyJobInput) async throws -> DescribeCopyJobOutputResponse
    {
        typealias describeCopyJobContinuation = CheckedContinuation<DescribeCopyJobOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeCopyJobContinuation) in
            describeCopyJob(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Describes the global settings of the AWS account, including whether it is opted in to
    ///          cross-account backup.</p>
    func describeGlobalSettings(input: DescribeGlobalSettingsInput) async throws -> DescribeGlobalSettingsOutputResponse
    {
        typealias describeGlobalSettingsContinuation = CheckedContinuation<DescribeGlobalSettingsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeGlobalSettingsContinuation) in
            describeGlobalSettings(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns information about a saved resource, including the last time it was backed up,
    ///          its Amazon Resource Name (ARN), and the AWS service type of the saved resource.</p>
    func describeProtectedResource(input: DescribeProtectedResourceInput) async throws -> DescribeProtectedResourceOutputResponse
    {
        typealias describeProtectedResourceContinuation = CheckedContinuation<DescribeProtectedResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeProtectedResourceContinuation) in
            describeProtectedResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns metadata associated with a recovery point, including ID, status, encryption, and
    ///          lifecycle.</p>
    func describeRecoveryPoint(input: DescribeRecoveryPointInput) async throws -> DescribeRecoveryPointOutputResponse
    {
        typealias describeRecoveryPointContinuation = CheckedContinuation<DescribeRecoveryPointOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeRecoveryPointContinuation) in
            describeRecoveryPoint(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns the current service opt-in settings for the Region. If service-opt-in is enabled
    ///          for a service, AWS Backup tries to protect that service's resources in this Region, when
    ///          the resource is included in an on-demand backup or scheduled backup plan. Otherwise, AWS
    ///          Backup does not try to protect that service's resources in this Region, AWS Backup does not
    ///          try to protect that service's resources in this Region.</p>
    func describeRegionSettings(input: DescribeRegionSettingsInput) async throws -> DescribeRegionSettingsOutputResponse
    {
        typealias describeRegionSettingsContinuation = CheckedContinuation<DescribeRegionSettingsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeRegionSettingsContinuation) in
            describeRegionSettings(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns metadata associated with a restore job that is specified by a job ID.</p>
    func describeRestoreJob(input: DescribeRestoreJobInput) async throws -> DescribeRestoreJobOutputResponse
    {
        typealias describeRestoreJobContinuation = CheckedContinuation<DescribeRestoreJobOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeRestoreJobContinuation) in
            describeRestoreJob(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes the specified continuous backup recovery point from AWS Backup and releases
    ///          control of that continuous backup to the source service, such as Amazon RDS. The source
    ///          service will continue to create and retain continuous backups using the lifecycle that you
    ///          specified in your original backup plan.</p>
    ///          <p>Does not support snapshot backup recovery points.</p>
    func disassociateRecoveryPoint(input: DisassociateRecoveryPointInput) async throws -> DisassociateRecoveryPointOutputResponse
    {
        typealias disassociateRecoveryPointContinuation = CheckedContinuation<DisassociateRecoveryPointOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: disassociateRecoveryPointContinuation) in
            disassociateRecoveryPoint(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns the backup plan that is specified by the plan ID as a backup template.</p>
    func exportBackupPlanTemplate(input: ExportBackupPlanTemplateInput) async throws -> ExportBackupPlanTemplateOutputResponse
    {
        typealias exportBackupPlanTemplateContinuation = CheckedContinuation<ExportBackupPlanTemplateOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: exportBackupPlanTemplateContinuation) in
            exportBackupPlanTemplate(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns <code>BackupPlan</code> details for the specified <code>BackupPlanId</code>. The
    ///          details are the body of a backup plan in JSON format, in addition to plan metadata.</p>
    func getBackupPlan(input: GetBackupPlanInput) async throws -> GetBackupPlanOutputResponse
    {
        typealias getBackupPlanContinuation = CheckedContinuation<GetBackupPlanOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getBackupPlanContinuation) in
            getBackupPlan(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns a valid JSON document specifying a backup plan or an error.</p>
    func getBackupPlanFromJSON(input: GetBackupPlanFromJSONInput) async throws -> GetBackupPlanFromJSONOutputResponse
    {
        typealias getBackupPlanFromJSONContinuation = CheckedContinuation<GetBackupPlanFromJSONOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getBackupPlanFromJSONContinuation) in
            getBackupPlanFromJSON(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns the template specified by its <code>templateId</code> as a backup plan.</p>
    func getBackupPlanFromTemplate(input: GetBackupPlanFromTemplateInput) async throws -> GetBackupPlanFromTemplateOutputResponse
    {
        typealias getBackupPlanFromTemplateContinuation = CheckedContinuation<GetBackupPlanFromTemplateOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getBackupPlanFromTemplateContinuation) in
            getBackupPlanFromTemplate(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns selection metadata and a document in JSON format that specifies a list of
    ///          resources that are associated with a backup plan.</p>
    func getBackupSelection(input: GetBackupSelectionInput) async throws -> GetBackupSelectionOutputResponse
    {
        typealias getBackupSelectionContinuation = CheckedContinuation<GetBackupSelectionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getBackupSelectionContinuation) in
            getBackupSelection(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns the access policy document that is associated with the named backup
    ///          vault.</p>
    func getBackupVaultAccessPolicy(input: GetBackupVaultAccessPolicyInput) async throws -> GetBackupVaultAccessPolicyOutputResponse
    {
        typealias getBackupVaultAccessPolicyContinuation = CheckedContinuation<GetBackupVaultAccessPolicyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getBackupVaultAccessPolicyContinuation) in
            getBackupVaultAccessPolicy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns event notifications for the specified backup vault.</p>
    func getBackupVaultNotifications(input: GetBackupVaultNotificationsInput) async throws -> GetBackupVaultNotificationsOutputResponse
    {
        typealias getBackupVaultNotificationsContinuation = CheckedContinuation<GetBackupVaultNotificationsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getBackupVaultNotificationsContinuation) in
            getBackupVaultNotifications(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns a set of metadata key-value pairs that were used to create the backup.</p>
    func getRecoveryPointRestoreMetadata(input: GetRecoveryPointRestoreMetadataInput) async throws -> GetRecoveryPointRestoreMetadataOutputResponse
    {
        typealias getRecoveryPointRestoreMetadataContinuation = CheckedContinuation<GetRecoveryPointRestoreMetadataOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getRecoveryPointRestoreMetadataContinuation) in
            getRecoveryPointRestoreMetadata(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns the AWS resource types supported by AWS Backup.</p>
    func getSupportedResourceTypes(input: GetSupportedResourceTypesInput) async throws -> GetSupportedResourceTypesOutputResponse
    {
        typealias getSupportedResourceTypesContinuation = CheckedContinuation<GetSupportedResourceTypesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getSupportedResourceTypesContinuation) in
            getSupportedResourceTypes(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns a list of existing backup jobs for an authenticated account for the last 30
    ///          days. For a longer period of time, consider using these <a href="https://docs.aws.amazon.com/aws-backup/latest/devguide/monitoring.html">monitoring tools</a>.</p>
    func listBackupJobs(input: ListBackupJobsInput) async throws -> ListBackupJobsOutputResponse
    {
        typealias listBackupJobsContinuation = CheckedContinuation<ListBackupJobsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listBackupJobsContinuation) in
            listBackupJobs(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns metadata of your saved backup plan templates, including the template ID, name,
    ///          and the creation and deletion dates.</p>
    func listBackupPlanTemplates(input: ListBackupPlanTemplatesInput) async throws -> ListBackupPlanTemplatesOutputResponse
    {
        typealias listBackupPlanTemplatesContinuation = CheckedContinuation<ListBackupPlanTemplatesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listBackupPlanTemplatesContinuation) in
            listBackupPlanTemplates(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns version metadata of your backup plans, including Amazon Resource Names (ARNs),
    ///          backup plan IDs, creation and deletion dates, plan names, and version IDs.</p>
    func listBackupPlanVersions(input: ListBackupPlanVersionsInput) async throws -> ListBackupPlanVersionsOutputResponse
    {
        typealias listBackupPlanVersionsContinuation = CheckedContinuation<ListBackupPlanVersionsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listBackupPlanVersionsContinuation) in
            listBackupPlanVersions(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns a list of existing backup plans for an authenticated account. The list is
    ///          populated only if the advanced option is set for the backup plan. The list contains
    ///          information such as Amazon Resource Names (ARNs), plan IDs, creation and deletion dates,
    ///          version IDs, plan names, and creator request IDs.</p>
    func listBackupPlans(input: ListBackupPlansInput) async throws -> ListBackupPlansOutputResponse
    {
        typealias listBackupPlansContinuation = CheckedContinuation<ListBackupPlansOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listBackupPlansContinuation) in
            listBackupPlans(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns an array containing metadata of the resources associated with the target backup
    ///          plan.</p>
    func listBackupSelections(input: ListBackupSelectionsInput) async throws -> ListBackupSelectionsOutputResponse
    {
        typealias listBackupSelectionsContinuation = CheckedContinuation<ListBackupSelectionsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listBackupSelectionsContinuation) in
            listBackupSelections(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns a list of recovery point storage containers along with information about
    ///          them.</p>
    func listBackupVaults(input: ListBackupVaultsInput) async throws -> ListBackupVaultsOutputResponse
    {
        typealias listBackupVaultsContinuation = CheckedContinuation<ListBackupVaultsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listBackupVaultsContinuation) in
            listBackupVaults(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns metadata about your copy jobs.</p>
    func listCopyJobs(input: ListCopyJobsInput) async throws -> ListCopyJobsOutputResponse
    {
        typealias listCopyJobsContinuation = CheckedContinuation<ListCopyJobsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listCopyJobsContinuation) in
            listCopyJobs(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns an array of resources successfully backed up by AWS Backup, including the time
    ///          the resource was saved, an Amazon Resource Name (ARN) of the resource, and a resource
    ///          type.</p>
    func listProtectedResources(input: ListProtectedResourcesInput) async throws -> ListProtectedResourcesOutputResponse
    {
        typealias listProtectedResourcesContinuation = CheckedContinuation<ListProtectedResourcesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listProtectedResourcesContinuation) in
            listProtectedResources(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns detailed information about the recovery points stored in a backup vault.</p>
    func listRecoveryPointsByBackupVault(input: ListRecoveryPointsByBackupVaultInput) async throws -> ListRecoveryPointsByBackupVaultOutputResponse
    {
        typealias listRecoveryPointsByBackupVaultContinuation = CheckedContinuation<ListRecoveryPointsByBackupVaultOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listRecoveryPointsByBackupVaultContinuation) in
            listRecoveryPointsByBackupVault(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns detailed information about recovery points of the type specified by a resource
    ///          Amazon Resource Name (ARN).</p>
    func listRecoveryPointsByResource(input: ListRecoveryPointsByResourceInput) async throws -> ListRecoveryPointsByResourceOutputResponse
    {
        typealias listRecoveryPointsByResourceContinuation = CheckedContinuation<ListRecoveryPointsByResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listRecoveryPointsByResourceContinuation) in
            listRecoveryPointsByResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns a list of jobs that AWS Backup initiated to restore a saved resource, including
    ///          metadata about the recovery process.</p>
    func listRestoreJobs(input: ListRestoreJobsInput) async throws -> ListRestoreJobsOutputResponse
    {
        typealias listRestoreJobsContinuation = CheckedContinuation<ListRestoreJobsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listRestoreJobsContinuation) in
            listRestoreJobs(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns a list of key-value pairs assigned to a target recovery point, backup plan, or
    ///          backup vault.</p>
    ///          <note>
    ///             <p>
    ///                <code>ListTags</code> are currently only supported with Amazon EFS backups.</p>
    ///          </note>
    func listTags(input: ListTagsInput) async throws -> ListTagsOutputResponse
    {
        typealias listTagsContinuation = CheckedContinuation<ListTagsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listTagsContinuation) in
            listTags(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Sets a resource-based policy that is used to manage access permissions on the target
    ///          backup vault. Requires a backup vault name and an access policy document in JSON
    ///          format.</p>
    func putBackupVaultAccessPolicy(input: PutBackupVaultAccessPolicyInput) async throws -> PutBackupVaultAccessPolicyOutputResponse
    {
        typealias putBackupVaultAccessPolicyContinuation = CheckedContinuation<PutBackupVaultAccessPolicyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putBackupVaultAccessPolicyContinuation) in
            putBackupVaultAccessPolicy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Turns on notifications on a backup vault for the specified topic and events.</p>
    func putBackupVaultNotifications(input: PutBackupVaultNotificationsInput) async throws -> PutBackupVaultNotificationsOutputResponse
    {
        typealias putBackupVaultNotificationsContinuation = CheckedContinuation<PutBackupVaultNotificationsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putBackupVaultNotificationsContinuation) in
            putBackupVaultNotifications(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Starts an on-demand backup job for the specified resource.</p>
    func startBackupJob(input: StartBackupJobInput) async throws -> StartBackupJobOutputResponse
    {
        typealias startBackupJobContinuation = CheckedContinuation<StartBackupJobOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: startBackupJobContinuation) in
            startBackupJob(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Starts a job to create a one-time copy of the specified resource.</p>
    ///          <p>Does not support continuous backups.</p>
    func startCopyJob(input: StartCopyJobInput) async throws -> StartCopyJobOutputResponse
    {
        typealias startCopyJobContinuation = CheckedContinuation<StartCopyJobOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: startCopyJobContinuation) in
            startCopyJob(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Recovers the saved resource identified by an Amazon Resource Name (ARN).</p>
    func startRestoreJob(input: StartRestoreJobInput) async throws -> StartRestoreJobOutputResponse
    {
        typealias startRestoreJobContinuation = CheckedContinuation<StartRestoreJobOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: startRestoreJobContinuation) in
            startRestoreJob(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Attempts to cancel a job to create a one-time backup of a resource.</p>
    func stopBackupJob(input: StopBackupJobInput) async throws -> StopBackupJobOutputResponse
    {
        typealias stopBackupJobContinuation = CheckedContinuation<StopBackupJobOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: stopBackupJobContinuation) in
            stopBackupJob(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Assigns a set of key-value pairs to a recovery point, backup plan, or backup vault
    ///          identified by an Amazon Resource Name (ARN).</p>
    func tagResource(input: TagResourceInput) async throws -> TagResourceOutputResponse
    {
        typealias tagResourceContinuation = CheckedContinuation<TagResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: tagResourceContinuation) in
            tagResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Removes a set of key-value pairs from a recovery point, backup plan, or backup vault
    ///          identified by an Amazon Resource Name (ARN)</p>
    func untagResource(input: UntagResourceInput) async throws -> UntagResourceOutputResponse
    {
        typealias untagResourceContinuation = CheckedContinuation<UntagResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: untagResourceContinuation) in
            untagResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Updates an existing backup plan identified by its <code>backupPlanId</code> with the
    ///          input document in JSON format. The new version is uniquely identified by a
    ///             <code>VersionId</code>.</p>
    func updateBackupPlan(input: UpdateBackupPlanInput) async throws -> UpdateBackupPlanOutputResponse
    {
        typealias updateBackupPlanContinuation = CheckedContinuation<UpdateBackupPlanOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateBackupPlanContinuation) in
            updateBackupPlan(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Updates the current global settings for the AWS account. Use the
    ///             <code>DescribeGlobalSettings</code> API to determine the current settings.</p>
    func updateGlobalSettings(input: UpdateGlobalSettingsInput) async throws -> UpdateGlobalSettingsOutputResponse
    {
        typealias updateGlobalSettingsContinuation = CheckedContinuation<UpdateGlobalSettingsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateGlobalSettingsContinuation) in
            updateGlobalSettings(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Sets the transition lifecycle of a recovery point.</p>
    ///          <p>The lifecycle defines when a protected resource is transitioned to cold storage and when
    ///          it expires. AWS Backup transitions and expires backups automatically according to the
    ///          lifecycle that you define.</p>
    ///          <p>Backups transitioned to cold storage must be stored in cold storage for a minimum of 90
    ///          days. Therefore, the “expire after days” setting must be 90 days greater than the
    ///          “transition to cold after days” setting. The “transition to cold after days” setting cannot
    ///          be changed after a backup has been transitioned to cold.</p>
    ///          <p>Only Amazon EFS file system backups can be transitioned to cold storage.</p>
    ///          <p>Does not support continuous backups.</p>
    func updateRecoveryPointLifecycle(input: UpdateRecoveryPointLifecycleInput) async throws -> UpdateRecoveryPointLifecycleOutputResponse
    {
        typealias updateRecoveryPointLifecycleContinuation = CheckedContinuation<UpdateRecoveryPointLifecycleOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateRecoveryPointLifecycleContinuation) in
            updateRecoveryPointLifecycle(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Updates the current service opt-in settings for the Region. If service-opt-in is enabled
    ///          for a service, AWS Backup tries to protect that service's resources in this Region, when
    ///          the resource is included in an on-demand backup or scheduled backup plan. Otherwise, AWS
    ///          Backup does not try to protect that service's resources in this Region. Use the
    ///             <code>DescribeRegionSettings</code> API to determine the resource types that are
    ///          supported.</p>
    func updateRegionSettings(input: UpdateRegionSettingsInput) async throws -> UpdateRegionSettingsOutputResponse
    {
        typealias updateRegionSettingsContinuation = CheckedContinuation<UpdateRegionSettingsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateRegionSettingsContinuation) in
            updateRegionSettings(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

}
#endif
